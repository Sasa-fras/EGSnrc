Mortran 3.2 Mon Feb  5 23:07:20 2024
               0  %L                                                                     ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0                                        "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0                                        "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0    {SETR F=$FORTVER}
            {  0     [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0    }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0     WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0              [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0      "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0   WITH {;{SETR X=NEWLABEL}
            {  0   WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0   [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0   WRITE(IUECHO,{P4}){P5};]
            {  0   [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0   WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0   }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0    WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0     {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0    {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0    {{EMIT;{P1}}={WAIT {P1}};
            {  0    IF QDEBUG [OUTPUT{P1};
            {  0    (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0    {{SETR A=NEWLABEL}
            {  0      REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0         WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0             IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0                  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0                      (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0                         G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0    {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0    {;IF (QDEBUG)[OUTPUT;
            {  0      (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0           {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0      {;{SETR A=NEWLABEL}
            {  0           V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0           [IF] {EXIST 2} [$DUMP{P2};] ;}
               0     "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0     "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  REPLACE {$CONFIG_TIME} WITH {'unknown'}
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0     { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0     {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0     {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0      {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0      {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0      {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0      {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0      {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0      {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0              {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0      ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0       $REAL         ECUT,   "Minimum electron transport energy"
            {  0                     PCUT,   "Minimum photon transport energy"
            {  0                     VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0      ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0    ;COMMON/BREMPR/
            {  0               $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0               $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0               $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0               PWR2I($MXPWR2I),
            {  0               $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0               IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0               ASYM($MXMED,$MXEL,2);
            {  0     $TYPE     ASYM;
            {  0     $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0                                      "rejection function, eq. (2.7.14 and 15)"
            {  0               ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0               BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0               DELPOS, "maximum delta, eq. (2.7.31)"
            {  0               WA,     "atomic weight"
            {  0               PZ,     "atomic fraction of an element in a compound"
            {  0               ZELEM,  "Z for a given component"
            {  0               RHOZ,   "density of an element in a compound"
            {  0               PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0               DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0               ZBRANG, "composite factor for angular distributions"
            {  0               LZBRANG;"-Log(ZBRANG)"
            {  0     $INTEGER  NNE,    "number of elements/compound"
            {  0               IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0               IPRDST, "flag to switch on pair angular distributions"
            {  0               ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0               itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0               pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0                          "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0    common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_emin($MXMED),nb_emax($MXMED),
            {  0                       nb_lemin($MXMED),nb_lemax($MXMED),
            {  0                       nb_dle($MXMED),nb_dlei($MXMED),
            {  0                       log_ap($MXMED);
            {  0    $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0             nb_dle,nb_dlei,log_ap;
            {  0    $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0      common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_xdata($NRC-PAIR-NXX),
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0          common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0                               b_triplet($MAX_TRIPLET,$MXMED),
            {  0                               dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0          $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0                               bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0    ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0                          be_array($MXTOTSH), "Shell binding energies      "
            {  0                          Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0                          erfJo_array($MXTOTSH),"needed for the calculation"
            {  0                                              "of the incoherent scattering"
            {  0                                              "function                    "
            {  0                          ne_array($MXTOTSH), "Occupation number           "
            {  0                          shn_array($MXTOTSH),"shell type                  "
            {  0                                              "(=1     for K,              "
            {  0                                              " =2,3,4 for L1,L2,L3        "
            {  0                                              " =5     for M               "
            {  0                                              " =6     for N               "
            {  0                                              " =7     for all others      "
            {  0                          shell_array($MXMDSH,$MXMED),
            {  0                          eno_array($MXMDSH,$MXMED),
            {  0                          eno_atbin_array($MXMDSH,$MXMED),
            {  0                          n_shell($MXMED),
            {  0                          radc_flag,          "flag for radiative corrections"
            {  0                          ibcmp($MXREG);      "flag to turn on binding effects"
            {  0     $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0                          shell_array,n_shell,radc_flag;
            {  0     $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0     $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0     COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0                 interaction_prob($MXSHELL,$MXELEMENT),
            {  0                 relaxation_prob($MXTRANS,$MXELEMENT),
            {  0                 edge_energies($MXEDGE,$MXELEMENT),
            {  0                 edge_number($MXELEMENT),
            {  0                 edge_a($MXEDGE,$MXELEMENT),
            {  0                 edge_b($MXEDGE,$MXELEMENT),
            {  0                 edge_c($MXEDGE,$MXELEMENT),
            {  0                 edge_d($MXEDGE,$MXELEMENT),
            {  0                 IEDGFL($MXREG),IPHTER($MXREG);
            {  0     $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0                 interaction_prob, " prob. for interaction with one of"
            {  0                                   " the above shells (provided photon"
            {  0                                   " energy is above be)              "
            {  0                 relaxation_prob,  " relaxation probabilities         "
            {  0                 edge_energies,    " photo-absorption edge energies   "
            {  0                 edge_a,edge_b,edge_c,edge_d;
            {  0                                   " photo cross section fit parameters "
            {  0     $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0                 IPHTER;  "flag for switching on photo-electron angular distr."
            {  0     $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0     COMMON/ELECIN/
            {  0     esig_e($MXMED),psig_e($MXMED),
            {  0     esige_max, psige_max,
            {  0     range_ep(0:1,$MXEKE,$MXMED),
            {  0     E_array($MXEKE,$MXMED),
            {  0     $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0          blcce($MXEKE,$MXMED)/0,1/),
            {  0     $LGN(EKE($MXMED)/0,1/),
            {  0     $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0     $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0     expeke1($MXMED),
            {  0     IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0     sig_ismonotone(0:1,$MXMED);
            {  0     $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0                             "for each medium"
            {  0              psig_e,        "maximum positron cross section per energy loss"
            {  0                             "for each medium"
            {  0              esige_max,     "maximum electron cross section per energy loss"
            {  0              psige_max,     "maximum electron cross section per energy loss"
            {  0              range_ep,      "electron (0) or positron (1) range"
            {  0              E_array,       "table energies"
            {  0              etae_ms0,etae_ms1,
            {  0                             "for interpolation of screening parameter (e-)"
            {  0              etap_ms0,etap_ms1,
            {  0                             "for interpolation of screening parameter (e+)"
            {  0              q1ce_ms0,q1ce_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e-)"
            {  0              q1cp_ms0,q1cp_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e+)"
            {  0              q2ce_ms0,q2ce_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e-)"
            {  0              q2cp_ms0,q2cp_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e+)"
            {  0              blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0                            "necessary to account for scattering already taken  "
            {  0                            "into account in discrete Moller/Bhabha             "
            {  0              expeke1,       "Exp(1/eke1)-1"
            {  0              $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0              XR0,           "unused, but read in HATCH"
            {  0              TEFF0,         "unused, but read in HATCH"
            {  0              BLCC,          "b lower case sub c"
            {  0              XCC,           "chi sub-c-c"
            {  0              ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0              PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0              EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0              PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0              EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0              PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0              PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0              TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0     $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0              EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0              IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0     $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0                             "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0                                        "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0                                        "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0      common/eii_data/
            {  0          eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_cons($MXMED),
            {  0          eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0          eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0          eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0          eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0          eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0          eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0          eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0          eii_flag;                      "EII flag                          "
            {  0                                         "         = 0 => no EII            "
            {  0                                         "         = 1 => simple EII        "
            {  0                                         "         > 1 => future use        "
            {  0      $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0      $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0      $INTEGER  eii_first,eii_no;
            {  0      $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0      ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0             UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0      ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0      common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0                       EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0                       BxIN, ByIN, BzIN,       "B field: initial region"
            {  0                       Bx, By, Bz,             "B field: current region"
            {  0                       Bx_new, By_new, Bz_new, "B field: in new region"
            {  0                       emfield_on;             "true if EM fields not null"
            {  0
            {  0     $REAL    ExIN,EyIN,EzIN,
            {  0              EMLMTIN,
            {  0              BxIN,ByIN,BzIN,
            {  0              Bx,By,Bz,
            {  0              Bx_new,By_new,Bz_new;
            {  0     $LOGICAL emfield_on;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0     common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0     $REAL              u_relax;
            {  0     $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
               0  REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0    common/shell_data/
            {  0      shell_be($MAXSHELL),      "binding energies"
            {  0      shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0      shell_num($MAXSHELL),     "the shell position in the element"
            {  0      shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0      shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0      shell_ntot;               "total number of shells in the list"
            {  0    $REAL    shell_be;
            {  0    $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0    common/relax_data/
            {  0      relax_first($MAXSHELL),    "first transition"
            {  0      relax_ntran($MAXSHELL),    "number of transitions"
            {  0      relax_state($MAXRELAX),    "final state of the transition"
            {  0      relax_prob($MAXRELAX),     "probability"
            {  0      relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0      relax_ntot;                "total number of transitions in the list"
            {  0    $REAL     relax_prob;
            {  0    $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0      common/relax_for_user/
            {  0       rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0       rfu_E,  "binding energy of current vacancy"
            {  0       rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0       rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0       rfu_n0, "same but number is shell number in the element"
            {  0       rfu_t0, "same but number is shell type according to EADL notation"
            {  0       rfu_j,  "shell number of current vacancy"
            {  0       rfu_n,  "same but number is shell number in the element"
            {  0       rfu_t;  "same but number is shell type according to EADL notation"
            {  0      $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0      $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001D0"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0    common/pe_shell_data/
            {  0      pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0      pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0                                             "element of a medium"
            {  0      pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0      pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0      pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0      pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0      pe_zpos($MXELEMENT),       "position of each Z element"
            {  0      pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0      pe_ne;                    "number of elements in the simulation"
            {  0    $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0    $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0      PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0    ;common/ET_control/
            {  0                smaxir($MXREG),estepe,ximax,
            {  0                "ximin_for_bca,"
            {  0                skindepth_for_bca,transport_algorithm,
            {  0                bca_algorithm,exact_bca,spin_effects;
            {  0      $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0                estepe,             "global energy loss constrain"
            {  0                ximax,              "max. first GS moment per step"
            {  0                                    "(roughly half the average MS angle squared"
            {  0                "ximin_for_bca,"
            {  0                                    "min. first GS moment per step for boundary"
            {  0                                    "crossing in VMC mode"
            {  0                skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0                                    "to switch to one of the BCAs "
            {  0      $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0                bca_algorithm;      "will be used if other inexact BCAs"
            {  0                                    "implemented in the future"
            {  0      $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0                spin_effects;       "if .true. electron/positron spin effects"
            {  0                                    "are taken into account in the single and"
            {  0                                    "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0    common/ms_data/
            {  0                ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    real*4      ums_array,fms_array,wms_array,
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0    common/spin_data/
            {  0                spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0                espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0                fool_intel_optimizer;
            {  0    real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0    $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0    common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0    real*8           count_pII_steps,count_all_steps;
            {  0    $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0    COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0                  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0                  x_final,y_final,z_final,
            {  0                  u_final,v_final,w_final,
            {  0                  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0      $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0                        EDEP_LOCAL; "local energy deposition in MeV"
            {  0      $REAL             TSTEP,  "distance to a discrete interaction"
            {  0                        TUSTEP, "intended step length, befor check with geometry"
            {  0                        USTEP,  "transport distance calculated from TUSTEP"
            {  0                        VSTEP,  "transport distance after truncation by HOWFAR"
            {  0                        TVSTEP, "curved path-length calculated from TVSTEP"
            {  0                        RHOF,   "mass density ratio"
            {  0                        EOLD,   "energy before deduction of energy loss"
            {  0                        ENEW,   "energy after  deduction of energy loss"
            {  0                        EKE,    "kinetic energy"
            {  0                        ELKE,   "Log(EKE)"
            {  0                        GLE,    "Log(energy) in PHOTON"
            {  0                        E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0                        x_final,y_final,z_final, "position at end of step"
            {  0                        u_final,v_final,w_final; "direction at end of step"
            {  0                                                 "only set (and relevant) "
            {  0                                                 "for electrons"
            {  0      $INTEGER          IDISC,  "flag indicating user discard"
            {  0                        IROLD,  "region before transport"
            {  0                        IRNEW,  "region after transport"
            {  0                        IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0     COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0         $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0              IRAYLM,IPHOTONUCM($MXMED)),
            {  0              MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0              photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0     $TYPE    MEDIA;"media names"
            {  0     $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0              RLDU, "radiation length after user scaling over-ride"
            {  0              RHO,  "mass density of a given medium"
            {  0              apx, upx;"new photon xsection data thresholds"
            {  0     $INTEGER MSGE, "??? "
            {  0              MGE,  "number of photon mapped energy intervals for a given medium"
            {  0              MSEKE,"??? "
            {  0              MEKE, "number of e mapped energy intervals for a given medium"
            {  0              MLEKE,"??? "
            {  0              MCMFP,"??? "
            {  0              MRANGE,"??? "
            {  0              IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0              IPHOTONUCM,"photonuclear switch for a given medium"
            {  0              IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0              NMED;  "number of media"
            {  0     character*16 eii_xfile;
            {  0              "Defaults to eii_ik.data if On or Off options selected"
            {  0              "which is the EII implemented by Iwan for EGSnrc"
            {  0              "else, following options available: "
            {  0              "  eii_'casnati'.data    "
            {  0              "  eii_'kolbenstvedt'.data "
            {  0              "  eii_'gryzinski'.data"
            {  0              "these must be in $HEN_HOUSE/data"
            {  0     character*16 photon_xsections;
            {  0              "If photon_xsections is not empty, photon cross sections will be"
            {  0              "re-initialized using data files  "
            {  0              "  'photon_xsection'_photo.data   "
            {  0              "  'photon_xsection'_pair.data    "
            {  0              "  'photon_xsection'_triplet.data "
            {  0              "  'photon_xsection'_rayleigh.data"
            {  0              "that must be placed in $HEN_HOUSE/data"
            {  0     character*16 comp_xsections;
            {  0              "If comp_xsections is not empty or not set to 'default' and"
            {  0              "bound Compton scattering is On, then total Compton cross sections"
            {  0              "will be taken from 'comp_xsections'_compton.data"
            {  0              "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0     character*16 photonuc_xsections;
            {  0              "If photonuc_xsections is not empty or not set to 'default',"
            {  0              "the photonuclear cross sections will be taken from"
            {  0              "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0              "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0    COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0             DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0    $REAL    DUNIT,   "unit scaling factor"
            {  0             RHOR;    "density of a given region"
            {  0    $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0             KMPO;    "fortran unit number of pegs4 echo file"
            {  0    $SHORT_INT MED,   "medium number for a given region"
            {  0               IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0               IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0      COMMON/PHOTIN/
            {  0         EBINDA($MXMED),
            {  0         $LGN(GE($MXMED)/0,1/),
            {  0         $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0         $LGN(RCO($MXMED)/0,1/),
            {  0         $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0         $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0         $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0         DPMFP,
            {  0         MPGEM($MXSGE,$MXMED),
            {  0         NGR($MXMED);
            {  0      $REAL
            {  0         EBINDA,      "energy of the K-edge for a given medium"
            {  0         GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0         GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0         GBR10,GBR11, "used for branching into pair interpolation"
            {  0         GBR20,GBR21, "used for branching into Compton interpolation"
            {  0         RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0         RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0         COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0         PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0         DPMFP;       "number of MFP's to go to the next interaction"
            {  0      $INTEGER
            {  0         MPGEM,       "??? "
            {  0         NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0     COMMON/STACK/
            {  0         $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0         LATCHI,NP,NPold;
            {  0     $ENERGY PRECISION
            {  0         E;     "total particle energy"
            {  0     $REAL
            {  0         X,Y,Z, "particle co-ordinates"
            {  0         U,V,W, "particle direction cosines"
            {  0         DNEAR, "perpendicular distance to nearest boundary"
            {  0         WT;    "particle weight"
            {  0     $INTEGER
            {  0         IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0         IR,    "current region"
            {  0         LATCH, "extra phase space variable"
            {  0         LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0         NP,    "stack pointer"
            {  0         NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0     COMMON/THRESH/RMT2,RMSQ,
            {  0                   $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0     $REAL         RMT2,  "2*electron mass in MeV"
            {  0                   RMSQ,  "electron mass squared in MeV**2"
            {  0                   AP,    "photon creation threshold energy"
            {  0                   AE,    "electron creation threshold energy (total)"
            {  0                   UP,    "upper photon energy in PEGS4 data set"
            {  0                   UE,    "upper electron energy in PEGS4 data set"
            {  0                   TE,    "electron creation threshold energy (kinetic)"
            {  0                   THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0     COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0     $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0     COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0                   COSPHI,PI,TWOPI,PI5D2;
            {  0     $REAL         THETA,  "polar scattering angle"
            {  0                   SINTHE, "sin(THETA)"
            {  0                   COSTHE, "cos(THETA)"
            {  0                   SINPHI, "sine of the azimuthal scattering angle"
            {  0                   COSPHI, "cosine of the azimuthal scattering angle"
            {  0                   PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0     COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0     $ENERGY PRECISION PZERO,   "precise zero"
            {  0                       PRM,     "precise electron mass in MeV"
            {  0                       PRMT2;   "2*PRM"
            {  0     $REAL             RM;      "electron mass in MeV"
            {  0     $INTEGER          MEDIUM,  "medium index of current region"
            {  0                       MEDOLD;  "medium index of previous region"
            {  0     " The rest mass value is as recommended by CODATA 2014"
            {  0     " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0     DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0           ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0      ;
            {  0    common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0                     mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0    $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0       ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0      ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0      ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0             EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0      ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0             EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0     ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0     ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0     ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0     ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0            STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0    ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0    ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0    EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0    THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0    ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0         EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0    ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0    ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0    ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0    ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0           BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0      IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0      [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0      [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0    [IF] '{P2}'=SNAME1
            {  0    [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0    [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0    {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0    {P2}2(L{P3},L{P4})*
            {  0    {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0      X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0      WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0     "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0     "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0     "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0     "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0     "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0    ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0    ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0                                    "energy dependent quantities"
            {  0    $CALCULATE-XI(tustep);
            {  0    IF ( xi < 0.1 )
            {  0      [
            {  0        ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        ustep = tustep*(1 - Exp(-xi))/xi;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0    p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0    chia2 = xccl/(4*blccl*p2);
            {  0                                  "Note that our chia2 is Moliere chia2/4"
            {  0                                  "Note also that xcc is now old egs xcc**2"
            {  0    xi = 0.5*xccl/p2/beta2*{P1};
            {  0    IF( spin_effects ) [
            {  0        elkems = Log(ekems);
            {  0        $SET INTERVAL elkems,eke;
            {  0        IF(lelec < 0) [
            {  0            $EVALUATE etap USING etae_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0        ]
            {  0        ELSE          [
            {  0            $EVALUATE etap USING etap_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0        ]
            {  0        chia2 = chia2*etap; xi = xi*xi_corr;
            {  0        $EVALUATE ms_corr USING blcce(elkems);
            {  0        blccl = blccl*ms_corr;
            {  0    ]
            {  0    ELSE [ xi_corr = 1; etap = 1; ]
            {  0    xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0      ;IF ( vstep < ustep0 )
            {  0      [
            {  0        ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0           "This estimates the energy loss to the boundary."
            {  0           "tustep was the intended curved path-length,"
            {  0           "ustep0 is the average transport distance in the initial direction"
            {  0           "       resulting from tustep"
            {  0           "vstep = ustep is the reduced average transport distance in the "
            {  0           "              initial direction due to boundary crossing"
            {  0        $CALCULATE-XI(vstep);
            {  0        IF ( xi < 0.1 )
            {  0        [
            {  0          tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0        ]
            {  0        ELSE
            {  0        [
            {  0
            {  0          IF ( xi < 0.999999 )
            {  0          [
            {  0             tvstep = -vstep*Log(1 - xi)/xi;
            {  0          ]
            {  0          ELSE
            {  0          [
            {  0             "This is an error condition because the average transition "
            {  0             "in the initial direction of motion is always smaller than 1/Q1"
            {  0             $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0             $egs_info(*,' Medium: ',medium);
            {  0             $egs_info(*,' Initial energy: ',eke);
            {  0             $egs_info(*,' Average step energy: ',ekems);
            {  0             $egs_info(*,' tustep: ',tustep);
            {  0             $egs_info(*,' ustep0: ',ustep0);
            {  0             $egs_info(*,' vstep:  ',vstep);
            {  0             $egs_info(*,' ==> xi = ',xi);
            {  0             $egs_fatal(*,'This is a fatal error condition');
            {  0          ]
            {  0        ]
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        tvstep = tustep;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0              "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0              "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0      ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0      $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0     ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0     $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0    IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0     ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0     IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0     (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0     4E14.6);
            {  0     IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0     USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0      IF(ustep <= 0) [
            {  0          "Negative ustep---probable truncation problem at a"
            {  0          "boundary, which means we are not in the region we think"
            {  0          "we are in.  The default macro assumes that user has set"
            {  0          "irnew to the region we are really most likely to be"
            {  0          "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0          IF(ustep < -1e-4) [
            {  0              ierust = ierust + 1;
            {  0              OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0                     ir(np),irnew,irold,x(np),y(np),z(np);
            {  0              (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0               ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0              IF(ierust > 1000) [
            {  0                  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0                  $CALL_EXIT(1);
            {  0              ]
            {  0          ]
            {  0          ustep = 0;
            {  0      ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0           $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0     WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0          $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0           DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0         $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0           DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0    ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0        IF(tperp >= range) ["particle cannot escape local region"
            {  0            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0            go to :USER-ELECTRON-DISCARD: ;
            {  0        ]
            {  0    ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0                              fcum($MXRAYFF,$MXMED),
            {  0                             b_array($MXRAYFF,$MXMED),
            {  0                             c_array($MXRAYFF,$MXMED),
            {  0                             i_array($RAYCDFSIZE,$MXMED),
            {  0                             $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0       ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0      GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0        ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0     $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0     Q2=X2*RMSQ/(20.60744*20.60744);
            {  0     COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0     IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0     CSQTHE=COSTHE*COSTHE;
            {  0     REJF=(1.0+CSQTHE)/2.0;
            {  0     $RANDOMSET RNNORJ;
            {  0     ] UNTIL (RNNORJ <= REJF);
            {  0     SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0    }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0     ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0     CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0       ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0      GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0     ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0        $RANDOMSET RNNO39;
            {  0        IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0          $AUSCALL($PHOTONUCAUSB);
            {  0          call PHOTONUC;
            {  0          $AUSCALL($PHOTONUCAUSA);
            {  0          GOTO :PNEWENERGY:;
            {  0        ]
            {  0      ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
               0  REPLACE {;COMIN/EM/;} WITH {;}
               0  REPLACE {$EMFIELD_PII;} WITH {;}
               0  REPLACE{$EMFIELD_PI;}WITH{;}
               0  REPLACE{$EM_FIELD_SS;}WITH{;}
               0  REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
               0  REPLACE{$EMFieldInVacuum;}WITH{;}
               0  REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0        ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0        $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0   UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0   V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0   IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0   [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0   (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0   (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0   (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0   [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0   [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0      $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0     $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0     IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0     ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0     $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0     IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0     BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0     -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0     IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0     {P4}=-2.0*BCYL/ACYL;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0     [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0     ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0     ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0   $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0     ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0     $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0     {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0     CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0     WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0     CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0     DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0     ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0     BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0     CCON=DCON1*CPCON-ZNP*ZNP;
            {  0     IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0     [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0     IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0     TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0     [{P4}=TCON1;{P3}=1;]]]]]
            {  0     ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0     IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0     [BPRIM=BCON1-WNP*DCON2;
            {  0     IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0     IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0     [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0     IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0     IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0     ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0     IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0     ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0     IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0     IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0     ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0     TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0     IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0     ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0     [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0     ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0     $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0     BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0     +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0     IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0     {P4}=-2.0*BSPH/ASPH;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0     [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0     [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0   $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0      ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0     {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0     {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0    EELEC=E(NP);
            {  0    IF(EELEC.GT.ECUT(IR(NP)))[
            {  0      BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0      GAMMA=EELEC/RM;
            {  0      ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0      RATIO=BETA/ALPHA;
            {  0      LOOP[
            {  0        $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0        IF(RATIO.LE.0.2)[
            {  0          FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0          IF( gamma < 100 ) [
            {  0              COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0          ]
            {  0          ELSE [
            {  0              IF( fkappa > 0 ) [
            {  0                  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0              ]
            {  0              ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0          ]
            {  0          "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0          "                            at high energies, IK"
            {  0          xi = (1+beta*fkappa)*gamma*gamma;
            {  0        ]
            {  0        ELSE[
            {  0          XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0          COSTHE=(1.-1./XI)/BETA;
            {  0        ]
            {  0        SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0        $RANDOMSET RNPHT2;
            {  0        ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0      SINTHE=SQRT(SINTH2);
            {  0      CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0                  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0      IF( iprdst > 0 ) [
            {  0          IF( iprdst = 4 ) [
            {  0              $RANDOMSET rtest;
            {  0              "gbeta = (1-rmt2/eig)**8;"
            {  0              gbeta = PESE1/(PESE1+10);
            {  0              IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0              ELSE [ iprdst_use = 4; ]
            {  0          ]
            {  0          ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0          ELSE [ iprdst_use = iprdst; ]
            {  0          DO ichrg = 1,2 [
            {  0              IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0                  ESE=ESE2;
            {  0                  IF( iprdst = 4 ) [
            {  0                      gbeta = ESE/(ESE+10);
            {  0                      $RANDOMSET rtest;
            {  0                      IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0                      ELSE [ iprdst_use = 4; ]
            {  0                  ]
            {  0              ]
            {  0              IF( iprdst_use = 1 ) [
            {  0                  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0                  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 2 ) [
            {  0                  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0                  ZTARG=ZBRANG(MEDIUM);
            {  0                  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTEIG=EIG/RM;
            {  0                  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTESE=ESE/RM;
            {  0                  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0                  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0                  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0                  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0                  ESEDER=1.0/ESEDEI;
            {  0                  "DETERMINE THE NORMALIZATION "
            {  0                  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0                  YA=(2.0/TTEIG)**2;
            {  0                  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0                  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0                  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0                  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0                  XIMID=GALPHA/(3.0*GBETA);
            {  0                  IF(GALPHA.GE.0.0)[
            {  0                      XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  ELSE[
            {  0                      XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0                  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0                  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0                  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0                  LOOP[
            {  0                      $RANDOMSET XITST;
            {  0                      $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0                      $RANDOMSET RTEST;
            {  0                      "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0                      THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0                      "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0                      REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0                  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0                  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 3 ) [
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0              ]
            {  0              ELSE [
            {  0                  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0                  "$RANDOMSET costhe;"
            {  0                  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0                  $RANDOMSET costhe;
            {  0                  costhe=1-2*sqrt(costhe);
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0              ]
            {  0              IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0              ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0          ]
            {  0          iq(np) = iq2; iq(np-1) = iq1; return;
            {  0      ]
            {  0      ELSE[
            {  0          THETA=0; "THETA=RM/EIG; "
            {  0      ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0          4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0              1.0+0.25*LOG(
            {  0                  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0                  )
            {  0              )
            {  0          ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0    $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0    PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0    elktmp = elke + Log(1 - {P1});
            {  0    $SET INTERVAL elktmp,eke;
            {  0    lelktmp = max(1,lelktmp);
            {  0    IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0    ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0    dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0                     "0.17408298 is 2/3*m**2"
            {  0    {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0    "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0    "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0                                          "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Uniform Run Control (URC) is false by default"
               0  REPLACE {$URC-DEFAULT} WITH {.false.}
               0  ;
               0  "SLEEP INTERVAL for URC (1 s by default)"
               0  "Time to wait for jobs to complete after last job finished"
               0  REPLACE {$URC-SLEEP} WITH {1}
               0  "Times to check for jobs to complete after last job finished"
               0  REPLACE {$URC-INTERVALS} WITH {1}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0              "This macro sets the minimum step size for a condensed"
               0              "history (CH) step. When the exact BCA is used, the minimum"
               0              "CH step is determined by efficiency considerations only"
               0              "At about 3 elastic MFP's single scattering becomes more"
               0              "efficient than CH and so the algorithm switches off CH"
               0              "If one of the various inexact BCA's is invoked, this macro"
               0              "provides a simple way to include more sophisticated"
               0              "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0     $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0     skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0      blccl = rhof*blcc(medium);
            {  0      xccl  = rhof*xcc(medium);
            {  0      p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0      IF ( spin_effects ) [
            {  0        IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0        ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0        $EVALUATE ms_corr USING blcce({P3});
            {  0        blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0      ]
            {  0      {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0      $SET-SCREENING-ANGLE({P1});
            {  0      call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0      chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0    IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0    IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0      (
            {  0          ' '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' PRESTA-II is aborting execution because you have not defined   '/
            {  0          ' the HOWNEAR macro for your geometry.                           '/
            {  0          ' '/
            {  0          ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0          ' which does not attempt the refined boundary crossing or lateral'/
            {  0          ' correlation features of the algorithm.                         '/
            {  0          ' '/
            {  0          ' If you include the following macro in your usercode:           '/
            {  0          ' '/
            {  0          ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0          ' '/
            {  0          ' you can choose between single scattering mode (very slow) and  '/
            {  0          ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0          ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0          ' manual)                                                        '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' '/
            {  0      );
            {  0      stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0                                          "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0      $RANDOMSET xphi;
            {  0      xphi  = 2*xphi - 1;
            {  0      xphi2 = xphi*xphi;
            {  0      $RANDOMSET yphi;
            {  0      yphi2  = yphi*yphi;
            {  0      rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0    $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PAVIP,    "precise total energy in the laboratory frame"
            {  0        PESG1,    "precise energy of 1st annihilation photon"
            {  0        PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0        A,        "total energy in units of the electron's rest energy"
            {  0        G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0        POT,      "P/T"
            {  0        EP0,      "minimum fractional energy"
            {  0        WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0        RNNO01,   "random numbers"
            {  0        RNNO02,
            {  0        EP,       "fractional energy of the more energetic photon"
            {  0        REJF,     "rejection function"
            {  0        ESG1,     "energy of the more energetic photon"
            {  0        ESG2,     "energy of the less energetic photon"
            {  0        aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0                  "for inline rotations"
            {  0  $INTEGER
            {  0        ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIP,     "precise total energy of incident positron"
            {  0        PEKIN,    "precise kinetic energy of incident positron"
            {  0        PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0        PESE1,    "precise total energy of first 'electron'"
            {  0        PESE2,    "precise total energy of second 'electron'"
            {  0        H1,       "used in direction cosine calculations"
            {  0        DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0        EKIN,     "kinetic energy of incident positron"
            {  0        T0,       "kinetic energy of incident positron in units of RM"
            {  0        E0,       "total energy of incident positron in units of RM"
            {  0        E02,      "E0**2"
            {  0        YY,       "1/(T0+2)"
            {  0        Y2,YP,YP2,"various functions of YY"
            {  0        BETA2,    "incident positron velocity in units of c"
            {  0        EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0        EP0C,     "1-EP0"
            {  0        B1,B2,B3,B4,  "used in rejection function calculation"
            {  0        RNNO03,RNNO04,"random numbers"
            {  0        BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0        REJF2,    "rejection function"
            {  0        ESE1,     "total energy of 1st 'electron'"
            {  0        ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0    PEIE,   "precise incident electron energy"
            {  0    PESG,   "presice energy of emitted photon"
            {  0    PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0    EIE,    "total incident electron energy"
            {  0    EKIN,   "kinetic incident energy"
            {  0    brmin,  " ap(medium)/ekin"
            {  0    waux,   "for faster sampling of 1/br"
            {  0    aux,    "ese/eie"
            {  0    r1,     "a random number"
            {  0    ajj,    "for energy bin determination if alias sampling is employed"
            {  0    alias_sample1,
            {  0    RNNO06, "random number"
            {  0    RNNO07, "random number"
            {  0    BR,     "energy fraction of secondary photon"
            {  0    ESG,    "energy of secondary photon"
            {  0    ESE,    "total energy of secondary electron"
            {  0    DELTA,  "scaled momentum transfer"
            {  0    phi1,   "screening function"
            {  0    phi2,   "screening function"
            {  0    REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0    a,b,c,  "direction cosines of incident `electron'"
            {  0    sinpsi, sindel, cosdel, us, vs,
            {  0            "all used for rotations"
            {  0    ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0    tteie,  "total energy in units of rest energy"
            {  0    beta,   "electron velocity in units of speed of light"
            {  0    y2max,  "maximum possible scaled angle"
            {  0    y2maxi, "inverse of the above"
            {  0    ttese,  "new electron energy in units of rm"
            {  0    rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0            "all of them used for angle rejection function calcs"
            {  0    esedei, "new total energy over old total energy"
            {  0    y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0    y2tst1,
            {  0    rtest,  "random number for rejection"
            {  0    xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0            "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0    L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIE,  "total incident electron energy in units of RM"
            {  0        TTESE,  "total scattered electron energy in units of RM"
            {  0        ESEDEI, "TTESE/TTEIE"
            {  0        beta,   "electron speed in units of c"
            {  0        Y2MAX,  "maximum value of the scaled angle"
            {  0        RJARG1,RJARG2,RJARG3,
            {  0                "arguments for which the rejection function is calculated"
            {  0        REJMIN,REJMID,REJMAX,
            {  0                "corresponding values of the rejection function"
            {  0        REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0        Y2TST,  "random number and candidate for a scaled angle"
            {  0        REJTST, "rejection function at Y2TST"
            {  0        Y2TST1, "aux. variable for rejection function calculation"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        Jo,     "the Compton profile parameter"
            {  0        br2,    "br*br"
            {  0        fpz,fpz1,"used for limited pz-range rejection"
            {  0        qc,     "momentum transfer corresponding to the Compton line energy"
            {  0        qc2,    "qc squared"
            {  0        af,     "for calculating F"
            {  0        Fmax,   "maximum of F"
            {  0        frej,   "used for F-rejection"
            {  0        eta_incoh, eta, "random numbers"
            {  0        aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0        pzmax,  "max. possible z-component of the initial electron momentum"
            {  0        pz,     "initial electron momentum projection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        br2,    "br*br"
            {  0        aux,aux1,aux2,"aux. variables"
            {  0        pzmax2, "max. possible momentum transfer squared"
            {  0        pz,     "momentum transfer prejection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0      demfp,        "differential electron mean free path"
            {  0      peie,         "precise energy of incident electron"
            {  0      total_tstep,  "total path-length to next discrete interaction"
            {  0      total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0      ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0      elkems,     "Log(ekems)"
            {  0      chia2,      "Multiple scattering screening angle"
            {  0      etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0      lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0      blccl,      "blcc(medium)*rhof"
            {  0      xccl,       "xcc(medium)*rhof"
            {  0      xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0      xi_corr,    "correction to xi due to spin effects"
            {  0      ms_corr,
            {  0      p2,         "electron momentum times c, squared"
            {  0      beta2,      "electron speed in units of c, squared"
            {  0      de,         "energy loss to dedx"
            {  0      save_de,    "de saved before $DE-FLUCTUATION"
            {  0      dedx,       "stopping power after density scaling"
            {  0      dedx0,      "stopping power before density scaling"
            {  0      dedxmid,    "stopping power at mid-step before density scaling"
            {  0      ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      aux,        "aux. variable"
            {  0      ebr1,       "e- branching ratio into brem"
            {  0      eie,        "energy of incident electron"
            {  0      ekef,       "kinetic energy after a step"
            {  0      elkef,      "Log(ekef)"
            {  0      ekeold,     "kinetic energy before a step"
            {  0      eketmp,     "used to evaluate average kinetic energy of a step"
            {  0      elktmp,     "log(eketmp)"
            {  0      fedep,      "fractional energy loss used in stopping power calculation"
            {  0      tuss,       "sampled path-length to a single scattering event"
            {  0      pbr1,       "e+ branching ratio into brem"
            {  0      pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0      range,      "electron range"
            {  0      rfict,      "rejection function for fictitious cross section"
            {  0      rnne1,      "random number"
            {  0      rnno24,     "random number"
            {  0      rnno25,     "random number"
            {  0      rnnotu,     "random number"
            {  0      rnnoss,     "random number"
            {  0      sig,        "cross section after density scaling but before a step"
            {  0      sig0,       "cross section before density scaling but before a step"
            {  0      sigf,       "cross section before density scaling but after a step"
            {  0      skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0      ssmfp,      "distance of one single elastic scattering mean free path"
            {  0      tmxs,       "electron step-size restriction"
            {  0      tperp,      "perpendicular distance to the closest boundary"
            {  0      ustep0,     "temporary storage for ustep"
            {  0      uscat,      "x-axis direction cosine for scattering"
            {  0      vscat,      "y-axis direction cosine for scattering"
            {  0      wscat,      "z-axis direction cosine for scattering"
            {  0      xtrans,     "final x-axis position after transport"
            {  0      ytrans,     "final y-axis position after transport"
            {  0      ztrans,     "final z-axis position after transport"
            {  0      cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0      iarg,      "calling code for ausgab"
            {  0      idr,       "calling code for ausgab"
            {  0      ierust,    "error counter for negative ustep errors"
            {  0      irl,       "region number"
            {  0      lelec,     "charge of electron"
            {  0      qel,       " = 0 for electrons, = 1 for positrons "
            {  0      lelke,     "index into the energy grid of tabulated functions"
            {  0      lelkems,   "index into the energy grid of tabulated functions"
            {  0      lelkef,    "index into the energy grid of tabulated functions"
            {  0      lelktmp,   "index into the energy grid of tabulated functions"
            {  0      ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0      "BCA = boundary crossing algorithm"
            {  0      callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0                  "= .false. => BCA does not require a call to howfar"
            {  0      domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0      dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0                  "= .false. => exact BCA requires no single scattering"
            {  0      callmsdist, "= .true.  => normal condensed-history transport"
            {  0                  "= .false. => one of the BCA's will be invoked"
            {  0      findindex,  "used for mscat"
            {  0      spin_index, "used for mscat with spin effects"
            {  0      compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0      ACD   , "used to test goodness of sine-table look-up"
            {  0      ADEV  , "absolute deviation in sine-table look-up"
            {  0      ASD   , "used to test goodness of sine-table look-up"
            {  0      COST  , "cos(theta) from instrinsic library function"
            {  0      CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0      DEL   , "leat squares delta for sine-table look-up"
            {  0      DFACT , "converts rl to dunits"
            {  0      DFACTI, "converts rl**-1 to dunits**-1"
            {  0      DUNITO, "units scaling varable"
            {  0      DUNITR, "saved value of dunit"
            {  0      FNSSS , "real form of integer nsinss"
            {  0      P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0      PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0      RDEV  , "relative deviation in sine-table look-up"
            {  0      S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0      S2C2MN, "min(s2c2)"
            {  0      S2C2MX, "max(s2c2)"
            {  0      SINT  , "sin(theta) from instrinsic library function"
            {  0      SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0      SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0      SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0              "table errors"
            {  0      SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0              "errors"
            {  0      WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0      XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0      XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0      WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0      YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0      ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0      I     , "generic do-loop variable"
            {  0      I1ST  , "flag = 0 on first pass"
            {  0      IB    , "do-loop variable used for reading the medium type"
            {  0      ID    , "integer value of -dunit, when dunit is negative"
            {  0      IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0      IL    , "do-loop variable used for reading the medium type"
            {  0      IM    , "do-loop variable looping over nmed, number of media"
            {  0      IRAYL , "Rayleigh switch read in from PEGS"
            {  0      IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0      ISTEST, "flag that switches on test of sine function fit"
            {  0      ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0      ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0      IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0              "sine-table look-up"
            {  0      IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0      J     , "do-loop variable looping over nmed, number of media"
            {  0      JR    , "do-loop variable looping over number of regions"
            {  0      LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0      LMDL  , "character width of medium header ' MEDIUM='"
            {  0      LMDN  , "character width of medium description"
            {  0      LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0      MD    , "temporary storage for the medium number"
            {  0      MXSINC, "number of intervals approximating the sine function"
            {  0      NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be cumulative electron mean free path. Presently unused."
            {  0      NEKE  , "array size input from PEGS."
            {  0              "Number of electron mapped energy intervals."
            {  0      NGE   , "array size input from PEGS."
            {  0              "Number of photon mapped energy intervals."
            {  0      NGRIM , "Rayleigh cross section array size."
            {  0      NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0      NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron energy intervals below threshold."
            {  0              "Presently unused."
            {  0      NM    , "number of media found in the "
            {  0      NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of intervals in an array giving the electron range."
            {  0              "Presently unused."
            {  0      NRNA  , "number of random angles testing sine function fit"
            {  0      NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron small energy intervals. Presently unused."
            {  0      NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of gamma small energy intervals. Presently unused."
            {  0      NSINSS, "number of sub-intervals for each sine function interval"
            {  0      LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0                   "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0       PEIE,   "precise total energy of incident electron"
            {  0       PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0       PESE1,  "precise total energy of 1st secondary electron"
            {  0       PESE2,  "precise total energy of 2nd secondary electron"
            {  0       PEKIN,  "precise kinetic energy of incident electron"
            {  0       H1,     "used for polar scattering angle calculation"
            {  0       DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0       EKIN,   "kinetic energy of incident electron"
            {  0       T0,     "kinetic energy of incident electron in units of RM"
            {  0       E0,     "total energy of incident electron in units of RM"
            {  0       EXTRAE, "energy above the Moller threshold"
            {  0       E02,    "E0**2"
            {  0       EP0,    "minimum alowed kinetic energy fraction"
            {  0       G2,G3,  "used for rejection function calculation"
            {  0       GMAX,   "maximum value of the rejection function"
            {  0       BR,     "kinetic energy fraction to lowew energy electron"
            {  0       R,      "(1-BR)/BR"
            {  0       REJF4,  "rejection function"
            {  0       RNNO27, "random number for BR sampling"
            {  0       RNNO28, "random number for rejection"
            {  0       ESE1,   "energy of 1st secondary electron"
            {  0       ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,      "precise energy of incident photon"
            {  0        PESE1,     "precise energy of 1st 'electron'"
            {  0        PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0        ESE2,      "total energy of lower energy 'electron'"
            {  0        RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0                   "random numbers"
            {  0        DELTA,     "scaled momentum transfer"
            {  0        REJF,      "screening rejection function"
            {  0        rejmax,    "the maximum of rejf"
            {  0        aux1,aux2, "auxilary variables"
            {  0        Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0        Bmax,      "Maximum of the screening function used with the uniform part"
            {  0        del0,      "delcm*eig"
            {  0        br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0                   "lower energy `electron'"
            {  0        Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0        L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0        PSE,   "momentum corresponding to ESE"
            {  0        ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIG, "incident photon energy in units of RM"
            {  0        TTESE, "energy of one of the 'electrons' in units of RM"
            {  0        TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0        ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0        ESEDER,"1/ESEDEI"
            {  0        XIMIN, "1st argument where rejection function might have a maximum"
            {  0        XIMID, "2nd argument where rejection function might have a maximum"
            {  0        REJMIN,"rejection function at XIMIN"
            {  0        REJMID,"rejection function at XIMID"
            {  0        REJTOP,"max(REJMIN,REJMID)"
            {  0        YA,XITRY,GALPHA,GBETA,
            {  0               "aux. variables for XIMID calculation"
            {  0        XITST, "random number for pair angle sampling"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        REJTST,"rejection function at XITST"
            {  0        RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0        ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0        PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0        sigma,        "elemental cross section"
            {  0        aux,aux1,     "aux. variables"
            {  0        probs($MXEL), "probability for an interaction with a given element"
            {  0        sigtot,       "total cross section"
            {  0        e_vac,        "shell binding energy"
            {  0        rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0        IARG,         "AUSGAB calling switch"
            {  0        iZ,           "Atomic number of the element the photon is "
            {  0                      "interactiong with"
            {  0        irl,          "local region number"
            {  0        ints($MXEL),  "energy interval number for a given element"
            {  0        j,ip,         "loop variables"
            {  0        n_warning,    "a warning counter"
            {  0        k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0        do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0        BETA,  "velocity of electron in units of c"
            {  0        GAMMA, "total energy of photo-electron in units of RM"
            {  0        ALPHA, "kinematic factor"
            {  0        RATIO, "=BETA/ALPHA"
            {  0        RNPHT, "random number"
            {  0        FKAPPA,"aux. variable for COSTHE calculation"
            {  0        XI,    "used in rejection function calculation"
            {  0        SINTH2,"SINTHE**2"
            {  0        RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0        "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0      PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0      EIG,    "photon energy"
            {  0      RNNO35, "random number for default MFP selection"
            {  0      GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0      GMFP,   "photon MFP after density scaling"
            {  0      COHFAC, "Rayleigh scattering correction"
            {  0      RNNO37, "random number for Rayleigh scattering selection"
            {  0      XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0      X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0      Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0      CSQTHE, "COSTHE**2"
            {  0      REJF,   "Rayleigh scattering rejection function"
            {  0      RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0      RNNO36, "random number for interaction branching"
            {  0      GBR1,   "probability for pair production"
            {  0      GBR2,   "probability for pair + compton"
            {  0      T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0      PHOTONUCFAC, "photonuclear correction"
            {  0      RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0      IARG,   "parameter for AUSGAB"
            {  0      IDR,    "parameter for AUSGAB"
            {  0      IRL,    "region number"
            {  0      LGLE,   "index for GMFP interpolation"
            {  0      LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0     IF( sig_ismonotone(qel,medium) ) [
            {  0         $EVALUATE-SIGF; sig0 = sigf;
            {  0     ]
            {  0     ELSE [
            {  0         IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0         ELSE            [sig0 = psig_e(medium);]
            {  0     ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0    IF(lelec < 0)
            {  0    [
            {  0        $EVALUATE sigf USING esig(elke);
            {  0        $EVALUATE dedx0 USING ededx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0    ELSE
            {  0    [
            {  0        $EVALUATE sigf USING psig(elke);
            {  0        $EVALUATE dedx0 USING pdedx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0      $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0      $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0      $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0     sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0    IF( compute_tstep ) [
            {  0      total_de = demfp/sig; fedep = total_de;
            {  0      ekef  = eke - fedep;
            {  0      IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0      ELSE
            {  0      [
            {  0        elkef = Log(ekef);
            {  0        $SET INTERVAL elkef,eke;
            {  0        IF( lelkef = lelke )
            {  0        [       " initial and final energy are in the same interpolation bin "
            {  0            $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0        ]
            {  0        ELSE
            {  0        [   " initial and final energy are in different interpolation bins, "
            {  0            " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0            " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0            ekei = E_array(lelke,medium);
            {  0            elkei = (lelke - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0            ekei = E_array(lelkef+1,medium);
            {  0            elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0            tstep=tstep+tuss+
            {  0                    range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0        ]
            {  0      ]
            {  0      total_tstep = tstep;
            {  0      compute_tstep = .false.;
            {  0    ]
            {  0    tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0    fedep = 1 - {P2}/{P1};
            {  0    elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0             " the above evaluates the logarithm of the midpoint energy"
            {  0    lelktmp = {P3};
            {  0    IF(lelec < 0) [
            {  0        $EVALUATE dedxmid USING ededx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = ededx1(lelktmp,medium)*dedxmid;
            {  0        "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0        "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0    "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0    {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0    ekei = E_array(lelke,medium);
            {  0    elkei = (lelke - eke0(medium))/eke1(medium);
            {  0    $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0    range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0    demfp = demfp - save_de*sig;
            {  0    total_de = total_de - save_de;
            {  0    total_tstep = total_tstep - tvstep*rhof;
            {  0    IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0    IF( lelec < 0 ) [
            {  0        $EVALUATE dedxmid USING ededx({P3});
            {  0        aux = ededx1({P4},medium)/dedxmid;
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx({P3});
            {  0        aux = pdedx1({P4},medium)/dedxmid;
            {  0    ]
            {  0
            {  0
            {  0
            {  0    {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0                              "rhof scaling must be done here and NOT in "
            {  0                              "$COMPUTE-ELOSS-G below!"
            {  0    fedep = {P5}/{P2};
            {  0    {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0               0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0    tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0      " here tuss is the range between the initial energy and the next lower "
            {  0      " energy on the interpolation grid "
            {  0    IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0        $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0        "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0        "    $COMPUTE-ELOSS above!                                  "
            {  0    ]
            {  0    ELSE [ " Must find first the table index where the step ends using "
            {  0           " pre-calculated ranges                                     "
            {  0        lelktmp = {P4};
            {  0        tuss = (range - {P1})*rhof;
            {  0           " now tuss is the range of the final energy electron "
            {  0           " scaled to the default mass density from PEGS4      "
            {  0        IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0          " i.e., if the step we intend to take is longer than the particle "
            {  0          " range, the particle energy goes down to the threshold "
            {  0          "({P2} is the initial particle energy)  "
            {  0          "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0          "to deal with such large eloss fractions => changed July 2005."
            {  0        ELSE [
            {  0            WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0                lelktmp = lelktmp - 1; ]
            {  0            elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0            eketmp = E_array(lelktmp+1,medium);
            {  0            "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0            "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0            "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0            tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0            $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0            {P5} = {P5} + {P2} - eketmp;
            {  0        ]
            {  0    ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0    ;COMMON/GetInput/
            {  0          ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0                                     "array index(0:4) for a value sought"
            {  0          VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0          CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0          VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0          DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0          VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0          VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0          NVALUE($NMAX),             "Number of values per value sought  "
            {  0          TYPE($NMAX),               "Type of the value sought           "
            {  0                                     "0 for integer                      "
            {  0                                     "1 for real                         "
            {  0                                     "2 for character                    "
            {  0                                     "3 for character with allowed_inputs"
            {  0          ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0                                     "attempted inputs                   "
            {  0          i_errors,                  "Unit no. for .errors output file   "
            {  0          NMIN, NMAX,                "Minimum and maximum index number of"
            {  0                                     "the values sought                  "
            {  0          ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0          DELIMETER;                 "Name of the delimeter              "
            {  0     character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0               CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
            {  0     $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0     $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0                          "Suppresses warnings from Intel compiler on Windows"
               0                     "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0    common/egs_vr/
            {  0      e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0      prob_RR,          "probability for survival in R. Roulette"
            {  0      nbr_split,        "do brems splitting if > 1"
            {  0      i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0      i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0                        "eliminated by RR in this interaction"
            {  0      n_RR_warning,     "a counter for user errors"
            {  0      i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0    $REAL          e_max_rr,prob_RR;
            {  0    $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0    $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0    i_survived_RR = 0;   "flag all survive"
            {  0    ;IF( i_play_RR = 1 ) [
            {  0        IF( prob_RR <= 0 ) [
            {  0            IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0              n_RR_warning = n_RR_warning + 1;
            {  0              OUTPUT prob_RR;
            {  0    ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0            ]
            {  0        ]
            {  0        ELSE [
            {  0            ip = {P1};
            {  0            LOOP [     "handle all particles from p1 to np"
            {  0                IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0                    $RANDOMSET rnno_RR;
            {  0                    IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0                        wt(ip) = wt(ip)/prob_RR;
            {  0                        ip = ip + 1; "increase local pointer"
            {  0                    ]
            {  0                    ELSE [                    "particle killed"
            {  0                        ;i_survived_RR = i_survived_RR + 1;
            {  0                        ;IF(ip < np) [
            {  0                            "=>replace it with last particle on stack"
            {  0                            e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0                        ]
            {  0                        np = np-1; "reduce stack by one=> particle gone"
            {  0                    ] "end of kill particle block"
            {  0                ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0            ] UNTIL (ip > np);
            {  0            "loops until either np is decreased to ip, or ip increased to np"
            {  0            IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0                           " so that the transport routines can exit properly"
            {  0                np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0            ]
            {  0        ] "end of russian roulette block"
            {  0    ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0      IF( radc_flag = 1 ) [
            {  0          $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0          $egs_info(*,'without having included rad_compton1.mortran');
            {  0          $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0          radc_flag = 0;
            {  0      ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0          ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0          ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0    DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0    $warning('(/a)','***************** Warning: ');
            {  0    $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0  "****************************************************************"
               0  " Useful output macros that do not rely on standard output unit. "
               0  " Useful for debugging code after egs_finish call which closes   "
               0  " all open units (for instance after a parallel job finishes).   "
               0  "****************************************************************"
               0  REPLACE {$egs_track2(#,#,#,#);} WITH {
            {  0        open({P1},file={P2},action='write',position='append');
            {  0        write({P1},{P3}) {P4};
            {  0        $FLUSH_UNIT({P1});
            {  0        close({P1});
            {  0  };
               0  REPLACE {$egs_track1(#,#,#);} WITH {
            {  0        open(666,file={P1},action='write',position='append');
            {  0        write(666,{P2}) {P3};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  REPLACE {$egs_track0(#,#);} WITH {
            {  0        open(666,file='track.log',action='write',position='append');
            {  0        write(666,{P1}) {P2};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  "************************************************************"
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0    common /egs_io/ file_extensions($mx_units),
            {  0                    file_units($mx_units),
            {  0                    user_code,  "The name of the user code"
            {  0                    input_file, "The input file name with path but no extension"
            {  0                    output_file,"Same as above but for output"
            {  0                    pegs_file,  "The pegs file name with path and extension"
            {  0                    hen_house,  "The HEN_HOUSE directory"
            {  0                    egs_home,   "The EGS_HOME directory"
            {  0                    work_dir,   "The working directory within the user code dir."
            {  0                    host_name,  "The name of the host"
            {  0                    n_parallel, "if >0, number of parallel jobs"
            {  0                    i_parallel, "if >0, parallel job number"
            {  0                    first_parallel,"first parallel job (default is 1)"
            {  0                    n_max_parallel,"if parallel run, max. number of running jobs"
            {  0                    n_chunk,    "Histories per calculation chunk"
            {  0                    n_files,
            {  0                    i_input,    "unit no. for .egsinp if required"
            {  0                    i_log,      "unit no. for .egslog if required"
            {  0                    i_incoh,    "unit no. for Compton data"
            {  0                    i_nist_data, "unit no. for NIST data"
            {  0                    i_mscat,     "unit no. for multiple scattering data"
            {  0                    i_photo_cs,  "unit no. for photon cross-section data"
            {  0                    i_photo_relax,  "unit no. for photon relaxation data"
            {  0                    xsec_out,       "switches on/off xsection file output"
            {  0                    is_batch,       "True for batch mode"
            {  0                    is_uniform_run, "True for uniform parallel run control"
            {  0                    is_pegsless;    "true if you are running without pegs file"
            {  0    character input_file*256, output_file*256, pegs_file*256,
            {  0              file_extensions*$max_extension_length,
            {  0              hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0              host_name*64;
            {  0    $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0              n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0              i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0    $LOGICAL  is_batch, is_pegsless, is_uniform_run;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0    $set_string(egs_home,' ');
            {  0    call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0      ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0      ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0      iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0      iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0      smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0      i_do_rr(i) = 0;               "range rejection flag"
            {  0      e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0      med(i) = 1;                   "default medium"
            {  0      rhor(i) = 0;                  "default mass density"
            {  0      iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0      iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0          "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0          IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0      ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        medium = med(j);
            {  0        IF( medium > 0 & medium <= nmed) [
            {  0            IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0    ecutmn = 1e30;
            {  0    DO i=1,$MXREG [
            {  0        IF( med(i) > 0 & med(i) <= nmed ) [
            {  0                  ecutmn = Min(ecutmn,ecut(i));
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0      IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc timing macros                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$DECLARE_TIMING_VARIABLES;} WITH {;
            {  0    real  CPUT0,CPUT1,CPUT2,TDUM;
            {  0    real egs_tot_time, egs_etime;}
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_CPU_TIME;} WITH {;}
               0  ;
               0  REPLACE {$SET_ELAPSED_CPUTIME(#);} WITH { {P1}=egs_etime(); }
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_TOTAL_TIME;} WITH
               0    { tdum = egs_tot_time(1); }
               0  ;
               0  REPLACE {$SET_ELAPSED_TOTAL_TIME(#);} WITH
               0    { {P1} = egs_tot_time(0); }
               0  ;
               0  REPLACE {$CONVERSION_TO_SECONDS} WITH {1.0}
               0  ;
               0  REPLACE {$TIME_RESOLUTION} WITH {0.01}
               0  ;
1              0  %E
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on Mon Feb  5 11:05:46 PM EST 2024         "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2024-02-06 04:05:46 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for ranmar random number generator                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Implementation for EGSnrc of the RANMAR random number generator (RNG),     "
               0  "  proposed by Marsaglia and Zaman.                                           "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  To use this set of macros, you need to initialize the RNG by a call to     "
               0  "  init_ranmar (in ranmar.mortran) or read-in a valid RNG state using the     "
               0  "  macro $RETRIEVE RNG STATE FROM UNIT #;                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$NRANMAR} WITH {128}
               0  REPLACE {;COMIN/RANDOM/;} WITH
               0  {;
            {  0  common/randomm/ rng_array($NRANMAR), urndm(97), crndm, cdrndm, cmrndm,
            {  0  i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed;
            {  0  integer*4       urndm, crndm, cdrndm, cmrndm, i4opt,
            {  0  ixx, jxx, fool_optimizer,rng_seed,rng_array;
            {  0  real*4          twom24;
            {  0  }
               0  "in the above, rng_seed is typed and part of common because it is"
               0  " initialized in BLOCK DATA for the ranlux rng.                  "
               0  " It is not actually used by ranmar."
               0
               0  " The following is the $RANDOMSET macro for EGSnrc."
               0  " Found that using integers it is faster by about 30% on a PIII CPU"
               0  " (which is the NRC computer environment                           "
               0
               0  " Found that when the RNG is not inlined, code runs faster "
               0  " Presumambly because the executable shrinks by a significant amount "
               0  " Iwan Kawrakow, May 2003 "
               0
               0  REPLACE {$RANDOMSET#;} WITH {;
            {  0  IF( rng_seed > $NRANMAR ) call ranmar_get;
            {  0  {P1} = rng_array(rng_seed)*twom24; rng_seed = rng_seed + 1;
            {  0  };
               0
               0  "REPLACE {$RANDOMSET#;} WITH
               0  "{
               0  "    i4opt = urndm(ixx) - urndm(jxx);
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    urndm(ixx) = i4opt;
               0  "    ixx = ixx - 1; jxx = jxx - 1;
               0  "    IF(ixx = 0)        [ ixx = 97; ]
               0  "    ELSE IF( jxx = 0 ) [ jxx = 97; ]
               0  "    crndm = crndm - cdrndm;
               0  "    IF(crndm < 0) crndm = crndm + cmrndm;
               0  "    i4opt = i4opt - crndm;
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    {P1} = twom24*i4opt;
               0  "}
               0  ;
               0
               0  REPLACE {$RNG-INITIALIZATION;} WITH { ;call init_ranmar; }
               0
               0  REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;
            {  0  ixx=0; jxx=0; call init_ranmar;
            {  0  };
               0
               0  REPLACE {$INITIALIZE RNG USING # AND #; } WITH {;
            {  0  ixx = {P1}; jxx = {P2};
            {  0  call init_ranmar;
            {  0  };
               0
               0  "**************************************************************************"
               0  " The macros below are not essential for the operation of the RNG,         "
               0  " they are defined for convinience in our NRC user codes                   "
               0  "**************************************************************************"
               0
               0  REPLACE {$STORE RNG STATE ON UNIT #;} WITH
               0  {
            {  0  rewind({P1});
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$PUT RNG STATE ON UNIT #;} WITH
               0  {
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$RETRIEVE RNG STATE FROM UNIT #;} WITH {;
            {  0  read({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  twom24 = 1./16777216.;  "just in case it is not initialized in rmarin"
            {  0  };
               0
               0  REPLACE {$SHOW-RNG-STATE(#);} WITH {;
            {  0  write({P1},'(a,2i4,$)') ' ixx jxx = ',ixx,jxx;
            {  0  };
               0
               0  REPLACE {$PRINT-RNG-STATE(#,#);} WITH {;
            {  0  write({P1},{P2}) ixx,jxx;
            {  0  };
               0
               0  REPLACE {$RNG-INPUTS(#,#,#,#);} WITH {;
            {  0  ival = ival + 1;
            {  0  VALUES_SOUGHT(IVAL)={P1};
            {  0  nvalue(ival) = 2;
            {  0  type(ival)   = 0;
            {  0  value_min(ival) = 1;
            {  0  value_max(ival) = 30081;
            {  0  default(ival)   = 9373;
            {  0  delimeter = {P2};
            {  0  nmin = ival; nmax = ival;
            {  0  call get_input;
            {  0  IF( error_flags(ival) = 0 ) [
            {  0  {P3} = value(ival,1);
            {  0  {P4} = value(ival,2);
            {  0  ]
            {  0  ELSE [ {P3} = 0; {P4} = 0; ]
            {  0  };
               0
               0  REPLACE {$RNG-STRING-1} WITH {' 1st initial random number seed: '}
               0  REPLACE {$RNG-STRING-2} WITH {' 2nd initial random number seed: '}
               0
               0  "            end of ranmar.macros         "
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc transport parameter macros                                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These macros are used in conjunction with the get_inputs.mortran routines  "
               0  "  to read in EGSnrc transport physics parameters. Specifically with          "
               0  "  subroutine get_transport_parameter.                                        "
               0  "                                                                             "
               0  "  The following are definitions of code words (values sought) for the        "
               0  "  various transport parameters that can be set. I hope they are              "
               0  "  self-explanatory. If you don't like them:                                  "
               0  "                                                                             "
               0  "  - include this file via the configuration file BEFORE your user code.      "
               0  "                                                                             "
               0  "  - Replace the macros in your user code with code words that you prefer.    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
               0  REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
               0  REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
               0  REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
               0  REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
               0  REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
               0  REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
               0  REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
               0  REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
               0  REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
               0  REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
               0  REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
               0  REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
               0  REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
               0  REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
               0  REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
               0  REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
               0  REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
               0  REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
               0  REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
               0  REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
               0  REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
               0  REPLACE {$IN_REGIONS}             WITH {'Regions'}
               0  REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
               0  REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
               0  REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
               0  REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
               0  REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
               0  "Ali:photonuc, 2 lines"
               0  "Cannot use $PHOTONUC; it clashes with other variables"
               0  REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
               0  REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
               0  REPLACE {$B_FIELD} WITH {'Magnetic Field'}
               0  REPLACE {$E_FIELD} WITH {'Electric Field'}
               0  REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
               0  ;
               0
               0  REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
               0  {;
            {  0  aux_inregions = .false.;
            {  0  IF( error_flags({P1}) = 0 ) [
            {  0  write(i_log,*) {P2};
            {  0  itmp = value({P1},1);
            {  0  IF( itmp = 2 | itmp = 3 ) [
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P2};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P3};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  Nmin = ival-1; Nmax = ival;
            {  0  CALL GET_INPUT;
            {  0  IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            {  0  IF( nvalue(ival) = nvalue(ival-1) ) [
            {  0  iitmp = itmp-2;
            {  0  DO j=1,$MXREG [ {P4}(j) = iitmp; ]
            {  0  "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
            {  0  iitmp = 1 - iitmp;
            {  0  "and then re-set in the specified regions"
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  "Ali:photonuc, 2 lines to crudely print start/stop regions"
            {  0  write(i_log,*) {P2},istart;
            {  0  write(i_log,*) {P3},iend;
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P4}(j) = iitmp; ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [
            {  0  IF( itmp > 3 ) itmp = itmp-2;
            {  0  write(i_log,*) ' Setting all to ',itmp;
            {  0  DO j=1,$MXREG [ {P4}(j) = itmp; ]
            {  0  ]
            {  0  ]
            {  0  ELSE ["Use default value"
            {  0  "Check if default is other than ON or Off"
            {  0  "and shift as no input by regions requested"
            {  0  IF({P4}(1) = 2 | {P4}(1) = 3)[
            {  0  value({P1},1) = {P4}(1)+2;
            {  0  ]
            {  0  ELSE[
            {  0  value({P1},1) = {P4}(1);
            {  0  ]
            {  0  ]
            {  0
            {  0  };
               0
               0  REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
               0  {;
            {  0
            {  0  aux_inregions = .false.;
            {  0  ival                = ival + 1;
            {  0  {P2}                = ival;
            {  0  values_sought(ival) = {P6};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 1;
            {  0  value_min(ival)     = {P3};
            {  0  value_max(ival)     = {P4};
            {  0  default(ival)       = {P5};
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P7};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P8};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
            {  0  CALL GET_INPUT;
            {  0
            {  0  IF( error_flag = 0 ) [
            {  0  IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P1}(j) = value({P2},k); ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 macros                                                        "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0  "MACROS TO SPLIT LONG STRING INTO A1 STRINGS"
               0  REPLACE {$S'{SYMBOL}#'} WITH
               0  {'#1'[IF]{EXIST 2}[,$S'{P2}']};
               0
               0  "pegs4 uses single precision.  real*8 causes problems"
               0  REPLACE {$REAL4} WITH {real*4};
               0
               0  PARAMETER $MXSTC=73;"NUMBER OF MEDIA WITH STERNHEIMER COEFFICIENTS"
               0  PARAMETER $RERR=1.E-5;      "RERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $AERR=1.E-16;     "AERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $FUDGEMS=1.0;  "FULL MS OFF ATOMIC ELECTRONS"
               0
               0  REPLACE {;COMIN/LBREMZ/;} WITH {
            {  0  ;COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  $REAL4 CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  }
               0
               0  REPLACE {;COMIN/PMCONS/;} WITH
               0  {;COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  $REAL4 PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  };
               0
               0  REPLACE {;COMIN/DERCON/;} WITH
               0  {;COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  $REAL4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  };
               0
               0  REPLACE {;COMIN/THRESHP/;} WITH
               0  {;COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP;
            {  0  $REAL4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP;
            {  0  $INTEGER IUNRSTP;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPRP/;} WITH
               0  {;COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6),
            {  0  DELCMP,ALPHIP(2),BPARP(2),DELPOSP(2);
            {  0  $REAL4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP;
            {  0  };
               0
               0  REPLACE {;COMIN/EPSTAR/;} WITH
               0  {;
            {  0  COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20),
            {  0  EPSTTL,NEPST,IEPST,EPSTFLP,
            {  0  NELEPS,ZEPST(20),IAPRFL,IAPRIMP;
            {  0  $INTEGER    ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP;
            {  0  CHARACTER   EPSTTL*80;
            {  0  $REAL4       EPSTEN,EPSTD,WEPST;
            {  0  };
               0
               0  "THIS COMMON IS USED FOR OPTION WHICH READS IN DENSITY EFFECT "
               0  "CORRECTION IN SPINIT AND CALCULATES USING IT IN SPIONB       "
               0  "THE FLAG EPSTFL IS READ UNDER NAMELIST INPUT, AND DEFAULTS   "
               0  "   TO ZERO IN THE BLOCK DATA. SET TO UNITY TO USE THE OPTION "
               0  "PEGS USES THE I-VALUE IN THE DENSITY INPUT FILE              "
               0  "VARIOUS CHECKS ARE DONE TO ENSURE THE DENSITY CORRECTION     "
               0  "   CORRESPONDS TO THE MATERIAL DEFINITION IN PEGS            "
               0  "THE ENERGY TABLE READ IN IS ASSUMED TO BE KINETIC ENERGY IN  "
               0  "   MEV BUT IS CONVERTED TO TOTAL ENERGY BY THE CODE.         "
               0  "THE ENERGY OPTION MUST BE USED IN PEGS PRIOR TO THE MIXT,COMP"
               0  "   OR ELEM OPTIONS TO ALLOW ALL THE CHECKS TO WORK PROPERLY. "
               0  "NELEPS IS THE NUMBER OF ELEMENTS IN THE MATERIAL             "
               0  "ZEPST(I) (INTEGER), WEPST(I) ARE THE Z VALUE AND FRACTION    "
               0  "   BY WEIGHT OF THE I-TH ELEMENT IN THE DATA FILE.           "
               0  "IAPRIM is a flag to tell which correction to the bremsstrahlung        "
               0  "       cross section to use:      0 =>  old Koch and Motz    "
               0  " =1(defaulat) read in new data file; =2, use no corrections. "
               0  "IAPRFL is a flag to say if APRIM file has been initialized   "
               0
               0  REPLACE {;COMIN/MOLVAR/;} WITH
               0  {;COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,
            {  0  RLCP,EDEN,RHOP,XCCP,BLCCP,TEFF0P,XR0P;
            {  0  $REAL4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP,
            {  0  XCCP,BLCCP,TEFF0P,XR0P;
            {  0  };
               0
               0  REPLACE {;COMIN/MIMSD/;} WITH
               0  {;COMMON/MIMSD/BMIN;
            {  0  $REAL4 BMIN;
            {  0  };
               0
               0  REPLACE {;COMIN/RADLEN/;} WITH
               0  {;COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183;
            {  0  $REAL4 ALRAD,ALRADP,A1440,A183;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LSPION--COMMON FOR COMMUNICATION BETWEEN SPINIT AND SPIONB    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LSPION/;} WITH
               0  {;COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  $REAL4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  };
               0
               0  REPLACE {;COMIN/SPCOMM/;} WITH
               0  {;COMMON/SPCOMM/MEDTBL(24,$MXSTC),
            {  0  NUMSTMED,STDATA(6,$MXSTC);
            {  0  $TYPE MEDTBL;
            {  0  $INTEGER NUMSTMED;
            {  0  $REAL4    STDATA;
            {  0  }
               0
               0  REPLACE {;COMIN/PWLFIN/;} WITH
               0  {;COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE;
            {  0  $REAL4 EPE,ZTHRE,ZEPE;
            {  0  $INTEGER NIPE,NALE;
            {  0  };
               0
               0  REPLACE {;COMIN/RSLTS/;} WITH
               0  {;COMMON/RSLTS/NEL,AXE,BXE,AFE($MXEKE,8),BFE($MXEKE,8);
            {  0  $REAL4 AXE,BXE,AFE,BFE;
            {  0  $INTEGER NEL;
            {  0  };
               0
               0  REPLACE {;COMIN/ELEMTB/;} WITH
               0  {;COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100);
            {  0  $INTEGER NET;
            {  0  $REAL4 ITBL,WATBL,RHOTBL;
            {  0  $TYPE ASYMT;
            {  0  }
               0
               0  REPLACE {;COMIN/MIXDAT/;} WITH
               0  {;COMMON/MIXDAT/NEP,LMED,PZP($MXEL),ZELEMP($MXEL),WAP($MXEL),RHOZP($MXEL),
            {  0  GASPP,EZ,TPZ,IDSTRN(24);
            {  0  $INTEGER NEP,LMED;
            {  0  $REAL4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ;
            {  0  $TYPE IDSTRN;
            {  0  }
               0
               0  REPLACE {;COMIN/DBRPR/;} WITH
               0  {;COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2;
            {  0  $REAL4 ALFP1,ALFP2,al2;
            {  0  };
               0
               0  "This block contains some media parameters required for"
               0  "cross-section calculations but not covered in any of the"
               0  "egsnrc common blocks.  It also contains $REAL4 versions"
               0  "of some egsnrc media parameters to allow direct comparison"
               0  "with cross-sections calculated by pegs4.mortran"
               0  REPLACE {;COMIN/MEDINP/;} WITH
               0  {;COMMON/MEDINP/inpdensity_file($MXMED),inpasym($MXMED,$MXEL),
            {  0  inpstrn(24,$MXMED),pz4($MXMED,$MXEL),
            {  0  rhoz4($MXMED,$MXEL),wa4($MXMED,$MXEL),inpgasp($MXMED);
            {  0  character*256 inpdensity_file;
            {  0  $TYPE inpasym,inpstrn;
            {  0  $REAL4 pz4,rhoz4,wa4,inpgasp;
            {  0  };
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {
            {  0  ;COMIN/LBREMZ,PMCONS,DERCON,EPSTAR,MOLVAR,LSPION,PWLFIN,
            {  0  RSLTS,SPCOMM,MIXDAT,RADLEN,MIMSD,THRESHP,BREMPRP,ELEMTB,MEDINP/;
            {  0  $REAL4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI;
            {  0  $INTEGER I01;
            {  0  EXTERNAL ALKE,ALKEI,EFUNS;
            {  0  $TYPE MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13);
            {  0  EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1));
            {  0  $REAL4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13);
            {  0  EQUIVALENCE (STDATA(1,1),STDAT1(1,1));
            {  0  EQUIVALENCE (STDATA(1,21),STDAT2(1,1));
            {  0  EQUIVALENCE (STDATA(1,41),STDAT3(1,1));
            {  0  EQUIVALENCE (STDATA(1,61),STDAT4(1,1));
            {  0  }
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH
               0  {;
            {  0
            {  0  call get_media_inputs(-1);
            {  0
            {  0  DO IM=1,NMED[
            {  0
            {  0  "store values in variables used to calculate cross-sections"
            {  0  AEP=AE(IM);
            {  0  UEP=UE(IM);
            {  0  APP=AP(IM);
            {  0  UPP=UP(IM);
            {  0  NEP=NNE(IM);
            {  0  IUNRSTP=IUNRST(IM);
            {  0  IAPRIMP=IAPRIM(IM);
            {  0  EPSTFLP=EPSTFL(IM);
            {  0  GASPP=INPGASP(IM); "recall gasp not an egsnrc variable"
            {  0  RHOP=RHO(IM);
            {  0  DO J=1,NEP[
            {  0  ZELEMP(J)=ZELEM(IM,J);
            {  0  "use the $REAL4 variables from MEDINP for these ones, for now"
            {  0  "since these have been calculated using $REAL4 math"
            {  0  PZP(J)=PZ4(IM,J);
            {  0  RHOZP(J)=RHOZ4(IM,J);
            {  0  WAP(J)=WA4(IM,J);
            {  0  ]
            {  0  DO IB=1,LMDN[
            {  0  IDSTRN(IB)=INPSTRN(IB,IM);
            {  0  ]
            {  0  TEP=AEP-RMP; THMOLLP=AEP+TEP ; "equation in pegs4.mortran"
            {  0
            {  0  IF (UEP.LE.AEP)[
            {  0  write(i_log,'(a,24a1)')'  Error: Material not defined: ',
            {  0  (media(j,IM),j=1,24);
            {  0  $egs_fatal(*,'Material used in the geometry was not defined in the'
            {  0  ,' material data.');
            {  0  ]
            {  0
            {  0  CALL MIX; "calculates MS parameters"
            {  0
            {  0  CALL SPINIT(inpdensity_file(IM)); "density corrections, may open density file"
            {  0
            {  0  CALL DIFFER;
            {  0  "do not know why we call above subroutine since"
            {  0  "bremsstrahlung cross-sections get reset in fix_brems"
            {  0
            {  0  "now call the piecewise linear fit subroutine to generate the remainder of"
            {  0  "the electron cross-sections"
            {  0  CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
            {  0  ALKEI,AXE,BXE,$MXEKE,8,AFE,BFE,EFUNS);
            {  0
            {  0  "cross-sections are now calculated"
            {  0  "store generated data in egsnrc variables"
            {  0
            {  0  "recompute the following two, note the different form of the equation for"
            {  0  "THMOLL compared to pegs4.mortran"
            {  0  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
            {  0
            {  0  "cross-section parameters"
            {  0  RLC(IM)=RLCP;"RLCP gets calculated in MIX"
            {  0
            {  0  XCC(IM)=XCCP;
            {  0  BLCC(IM)=BLCCP;
            {  0  XR0(IM)=XR0P;
            {  0  TEFF0(IM)=TEFF0P;
            {  0
            {  0  "all of the below gets reset in fix_brems"
            {  0  DELCM(IM)=DELCMP;
            {  0  DO I=1,2[
            {  0  ALPHI(I,IM)=ALPHIP(I);
            {  0  BPAR(I,IM)=BPARP(I);
            {  0  DELPOS(I,IM)=DELPOSP(I);
            {  0  ]
            {  0  DO I=1,6[
            {  0  DL1(I,IM)=DLP1(I);
            {  0  DL2(I,IM)=DLP2(I);
            {  0  DL3(I,IM)=DLP3(I);
            {  0  DL4(I,IM)=DLP4(I);
            {  0  DL5(I,IM)=DLP5(I);
            {  0  DL6(I,IM)=DLP6(I);
            {  0  ]
            {  0
            {  0
            {  0  "the following egsnrc quantities are all zeroed in the pegs4 generated data"
            {  0  "so they shall be zeroed here"
            {  0  MSGE(IM)=0;MSEKE(IM)=0;MLEKE(IM)=0;MCMFP(IM)=0;MRANGE(IM)=0;
            {  0
            {  0  "now, the non-zero quantities"
            {  0  MGE(IM)=$MXGE; "we do not use PWLF1 for photon quantities"
            {  0  "this setting is also done in init_user_photon"
            {  0  MEKE(IM)=NEL; "no. of electron energies as determed from PWLF1"
            {  0
            {  0  "now, set secondary egsnrc variables"
            {  0
            {  0  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
            {  0  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
            {  0
            {  0  "store results of pwlf in egsnrc variables"
            {  0  EKE0(IM)=BXE;
            {  0  EKE1(IM)=AXE;
            {  0
            {  0  "BFE and AFE were acquired with the call to"
            {  0  "PWLF1 above but we need to fill in the arrays"
            {  0  DO I=1,NEKE[
            {  0  ESIG0(I,IM)=BFE(I,1);
            {  0  ESIG1(I,IM)=AFE(I,1);
            {  0  PSIG0(I,IM)=BFE(I,2);
            {  0  PSIG1(I,IM)=AFE(I,2);
            {  0  EDEDX0(I,IM)=BFE(I,3);
            {  0  EDEDX1(I,IM)=AFE(I,3);
            {  0  PDEDX0(I,IM)=BFE(I,4);
            {  0  PDEDX1(I,IM)=AFE(I,4);
            {  0  EBR10(I,IM)=BFE(I,5);
            {  0  EBR11(I,IM)=AFE(I,5);
            {  0  PBR10(I,IM)=BFE(I,6);
            {  0  PBR11(I,IM)=AFE(I,6);
            {  0  PBR20(I,IM)=BFE(I,7);
            {  0  PBR21(I,IM)=AFE(I,7);
            {  0  TMXS0(I,IM)=BFE(I,8);
            {  0  TMXS1(I,IM)=AFE(I,8);
            {  0  ]
            {  0
            {  0  "below is for debugging to ensure that"
            {  0  "pegsless and pegs versions would give identical"
            {  0  "results if pegsless cross sections were to be"
            {  0  "read from a file a la pegs"
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0  ]
            {  0
            {  0  "put rescaling here in case we want to plot stopping powers via"
            {  0  "show_media_parameters below"
            {  0  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
            {  0  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
            {  0  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
            {  0  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
            {  0  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
            {  0  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
            {  0  DUNITR=DUNIT; "SAVE REQUESTED"
            {  0  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
            {  0  DUNIT=RLC(ID);]
            {  0  IF(DUNIT.NE.1.0) [
            {  0  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
            {  0  DUNITR,DUNIT,'(CM.)' );
            {  0  ]
            {  0  DO IM=1,NMED [
            {  0  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
            {  0  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
            {  0
            {  0  FOR I=1 TO MEKE(IM) [
            {  0  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
            {  0  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
            {  0  $SCALE TEFF0(IM) BY DFACT;
            {  0  $SCALE BLCC(IM) BY DFACTI;
            {  0  $SCALE XCC(IM) BY SQRT(DFACTI);
            {  0  RLDU(IM)=RLC(IM)/DUNIT;
            {  0  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
            {  0  ] "END IM DO"
            {  0
            {  0  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
            {  0  VACDST=VACDST*DUNITO/DUNIT;
            {  0  DUNITO=DUNIT; "SAVE OLD DUNIT"
            {  0
            {  0  call show_media_parameters(i_log);
            {  0
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {
            {  0  ;
            {  0  "***PHYSICAL AND MATHEMATICAL CONSTANTS                                "
            {  0  "     C        SPEED OF LIGHT(CM/SEC)                                  "
            {  0  "     RME      ELECTRON REST MASS(GRAMS)                               "
            {  0  "     HBAR     PLANCK'S CONSTANT/(2*PI)  (ERG SEC)                     "
            {  0  "     ECGS     ELECTRON CHARGE (ESU)                                   "
            {  0  "     EMKS     ELECTRON CHARGE (COULOMB)                               "
            {  0  "     AN       AVOGADRO'S NUMBER                                       "
            {  0  PIP=3.1415926536;
            {  0  C=2.997925E+10;
            {  0  HBAR=1.05450E-27;
            {  0  ECGS=4.80298E-10;
            {  0  EMKS=1.60210E-19;
            {  0  AN=6.02252E+23;
            {  0  "***DERIVED CONSTANTS                                                  "
            {  0  "     RADDEG   ONE RADIAN IN DEGREES                                   "
            {  0  "     FSC      FINE STRUCTURE CONSTANT                                 "
            {  0  "     ERGMEV   ONE MILLION ELECTRON VOLTS EXPRESSED IN ERGS            "
            {  0  "     R0       CLASSICAL ELECTRON RADIUS                               "
            {  0  "     RM       ELECTRON REST ENERGY IN MEV                             "
            {  0  RADDEG=180./PIP;
            {  0  FSC = ECGS**2/(HBAR*C);
            {  0  "     1.E+7 IS THE NUMBER OF ERGS PER JOULE                            "
            {  0  ERGMEV = (1.E+6)*(EMKS*1.E+7);
            {  0  RME = PRM/C**2*ERGMEV;
            {  0  "We are using RMP instead of PRM because single precision is required"
            {  0  RMP = PRM;
            {  0  R0 = (ECGS**2)/(RME*C**2);
            {  0  RMPSQ = RMP*RMP;
            {  0  A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV;
            {  0  A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13));
            {  0
            {  0  "DATA FOR COMMON BLOCK LSPION"
            {  0  DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/;
            {  0
            {  0  "DATA for COMMON BLOCK SPCOMM"
            {  0  DATA LMED/24/,NUMSTMED/$MXSTC/;
            {  0
            {  0  "DATA for COMMON BLOCK PWLFIN"
            {  0  DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/$MXEKE/;
            {  0
            {  0  "DATA for COMMON BLOCK MIMSD"
            {  0  DATA BMIN/4.5/;
            {  0
            {  0  "DATA for COMMON BLOCK RADLEN"
            {  0  DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/,
            {  0  A1440/1194.0/,A183/184.15/;
            {  0
            {  0  DATA MEDTB1/
            {  0  $S'H2-GAS',18*' ',$S'H2-LIQUID',15*' ',$S'HE-GAS',18*' ',$S'LI',22*' ',
            {  0  $S'BE',22*' ',$S'C-2.265 G/CM**3',9*' ',$S'C-1.70 G/CM**3',10*' ',
            {  0  $S'N2-GAS',18*' ',$S'O2-GAS',18*' ',$S'NE-GAS',18*' ',$S'NA',22*' ',
            {  0  $S'MG',22*' ',$S'AL',22*' ',$S'SI',22*' ',$S'AR-GAS',18*' ',
            {  0  $S'K',23*' ',$S'CA',22*' ',$S'TI',22*' ',$S'V',23*' ',$S'MN',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB2/
            {  0  $S'FE',22*' ',$S'CO',22*' ',$S'NI',22*' ',$S'CU',22*' ',$S'ZN',22*' ',
            {  0  $S'GE',22*' ',$S'SE',22*' ',$S'KR-GAS',18*' ',$S'RB',22*' ',
            {  0  $S'MO',22*' ',$S'AG',22*' ',$S'CD',22*' ',$S'IN',22*' ',$S'SN',22*' ',
            {  0  $S'XE-GAS',18*' ',$S'CS',22*' ',$S'GD',22*' ',$S'TA',22*' ',
            {  0  $S'W',23*' ',$S'PT',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB3/
            {  0  $S'AU',22*' ',$S'HG',22*' ',$S'PB',22*' ',$S'RN-GAS',18*' ',
            {  0  $S'U',23*' ',
            {  0  $S'AIR-GAS',17*' ',$S'CO2-GAS',17*' ',$S'POLYETHYLENE',12*' ',
            {  0  $S'POLYPROPYLENE',11*' ',$S'XYLENE',18*' ',$S'TOLUENE',17*' ',
            {  0  $S'NYLON',19*' ',$S'VINYLTOLUENE',12*' ',$S'A150-PLASTIC',12*' ',
            {  0  $S'STILBENE',16*' ',$S'POLYSTYRENE',13*' ',$S'ANTHRACENE',14*' ',
            {  0  $S'LEXAN',19*' ',$S'LUCITE',18*' ',$S'H2O',21*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB4/
            {  0  $S'MYLAR',19*' ',
            {  0  $S'KAPTON',18*' ',$S'LIF',21*' ',$S'POLYVINYL-CL',12*' ',
            {  0  $S'PYREX-GLASS',13*' ',$S'SIO2',20*' ',$S'CAF2',20*' ',
            {  0  $S'PHOTOEMULSION',11*' ',$S'AGCL',20*' ',$S'NAI',21*' ',
            {  0  $S'LII',21*' ',$S'AGBR',20*' ',$S'CSI',21*' '
            {  0  /;
            {  0
            {  0  DATA STDAT1/
            {  0  0.03535,6.790,1.864,3.5,19.2,9.584,
            {  0  0.09179,5.831,0.476,2.0,21.8,3.263,
            {  0  0.0114,7.625,2.202,4.0,41.8,11.139,
            {  0  0.3492,3.233,0.0966,2.0,40.0,3.122,
            {  0  0.3518,3.034,-0.0089,2.0,63.7,2.785,
            {  0  0.5848,2.360,-0.0089,2.0,78.0,2.868,
            {  0  0.7154,2.191,-0.0089,2.0,78.0,3.155,
            {  0  0.2120,3.041,1.738,4.0,82.0,10.540,
            {  0  0.2666,2.825,1.754,4.0,95.0,10.700,
            {  0  0.1202,3.357,2.073,4.5,137.0,11.904,
            {  0  0.2204,3.103,0.4515,2.8,149.0,5.053,
            {  0  0.1714,3.223,0.2386,2.8,156.0,4.530,
            {  0  0.3346,2.795,0.0966,2.5,166.0,4.239,
            {  0  0.3755,2.720,0.0966,2.5,173.0,4.435,
            {  0  0.1902,2.982,1.764,4.5,188.0,11.948,
            {  0  0.3041,2.674,0.2386,3.0,190.0,5.642,
            {  0  0.2177,2.874,0.1751,3.0,191.0,5.040,
            {  0  0.1782,2.946,0.0485,3.0,233.0,4.445,
            {  0  0.1737,2.935,-0.0089,3.0,245.0,4.266,
            {  0  0.1996,2.812,-0.0089,3.0,272.0,4.270
            {  0  /;
            {  0
            {  0  DATA STDAT2/
            {  0  0.2101,2.771,-0.0089,3.0,286.0,4.291,
            {  0  0.2229,2.713,-0.0089,3.0,297.0,4.260,
            {  0  0.2504,2.619,-0.0089,3.0,311.0,4.312,
            {  0  0.2557,2.613,-0.0089,3.0,322.0,4.419,
            {  0  0.3163,2.468,0.0485,3.0,330.0,4.691,
            {  0  0.2809,2.647,0.2386,3.0,350.0,5.141,
            {  0  0.2979,2.635,0.2386,3.0,348.0,5.321,
            {  0  0.1519,3.030,1.716,4.8,352.0,12.512,
            {  0  0.1450,3.078,0.4515,3.5,363.0,6.478,
            {  0  0.2228,2.824,0.1751,3.0,424.0,4.879,
            {  0  0.3091,2.563,-0.0089,3.0,470.0,5.063,
            {  0  0.1853,2.819,0.0485,3.3,469.0,5.273,
            {  0  0.2004,2.790,0.1751,3.3,487.0,5.517,
            {  0  0.1898,2.839,0.2386,3.3,488.0,5.534,
            {  0  0.1329,3.020,1.563,5.0,482.0,12.728,
            {  0  0.2214,2.784,0.4515,3.5,488.0,6.914,
            {  0  0.2068,2.686,0.0485,3.5,591.0,5.874,
            {  0  0.1663,2.805,0.1751,3.5,718.0,5.526,
            {  0  0.1499,2.870,0.1751,3.5,727.0,5.406,
            {  0  0.1465,2.903,0.0966,3.5,790.0,5.473
            {  0  /;
            {  0
            {  0  DATA STDAT3/
            {  0  0.1533,2.881,0.0966,3.5,790.0,5.575,
            {  0  0.1824,2.798,0.2386,3.5,800.0,5.961,
            {  0  0.1861,2.814,0.2386,3.5,823.0,6.202,
            {  0  0.1130,3.023,1.537,5.3,794.0,13.284,
            {  0  0.1362,3.034,0.2386,3.5,890.0,5.869,
            {  0  0.2466,2.879,1.742,4.0,85.7,10.595,
            {  0  0.1999,3.022,1.648,4.0,88.7,10.239,
            {  0  0.4875,2.544,0.1379,2.0,57.4,3.002,
            {  0  0.2493,2.975,0.1537,2.3,59.2,3.126,
            {  0  0.2755,2.911,0.1695,2.3,61.8,3.270,
            {  0  0.2830,2.890,0.1722,2.3,62.5,3.303,
            {  0  0.5345,2.439,0.1336,2.0,63.9,3.063,
            {  0  0.3495,2.749,0.1467,2.2,64.7,3.201,
            {  0  0.5462,2.435,0.1329,2.0,65.1,3.110,
            {  0  0.2989,2.851,0.1731,2.3,67.7,3.367,
            {  0  0.3670,2.724,0.1647,2.2,68.7,3.300,
            {  0  0.5858,2.364,0.1146,2.0,69.5,3.151,
            {  0  0.3865,2.664,0.1608,2.2,73.1,3.321,
            {  0  0.3996,2.606,0.1824,2.2,74.0,3.330,
            {  0  0.2065,3.007,0.2400,2.5,75.0,3.502
            {  0  /;
            {  0
            {  0  DATA STDAT4/
            {  0  0.3124,2.782,0.1561,2.3,78.7,3.326,
            {  0  0.4061,2.614,0.1492,2.2,79.3,3.342,
            {  0  0.1308,3.476,0.0171,2.5,94.0,3.167,
            {  0  0.1873,2.962,0.1558,2.8,108.2,4.053,
            {  0  0.2988,2.805,0.1479,2.5,134.0,3.971,
            {  0  0.1440,3.220,0.1385,2.8,139.2,4.003,
            {  0  0.3750,2.592,0.0676,2.5,166.0,4.065,
            {  0  0.3416,2.496,0.1009,3.0,331.0,5.332,
            {  0  0.1243,3.002,-0.0138,3.5,398.4,5.344,
            {  0  0.1560,2.926,0.1203,3.5,452.0,6.057,
            {  0  0.1785,2.845,0.0892,3.5,485.1,6.267,
            {  0  0.1351,2.976,0.0358,3.5,487.2,5.616,
            {  0  0.1796,2.840,0.0395,3.5,553.1,6.281
            {  0  /;
            {  0
            {  0  DATA NET/100/;
            {  0
            {  0  DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137.,
            {  0  149.,156.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245.,
            {  0  257.,272.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352.,
            {  0  363.,366.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488.,
            {  0  488.,487.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574.,
            {  0  580.,591.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736.,
            {  0  746.,757.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826.,
            {  0  841.,847.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./;
            {  0
            {  0  DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067,
            {  0  15.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738,
            {  0  32.064,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998,
            {  0  54.9380,55.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216,
            {  0  78.96,79.808,83.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0,
            {  0  101.07,102.905,106.4,107.87,112.4,114.82,118.69,121.75,127.60,
            {  0  126.9044,131.30,132.905,137.34,138.91,
            {  0  140.12,140.907,144.24,147.,150.35,151.98,157.25,158.924,162.50,
            {  0  164.930,167.26,168.934,173.04,174.97,178.49,180.948,183.85,
            {  0  186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,208.980,
            {  0  210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242.,
            {  0  243.,247.,247.,248.,254.,253./;
            {  0
            {  0  DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0,
            {  0  0.9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54,
            {  0  5.87,7.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80,
            {  0  4.2,3.4,1.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5,
            {  0  8.65,7.30,7.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769,
            {  0  7.007, 1.  ,7.54,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85,
            {  0  11.40,16.60,19.30,20.53,22.48,22.42,21.45,19.30,14.19,11.85,
            {  0  11.34,9.78,9.30, 1.  ,4., 1.  ,5.,  1. ,11.0,15.37,18.90,
            {  0  20.5,19.737,11.7,7.,1.   , 1.  , 1.  ,  1. /;
            {  0
            {  0  DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE',
            {  0  'NA','MG','AL','SI','P','S','CL','AR','K','CA','SC','TI',
            {  0  'V','CR','MN','FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR',
            {  0  'KR','RB','SR','Y','ZR','NB','MO','TC','RU','RH','PD','AG','CD',
            {  0  'IN','SN','SB','TE','I','XE','CS','BA','LA','CE','PR','ND',
            {  0  'PM','SM','EU','GD','TB','DY','HO','ER','TM','YB','LU','HF','TA',
            {  0  'W','RE','OS','IR','PT','AU','HG','TL','PB','BI','PO','AT','RN',
            {  0  'FR','RA','AC','TH','PA','U','NP','PU','AM','CM','BK','CF','ES',
            {  0  'FM'/;
            {  0
            {  0  "for COMMON BLOCK EPSTAR"
            {  0  DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/;
            {  0
            {  0  }
               0
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros to read and write phase space files                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1999                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros required to read from and write to phase space files. These macros  "
               0  "  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
               0  "  manipulations of phase space files that were hard-coded. Currently, these  "
               0  "  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
               0  "  configuration script looks for this file in the following directories, in  "
               0  "  this order                                                                 "
               0  "                                                                             "
               0  "  $HOME/egs4/BEAM_accelerator                                                "
               0  "  $HOME/egs4/beam                                                            "
               0  "  $OMEGA_HOME/beam                                                           "
               0  "                                                                             "
               0  "  All other configuration or compile scripts only use the version of this    "
               0  "  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
               0  "  that this file is concatenated before any codes that use the macros.       "
               0  "  Detailed description of what each macro does is provided at the top of     "
               0  "  the macro.                                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  ;
               0  REPLACE {;COMIN/RWPHSP/;} WITH {
            {  0  "RWPHSP must be included in the common block of main in any code that uses"
            {  0  "any of these phase space macros and also in the common block of"
            {  0  "any subroutine that uses any phase space macros.  Note that the macro"
            {  0  "$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
            {  0  "somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
            {  0  "DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
            {  0  "at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
            {  0  "variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
            {  0  "the top of any code that uses these macros.  If your compiler has trouble"
            {  0  "with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."
            {  0
            {  0  ;COMMON/RWPHSP/
            {  0  STRING_TEMP_ZLAST_OUT,
            {  0  "holds output phsp data for up to 1000 particles, with ZLAST"
            {  0  STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
            {  0  IHSTRY_PHSP, "history number (from primary non-phase space source) of"
            {  0  "particle being scored"
            {  0  iaea_dummy_long, "used to store INTEGER*8 values temporarily"
            {  0  NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
            {  0  "dosxyznrc source 20"
            {  0  ESHORT,    "single precision E read from/written to phsp"
            {  0  WEIGHTTMP, "modified version of WT to be written to phsp"
            {  0  WT_PHSP_SHORT, "single precision wt read from phsp"
            {  0  X_PHSP_SHORT, "single precision x read from phsp"
            {  0  Y_PHSP_SHORT, "single precision y read from phsp"
            {  0  Z_PHSP_SHORT, "single precision Z--for iaea format only"
            {  0  U_PHSP_SHORT, "single precision u read from phsp"
            {  0  V_PHSP_SHORT, "single precision v read from phsp"
            {  0  W_PHSP_SHORT, "single precision w--for iaea format only"
            {  0  ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
            {  0  MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
            {  0  EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
            {  0  EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
            {  0  NINC_PHSP_SHORT, "no. of particles from original primary source"
            {  0  dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
            {  0  iaea_extra_floats, "array of extra floats in IAEA phsp file"
            {  0  NUM_PHSP_TOT, "tot no of particles in phsp file"
            {  0  PHOT_PHSP_TOT,"no. of photons in phsp file"
            {  0  iaea_result,  "<0 if an error finding an available array index for IAEA"
            {  0  "phsp file"
            {  0  iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
            {  0  iaea_q_typ,    "array to convert from charge to IAEA type"
            {  0  iaea_typ_q,   "array to convert from IAEA type to charge"
            {  0  iaea_q_index, "array index"
            {  0  I_PHSP,    "loop counter"
            {  0  IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
            {  0  LATCHTMP,  "modified version of LATCH to be written to phsp"
            {  0  WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
            {  0  WRITE_PHSP_SOFAR, "how many particles written so far to file"
            {  0  PHSP_RESTART, "set to 1 if this is a restart"
            {  0  PHSP_RECL, "the record length"
            {  0  PHSP_RECL_OLD, "saves record length"
            {  0  iaea_extra_ints, "array in which LATCH will be stored for iaea format"
            {  0  iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
            {  0  "extra int and float variables in an IAEA phsp file"
            {  0  iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
            {  0  "IAEA phsp files read IN"
            {  0  iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
            {  0  iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
            {  0  i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
            {  0  "was used"
            {  0  iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
            {  0  " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
            {  0  " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
            {  0  MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"
            {  0
            {  0  CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
            {  0  CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
            {  0  $LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
            {  0  REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
            {  0  MUIDX_PHSP_SHORT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
            {  0  iaea_extra_floats(10);
            {  0  INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
            {  0  IERR_PHSP,LATCHTMP,
            {  0  WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
            {  0  PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
            {  0  iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
            {  0  iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
            {  0  i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
            {  0  iaea_i_muidx_out,dosxyz2beam_izscore;
            {  0  CHARACTER*5 MODE_RW;
            {  0
            {  0  "variables below are not part of the common block but are used locally"
            {  0  "by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"
            {  0
            {  0  INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
            {  0  REAL*4 REAL_TEMP_OUT(7);
            {  0  CHARACTER*32 REC_TEMP_OUT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
            {  0  "Must be placed after the variable declarations in any subroutine"
            {  0  "where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
            {  0  "it does not necessarily have to be put at the top of main, unless one or"
            {  0  "both of these macros are used in main."
            {  0  "It equivalences the character string REC_TEMP_OUT with the phase space data"
            {  0  "for 1 particle. REC_TEMP_OUT is then used to fill the character array"
            {  0  "STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
            {  0  "particles before writing."
            {  0
            {  0  EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
            {  0  EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
            {  0  EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
            {  0  EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
            {  0  EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
            {  0  EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
            {  0  EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
            {  0  EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
            {  0  }
               0  ;
               0
               0  REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
            {  0  "This macro initializes counters and flags that are used by the"
            {  0  "$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
            {  0  "used once and should be placed after the variable declarations in main."
            {  0
            {  0  DO I_PHSP=1,$MAX_SC_PLANES[
            {  0  WRITE_PHSP_COUNTER(I_PHSP)=0;
            {  0  WRITE_PHSP_SOFAR(I_PHSP)=0;
            {  0  IHSTRY_PHSP(I_PHSP)=0;
            {  0  ]
            {  0  PHSP_RESTART=0;
            {  0  PHSP_RECL_OLD=0;
            {  0
            {  0  iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
            {  0  iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;
            {  0
            {  0  iaea_n_extra_ints=0;iaea_n_extra_floats=0;
            {  0
            {  0  iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;
            {  0
            {  0  i_iaea_open_for_write=0;
            {  0
            {  0  iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;
            {  0
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
            {  0  "Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
            {  0  "by clearing the bits that store this information.  It also puts the"
            {  0  "single precision energy, ESHORT, read in into double precision form."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0
            {  0  {P4}=ESHORT;
            {  0
            {  0  IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
            {  0  ELSE [ {P1} = 0; ]
            {  0
            {  0  IF($BTEST({P3},30)) [
            {  0  {P2} = -1;
            {  0  {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [
            {  0  IF($BTEST({P3},29)) [
            {  0  {P2} = 1; {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [ {P2} = 0; ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
            {  0  "This macro calculates W, based on U and V and the sign of WT as read in from"
            {  0  "the phase space file.  Once the sign of WT is determined, WT is set equal"
            {  0  "to its absolute value, since there cannot be a negative particle weight."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=W"
            {  0  "{P2}=WT"
            {  0  "{P3}=X"
            {  0  "{P4}=Y"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0
            {  0  {P1} = min( 1., {P5}**2 + {P6}**2);
            {  0  {P1} = sqrt(1. - {P1});
            {  0  {P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"
            {  0
            {  0  {P2}=ABS({P2}); "WT is always positive"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
            {  0  "macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
            {  0  "read from phase space file into (potentially) double precision"
            {  0  "x, y, u, v passed to READ_PHSP_RECORD macro"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=X"
            {  0  "{P2}=Y"
            {  0  "{P3}=U"
            {  0  "{P4}=V"
            {  0
            {  0  {P1}=X_PHSP_SHORT;
            {  0  {P2}=Y_PHSP_SHORT;
            {  0  {P3}=U_PHSP_SHORT;
            {  0  {P4}=V_PHSP_SHORT;
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required  ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro actually reads the phase space data for a single particle."
            {  0  "It is called by $READ_PHSP, but can also be used as a stand-alone macro."
            {  0  "If the energy, E, is < 0.0, then this is the first particle scored"
            {  0  "from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
            {  0  "and E is set to ABS(E)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=NHSTRY"
            {  0  "{P5}=ZLAST"
            {  0  "{P6}=LATCH"
            {  0  "{P7}=E"
            {  0  "{P8}=WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
            {  0  ]
            {  0
            {  0  IF({P3}=76695869)[
            {  0  write(*,*)' x,y,u,v,wt,eshort,latch',
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
            {  0  WT_PHSP_SHORT,ESHORT,{P6};
            {  0  ]
            {  0
            {  0  "first particle from new primary history"
            {  0  IF(ESHORT<0.0)[
            {  0  {P4}={P4}+1;
            {  0  ESHORT=ABS(ESHORT);
            {  0  ]
            {  0
            {  0  {P7}=ESHORT;
            {  0  {P8}=WT_PHSP_SHORT;
            {  0  $PARSE_PHSP_RECORD({P9});
            {  0
            {  0  IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required            ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
            {  0  "the -E marker in the phase space file and does not advance NHSTRY"
            {  0  "It is only used in readphsp before byte swapping"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=ZLAST"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=E"
            {  0  "{P7}=WT"
            {  0  "{P8}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Note colon          ^  required between the first and second"
            {  0  "input parameters (third and fourth input variables)"
            {  0
            {  0  "This macro reads the phase space data for a single particle.  It finds"
            {  0  "the value of IQ and NPASS from the LATCH variable read in and then"
            {  0  "restores the LATCH variable.  It calculates W from U, V and the sign"
            {  0  "of WT and then restores WT to its absolute value.  And it puts the"
            {  0  "single-precision energy, ESHORT, read in into double-precision format."
            {  0  "If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
            {  0  "this as the first particle scored from a new primary history."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,record number reading from"
            {  0  "{P2}=NHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E"
            {  0  "{P9}=WT,X,Y,U,V"
            {  0
            {  0  $READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});
            {  0
            {  0  IF(IERR_PHSP=0)[
            {  0  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
            {  0  $GET_W_WT({P5},{P9});
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
            {  0  "This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
            {  0  "for a particle and is the form of LATCH written to the phase space file."
            {  0  "It puts double precision energy, E, into single precision format, ESHORT,"
            {  0  "for writing to the phase space file.  This macro is called from $READ_PHSP"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=W"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=E"
            {  0  "{P6}=WT"
            {  0
            {  0  LATCHTMP={P4};
            {  0
            {  0  IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
            {  0  ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]
            {  0
            {  0  IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
            {  0  ELSEIF({P2} = 0) [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBCLR(LATCHTMP,29);
            {  0  ]
            {  0  ELSE [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBSET(LATCHTMP,29);
            {  0  ]
            {  0
            {  0  ESHORT={P5};
            {  0
            {  0  WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
            {  0  "Macro to set E to -E if this is the first particle scored from a new"
            {  0  "primary (non-phsp source) history.  This macro is called from"
            {  0  "$WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters"
            {  0  "{P1}=phase space scoring plane no."
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=E"
            {  0  "{P4}=WT,X,Y,U,V"
            {  0
            {  0  IF({P2}~=IHSTRY_PHSP({P1}))[
            {  0  {P3}=-{P3};
            {  0  IHSTRY_PHSP({P1})={P2};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Macro to store the output phase space data for one particle in the"
            {  0  "variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
            {  0  "equivalenced to the string variable REC_TEMP_OUT, which stores the"
            {  0  "phase space for one particle in string form and which, in turn, is"
            {  0  "used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
            {  0  "which stores output phase space data for up to 1000 particles at a time."
            {  0  "This macro is called from $WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=ZLAST"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0  "{P5}=WT"
            {  0  "{P6}=X"
            {  0  "{P7}=Y"
            {  0  "{P8}=U"
            {  0  "{P9}=V"
            {  0
            {  0  LATCH_TEMP_OUT={P3};
            {  0  REAL_TEMP_OUT(1)={P4};
            {  0  REAL_TEMP_OUT(2)={P6};
            {  0  REAL_TEMP_OUT(3)={P7};
            {  0  REAL_TEMP_OUT(4)={P8};
            {  0  REAL_TEMP_OUT(5)={P9};
            {  0  REAL_TEMP_OUT(6)={P5};
            {  0  IF({P1}~=0) REAL_TEMP_OUT(7)={P2};
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
            {  0  "Note that a colon is required       ^  between the fifth and sixth"
            {  0  "input parameters"
            {  0
            {  0  "This macro is used to output phase space data 1000 particles at a time."
            {  0  "For every particle, the phase space data to be output is stored in"
            {  0  "the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
            {  0  "STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
            {  0  "space header info is considered to occupy the space of 1 particle in the"
            {  0  "first block of 1000 particles, however, it will be overwritten with nulls."
            {  0  "This is fine since the header info should be recalculated and rewritten at"
            {  0  "the top of the file after all data has been written out anyway."
            {  0  "Also note that restarting with this writing scheme requires that any"
            {  0  "blocks of N (N<1000) particles at the end of a phase space file from"
            {  0  "the previous run must immediately be read into the first N spaces of"
            {  0  "STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
            {  0  "for new particles.  Finally, after all phase space data has been output,"
            {  0  "there will probably be info for M (M<1000) particles still in"
            {  0  "STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
            {  0  "because the write counter did not reach 1000.  These are output using"
            {  0  "the $PHSP_BUFFER_FLUSH macro described below."
            {  0
            {  0  "Group writing reduces network traffic and saves a lot of time when the"
            {  0  "one of the main CPU-intensive activities is the writing of phase space data."
            {  0  "Group reading has also been considered, but preliminary studies have shown"
            {  0  "that it does not reduce CPU time significantly."
            {  0
            {  0  "Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
            {  0  "E to -E if this is the first particle scored from a new primary"
            {  0  "(non-phsp source) history."
            {  0
            {  0  "This macro is called by $WRITE_PHSP, but can also be used as a stand-"
            {  0  "alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
            {  0  "use of $PHSP_BUFFER_FLUSH (see below)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=name of phase space file"
            {  0  "{P4}=record number writing to"
            {  0  "{P5}=scoring plane number"
            {  0  "{P6}=IHSTRY"
            {  0  "{P7}=ZLAST"
            {  0  "{P8}=LATCH"
            {  0  "{P9}=E,WT,X,Y,U,V"
            {  0
            {  0  IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
            {  0  "we have a restart or its the start of a new batch"
            {  0  IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
            {  0  "make what was the buffer flush part of the first record of the restart"
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
            {  0  IF(WRITE_PHSP_SOFAR({P5})>0)[
            {  0  PHSP_RESTART=1;
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
            {  0  ]
            {  0  ELSE[
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
            {  0  ]
            {  0  ]
            {  0
            {  0  $SET_NEGATIVE_E({P5},{P6},{P9});
            {  0
            {  0  $PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});
            {  0
            {  0  IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
            {  0  32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
            {  0  28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  IF({P1}~=0)[
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
            {  0  32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
            {  0  28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0
            {  0  IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
            {  0  IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
            {  0  CLOSE({P2});
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  IF({P1}~=0)[
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
            {  0  ]
            {  0  IF(PHSP_RECL_OLD~=0)[
            {  0  "have to do this in case the output file=input file"
            {  0  PHSP_RECL=PHSP_RECL_OLD;
            {  0  CLOSE({P2});
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
            {  0  "This macro outputs the data for the M (M<1000) remaining particles still"
            {  0  "stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
            {  0  "The macro does not flush all of the data at once, but in blocks that"
            {  0  "divide exactly into the number of particles already in the phase space"
            {  0  "file.  For each block that is flushed, the phase space file is re-opened"
            {  0  "with a record length (RECL) equal to the size of the block.  Since RECL"
            {  0  "divides exactly into the number of particles already in the file, the"
            {  0  "block to be flushed can be appended onto the data that already exists in"
            {  0  "the file with no overwrites and/or blank space."
            {  0  "The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
            {  0  "a time, which is more time-consuming."
            {  0  "$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
            {  0  "$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
            {  0  "phase space data is output.  In the case of BEAM, it is placed at the end"
            {  0  "of each batch, so that, if the simulation crashes, phase space information"
            {  0  "from the last batch is not lost."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=file name"
            {  0  "{P4}=particle number +1"
            {  0  "{P5}=scoring plane number"
            {  0  TEMP_PHSP_COUNTER=0;
            {  0  NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
            {  0  IF(NUM_PHSP_TOFLUSH>0)[
            {  0  IF(WRITE_PHSP_SOFAR({P5})=0)[
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
            {  0  ]
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
            {  0  REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
            {  0  ]UNTIL(REM_PHSP=0);
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["write ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_ZLAST_OUT({P5})
            {  0  (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_OUT({P5})
            {  0  (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
            {  0  ] UNTIL(NUM_PHSP_TOFLUSH=0);
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=0;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
            {  0  "Note that colons     ^             ^  are required between the first and"
            {  0  "second input parameters (5th and 6th input variables) and the"
            {  0  "8th and 9th input parameters (13th and 14th input variables)"
            {  0
            {  0  "This outputs phase space data in blocks of 1000 particles at a time."
            {  0  "In preparation for output, LATCH is modified to hold NPASS and IQ,"
            {  0  "energy (E) is placed into a single precision variable, ESHORT, and"
            {  0  "weight (WT) is given the sign of W.  If this is the first particle"
            {  0  "scored from a new primary (non-phase space source) history, then"
            {  0  "ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,name of phase space file,"
            {  0  "     record number writing to, scoring plane number"
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E,WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  $GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});
            {  0
            {  0  $WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
            {  0  "This macro reads the info from the header of a phase space file."
            {  0  "It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
            {  0  "as a stand-alone macro."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=MODE0 or MODE2"
            {  0  "{P3}=total number of particles"
            {  0  "{P4}=no. of photons"
            {  0  "{P5}=max k.e. of particles"
            {  0  "{P6}=min. k.e. of electrons"
            {  0  "{P7}=no. of particles incident from original source"
            {  0
            {  0  READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  {P3}=NUM_PHSP_TOT;
            {  0  {P4}=PHOT_PHSP_TOT;
            {  0  {P5}=EKMAX_PHSP_SHORT;
            {  0  {P6}=EKMINE_PHSP_SHORT;
            {  0  {P7}=NINC_PHSP_SHORT;
            {  0
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
            {  0  STOP;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
            {  0  "Macro to open a phase space file in preparation for reading it."
            {  0  "The macro opens the file in one of 3 modes, as a file that is known"
            {  0  "to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
            {  0  "(IZLAST=0), or with no prior knowledge of whether the file has"
            {  0  "ZLAST or not (IZLAST<0)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  IF({P1}>0)["with ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  "error above on file opening when assumed it was MODE2"
            {  0  OUTPUT;(/' ***error opening file as MODE2 ****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE3')[
            {  0  OUTPUT;(//' That file does not start with MODE3,',
            {  0  ' as all old compressed files (with ZLAST) must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE3 file! '/
            {  0  ' Please convert it into a MODE2 file using [readphsp] ',
            {  0  ' and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}=0)["without ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
            {  0  "this factor is machine-dependent and stored in machine.mortran"
            {  0  "check file is MODE0 -ie standard compressed"
            {  0  IF(IERR_PHSP~=0)[
            {  0  "come here if error opening file assumed MODE0"
            {  0  OUTPUT;(/' ***ERROR opening file as MODE0****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE1')[
            {  0  OUTPUT;(//' That file does not start with MODE1,',
            {  0  ' as all old compressed files must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE1 file! '/
            {  0  ' Please convert it into a MODE0 file using [readphsp] ',
            {  0  'and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE0')[
            {  0  OUTPUT;
            {  0  (/' Does not start with MODE0 as files without ZLAST must'/
            {  0  '  Try again!'//);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
            {  0  OUTPUT;(/' First, try to open it as a MODE0 file');
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  {P1}=0;
            {  0  IF({P4}~='MODE0')[
            {  0  OUTPUT;(/' The file does not start with MODE0 as it supposed to');
            {  0  CLOSE({P2});
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
            {  0  "Puts max ke of particles, min ke of electrons, and no. of particles"
            {  0  "incident from original source--all of which may be double precision"
            {  0  "into real*4 variables"
            {  0  "{P1}=tot. no. of particles"
            {  0  "{P2}=no. of photons"
            {  0  "{P3}=max ke of particles"
            {  0  "{P4}=min ke of electrons"
            {  0  "{P5}=no. of particles incident from primary source"
            {  0  IF({P1}>2147483647)[
            {  0  write(*,*)' Warning while writing phase space file:';
            {  0  write(*,*)' No. of particles > 2^31-1.';
            {  0  write(*,*)' Total no. of particles (and photons) written';
            {  0  write(*,*)' to header may be nonsense.';
            {  0  ]
            {  0  NUM_PHSP_TOT={P1};
            {  0  PHOT_PHSP_TOT={P2};
            {  0  EKMAX_PHSP_SHORT={P3};
            {  0  EKMINE_PHSP_SHORT={P4};
            {  0  NINC_PHSP_SHORT={P5};
            {  0  }
               0
               0  REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
            {  0  "Macro to write the header information into a phase space file."
            {  0  "Files must be closed and re-opened with record length (RECL) for"
            {  0  "a single particle in order to prevent over-writing any particle data."
            {  0  "Once the header info is written, the file is closed again and re-opened"
            {  0  "with the RECL for 1000 particles."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $PARSE_PHSP_HEADER_FOR_WRITE({P5});
            {  0  WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
            {  0  EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
            {  0  "This macro opens a phase space file for writing.  The file is opened with"
            {  0  "a record length that will hold phase space data for 1000 particles in 1"
            {  0  "record.  This is to to enable writing phase space data for 1000 particles"
            {  0  "at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
            {  0  "$WRITE_PHSP_HEADER to output a dummy header to the file."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE_RW"
            {  0  IF({P1}~=0)["with ZLAST"
            {  0  {P4}='MODE2';
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  {P4}='MODE0';
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
            {  0  }
               0  ;
               0
               0  REPLACE {$CLOSE_PHSP(#);} WITH {;
            {  0  "Macro to close a phase space file."
            {  0
            {  0  "Input parameter:"
            {  0  "{P1}=the unit number of the phase space file"
            {  0
            {  0  CLOSE(UNIT={P1});
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  "AUNIT is a character variable"
            {  0  "construct phase space file name."
            {  0  "part of this--the part that determines the directory and"
            {  0  "file prefix--is done in beam"
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
            {  0  OUTPUT;
            {  0  (/' Restarting after previous run, will read old data & phase-space',
            {  0  ' files');
            {  0  DO I=1,NSC_PLANES [
            {  0  OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
            {  0  :OPEN_MODE0:;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0
            {  0  $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_WRITE_PHSP;} WITH {;
            {  0  IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
            {  0  ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]
            {  0
            {  0  "output directory and file prefix are defined in beam.mortran"
            {  0
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
            {  0  ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
            {  0  X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
            {  0  BEAM_MU_INDEX);
            {  0  ]
            {  0
            {  0  ELSE[
            {  0
            {  0  IF( i_parallel > 0 ) ["add an _w"
            {  0  phsp_fn=$cstring(phsp_fn)// '_w';
            {  0  call egs_itostring(phsp_fn,i_parallel,.false.);
            {  0  ]
            {  0  phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
            {  0  $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
            {  0  ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
            {  0  LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
            {  0  ]
            {  0  IF(IZLAST = 2)[
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
            {  0  JHSTRY=JHSTRY+1;
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
            {  0  XLAST(NP),YLAST(NP),ZLAST(NP),0;
            {  0  :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
            {  0  ]
            {  0  "Check only needed when actually writting to a phsp file"
            {  0  IF(NPPHSP(ISCORE)=phsp_upper_limit)[
            {  0  $egs_fatal('(//a,i19,4(a/))',
            {  0  ' *** WHILE WRITING PHASE SPACE FILE:',
            {  0  NPPHSP(ISCORE), ' particles in file.',
            {  0  ' Due to the fact that the counter for the number',
            {  0  ' of particles in the file cannot be larger than this,',
            {  0  ' no more particles will be written to the phsp file.'
            {  0  );
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
            {  0  IF(IO_OPT=4)["update no. of primary histories in header"
            {  0  DO I1=1,NSC_PLANES[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
            {  0  $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
            {  0  ]
            {  0  ]
            {  0  ELSE["standard BEAMnrc format"
            {  0  IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  DO I1=1,NSC_PLANES[
            {  0  NPPHSPSP=NPPHSP(I1);
            {  0  IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]
            {  0
            {  0  "output directory and file prefix defined in beam.mortran"
            {  0
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
            {  0  IF(NPPHSPSP=NPHOTPHSP(I1))[
            {  0  "no electrons"
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), 0.0, NINCPHSP);
            {  0  ]
            {  0  ELSE[
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
            {  0  ]
            {  0  ]
            {  0  "we store the total particle number in the 1st record of the ph-sp file"
            {  0  ]
            {  0  ]"end of standard BEAMnrc format"
            {  0  };
               0
               0  REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
            {  0  DO I=1,NSC_PLANES[
            {  0  OUTPUT I,NPPHSP(I);
            {  0  (//' PH-SP FILE',I4,': '/
            {  0  '               TOTAL NO. OF PARTICLES =',I12);
            {  0  IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
            {  0  "added phase space files before restarting"
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
            {  0  EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
            {  0  EKMINPHSPE(I)=99999.; "info unavailable"
            {  0  IF(IZLAST=0 & IZLAST1=1)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored with ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=0.  Restart with'/
            {  0  ' IZLAST=1.'//);
            {  0  STOP;
            {  0  ]
            {  0  ELSEIF(IZLAST=1 & IZLAST1=0)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored  without ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=1.  Restart with'/
            {  0  ' IZLAST=0.'//);
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
            {  0  NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  IF(NINCPHSP>
            {  0  NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
            {  0  "files have been added"
            {  0  OUTPUT I;(//' ***ERROR:'/
            {  0  ' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
            {  0  ' The code currently does not support this.  Please add phase space'/
            {  0  ' files only after all runs, including restarts, are complete.'//);
            {  0  "STOP;"
            {  0  ]
            {  0  ]
            {  0  IF(NPPHSP(I) > 0)[
            {  0  CALL DATETIME(1);
            {  0  OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
            {  0  "Read last particles to check whether it is right"
            {  0  IF(IO_OPT=4)[
            {  0  "just check that file size=checksum"
            {  0  $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
            {  0  NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
            {  0  "binary read"
            {  0  OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
            {  0  ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
            {  0  I12,' IN THIS FILE:'/' ',I12,6F12.5);
            {  0  "CALL TIME(TIMEN);"
            {  0  "OUTPUT TIMEN;"
            {  0  "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
            {  0  ]
            {  0  OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
            {  0  call egs_time(6); OUTPUT; (' ');
            {  0  ]
            {  0  ]"end of loop over planes"
            {  0  };
               0
               0  REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
            {  0  IF(n_parallel=0 | ~is_finished) [
            {  0  "do not close phsp files that have already been closed"
            {  0  "after individual parallel jobs have ended"
            {  0  IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
            {  0  "phase-space output"
            {  0  DO I=1,NSC_PLANES [
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  CLOSE(IOUTFLU(I));
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps."
            {  0  "Some mods by BW."
            {  0  IF(IRESTART=0) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,0,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  ELSEIF(IRESTART=1) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,1,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
            {  0  1,nhist,latch(np),iq(np),e(np),
            {  0  wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
            {  0  frMU_indx); "added MU index (JL 2013)"
            {  0  "zlast not used in dosxyz so this is a dummy variable"
            {  0
            {  0  };
               0
               0  REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
            {  0  ]
            {  0  ELSEIF(isource = 2 | isource = 8 )[
            {  0  ainflu=dble(IHSTRY+ncaseold+nsmiss+
            {  0  (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
            {  0  ]
            {  0  ELSEIF(isource=4)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss);
            {  0  ]
            {  0  ELSEIF(isource=6)[
            {  0  ainflu=dble(IHSTRY+ncaseold);
            {  0  ]
            {  0  ELSEIF(isource=9|isource=10|isource=21)[
            {  0  ainflu=dble(nhist);
            {  0  ]
            {  0  ELSEIF(isource=20)[
            {  0  ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
            {  0  ]
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
            {  0  $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
            {  0
            {  0  };
               0
               0  " The following are null macros that will be overwritten by the library "
               0  " version of BEAM "
               0  REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};
               0
               0  "End of phsp_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for IAEA phase space data format                             "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2007                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros for reading and writing phase space data in the official IAEA       "
               0  "  format.  See the online documentation at https://www-nds.iaea.org/phsp/    "
               0  "  for more about this format. These macros make use of the C++ IAEA phase    "
               0  "  space handling routines in directory $HEN_HOUSE/iaea_phsp/, which are      "
               0  "  provided for public use by the IAEA.                                       "
               0  "                                                                             "
               0  "  In order to use the routines, Fortran compilation must include the flags:  "
               0  "                                                                             "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_header.cpp                                       "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_phsp.cpp                                         "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_record.cpp                                       "
               0  "  $HEN_HOUSE/iaea_phsp/utilities.cpp                                         "
               0  "  -lm -lstdc++                                                               "
               0  "                                                                             "
               0  "  In BEAMnrc, this is done by going into $HEN_HOUSE/specs/beamnrc.spec and   "
               0  "  setting `BEAM_OBJECTS =` the above flags.                                  "
               0  "                                                                             "
               0  "  These macros also make use of variables in COMIN/RWPHSP defined in         "
               0  "                                                                             "
               0  "  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
               0  "                                                                             "
               0  "  hence they must be included in the mortjob.mortran file AFTER              "
               0  "                                                                             "
               0  "  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
               0  "                                                                             "
               0  "  These macros are defined as null in phsp_macros.mortran in case the IAEA   "
               0  "  C++ routines are unavailable and cannot be included in the code.           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=file name"
            {  0  "{P3}=IZLAST"
            {  0  "{P4}=IRESTART=0 for first run, 1 for restart"
            {  0  "{P5}=Z position of the scoring plane"
            {  0  "{P6}=IMUPHSP"
            {  0  "{P7}=IZSCORE, set to 1 to score Z for each particle"
            {  0  "note that if IRESTART=1, then nothing is done with {P3} and {P5}"
            {  0
            {  0  call iaea_new_source({P1},{P2},{P4}+2,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error opening IAEA phase space file for write.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  i_iaea_open_for_write=1;
            {  0  IF({P4}=0)[
            {  0  IF({P7}~=1) call iaea_set_constant_variable({P1},2,{P5});
            {  0  IF({P3}~=0)[
            {  0  IF({P6}~=0)[
            {  0  call iaea_set_extra_numbers({P1},2,1);
            {  0  "use generic user type for MU_INDEX"
            {  0  call iaea_set_type_extrafloat_variable({P1},1,0);
            {  0  iaea_i_muidx_out=2;
            {  0  ]
            {  0  ELSE [
            {  0  call iaea_set_extra_numbers({P1},1,1);
            {  0  ]
            {  0  call iaea_set_type_extrafloat_variable({P1},0,3);
            {  0  iaea_i_zlast_out=1;
            {  0  ]
            {  0  ELSEIF({P6}~=0)[
            {  0  call iaea_set_extra_numbers({P1},1,1);
            {  0  call iaea_set_type_extrafloat_variable({P1},0,0);
            {  0  iaea_i_muidx_out=1;
            {  0  ]
            {  0  ELSE[
            {  0  call iaea_set_extra_numbers({P1},0,1); "always store LATCH"
            {  0  ]
            {  0  call iaea_set_type_extralong_variable({P1},0,2);
            {  0  iaea_i_latch_out=1;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=file name"
            {  0
            {  0  call iaea_new_source({P1},{P2},1,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error opening IAEA phase space source.';
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_PARSE_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=WT"
            {  0  "{P2}=X"
            {  0  "{P3}=Y"
            {  0  "{P4}=Z"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0  "{P7}=W"
            {  0  "{P8}=ZLAST"
            {  0  "{P9}=BEAM_MU_INDEX"
            {  0
            {  0  WT_PHSP_SHORT={P1};
            {  0  X_PHSP_SHORT={P2};
            {  0  Y_PHSP_SHORT={P3};
            {  0  Z_PHSP_SHORT={P4};
            {  0  U_PHSP_SHORT={P5};
            {  0  V_PHSP_SHORT={P6};
            {  0  W_PHSP_SHORT={P7};
            {  0  ZLAST_PHSP_SHORT={P8};
            {  0  MUIDX_PHSP_SHORT={P9};
            {  0  }
               0
               0
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=NPASS"
            {  0  "{P3}=scoring plane no."
            {  0  "{P4}=NHSTRY (primary history no.)"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=IQ"
            {  0  "{P7}=E"
            {  0  "{P8}=WT,X,Y,Z,U,V,W,ZLAST,BEAM_MU_INDEX"
            {  0
            {  0  IF({P2}=0)["do not output if NPASS=1"
            {  0  ESHORT={P7}; "put energy into single precision"
            {  0  "calculate increment in primary history no. between this particle"
            {  0  "and last particle scored"
            {  0  iaea_n_stat={P4}-IHSTRY_PHSP({P3});
            {  0  IHSTRY_PHSP({P3})={P4}; "reset ihstry"
            {  0  "JWU: IAEA phsp uses kinetic energy!"
            {  0  IF( ({P6}=1) | ({P6}=-1) )[
            {  0  ESHORT = ESHORT - 0.5109989461;
            {  0  ]
            {  0  $IAEA_PARSE_FOR_WRITE({P8});
            {  0  IF(i_iaea_open_for_write=1)[
            {  0  iaea_extra_ints(iaea_i_latch_out)={P5};"store LATCH"
            {  0  IF(iaea_i_zlast_out>0) iaea_extra_floats(iaea_i_zlast_out)=ZLAST_PHSP_SHORT;
            {  0  IF(iaea_i_muidx_out>0) iaea_extra_floats(iaea_i_muidx_out)=MUIDX_PHSP_SHORT;
            {  0  ]
            {  0  ELSE[
            {  0  "use same array indices as input IAEA phsp file"
            {  0  "we only get here if the IAEA_OPEN_PHSP_FOR_WRITE macro"
            {  0  "has not been used"
            {  0  iaea_extra_ints(iaea_i_latch)={P5};"store LATCH"
            {  0  IF(iaea_i_zlast>0) iaea_extra_floats(iaea_i_zlast)=ZLAST_PHSP_SHORT;
            {  0  IF(iaea_i_muidx>0) iaea_extra_floats(iaea_i_muidx)=MUIDX_PHSP_SHORT;
            {  0  ]
            {  0  call iaea_write_particle({P1},iaea_n_stat,iaea_q_typ({P6}+2),ESHORT,
            {  0  WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
            {  0  V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=total no. of particles"
            {  0  "{P3}=total no. of photons"
            {  0  "{P4}=max, K.E. of all particles"
            {  0  "{P5}=no of incident primary histories"
            {  0  "{P6}=Z of scoring plane"
            {  0  "{P7}=IZLAST"
            {  0  "{P8}=IMUPHSP"
            {  0  "{P9}=IZSCORE"
            {  0
            {  0  call iaea_get_max_particles({P1},-1,iaea_dummy_long);
            {  0  {P2}=iaea_dummy_long;
            {  0  call iaea_get_max_particles({P1},1,iaea_dummy_long);
            {  0  {P3}=iaea_dummy_long;
            {  0  call iaea_get_total_original_particles({P1},iaea_dummy_long);
            {  0  {P5}=iaea_dummy_long;
            {  0  call iaea_get_maximum_energy({P1},EKMAX_PHSP_SHORT);
            {  0  {P4}=EKMAX_PHSP_SHORT;
            {  0  call iaea_get_constant_variable({P1},2,Z_PHSP_SHORT,iaea_result);
            {  0  IF(iaea_result=-3)[
            {  0  write(i_log,*)
            {  0  ' Z positions of each particle will be read from phase space data.';
            {  0  {P6}=999.;
            {  0  {P9}=1; "tell host code that Z is scored"
            {  0  ]
            {  0  ELSEIF(iaea_result<0)[
            {  0  write(i_log,*)' Error reading Z position where IAEA phsp was scored.';
            {  0  {P9}=0;
            {  0  ]
            {  0  ELSE[
            {  0  {P6}=Z_PHSP_SHORT;
            {  0  {P9}=0;
            {  0  ]
            {  0  call iaea_get_extra_numbers({P1},iaea_n_extra_floats,iaea_n_extra_ints);
            {  0  IF(iaea_n_extra_floats = -1 | iaea_n_extra_ints = -1)[
            {  0  write(i_log,*)' Error reading number of extra variables stored in IAEA phsp';
            {  0  ]
            {  0  call iaea_get_type_extra_variables({P1},iaea_result,iaea_extra_int_types,
            {  0  iaea_extra_float_types);
            {  0  IF(iaea_result=-1)[
            {  0  write(i_log,*)' Error getting types of extra variables stored in IAEA phsp';
            {  0  ]
            {  0  DO I_PHSP=1,iaea_n_extra_ints [
            {  0  IF(iaea_extra_int_types(I_PHSP)=2)[
            {  0  iaea_i_latch=I_PHSP;
            {  0  EXIT;
            {  0  ]
            {  0  ]
            {  0  IF(iaea_i_latch=-99)[
            {  0  write(i_log,*)' Warning: IAEA format phsp file does not store LATCH';
            {  0  ]
            {  0  DO I_PHSP=1,iaea_n_extra_floats [
            {  0  IF(iaea_extra_float_types(I_PHSP)=3)[
            {  0  iaea_i_zlast=I_PHSP;
            {  0  EXIT;
            {  0  ]
            {  0  ]
            {  0  IF(iaea_i_zlast=-99)[
            {  0  {P7}=0; "no zlast"
            {  0  ]
            {  0  ELSE[
            {  0  {P7}=1;
            {  0  ]
            {  0  "test to see if this file contains MU_INDEX"
            {  0  "we assume this is the first float after zlast, if zlast is scored,"
            {  0  "and has generic user type = 0"
            {  0  iaea_i_muidx=MAX(1,iaea_i_zlast+1);
            {  0  IF(iaea_i_muidx>iaea_n_extra_floats | iaea_extra_float_types(iaea_i_muidx)~=0) [
            {  0  iaea_i_muidx=-99;"reset this to no scoring"
            {  0  {P8}=0;
            {  0  ]
            {  0  ELSE[
            {  0  {P8}=1;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit no."
            {  0  "{P2}=record no. (particle no.) to go to"
            {  0
            {  0  iaea_dummy_long={P2};
            {  0  call iaea_set_record({P1},iaea_dummy_long,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error going to record ',{P2},' in IAEA phsp file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_PARSE_FOR_READ(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=WT"
            {  0  "{P2}=X"
            {  0  "{P3}=Y"
            {  0  "{P4}=Z"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0  "{P7}=W"
            {  0  "{P8}=ZLAST"
            {  0  "{P9}=MU_INDEX"
            {  0
            {  0  {P1}=WT_PHSP_SHORT;
            {  0  {P2}=X_PHSP_SHORT;
            {  0  {P3}=Y_PHSP_SHORT;
            {  0  {P4}=Z_PHSP_SHORT;
            {  0  {P5}=U_PHSP_SHORT;
            {  0  {P6}=V_PHSP_SHORT;
            {  0  {P7}=W_PHSP_SHORT;
            {  0  {P8}=ZLAST_PHSP_SHORT;
            {  0  {P9}=MUIDX_PHSP_SHORT;
            {  0  }
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=NPASS"
            {  0  "{P3}=NHSTRY (no. of primary histories represented by particle read)"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=IQ"
            {  0  "{P6}=E"
            {  0  "{P7}=WT,X,Y,Z,U,V,W,ZLAST,MU_INDEX"
            {  0
            {  0  {P2}=0; "no multiple passers stored in IAEA format"
            {  0
            {  0  call iaea_get_particle({P1},iaea_n_stat,iaea_q_index,ESHORT,WT_PHSP_SHORT,
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
            {  0  V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
            {  0  IF(iaea_n_stat=-1)[
            {  0  WRITE(i_log,*)' Error getting particle data from IAEA phsp file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_n_stat=-2)[
            {  0  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  File restarted.';
            {  0  ]
            {  0  ELSEIF(iaea_n_stat>=0)[
            {  0  {P3}={P3}+iaea_n_stat;
            {  0  IF(iaea_i_latch=-99)[
            {  0  {P4}=0; "latch not stored here"
            {  0  ]
            {  0  ELSE [
            {  0  {P4}=iaea_extra_ints(iaea_i_latch);
            {  0  ]
            {  0  {P5}=iaea_typ_q(iaea_q_index);
            {  0  "JWU: IAEA phsp uses kinetic energy!"
            {  0  IF( ({P5}=1) | ({P5}=-1) )[
            {  0  ESHORT = ESHORT + 0.5109989461;
            {  0  ]
            {  0  {P6}=ESHORT;
            {  0  IF(iaea_i_zlast=-99)[
            {  0  ZLAST_PHSP_SHORT=0; "no zlast stored"
            {  0  ]
            {  0  ELSE [
            {  0  ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast);
            {  0  ]
            {  0  IF(iaea_i_muidx=-99)[
            {  0  MUIDX_PHSP_SHORT=0; "no mu_index stored"
            {  0  ]
            {  0  ELSE [
            {  0  MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx);
            {  0  ]
            {  0  $IAEA_PARSE_FOR_READ({P7});
            {  0  ]
            {  0  }
               0  ;
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_destroy_source({P1},iaea_result);
            {  0
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error closing IAEA phase space ID ',{P1};
            {  0  ]
            {  0  }
               0  ;
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=no. of incident primary histories"
            {  0
            {  0  iaea_dummy_long={P2};
            {  0  call iaea_set_total_original_particles({P1},iaea_dummy_long);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_update_header({P1},iaea_result);
            {  0
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error writing IAEA phase space header for ID ',{P1};
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_check_file_size_byte_order({P1},iaea_result);
            {  0
            {  0  IF(iaea_result=-3)[
            {  0  WRITE(i_log,*)' ERROR: Size of phase space file does not match';
            {  0  WRITE(i_log,*)' the value of checksum in the header.  Something may be';
            {  0  WRITE(i_log,*)' wrong.  Check your file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-4)[
            {  0  WRITE(i_log,*)' ERROR: Byte order in the phase space file does not';
            {  0  WRITE(i_log,*)' match the machine you are running on.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-5)[
            {  0  WRITE(i_log,*)' ERROR: Size of file does not match the value of checksum';
            {  0  WRITE(i_log,*)' in the header AND there is a byte order mismatch between';
            {  0  WRITE(i_log,*)' the file and the machine you are running on.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-1)[
            {  0  WRITE(i_log,*)' ERROR: Cannot open phase space header.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-2)[
            {  0  WRITE(i_log,*)' ERROR: Something is wrong with the phase space file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros required by srcrz.mortran                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Dave Rogers, 2001                                         "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These are macros used by srcrz.mortran which need to be defined before     "
               0  "  the user code because values are input to it.                              "
               0  "                                                                             "
               0  "  This code was stripped out of the user codes and out of srcrz.mortran,     "
               0  "  since having it defined twice could lead to errors.                        "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  ;
               0  REPLACE {;COMIN/SOURCE/;} WITH {
            {  0  "       ================="
            {  0
            {  0  "IK: - Put 8 bit variables first to avoid misalignment complains from some"
            {  0  "      compilers                                                          "
            {  0  "    - Put 32 bit integers last so that there are no padding warnings     "
            {  0  "      when usinmg double precision                                       "
            {  0  "To people putting additional variables in common blocks at random        "
            {  0  "locations: on modern CPU's it is most efficient when variables in commons"
            {  0  "are aligned at 64 bit boundaries. Thus, when this is not the case, some  "
            {  0  "compilers will put in dummy padding bytes between variables to assure 64 "
            {  0  "bit alignment and issue a warning. So, please, use the following rules:  "
            {  0  " - put known 64 bit variables first                                      "
            {  0  " - put real variables before integer variables. This is needed because   "
            {  0  "   when one switches to double precision, real variables become 64 bit   "
            {  0  " - put short integers last                                               "
            {  0
            {  0  ; COMMON/SOURCE/
            {  0  SPCNAM,SCOMEG,SCOMEG2,NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,
            {  0  NSHIST, NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,
            {  0  NPHOTPHSP,RCDFIN,RDISTF,RPDF,RCDF,AINFLU,RBEAM,RBEAM2,
            {  0  UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
            {  0  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
            {  0  AFACE,ASIDE,ZCOFST,ZSOFST,SVTMP1,SVTMP2,SVTMP3,SVTMP4,
            {  0  RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
            {  0  XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEIGHTOLD,
            {  0  ENFLAG,IMODE,NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
            {  0  NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
            {  0  N_RUN_CHUNK_OLD,IPHATIN,i_iaea_in,i_unit_in;
            {  0
            {  0  CHARACTER*256 SPCNAM;
            {  0  REAL*8 SCOMEG,SCOMEG2;
            {  0  $LONG_INT NHSTRY,N_LEFT,other_num_1,other_num_2,NNREAD,NSHIST,
            {  0  NSLEFT,NCASE_PHSP,NPHSPN,NPHSPN_MIN,NPHSPN_MAX,P_PER_PHSP_CHUNK,
            {  0  NPHOTPHSP
            {  0  $REAL    RCDFIN($MXRDIST,2),RDISTF(100),RPDF(100),RCDF(100),AINFLU,RBEAM,RBEAM2,
            {  0  UINC,VINC,WINC,XBEAM,YBEAM,ZBEAM,DISTRH,DSTRH2,DISTZ,DISTZ2,
            {  0  DISTB,DISTB2,RCYL1,RCYL2,PROBFC,PROBSD,PROBBK,
            {  0  AFACE,ASIDE,ZCOFST,ZSOFST,
            {  0  SVTMP1,SVTMP2,SVTMP3,SVTMP4,
            {  0  RMINBM,RMINSQ,EINSRC,EKSRCM,ZSMAX,ZSMIN,NINCSRC,
            {  0  XINOLD,YINOLD,ZINOLD,UINOLD,VINOLD,WINOLD,WEIGHTOLD;
            {  0  $INTEGER ENFLAG,IMODE,
            {  0  NRDIST,NSRCRG,ISRPT,ISRPAR,NPASS,DOSE_STAT,
            {  0  NRCYCL,IPARALLEL,PARNUM,CYCLNUM,OUTCNT,IRINOLD,NRCFLGOLD,
            {  0  N_RUN_CHUNK_OLD,IPHATIN,
            {  0  i_iaea_in,i_unit_in;
            {  0  CHARACTER*1 FILSPC(256);
            {  0  EQUIVALENCE (SPCNAM,FILSPC);
            {  0  }
               0
               0  "COMMON USED FOR PASSING INFORMATION SPECIFIC TO SOURCES
               0  "RCDFIN   INVERSE OF THE RADIAL CUMULATIVE PROBABILITY FUNCTION (ISOURC=20)
               0  "RDISTF   RADIAL MESH POINTS FOR THE RADIAL PROBABILITY FUNCTION (ISOURC=20)
               0  "RPDF     RADIAL PROBABILITY FUNCTION (ISOURC=20)
               0  "RCDF     RADIAL CUMULATIVE PROBABILITY FUNCTION (ISOURC=20)
               0  "AINFLU   INCIDENT FLUENCE
               0  "RBEAM    RADIUS OF THE BEAM AT THE FRONT OF THE TARGET or OUTER RADIUS
               0  "                           of SOURCE for ISOURC = 3
               0  "RBEAM2   RBEAM**2
               0  "UINC     INCIDENT X-AXIS DIRECTION COSINE (ISOURC=0)
               0  "VINC     INCIDENT Y-AXIS DIRECTION COSINE (ISOURC=0)
               0  "WINC     INCIDENT Z-AXIS DIRECTION COSINE (ISOURC=0)
               0  "XBEAM    HALF-HEIGHT OF THE BEAM AT THE CENTER OF THE TARGET
               0  "ZBEAM    HALF-WIDTH OF THE BEAM AT THE CENTER OF THE TARGET
               0  "DISTRH   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
               0  "DSTRH2   = DISTRH**2
               0  "DISTZ    DISTANCE OF THE POINT SOURCE FROM THE FRONT OF THE TARGET
               0  "DISTZ2   = DISTZ**2
               0  "DISTB    DISTANCE OF THE POINT SOURCE FROM THE BACK OF THE TARGET
               0  "DISTB2   = DISTB**2
               0  "RCYL1    RADIUS OF THE TARGET
               0  "RCYL2    = RCYL1**2
               0  "PROBFC   PROBABILITY THAT INCIDENT BEAM STRIKES THE FLAT FACE (ISOURC=12)
               0  "PROBBK   PROBABILITY THAT INCIDENT BEAM STRIKES THE FLAT FACE (ISOURC=12)
               0  "PROBSD   PROBABILITY THAT INCIDENT BEAM STRIKES THE CURVED SIDE (ISOURC=12)
               0  "AFACE    FACIAL AREA OF THE TARGET
               0  "ASIDE    RECTANGULAR AREA OF THE TARGET SEEN BY THE BEAM
               0  "ZCOFST   Z-AXIS OFFSET OF THE CENTER OF THE TARGET
               0  "ZSOFST   Z-AXIS OFFSET OF THE SOURCE
               0  "NRDIST   # RADIAL BINS IN DISTRIBUTION HISTOGRAM (ISOURC=20)
               0  "RMINBM   MINIMUM BEAM RADIUS FOR ISOURC=14 or INNER RADIUS of
               0  "                                                SOURCE,ISOURCE = 3
               0  "RMINSQ   RMINBM**2
               0  "EINSRC   SOURCE ENERGY INPUT FROM FULL PHASE-SPACE SOURCE FILE (ISOURC=21,22)
               0  "NSHIST   NUMBER OF PARTICLES IN SOURCE FILE (ISOURC=21,22)
               0  "NSLEFT   NUMBER OF PARTICLES REMAINING IN SOURCE FILE (ISOURC=21,22)
               0  "ENFLAG   FLAG THAT SOURCE ENERGY IS READ HERE (ISOURC=21,22)
               0  "EKSRCM   MAXIMUM ENERGY OF SOURCE (ISOURC=21,22)
               0  "SPCNAM   FILE NAME OF SOURCE DATA FILE (ISOURC=21,22)
               0  "ZSMAX    MAXIMUM of SOURCE Z extent for ISOURC = 3
               0  "ZSMIN    MINIMUM of SOURCE Z extent for ISOURC = 3
               0  "IMODE    =0 FOR DEFAULT BEAM FILE FORMAT WITH 7 VARIABLES PER RECORD"
               0  "         =2 FOR PH-SP FILES CREATED BY BEAM WITH 8 VARIABLES/RECORD, +ZLAST"
               0  "NCASE_PHSP  TOTAL NUMBER OF PARTICLES STORED IN THE PH-SP FILE"
               0  "NPHOTPHSP no. of photons in phase space source"
               0  "NPHSPN   Stores particle no. to be read from phase space source (ISOURC=21,22)"
               0  "NHSTRY   Stores no. of primary histories read from phsp source (ISOURC=21,22)"
               0  "NPASS    NO. of times a particle has crossed the phase space plane (21,22)"
               0  "NNREAD   Total number of particles read from phase space source (ISOURC=21,22)"
               0  "DOSE_STAT For ISOURC=21,22, set to 1 if we cannot read no. primary histories"
               0  "NINCSRC  number of particles incident from primary source (ISOURC=21,22)"
               0  "SCOMEG(2) ACCUMULATES PARTICLE WEIGHTS (WEIGHT^2) FROM THE SOURCE,
               0  "          EVENTUALLY GIVES SOLID ANGLE (UNCERTAINTY ON SOLID ANGLE) OF
               0  "          THE TARGET
               0  "NRCYCL   no of times to recycle each source particle (ISOURC=21,22)"
               0  "IPARALLEL no. of parallel jobs into which a simulation is split(ISOURC=21,22)"
               0  "PARNUM   set to a different integer value in the range 1<=PARNUM<=IPARALLEL
               0  "         for the IPARALLEL parallel jobs (ISOURC=21,22)
               0  "CYCLNUM  keeps track of how many times a particle has been recycled
               0  "         (ISOURC=21,22)
               0  "OUTCNT   keeps track of how many times a phsp source has been restarted
               0  "         (ISOURC=21,22)
               0  "XINOLD   holds XIN for recycled particles (ISOURC=21,22)
               0  "YINOLD   holds YIN for recycled particles (ISOURC=21,22)
               0  "ZINOLD   holds ZIN for recycled particles (ISOURC=21,22)
               0  "UINOLD   holds UIN for recycled particles (ISOURC=21,22)
               0  "VINOLD   holds VIN for recycled particles (ISOURC=21,22)
               0  "WINOLD   holds WIN for recycled particles (ISOURC=21,22)
               0  "WEIGHTOLD   holds WEIGHT for recycled particles (ISOURC=21,22)
               0  "IRINOLD  holds IRIN for recycled particles (ISOURC=21,22)
               0  "NRCFLGOLD   holds NRCFLG for recycled particles (ISOURC=21,22)
               0  "N_LEFT   no. of histories left in a parallel run excluding current run
               0  "         used for parallel runs with ISOURC=21,22 only
               0  "N_RUN_CHUNK_OLD  no. of previous chunk of parallel run.  Used for
               0  "         parallel runs with ISOURC=21,22 only
               0  "NPHSPN_MIN  min. value for NPHSPN in chunk of phsp source.  Used for
               0  "         parallel runs with ISOURC=21,22 only
               0  "NPHSPN_MAX  max. value for NPHSPN in chunk of phsp source.  Used for
               0  "         parallel runs with ISOURC=21,22 only
               0  "P_PER_PHSP_CHUNK no. of particles in phsp source per chunk of parallel run
               0  "         For parallel runs with ISOURC=21,22 only
               0  "IPHATIN  set to 1 if this is a fat photon (from DBS)--ISOURC=23 only
               0  "i_iaea_in set to 1 if phase space source is in IAEA format (ISOURC=21,22 only)
               0  "i_unit_in Unit no. for phsp source (IAEA format only)
               0
               0  "Last line in srcrz.macros "
               0
               0
               0  "Aug 2020 fluor discards included in K during_pe_compt"
               0  "during_pe_compt and during_eii   and IDC are here
               0  "also includes hack to print primary and scatter components for IFULL=3 "
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosrznrc application                                                "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Eric Fox, 1984                                            "
               0  "                   Dave Rogers, 1985                                         "
               0  "                   Alex Bielajew, 1986                                       "
               0  "                                                                             "
               0  "  Contributors:    Charlie Ma                                                "
               0  "                   Aaron Merovitz                                            "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This code was originally adapted from CAVITY.MOR.V05 by Eric Fox in 1984   "
               0  "  and further developed by Dave Rogers in 1985 and Alex Bielajew in 1986.    "
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This code simulates the passage of an electron or photon beam in a finite, "
               0  "  right cylindrical  geometry.                                               "
               0  "                                                                             "
               0  "  It also scores pulse height distributions in an arbitrary volume made up   "
               0  "  of any number of regions. There is a write to unit 2 of the calculated     "
               0  "  spectra/response functions.                                                "
               0  "                                                                             "
               0  "  The energy deposited within various user defined regions is scored and     "
               0  "  analyzed statistically following the simulation.                           "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 2003:                                                       "
               0  "                                                                             "
               0  "  Changes since Revision 1.55 in RCS; work done from March to June 2003      "
               0  "  during the preparation of the EGSnrc MP system:                            "
               0  "                                                                             "
               0  "  - replaced all date and time stuff with calls to the new egsnrc date and   "
               0  "    time routines.                                                           "
               0  "                                                                             "
               0  "  - fixed occurrences of local variables assumed to be static                "
               0  "                                                                             "
               0  "  - implemented a new parallel processing strategy using a lock files to     "
               0  "    control the execution on multiple CPUs                                   "
               0  "                                                                             "
               0  "  - Cleaned up use of Fortran I/O units which are now explicitly opened and  "
               0  "    closed if needed except for unit 1 (the .egslst file) and unit 15 (the   "
               0  "    errors file), which are defined to be automatically opened in egs_init   "
               0  "    in the .io file.                                                         "
               0  "                                                                             "
               0  "  Dave Rogers, 2011:                                                         "
               0  "                                                                             "
               0  "  Fixed up the kerma scoring routines which were seriously wrong. Main thing "
               0  "  was that only first member of pair produced particles was being included   "
               0  "  in the kerma. Also fixed a minor bug in the plotting of the D/K ratio vs   "
               0  "  depth (bins were offset). Added lots of comments as I tried to relearn the "
               0  "  code and made many comments in lower case to make them more readable.      "
               0  "                                                                             "
               0  "  Reid Townson, 2017:                                                        "
               0  "                                                                             "
               0  "  Energy depositions for kerma calculations below the cut-off are now sorted "
               0  "  out using AUSGAB to include only Auger from relaxations, not fluorescence. "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  ;
               0  REPLACE {$VERSION} WITH {
            {  0  ,' ', }
               0  ;
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "******************************************************************************
               0  "
               0  "
               0  "                               ********************
               0  "                               *                  *
               0  "                               * dosrznrc.mortran *
               0  "                               *                  *
               0  "                               ********************
               0  "
               0  "
               0  "       INTRODUCTION:
               0  "       This code simulates the passage of an electron or photon beam in a
               0  "       finite, right cylindrical  geometry.
               0  "
               0  "       It also scores pulse height distributions
               0  "       in an arbitrary volume made up of any number of regions.
               0  "       There is a write to unit 2 of the calculated spectra/response functions
               0  "
               0  "       The energy deposited within various user defined regions is scored and
               0  "       analyzed statistically following the simulation.
               0  ;
               0  "       USER CONTROLS:
               0  "       The user 1) defines the geometry of the target via the input of a
               0  "                   number of planar and cylindrical coordinates which
               0  "                   divide the cylinder into a number of regions, each region
               0  "                   composed of a user specified material.
               0  "                2) specifies in which of these regions the dose is to be
               0  "                   scored.
               0  "                3) selects the form and degree of detail of the output.
               0  "                4) selects either the energy if a monoenergetic beam is to be
               0  "                   used or specifies an energy spectrum consisting of
               0  "                   energy points and corresponding probabibities
               0  "                5) selects the source of radiation from amongst parallel and
               0  "                   point sources originating from the side or front,
               0  "                   isotropically radiating sources embedded in regions
               0  "                   in the cylinder and phase space files from BEAM.
               0  "                6) selects the number of histories, time limit and statistical
               0  "                   limit. all histories will be run unless time runs out or
               0  "                   the variance calculated in the peak region drops below
               0  "                   the statistical limit.
               0  "                7) selects transport controls such as the fractional energy
               0  "                   loss per charged particle step, the maximum step size,
               0  "                   particle energy cutoffs, range rejection parameters.
               0  "
               0  "       SIMULATION:
               0  "       Each particle emitted from the source is transported along with all its
               0  "       offspring (with energies greater than the cutoff) using EGS4.
               0  "
               0  "       SCORING:
               0  "       In each of the defined dose scoring regions, the total dose and the
               0  "       dose less that due to stopped/discarded particles is scored. In
               0  "       addition, the dose scored in a region can be broken down into that
               0  "       due to particles which entered via the front wall, back wall, outer
               0  "       wall and inner wall. The total number of charged particle steps
               0  "       taken and the total number taken in the dose scoring region
               0  "       are counted.
               0  "
               0  "       OUTPUT:
               0  "       The first section of the output echos the user input.
               0  "       The second section is is composed of messages and information printed
               0  "       during the simulation as a means of monitoring the simulation.
               0  "       The third section details the total doses accumulated with
               0  "       accompanying statistical uncertainties.
               0  "       The first and third sections may include grid format summaries if
               0  "       requested by the user.
               0  "       Plot files for the xmgr program are also output.
               0  ;
               0
               0  "       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
               0  "       ===========================================================
               0  "         Z axis = axis of rotation runs across page shown as .......
               0  "
               0  "
               0  "       --------------------------------------------------------- RCYL(NR)
               0  "       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
               0  "       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
               0  "       --------------------------------------------------------- RCYL(NR-1)
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       --------------------------------------------------------- RCYL(2)
               0  "       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
               0  "       --------------------------------------------------------- RCYL(1)
               0  "..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
               0  ;"      ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       ---------------------------------------------------------
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       |       |       |       |               |       |       |
               0  "       ---------------------------------------------------------
               0  "         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
               0  "
               0  ;
               0  "=============================================================================
               0  "
               0  "                       HISTORY
               0  "
               0  "   This is the work-horse dose scoring code developed and used extensively
               0  "   at NRC.  The major developers were Alex Bielajew and Dave Rogers
               0  "   and undergarduate student assistants along with specific patches
               0  "   and extensions by others at NRC. In particular, it was converted
               0  "   for EGSnrc use by Iwan Kawrakow.
               0  "
               0  "   If using this code, please reference it as the NRCC user-code DOSRZnrc
               0  "   for the EGSnrc system and cite PIRS-702
               0
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "   Instructons for use of input routines
               0  "
               0  "   Input is via the routine get_inputs which has extensive documentation
               0  "   at the top of its source code.
               0  "
               0  "   Inputs are all in the format: name of value_sought= value
               0  "   where the name of value_sought must match that expected by the
               0  "   program. The = sign must have no blanks on its immediate left and
               0  "   at least one on its immediate right..
               0  "
               0  "   The value_sought must be the first thing on a line but blanks are
               0  "     allowed before it.
               0  "
               0  "   Various inputs are only sought between certain delimeter strings
               0  "     which are defined below (eg :start I/O control: :stop I/O control:)
               0  "     If not specified, the whole file is searched for a requested value_sought.
               0  "     Delimeter strings are enclosed by colons.
               0  "     Note that within delimeter strings, order of inputs does not matter.
               0  "
               0  "   If a requested quantity is not found, this is noted in $input.errors
               0  "     and this file is printed at the end of the log file.
               0  "
               0  "   A semi-colon implies the end of input for this quantity but is
               0  "     not mandatory.  However, this means they cannot be used in titles.
               0  "   A # sign indicated everything else on the line is a comment (and
               0  "     cannot be used in titles.
               0  "   Case is not important in the names of the quantites.
               0  "
               0  "   Commas separate multiple values for a given quantity and a comma
               0  "     at the end of a line implies there is more input on the next line.
               0  "   Values can extend over as many lines as needed. Use commas to imply
               0  "     there are more values on the next line.
               0  "
               0  "   Blank lines and blanks in general are ignored.
               0  "   tabs are NOT allowed when character input is being sought,
               0  "   including tabs used to put # to the right after a character input. Use
               0  "   blanks instead.
               0  "
               0  "   The maximum record length is 256 characters.
               0  "
               0  "   There is a routine morph_dosrz which takes an old format input file
               0  "     and translates it.
               0  "
               0  "   There should be a file morph_template.egs4inp which can be used
               0  "     and which defines most options.
               0  "
               0  "   One drawback of this system is that there is a disconnect between
               0  "     the internal variable name used and the value_sought strings.
               0  "     In the input description variables listed in [ ] braces are
               0  "     the internal variable names associated with this input.
               0  "
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "                                TITLE
               0  "                                *****
               0  "*******************************************************************************
               0  "
               0  "       TITLE          (C)  Title of the input file (format= '80A1')
               0  ;
               0  "*******************************************************************************
               0  "                       INPUT/OUTPUT CONTROL INPUT
               0  "                       **************************
               0  "*******************************************************************************
               0  "
               0  " I/O DELIMETERS:    :start I/O control:
               0  "                    :stop I/O control:
               0  "
               0  "  IWATCH= off         (0)  for normal output
               0  "        = interactions(1)  output info on every discrete interaction
               0  "        = steps       (2)  output on every electron/photon step as well
               0  "        = deposited   (3)  output when energy is deposited as well
               0  "        = graph       (4)  outputs file for EGS_Windows graphics
               0  "                           [IWATCH]
               0  "
               0  "  STORE INITIAL RANDOM NUMBERS
               0  "        = no          (0)  DO NOT STORE THE INITIAL RANDOM NUMBERS
               0  "        = last        (1)  STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
               0  "        = all         (2)  STORE ALL THE INITIAL RANDOM NUMBERS
               0  "
               0  "  IRESTART
               0  "        = first       (0)  first run for this input file
               0  "        = restart     (1)  restart of a previous run, i.e. add more histories
               0  "        = analyze     (3)  just read in the raw data and do the statistical
               0  "                           analysis( gives no timing - restart 100 histories
               0  "                           to get the same effect and more info)
               0  "        = start-RNS   (4)  read starting random numbers from a filE (e.g. FOR
               0  "                           OUTPUT TO A GRAPHICS PACKAGE)
               0  "        = parallel    (5)  post-process distributed runs (all files
               0  "                           named <filenamebase>_w#)
               0  "                           [IRESTART ]
               0  "
               0  "  OUTPUT OPTIONS
               0  "        = short                      (0)  short output -just dose grid(DG)
               0  "        = dose summary               (1)  output dose summary only (DS)
               0  "        = material summary           (2)  output material summary grid(MG) & DG
               0  "        = material and dose summary  (3)  output MG + DS
               0  "        = long                       (4)  output MG + DS + DG
               0  "                              Note-any time there is a dose summary, there
               0  "                              is also an .egs4dose file, unit 10
               0  "                           [IOOPTN]
               0  "
               0  "  STORE DATA ARRAYS
               0  "        = yes             (0) Store data arrays dor re-use
               0  "        = no              (1) don't store them
               0  "                          [IDAT]
               0  "
               0  "  ELECTRON TRANSPORT
               0  "        = normal          (0) normal electron transport (discrete interactions)
               0  "        = no interactions (1) no discrete interactions (used for CDSA
               0  "                              calculations but note that special data
               0  "                              sets are also needed to do a full CSDA
               0  "                              calculation. All turning off
               0  "                              interactions does is just that. See use
               0  "                              of IUNRST=2,3,4 PEGS4 data sets for real CSDA)
               0  "                           [ ICSDA]
               0  "
               0  "                         For complex geometries you may want to just output
               0  "                         a few regions.  These are defined here. Note that
               0  "                         proper transport is done everywhere and this is
               0  "                         NOT related to range rejection.
               0  "
               0  "  DOSE ZBOUND MIN    (I) Minimum plane # defining dose region (default=1)
               0  "                         [NZDMIN]
               0  "  DOSE ZBOUND MAX    (I) Maximum plane # defining dose region
               0  "                         [NZDMAX]
               0  "  DOSE RBOUND MIN    (I) Minimum cylinder # defining dose region (default=0)
               0  "                         [NRDMIN]
               0  "  DOSE RBOUND MAX    (I) Maximum cylinder # defining dose region
               0  "                         [NRDMAX]
               0  ;
               0  "
               0  "*******************************************************************************
               0  "                       MONTE CARLO CONTROL INPUT
               0  "                       *************************
               0  "*******************************************************************************
               0  "
               0  " MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
               0  "                            :stop Monte Carlo inputs:
               0  "
               0  "  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
               0  "                                   (MIN:100, DEFAULTS TO 20 000,
               0  "                                   max=1073741824=2^30 max is a compiler
               0  "                                   restriction for 32bit integers
               0  "                                   [NCASE]
               0  "  INITIAL RANDOM NO. SEEDS=  INTGER1, INTEGER2
               0  "                  User-code can use RANLUX or RANMAR, depending on selection
               0  "                  Default is RANLUX
               0  "            RANLUX
               0  "                  INTEGER1 is the luxury level, use 1 to 4, 4 taking longest
               0  "                           default is 1 (set by $DEFAULT-LL in ranlux.macros)
               0  "                  INTEGER2 selects the independent sequence to use, it
               0  "                           can be from 1 to 1073741824 (2**30)
               0  "            RANMAR
               0  "                  INTEGER1 is a seed between 1 and 31328 (0 =>default 1802)
               0  "                  INTEGER2 is a seed between 1 and 30081 (0 =>default 9937)
               0  "                     Selection of unique INTEGER2 values guarantees independent
               0  "                     sequences.
               0  "            Note:
               0  "               After the seeds are first input and used for initialization,
               0  "               the variables IXXIN and JXXIN are just pointers used by the RNG
               0  "
               0  "  MAX CPU HOURS ALLOWED       (I)  max CPU time allowed in hours, default=999
               0  "                                   [TIMMAX]
               0  "
               0  "  IFULL
               0  "         = dose and stoppers         (0) just calculate total dose and that due
               0  "                                         to stoppers and discards.
               0  "         = entrance regions          (1) as well analyze the total dose per
               0  "                                         entrance region.
               0  "         = pulse height distribution (2) score a pulse height distribution in
               0  "                                         the volume specified after the
               0  "                                         material inputs.
               0  "         = scatter fraction          (3) score the scatter fraction instead of
               0  "                                         stoppers.  Only for incident photons.
               0  "                                         Dose after Compton and for fluorescent
               0  "                                         photons if followed.
               0  "
               0  "  STATISTICAL ACCURACY SOUGHT        (R) % statistical accuracy of the total
               0  "                                         dose in the peak region that is sought
               0  "                                         The program executes until this
               0  "                                         accuracy is obtained or the CPU time
               0  "                                         runs out. If 0, no effect.
               0  "
               0  "  SCORE KERMA
               0  "        = no              (0) do not score kerma
               0  "        = yes             (1) score kerma wherever dose scored and estimate
               0  "                              ratio of dose/kerma using correlated uncertainty
               0  "                              estimate.
               0  "                              This only makes sense for photon beams.
               0  "                              [IKERMA]
               0  "
               0  ;
               0  "*******************************************************************************
               0  "                       CYLINDRICAL GEOMETRY INPUT
               0  "                       **************************
               0  "*******************************************************************************
               0  "
               0  " GEOMRZ DELIMETERS:    :start geometrical inputs:
               0  "                       :stop geometrical inputs:
               0  "
               0  "  METHOD OF INPUT
               0  "        = Groups         (0)   input groups of slabs of equal thickness
               0  "        = Individual     (1)   detailed input of the geometry and media.
               0  "                               [ITERSE]
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  " Information defining depth boundaries along z axis (all dimensions cm)
               0  "
               0  " Only if  METHOD OF INPUT=  Groups
               0  "
               0  "  Z OF FRONT FACE        (R)   start of first slab (real)
               0  "  NSLAB                  (M)   # planar slabs in a group (integers)
               0  "  SLAB THICKNESS         (M)   thickness of each slab in the group (reals)
               0  "
               0  "
               0  " Only if  METHOD OF INPUT=  Individual
               0  "
               0  "  Z OF FRONT FACE        (R)   start of first slab (real)
               0  "  DEPTH BOUDARIES        (M)   geometrical z-plane coordinates (reals)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "  Information defining radial boundaries
               0  "
               0  "  RADII                  (M)   radii of cylinders defining the geometry (reals)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "  MATERIAL INPUT
               0  "  **************
               0  "
               0  "  MEDIA              (M)   material name which must match that in the
               0  "                           pegs4 data set EXACTLY, including case.
               0  "                           24 characters max per medium, ended by , or ;
               0  "
               0  "  Define which media in which regions, numbering in order given above.
               0  "
               0  "  DESCRIPTION BY= Regions(0)   using the geometric region number
               0  "                = Planes (1)   USING THE IX, IZ PLANES
               0  "                               [DESCRIBE]
               0  "
               0  " If DESCRIPTION BY= Regions
               0  "
               0  "  MEDNUM                 (M)   the material number (integers)
               0  "                               (MEDNUM=0 => vacuum)
               0  "  START REGION           (M)   initial geometrical zone(irl) (integers) for
               0  "                               this medium [NREGLO]
               0  "  STOP REGION            (M)   final geometrical zone(irl) (integers) for
               0  "                               this medium.[NREGHI]
               0  "                               ( >NREGLO to input more than one zone)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "
               0  "                         These inputs should be thought of as triplets of
               0  "                         MEDNUM,START and STOP REGIONs     which are used
               0  "                         to specify the medium numbers for all regions where
               0  "                         the medium is not the default (medium 1).
               0  "
               0  " If DESCRIPTION BY=  Planes
               0  "
               0  "  MEDNUM                 (M)   the material number (integers)
               0  "                               (MEDNUM=0 => vacuum)
               0  "  START ZSLAB            (M)   initial zslab (iz) (integers)
               0  "  STOP ZSLAB             (M)   final zslab (iz) (integers)
               0  "  START RING             (M)   initial radial ring (ix) (integers)
               0  "  STOP RING              (M)   final radial ring (ix) (integers)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "  One must use one type of input or the other so you must decide
               0  "  which is more convenient for any given case.
               0  "
               0  "
               0  ;
               0  "*******************************************************************************
               0  "                       PULSE HEIGHT DISTRIBUTION INPUTS     (ONLY IF IFULL=2)
               0  "                       ********************************
               0  "*******************************************************************************
               0  "
               0  " (ONLY IF IFULL= pulse height distribution)
               0  "
               0  "  PULSE HEIGHT DISTRIBUTION DELIMETERS:
               0  "                      :start pulse height distribution input:
               0  "                      :stop pulse height distribution input:
               0  "
               0  "
               0  "   REGION OF SENSITIVE VOLUME   (M)   Region numbers(IRL) of sensitive volume
               0  "
               0  "
               0  "   SLOTE    (R)   for the pulse height distribution, defines the
               0  "                  output energy bins. for SLOTE > 0.0, use equal size
               0  "                  bins of this width in MeV (this will get increased
               0  "                  by  factors of two until the whole spectrum input
               0  "                  gets covered.
               0  "                  SLOTE < 0.0, flags input additional 'TOPS OF ENERGY BINS'
               0  "
               0  "   DELTAE   (R)   code analyses peak efficiencies using a bin width
               0  "                  of 2*deltae about each peak and two background regions
               0  "                  of width deltae above and below the peak. default
               0  "                  value is 0.005 MeV. (meaningless for electrons and positrons
               0  "
               0  " IF SLOTE < 0.0 Input tops of individual energy bins for pulse height distn.
               0  "
               0  "   TOPS OF ENERGY BINS   (M)  lowest energy first, tops of bins.
               0  "                  [BINTOP]
               0  "
               0  "
               0  "*******************************************************************************
               0  "                            SOURCE INPUT(check latest version of srcrz)
               0  "                            **************
               0  "*******************************************************************************
               0  " SOURCE DELIMETERS:    :start source inputs:
               0  "                       :stop source inputs:
               0  "
               0  "FOR ALL SOURCES
               0  "                                      Charge of the incident beam
               0  "  INCIDENT PARTICLE= electron   (-1)  electrons
               0  "                     photon     (0)   photons
               0  "                     positron   (1)   positrons
               0  "
               0  "  (for SOURCE 21,22,23)  all    (2)  include all of the particles
               0  "                                     in the phase space file
               0  "                                     [IQIN]
               0  "                    charged     (3)  include e+ and e-
               0  "
               0  "  SOURCE NUMBER                 (I)   number of the source
               0  "                                      [ISOURC]
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  0 <<<<<<<<
               0  "
               0  "     PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS) ""toc:
               0  "
               0  "
               0  "  SOURCE OPTIONS            (M4)  RBEAM, UINC, VINC, WINC
               0  "
               0  "               RBEAM          radius of parallel beam in cm
               0  "                              (defaults to max radius of geometry)
               0  "               UINC           incident x-axis direction cosine
               0  "               VINC           incident y-axis direction cosine
               0  "               WINC           incident z-axis direction cosine
               0  "                              NOTE: (UINC,VINC,WINC)
               0  "                              get automatically normalized
               0  "                              defaults to (0.0,0.0,1.0)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  1 <<<<<<<<
               0  "
               0  "     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, 0, 0
               0  "
               0  "               DISTZ          distance of the point source from the
               0  "                              front of the target in cm (DEFAULT 100.)
               0  "               RBEAM          radius of the beam at the front of the
               0  "                              target in cm (defaults to MAX radius)
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  2 <<<<<<<<
               0  "
               0  "        BROAD PARALLEL BEAM INCIDENT FROM FRONT (+VE Z-AXIS) ""toc:
               0  "               WITH UNIT AREA BEAM AND LARGE SCORING AREA
               0  "
               0  "  SOURCE OPTIONS          (M4)  0, 0, 0, 0
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  3 <<<<<<<<
               0  "
               0  "     UNIFORM ISOTROPICALLY RADIATING DISK OF FINITE SIZE   ""toc:
               0  "            (MUST BE ALLOWED FOR IN THE GEOMETRICAL DEFINITIONS)
               0  "
               0  "  SOURCE OPTIONS                (M4)  RMINBM, RBEAM, ZSMIN, ZSMAX
               0  "
               0  "               RMINBM,RBEAM           inner and outer radii of source region
               0  "                                      must be inside geometry
               0  "               ZSMIN,ZSMAX            min and max z values for source
               0  "
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  4 <<<<<<<<
               0  "
               0  "     FOR CENTRAL AXIS FLUENCE VS BEAM RADIUS      ""toc:
               0  "
               0  "  SOURCE OPTIONS            (M4)  RCAXIS, 0, 0, 0
               0  "
               0  "               RCAXIS       radius of central axis scoring zone (cm)
               0  "
               0  "        NOTE: this source option treats the cylindrical radii input
               0  "              above as beam radii. the largest radius must be infinite
               0  "              and the phantom must be homogeneous (at least in each layer)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  10 <<<<<<<<
               0  "
               0  "     PARALLEL BEAM INCIDENT FROM THE SIDE (+VE Y-AXIS)    ""toc:
               0  "
               0  "  SOURCE OPTIONS           (M4)  XBEAM, ZBEAM, 0, 0
               0  "
               0  "               XBEAM             half-width of the rectangular beam in cm
               0  "                                 (defaults to max radius)
               0  "               ZBEAM             half-height of the rectangular beam in cm
               0  "                                 (defaults to max)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  11 <<<<<<<<
               0  "
               0  "     POINT SOURCE INCIDENT FROM THE SIDE     ""toc:
               0  "
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTRH, XBEAM, ZBEAM, 0
               0  "
               0  "               DISTRH                 distance of the source from the middle
               0  "                                      of the target in cm (defaults to 100.)
               0  "               XBEAM                  half-width of the beam at the center of
               0  "                                      the target in cm (defaults to max radius)
               0  "               ZBEAM                  half-height of the beam at the center of
               0  "                                      the target in cm (defaults to max)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  12 <<<<<<<<
               0  "
               0  "   POINT SOURCE OFF AXIS         ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTRH, DISTZ, 0, 0
               0  "
               0  "               DISTRH                 distance of the point source off the
               0  "                                      Z-axis.
               0  "               DISTZ                  perpendicular distance of the
               0  "                                      point source away from the front face.
               0  "                                      a negative value is permitted.
               0  "
               0  "                                      DISTZ > 0
               0  "                                      point located in front of front face
               0  "
               0  "                                      0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
               0  "                                      point located between front and rear face
               0  "
               0  "                                      DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
               0  "                                      point located rear of rear plane
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  13 <<<<<<<<
               0  "
               0  "        PARALLEL BEAM FROM ANY ANGLE     ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  UINC, VINC, WINC, 0
               0  "
               0  "               UINC                   incident x-axis direction cosine
               0  "               VINC                   incident y-axis direction cosine
               0  "               WINC                   incident z-axis direction cosine
               0  "
               0  "                 NOTE: (UINC,VINC,WINC) get automatically normalized
               0  "                       default is (0.0,0.0,1.0)
               0  "
               0  "
               0  "------------------------------------------------------------------------------
               0  "                     >>>>>>>> SOURCE  14 <<<<<<<<
               0  "
               0  "   POINT SOURCE ON AXIS INCIDENT FROM THE FRONT WITH ALL   ""toc:
               0  "    EVENTS INSIDE RMINBM NOT FOLLOWED (A FUDGE FOR COLLIMATOR STUDIES)
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, RMINBM, IGNORED
               0  "
               0  "               DISTZ                  distance of the point source from the
               0  "                                      front of the target in cm
               0  "                                      (defaults to 100.)
               0  "               RBEAM                  radius of the beam at the front of the
               0  "                                      target in cm (defaults to max radius)
               0  "               RMINBM                 below this radius, all histories are
               0  "                                      terminated by the source routines by
               0  "                                      giving them zero weight.
               0  "                                      The howfar routines must check for this.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "
               0  "
               0  "                     >>>>>>>> SOURCE  15 <<<<<<<<
               0  "
               0  "  POINT SOURCE OFF AXIS. The same as source 12 but uses an alternative
               0  "  implementation for sampling points on the surface of the RZ-geomtry. The
               0  "  motivation for implementing this source was to check that source 12 is OK
               0  "  and to check the effect of varying weights from the source on the
               0  "  statistical uncertainty (contrary to source 12, source 16 produces
               0  "  essentially  constant weights if the geometry-to-source distance is large
               0  "  compared to the geometry dimension, a typical situation for ion chamber
               0  "  simulations)
               0  "
               0  "  SOURCE OPTIONS                (M4)  DIST, ANGLE, IGNORED, IGNORED
               0  "
               0  "             DIST                     distance of the centre of the geometry
               0  "                                      to the source in cm.
               0  "             ANGLE                    angle of rotation around the x-axis.
               0  "                                      (because of the cylindrical symetry,
               0  "                                      rotations around the x-axis and y-axis
               0  "                                      are indistinguishable). 0 degrees
               0  "                                      corresponds to a source above the front
               0  "                                      face (i.e. the same as source 1), 90
               0  "                                      degrees to a source from the side
               0  "                                      (i.e. the same as source 11).
               0  "                                      The source MUST be outside the geometry,
               0  "                                      otherwise the initialization routine
               0  "                                      will abort execution.
               0  "
               0  "           Note that if you are not actually rotating about the center of the
               0  "           geometry, you must calculate the angle and distance as if you
               0  "           were.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "
               0  "
               0  "                     >>>>>>>> SOURCE  16 <<<<<<<<
               0  "
               0  "           EXTENDED (CIRCULAR OR RECTANGULAR)  SOURCE OFF AXIS.
               0  "
               0  "  SOURCE OPTIONS                (M4)  DIST, ANGLE, TMP1, TMP2
               0  "
               0  "            DIST                      distance of geometry centre to source
               0  "                                      centre in cm.
               0  "
               0  "            ANGLE                     angle of rotation around the x-axis
               0  "                                      (see comments/explanations to source 15)
               0  "
               0  "            TMP1, if TMP2 <= 0        radius of the source (i.e., the emitting
               0  "        or  TMP2, if TMP1 <= 0        position is picked uniformly within the
               0  "                                      circle).
               0  "
               0  "            TMP1 and TMP2, if both    half-sizes of the radiating rectangle
               0  "            >= 0                      in x- and y-directions before rotation,
               0  "                                      i.e., initially x and y are picked
               0  "                                      within the rectangle and z is set to
               0  "                                      -DIST + geometry centre. Then a rotation
               0  "                                      around the x-axis is performed.
               0  "       In all cases the source plane is perpendicular to the line joining
               0  "       it to the center of the geometry.   Note that this introduces a
               0  "       slight error if the center of your geometry is not the true point
               0  "       of rotation.
               0  "
               0  "       Note: if TEMP1 <= 0 and TEMP2 <= 0, source 16 becomes a point-source
               0  "             off-axis, i.e. the same as source 12 and 15.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  20 <<<<<<<<
               0  "
               0  "   RADIAL DISTRIBUTION INPUT      ""toc:
               0  "
               0  "  MODEIN= Local                 (0)   if radial distribution is to be input
               0  "                                      locally through the .egs4inp file
               0  "        = External              (1)   if the distribution is to be input
               0  "                                      via an external file
               0  "
               0  "                        -----------------------------
               0  " ONLY IF MODEIN= Local
               0  "
               0  "  NRDIST                        (I)   # radial bins in distribution histogram
               0  "  RDISTF                        (M)   top of radial bin.
               0  "                                      should be values for 1 to NRDIST.
               0  "  RPDF                          (M)   Probability of initial particle being
               0  "                                      in this bin.
               0  "                                      Probability doesn't need to be normalized
               0  "                                      but it should be in units cm**-2
               0  "                                      Should be values for 1 to NRDIST.
               0  "  RDIST IOUTSP= None            (0)   No distribution data in output summary
               0  "              = Include         (1)   include distribution data output summary
               0  "
               0  "                        -----------------------------
               0  "  ONLY IF MODEIN= External
               0  "
               0  "  RDIST FILENAME                (C)   filename(with ext) contains
               0  "                                      distribution information
               0  "
               0  "  RDIST IOUTSP= None            (0)   No distribution data in output summary
               0  "              = Include         (1)   include distribution data output summary
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  21 <<<<<<<<
               0  "
               0  "    FULL BEAM PHASE-SPACE BEAM DATA, INCIDENT ON FRONT FACE    ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  IMODE, 0, 0, 0
               0  "
               0  "               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
               0  "                                  2=> 8 variables/record: the above + ZLAST
               0  "
               0  "  FILSPC                        (C)   filename (with ext) contains
               0  "                                      phase space information
               0  "                                      (maximum of 80 characters)
               0  "                                      (assigned to unit 42)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  22 <<<<<<<<
               0  "
               0  "    FULL BEAM PHASE-SPACE BEAM DATA FROM ANY ANGLE, INSIDE OR OUTSIDE   ""toc:
               0  "
               0  "    PARTICLES ARE READ IN FROM A BEAM PHASE SPACE and placed on a plane
               0  "    described by the SOURCE OPTIONS inputs (see below). Then it is checked
               0  "    whether they are already inside the geometry. If yes, the region index
               0  "    is determined and the shower intiated. If not, it is checked whether
               0  "    the particle trajectory will intersect the geometry (assuming that the
               0  "    geometry is surrounded by vacuum). If not, the particle is rejected and
               0  "    the next one taken from the phase-space file. If yes, the particle
               0  "    is placed on the entry point and the shower is initiated.
               0  "
               0  "  SOURCE OPTIONS                (M4)  IMODE, DIST, ANGLE, ZOFFSET
               0  "
               0  "               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
               0  "                                  2=> 8 variables/record: the above + ZLAST
               0  "               DIST               Perpendicular distance of the phase-space
               0  "                                  plane to the point of rotation in cm.
               0  "               ANGLE              Angle of rotation in degrees. The rotation
               0  "                                  is performed around an axis that is parallel
               0  "                                  to the x-axis and passes through the point
               0  "                                  (x,y,z)=(0,0,ZOFFSET).
               0  "               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
               0  "                                  the centre of the geometry is taken as
               0  "                                  the point of rotation (but note that
               0  "                                  the maximum value allowed by the input
               0  "                                  routine is 1e6, so that |ZOFFSET| must
               0  "                                  be between 1e4 and 1e6 to use the centre
               0  "                                  of the geometry automatically).
               0  "
               0  "    Examples:
               0  "       - to place a phase-space on the upper z-face of the geometry,
               0  "         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
               0  "         This is the same as source 21
               0  "       - to place a phase space on the lower z-face of the geometry,
               0  "         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
               0  "       - to have a phase file incident from, say, 60 degrees with
               0  "         a distance to the centre of the geometry of 30 cm, use
               0  "         DIST=30, ANGLE=60, ZOFFSET=9999.
               0  "   etc.
               0  "
               0  "  FILSPC                        (C)   filename (with ext) contains
               0  "                                      phase space information
               0  "                                      (maximum of 80 characters)
               0  "                                      (assigned to unit 42)
               0  "
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  23 <<<<<<<<
               0  "
               0  "    BEAM TREATMENT HEAD SIMULATION AS SOURCE INCIDENT FROM AND ANGLE,  ""toc:
               0  "    INSIDE OR OUTSIDE PHANTOM                                          ""toc:
               0  "
               0  "    PARTICLES ARE READ DIRECTLY FROM A BEAM SIMULATION COMPILED AS A
               0  "    SHARED LIBRARY.  Particles are read at the scoring plane in
               0  "    the BEAM simulation (although no phase space file is scored) and are
               0  "    tranlated/rotated by the inputs DIST, ANGLE, XOFFSET, YOFFSET, ZOFFSET,
               0  "    described below.  Then it is checked
               0  "    whether they are already inside the geometry. If yes, the region index
               0  "    is determined and the shower intiated. If not, it is checked whether
               0  "    the particle trajectory will intersect the geometry (assuming that the
               0  "    geometry is surrounded by vacuum). If not, the particle is rejected and
               0  "    the next one taken from the BEAM simulation (more histories are run in
               0  "    the BEAM simulation if required).  If yes, the particle
               0  "    is placed on the entry point and the shower is initiated.
               0  "
               0  "  BEAM CODE                     (C)  The name of the accelerator code being
               0  "                                     used as a source including the BEAM_
               0  "                                     prefix (ie BEAM_accelname).  This code
               0  "                                     must have been compiled as a shared
               0  "                                     library (see the BEAM manual for more
               0  "                                     details) and exist as
               0  "                                     libBEAM_accelname.so (for Linux/Unix) or
               0  "                                     libBEAM_accelname.dll (for Windows) in
               0  "                                     directory $EGS_HOME/bin/config.
               0  "
               0  "  INPUT FILE                    (C)  The name of a working input file
               0  "                                     (no .egsinp extension) for
               0  "                                     the BEAM code BEAM_accelname.  This
               0  "                                     input file must specify output of a
               0  "                                     phase space file at one scoring plane.
               0  "                                     Particles that would have been scored
               0  "                                     in the phase space file are extracted
               0  "                                     and used as the incident particles in
               0  "                                     the DOSXYZ simulation instead.  The
               0  "                                     input file must exist in the directory
               0  "                                     $EGS_HOME/BEAM_accelname.
               0  "
               0  "  PEGS FILE                     (C)  The name of the pegs4 data set (no
               0  "                                     .pegs4dat extension) used
               0  "                                     by BEAM_accelname with the input file
               0  "                                     specified by INPUT FILE.  The pegs4
               0  "                                     data set must exist in either
               0  "                                     $HEN_HOUSE/pegs4/data or in
               0  "                                     $EGS_HOME/pegs4/data.
               0  "
               0  "  WEIGHT WINDOW                 (M2)  MIN_WEIGHT_23, MAX_WEIGHT_23
               0  "
               0  "               MIN_WEIGHT_23         Min. weight of particles to use from
               0  "                                     the BEAM simulation (defaults to -1E30)
               0  "               MAX_WEIGHT_23         Max. weight of particles to use from
               0  "                                     the BEAM simulation (defaults to 1E30)
               0  "
               0  "  SOURCE OPTIONS                (M5)  DIST, ANGLE, ZOFFSET, XOFFSET, YOFFSET
               0  "
               0  "               DIST               Perpendicular distance of the phase-space
               0  "                                  plane to the point of rotation in cm.
               0  "               ANGLE              Angle of rotation in degrees. The rotation
               0  "                                  is performed around an axis that is parallel
               0  "                                  to the x-axis and passes through the point
               0  "                                  (x,y,z)=(0,0,ZOFFSET).
               0  "               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
               0  "                                  the centre of the geometry is taken as
               0  "                                  the point of rotation (but note that
               0  "                                  the maximum value allowed by the input
               0  "                                  routine is 1e6, so that |ZOFFSET| must
               0  "                                  be between 1e4 and 1e6 to use the centre
               0  "                                  of the geometry automatically).
               0  "               XOFFSET,YOFFSET    X and Y offset of scoring plane in BEAM
               0  "                                  simulation (cm).  Offsets are applied before
               0  "                                  rotating the source.
               0  "
               0  "    Examples:
               0  "       - to have BEAM simulation incident on the upper z-face of the geometry,
               0  "         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
               0  "         This is the same as source 21
               0  "       - to have BEAM simulation incident on the lower z-face of the geometry,
               0  "         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
               0  "       - to have BEAM simulation incident from, say, 60 degrees with
               0  "         a distance to the centre of the geometry of 30 cm, use
               0  "         DIST=30, ANGLE=60, ZOFFSET=9999.
               0  "
               0  "
               0  ;
               0  "*******************************************************************************
               0  "
               0  " Source Energy Inputs (not required if ISOURC=21,22,23 - phase space or BEAM
               0  "                                                         simulation )
               0  "
               0  "  Input from ensrc.mortran
               0  "
               0  " ENSRC DELIMETERS:  :start source inputs:
               0  "                    :stop source inputs:
               0  "
               0  "
               0  "  INCIDENT ENERGY
               0  "        = monoenergetic  (0)  if monoenergetic beam
               0  "        = spectrum       (1)  if energy spectrum to be used
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Monoenergetic:
               0  "
               0  "     INCIDENT KINETIC ENERGY(MEV)   (I)
               0  "                                   kinetic energy of the incident beam in MeV
               0  "                                   (defaults to 1.25)
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Spectrum:
               0  "
               0  "                   SPEC FILENAME   (C)  filename (with ext)
               0  "                                   contains spectrum information
               0  "
               0  "                                   FILE FORMAT:
               0  "                                   TITLE      spectrum title  (80 char)
               0  "                                   NENSRC, ENMIN, MODE
               0  "                                   NENSRC     # energy bins in spec. histogram
               0  "                                   ENMIN      lower energy of first bin
               0  "                                   MODE       =0, assumes cts/bin
               0  "                                              =1  assumes cts/MeV
               0  "                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
               0  "                                   top of energy bin and probability of
               0  "                                   initial particle being in this bin.
               0  "                                   probability does not need to be normalized
               0  "
               0  "                   SPEC IOUTSP
               0  "                        = none     (0)  no spectrum data in output summary
               0  "                        = include  (1)  include spectrum data in output summary
               0  ;
               0  "*******************************************************************************
               0  "
               0  "                       TRANSPORT CONTROL INPUT
               0  "                       ***********************
               0  "
               0  "  BE AWARE!!!!!!!!!!!!!!!!!!!!
               0  "            IK changed this section to make things more flexible.
               0  "            All mc transport parameter are handled in a separate
               0  "            routine, the delimeters are
               0  "                  :start mc transport parameter:
               0  "                  :stop mc transport parameter:
               0  "            Input associated with variance reduction,
               0  "            previously in the transport control section,
               0  "            is to be put between the delimeters
               0  "                  :start variance reduction:
               0  "                  :stop variance reduction:
               0  "
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  Currently, the following options are available (except for a few entries,
               0  "  case does not matter):
               0  "
               0  "       Global ECUT=     Set a global (in all regions) electron transport
               0  "                        cut off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Set a global (in all regions) photon transport
               0  "                        cut off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Set a global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions will
               0  "                        be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Set the maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%)
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is Off
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        even in `well conditioned' situations (e.g. depth
               0  "                        dose curves for RTP energy range electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If On, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but signifficant in the keV energy range.
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski or penelope.  If set to On or ik, then
               0  "                        use Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then use the cross-sections of
               0  "                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
               0  "                        Similar for kolbenstvedt, gryzinski and penelope.
               0  "                        This is only of interest in kV X-ray calculations.
               0  "                        Note that the user can supply their own EII
               0  "                        cross-section data as well. The requirement is that
               0  "                        the file eii_suffix.data exists in the $HEN_HOUSE/data
               0  "                        directory, where suffix is the name specified.
               0  "                        Entry is case-sensitive except for Off, On or ik.
               0  "                        [ eii_flag ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impuls approximation. Default is On.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to turn on for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Pair angular sampling= Off, Simple or KM
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.
               0  "                        Default is Simple, make sure you always use Simple or
               0  "                        KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel--the default), epdl (Evaluated Photon
               0  "                        Data Library), xcom and pegs4.  Allows the use of
               0  "                        photon cross-sections other than from the PEGS4 file
               0  "                        unless the pegs4 option is specified.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is Off
               0  "                        [ IPHTER ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turn on coherent (Rayleigh) scattering,
               0  "                        even if no Rayleigh data in PEGS4 file.
               0  "                        Default is Off. Should be turned on for low energy
               0  "                        applications. If custom, user must provide media names
               0  "                        and form factor files for each medium.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "       Atomic relaxations= Off, On
               0  "                        Default is Off. The effect of using On is twofold:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross seections
               0  "                        - Shell vacancies created in photo-absorption events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         Make sure to turn this option on for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "                         can also be turned On/Off on a region-by-region
               0  "                         basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                        in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0  "
               0  "                    VARIANCE REDUCTION
               0  "                    ******************
               0  "
               0  "  Delimeter:       :start variance reduction:
               0  "                   :stop variance reduction:
               0  "
               0  "  BREM SPLITTING
               0  "         = Off            (0)   no bremsstrahlung splitting
               0  "         = On             (1)   there is bremsstrahlung spliting
               0  "
               0  "  NUMBER OF BREMS PER EVENT
               0  "                          (I)   number of brems / event if splitting on
               0  "
               0  "  CHARGED PARTICLE RUSSIAN ROULETTE
               0  "         = Off        (0)  Do not play Russian Roulette with charged particles
               0  "         = On         (1)  Play Russian Roulette with charged particles with
               0  "                           probability of survival=PROB_RR=1/nbr_split.
               0  "                           [I_PLAY_RR]
               0  "
               0  "  ELECTRON RANGE REJECTION
               0  "         = off        (0)  No electron range rejection
               0  "         = on         (1)  Do electron range rejection. All charged
               0  "                           particles without enough range to get out
               0  "                           of their current region have their
               0  "                           history terminated.  This uses EGSnrc internal
               0  "                           range rejection and takes no time to test.
               0  "                           The parameter ESAVEIN also plays a role (see below)
               0  "                           [IREJCT]
               0  "
               0  "      We could/should? reinstitute the old approach by searching all
               0  "      regions outside the region of interest, finding the one with the
               0  "      greatest range and then use that range as a test against the distance
               0  "      to the region of interest.  Some of the coding is left in place.
               0  "      This has been implemented in CAVRZnrc
               0  "
               0  "  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
               0  "                           electron  when E< ESAVEIN and RANGE < CDIST
               0  "                           where CDIST is closest distance to region of
               0  "                           interest specified. This ignores bremsstrahlung
               0  "                           losses below ESAVEIN.
               0  "                           This parameter must be input even if not used.
               0  "                           ESAVEIN is a total energy.
               0  "
               0  "
               0  "========================================================================
               0  "  FOLLOWING IS NOT USED  - leave in until decide what to do
               0  "========================================================================
               0  "  RANGE REJECTION PARAMETERS
               0  "                 (M5)   CRANGE(1,1),CRANGE(2,1),ERANGE,CRANGE(1,2),CRANGE(2,2)
               0  "
               0  "               Coefficients of a 2-piece logarithmic fit to the electron
               0  "               CSDA range used to discard electrons that cannot reach the
               0  "               range rejection region.
               0  "               The electron residual range is computed in HOWFAR as
               0  "               RANGE=EXP(CRANGE(1,I)+CRANGE(2,I)*ELKE)/RHO
               0  "               where  i=1 for EKE>ERANGE, ELSE I=2.
               0  "               default values for crange,erange are for carbon
               0  "               with ERANGE=200keV FROM B&S '64. The range should always
               0  "               be overestimated with the closest fit being at the energy
               0  "               where most of the electrons are expected to be.
               0  "            NB There is only one medium used and hence it must be the
               0  "               one with the longest range in the problem.
               0  ;
               0  "
               0  " If  ELECTRON RANGE REJECTION= on
               0  "
               0  "  RANGE REJECTION MINIMUM PLANE   (I)  min. Z boundary for range rejection
               0  "
               0  "  RANGE REJECTION MAXIMUM PLANE   (I)  max. Z boundary for range rejection
               0  "
               0  "  RANGE REJECTION MINIMUM RADIUS  (I)  min radial boundary for range rejection
               0  "
               0  "  RANGE REJECTION MAXIMUM RADIUS  (I)  max radial boundary for range rejection
               0  "
               0  "               The above boundaries define the ``tracking region'' and if
               0  "               a charged particles range is such that it cannot get to
               0  "               this region, the history is terminated if E<ESAVEIN.
               0  "========================================================================
               0  "========================================================================
               0  "
               0  "
               0  "  RUSSIAN ROULETTE DEPTH      (R)
               0  "                           for russian roulette -
               0  "                           as any photon crosses the Z='RUSSIAN ROULETTE DEPTH'
               0  "                           plane,  russian roulette is played.
               0  "                           [RRZ]
               0  "
               0  "  RUSSIAN ROULETTE FRACTION   (R)
               0  "                           Each time russian roulette is played, RRF IS THE
               0  "                           probability of survival.
               0  "                           weight increases by 1/RRF,  if it survives
               0  "                           [RRCUT]
               0  "
               0  "                    ****** IF BOTH ZERO, NO RUSSIAN ROULETTE IS PLAYED ******
               0  "
               0  "  EXPONENTIAL TRANSFORM C     (R)
               0  "                           Parameter for pathlength biasing <0 FOR SHORTENING
               0  "                           If 0.0, no biasing done.
               0  "                           Review chapter discusses in detail.
               0  "                           [CEXPTR]
               0  ;
               0  "
               0  "  PHOTON FORCING
               0  "        = Off         (0)    normal photon transport (no forcing)
               0  "        = On          (1)    force photon interactions explicitly
               0  "                             must set START and STOP FORCING in this case
               0  "                             [IFORCE]
               0  "
               0  "  START FORCING       (I)    number of photon interaction/history at which
               0  "                             to start forcing photon interactions
               0  "                             This input is required even if forcing off
               0  "                             [NFMIN]
               0  "  STOP FORCING AFTER  (I)    number of photon interaction/history after which
               0  "                             to stop forcing photon interactions
               0  "                             [NFMAX]
               0  "                             STOP FORCING AFTER must be >= START FORCING
               0  "                             This input is required even if forcing off
               0  "
               0  "  CS ENHANCEMENT FACTOR  (R)  can scale the photon cross section by this
               0  "                             factor in a specified set of regions.
               0  "                             From 1 to 10,000. with a default of 200 if
               0  "                             it is on at all.
               0  "
               0  "  CS ENHANCEMENT START REGION (M)
               0  "  CS ENHANCEMENT STOP REGION  (M)
               0  "                             Photon cross section scalled in these defined
               0  "                             sets of regions.
               0  "                             From 0 to NREG.  Defaults to region 1 which means
               0  "                             no enhancement since this is outside the geometry.
               0  "
               0  "
               0  ;
               0  "*******************************************************************************
               0  "
               0  "                             PLOT CONTROL INPUTS
               0  "                             *******************
               0  "*******************************************************************************
               0  "
               0  "  PLOT CONTROL DELIMETERS:   :start plot control:
               0  "                             :stop plot control:
               0  "
               0  "
               0  "   PLOTTING
               0  "          = Off         (0)   no plots or plot files to be prepared
               0  "          = On          (1)   plotting to be prepared or printed
               0  "
               0  "
               0  "  ONLY IF   PLOTTING= On
               0  "
               0  "   LINE PRINTER OUTPUT
               0  "          = Off         (0)   don't plot in egs4lst file
               0  "          = On          (1)   do plot in egs4lst file
               0  "
               0  " ONLY IF   PLOTTING= On
               0  "
               0  "   EXTERNAL PLOTTER OUTPUT
               0  "          = Off         (0)   don't prepare plot files for xmgr
               0  "          = On          (1)   prepare xmgr input  files
               0  "
               0  " ONLY IF   EXTERNAL PLOTTER OUTPUT= On
               0  "   EXTERNAL PLOT TYPE
               0  "          = Point       (1)   point plot in xmgr file
               0  "          = Histogram   (2)   histogram  plot in xmgr file
               0  "          = Both        (3)   both point plot and histogram
               0  "
               0  "
               0  " ONLY IF   PLOTTING= On
               0  "   PLOT RADIAL REGION IX  (M)  radial regions to plot vs depth
               0  "                               (= 0 for no plots)
               0  "
               0  " ONLY IF   PLOTTING= On
               0  "   PLOT PLANAR REGION IZ  (M)  planar slab numbers to plot vs radius
               0  "                               (= 0 for no plots)
               0  "
               0  "******************************************************************************"
               0  "                          END OF INPUTS
               0  "                          *************
               0  "
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  ;
               0  "
               0  "                       USER DEFINED MACROS
               0  "                       *******************
               0  ;
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  REPLACE {$PLTDIM} WITH {500}     "bins for plotting routine xvgrplot"
               0  REPLACE {$EBIN} WITH {$PLTDIM}   "Max number of bins in pulse height distn     "
               0  "                                 Note if you use large values of EBIN so that "
               0  "                                 2*EBIN > MXDATA (below), then use 2*EBIN     "
               0  REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET      "
               0  REPLACE {$NSWTCH} WITH {8}       "# OF NRC SWITCHES FOR CONTROLLING SCATTERING "
               0  REPLACE {$MXMED} WITH {10}       "MAX # OF MEDIA                               "
               0  REPLACE {$NCASEMIN} WITH {100}   "min. no. of histories                        "
               0  REPLACE {$NBATCH} WITH {10}      "# BATCHES FOR OUTPUT                         "
               0  REPLACE {$MXSTACK} WITH {900000} "MAXIMUM STACK                                "
               0  REPLACE {$MAXZREG} WITH {200}    "MAX # OF DOSE SCORING PLANAR ZONES           "
               0  REPLACE {$MAXRADII} WITH {60}    "MAX # OF DOSE SCORING RADIAL ZONES           "
               0  REPLACE {$MAXRZ} WITH {$MAXZREG} "MAX($MAXRADII,$MAXZREG)                      "
               0  REPLACE {$MXRDIST} WITH {100}    "# OF POINTS IN RADIAL DISTRIBUTION FIT       "
               0  REPLACE {$MAXIT} WITH {7}        "MAX # OF DOSE COMPONENTS TO BE SCORED        "
               0  "                                (1) TOTAL DOSE                                "
               0  "                                (2) STOPPERS AND DISCARDS DOSE                "
               0  "                                (3) TOTAL DOSE FROM FRONT WALL                "
               0  "                                (4) TOTAL DOSE FROM SIDE WALL                 "
               0  "                                (5) TOTAL DOSE FROM BACK WALL                 "
               0  "                                (6) TOTAL DOSE FROM INSIDE WALL               "
               0  "                                (7) TOTAL DOSE SCORED IN REGION NSRCRG        "
               0  "                                    DUE TO PARTICLES CREATED IN THE           "
               0  "                                    REGION (ONLY WHEN ISOURC = 3)             "
               0  REPLACE {$MAXCMPTS} WITH {$MAXIT}"MAX # OF COMPONENTS IN SUBROUTINE GRID       "
               0  "COMPUTED MACROS                                                               "
               0  REPLACE {$MAXZPLANE} WITH {{COMPUTE $MAXZREG+1}}
               0  "                                 MAX # OF PLANAR BOUNDARIES                   "
               0  REPLACE {$MAXRADII1} WITH {{COMPUTE $MAXRADII+1}}
               0  "                                 MAX # OF RADIAL DOSE COMPONENTS TO SCORE + 1 "
               0  REPLACE {$MXREG} WITH {{COMPUTE ($MAXRADII*$MAXZREG)+1}}
               0  "                                 # IF REGIONS, +1 IS FOR THE VACUUM           "
               0  REPLACE {$MXDATA} WITH {{COMPUTE $MXREG-1}}
               0  "REPLACE {$MXDATA} WITH {{COMPUTE 2*$EBIN}}"
               0  "                       Use the second version of the above macro IF and ONLY  "
               0  "                       if 2*$EBIN > ($MXREG-1)*$STAT                          "
               0  "                       Note an explicit test/check is implemented below"
               0  "                                 MAXIMUM DATA POINTS FOR ANALYSIS             "
               0  REPLACE {$MAXBRSPLIT} WITH {200} "MAX BREM SPLITTING NUMBER"
               0
               0  REPLACE {$MAX_SC_PLANES} WITH {1};"needed to use phsp macros"
               0  ;
               0
1              0  %E
               0  "Following macro tells code to use the get_inputs routine for"
               0  "the presta II inputs"
               0
               0  REPLACE {$PRESTA-II-INPUTS;}  WITH { call prestaII_inputs; }
               0
               0
               0
               0  ;
               0  "This MACRO changes integers of three digits"
               0  "or less into a character string. It is needed with the get_opts routine."
               0  "In each case 48 must be added to the digit we are"
               0  "converting into ASCII since '0' is ASCII # 48."
               0  "Aaron Merovitz, Jan 1998"
               0
               0  REPLACE {$CONVERT_INT(#)_TO_CHAR(#);} WITH {
            {  0  ;
            {  0  "{P1} is the integer value < 1000"
            {  0  "{P2} is the character string returned"
            {  0  NEGVAL=.FALSE.;
            {  0  IF ({P1} < 0) [
            {  0  NEGVAL=.TRUE.;
            {  0  {P1} = ABS({P1});
            {  0  ]
            {  0  IF (({P1} = MOD({P1},1000)))[
            {  0  CHECK=1;
            {  0  IF ({P1} = MOD({P1},10)) [
            {  0  IF (NEGVAL) [{P2}='-'//CHAR({P1}+48);]
            {  0  ELSE [{P2}=CHAR({P1}+48);]
            {  0  CHECK=0;
            {  0  ]
            {  0  IF ((CHECK.NE.0).AND.({P1} = MOD({P1},100))) [
            {  0  a(1)=CHAR(({P1}/10)+48);
            {  0  int=(MOD({P1},10)+48);
            {  0  a(2)=CHAR(int);
            {  0  IF (NEGVAL) [{P2}='-'//a(1)//a(2);]
            {  0  ELSE [{P2}=a(1)//a(2);]
            {  0  CHECK=0;
            {  0  ]
            {  0  IF (CHECK.NE.0) [
            {  0  a(1)=CHAR(({P1}/100)+48);
            {  0  int=(MOD({P1},100)/10+48);
            {  0  a(2)=CHAR(int);
            {  0  int=MOD({P1},10)+48;
            {  0  a(3)=CHAR(int);
            {  0  IF (NEGVAL) [{P2}='-'//a(1)//a(2)//a(3);]
            {  0  ELSE [{P2}=a(1)//a(2)//a(3);]
            {  0  ]
            {  0  ]
            {  0  ELSE [{P2}='3max';]
            {  0  }
               0
               0
               0  REPLACE {;COMIN/BREMPR_addition/;} WITH {
            {  0  ;COMMON /BREMPR_addition/IBRSPL;
            {  0  $INTEGER IBRSPL;         "flag set to 1 if bremsstrahlung splitting used"
            {  0  !   COMIN BREMPR_addition is defined in DOSRZnrc.mortran;
            {  0  }
               0  ;APPEND {;COMIN/BREMPR_addition/;} TO {;COMIN/BREMPR/;}
               0
               0  ;
               0  "MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
               0  "USED BY EGSnrc FOR VARIANCE REDUCTION"
               0  "      note WT and GWTOLD were updated in fast step"
               0  "      until April 1991                            "
               0
               0  "In order to use $SELECT-PHOTON-MFP with implicit none, we need
               0  "to define all variables used in $SELECT-PHOTON-MFP in the
               0  "PHOTON routine, IK Jan 5 2000
               0
               0  APPEND {;COMIN/NRCNEW/;} TO {$COMIN-PHOTON;}
               0  ;
               0  APPEND
               0  {;
            {  0  $REAL SPMFP,TEMP,TEMP1,PATHLT;
            {  0  $REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
            {  0  $INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP,NRCDUM;
            {  0  ;} TO
               0  {$DEFINE-LOCAL-VARIABLES-PHOTON;}
               0
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0  "         =================="
            {  0  NFTIME=NFTIME+1;
            {  0  $RANDOMSET RNNO35;IF(RNNO35 = 0.0)RNNO35=1.E-30;
            {  0  IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))[
            {  0  SPMFP=-LOG(RNNO35);
            {  0  IF( (CEXPTR.LT.1.0) .AND.(NFTIME.GE.NFMIN) .AND.(NFTIME.LE.NFMAX)
            {  0  .AND.( ((W(NP).GT.0.0).AND.(CEXPTR.GT.0.0)).OR.(CEXPTR.LT.0.0))
            {  0  )[
            {  0  TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
            {  0  SPMFP=SPMFP/TEMP1;WT(NP)=WT(NP)*EXP(-SPMFP*TEMP)/TEMP1;
            {  0  ]
            {  0  DPMFP=SPMFP;
            {  0  ]
            {  0  ELSE[
            {  0  IF((do_fast_step).AND.(NFTIME.EQ.1).AND.(CEXPTR.EQ.0.0))
            {  0  GOTO :FASTSTEP:;
            {  0  "IFPB IN COMIN USER-VARIANCE-REDUCTION"
            {  0  DUMU=USTEP;
            {  0  DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
            {  0  IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
            {  0  IDUM=IDISC;
            {  0  NRCDUM=NEWNRC;
            {  0  PATHL=0.0;MEDTMP=0;
            {  0  LOOP[
            {  0  USTEP=VACDST;
            {  0  IROLD=IR(NP);MEDIUM=MED(IROLD);
            {  0  IF(MEDIUM=0)["vacuum"
            {  0  DELTAP=0.;
            {  0  ]
            {  0  ELSE[
            {  0  IF(MEDTMP.NE.MEDIUM)[
            {  0  MEDTMP=MEDIUM;
            {  0  $SET INTERVAL GLE,GE;
            {  0  $EVALUATE DELTAP USING GMFP(GLE);
            {  0  ]
            {  0  IF(IRAYLR(IROLD).EQ.1)[ $EVALUATE COHFAC USING COHE(GLE); ]
            {  0  ELSE[ COHFAC=1.0; ]
            {  0  ]
            {  0  IRNEW=IROLD;
            {  0  CALL HOWFAR;
            {  0  IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
            {  0  "only add to pathl if not going through vacuum"
            {  0  IF(IRNEW.EQ.1) EXIT;
            {  0  IR(NP)=IRNEW;
            {  0  X(NP)=X(NP)+USTEP*U(NP);
            {  0  Y(NP)=Y(NP)+USTEP*V(NP);
            {  0  Z(NP)=Z(NP)+USTEP*W(NP);
            {  0  ]
            {  0  USTEP=DUMU;
            {  0  X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
            {  0  IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
            {  0  IDISC=IDUM;
            {  0  NEWNRC=NRCDUM;
            {  0  IF(CEXPTR.EQ.0)[
            {  0  IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
            {  0  ELSE[GWAIT=1.-EXP(-PATHL);]
            {  0  ]
            {  0  GWTOLD=WT(NP);
            {  0  WT(NP)=GWTOLD*GWAIT;
            {  0
            {  0  :FASTSTEP:;
            {  0  IF(CEXPTR.EQ.0)[
            {  0  EPSLON=RNNO35*GWAIT;
            {  0  IF(EPSLON.LE.1.0E-3)[
            {  0  IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
            {  0  DPMFP=EPSLON*(1.+0.5*EPSLON);
            {  0  ]
            {  0  ELSE[
            {  0  ARG=1./(1.-EPSLON);
            {  0  DPMFP=LOG(ARG);
            {  0  IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
            {  0  ]
            {  0  ]
            {  0  ELSE["CEXPTR non-zero"
            {  0  TEMP=CEXPTR*W(NP);TEMP1=1.0-TEMP;
            {  0  PATHLT=PATHL*TEMP1;
            {  0  IF(ABS(PATHLT).LE.1.0E-3)[
            {  0  SPMFP=PATHL*RNNO35*(1.0-0.5*PATHLT*(1.0-RNNO35));
            {  0  GWAIT=PATHL*(1.0-0.5*PATHLT)*EXP(-SPMFP*TEMP);
            {  0  DPMFP=SPMFP;
            {  0  ]
            {  0  ELSE[
            {  0  GWAIT=1.-EXP(-PATHLT);
            {  0  SPMFP=-LOG(1.0-RNNO35*GWAIT)/TEMP1;
            {  0  GWAIT=GWAIT*EXP(-SPMFP*TEMP)/TEMP1;
            {  0  DPMFP=SPMFP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0
               0  " The following macro is used in conjunction with an user
               0  " input cs_enhance and iefl(irl) to increase the photon
               0  " interaction density in regions of interest (where iefl(irl) is set to 1)
               0  " cs_enhance means desired average number of interactions per
               0  " g/cm**2. If cs_enhance*rho(medium) > 1/gmfp (1/gmfp is the the actual
               0  " number of interactions per unit length), cs_enhance*rho(medium) is
               0  " used to sample interaction distances in these regions.
               0  " Scattered and unscattered photon fractions are then killed via Russian
               0  " Roulette (to avoid too many low-weight photons)
               0  "
               0  "       ics_enhance  flag to indicate if both some regions are asked     "
               0  "                    and the enhancement factor is > 1.001               "
               0  "                    ics_enhance = 1 if BOTH conditions fulfilled        "
               0  "       cs_enhance   cross section enhancement factor as input by user   "
               0  "       ienhance     flag indicating whether an interaction in enhanced  "
               0  "                    region occurred                                     "
               0  "       iefl(irl)    set 0 if there is no enhancement, 1 if there is     :
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0  ;IF(IRAYLR(IRL).EQ.1) [
            {  0  $EVALUATE COHFAC USING COHE(GLE);
            {  0  GMFP=GMFP*COHFAC
            {  0  ];
            {  0  "enhancement flag to beef up a local cross-section"
            {  0  ;IF(iefl(IRL) = 1) ["these are all zero if cs_enhance is 1.0"
            {  0  cs_enhance_current = cs_enhance*rho(medium)*gmfp;
            {  0  IF( cs_enhance_current > 1 ) [
            {  0  GMFP=GMFP/cs_enhance_current;
            {  0  ienhance=1;
            {  0  ]
            {  0  ELSE [
            {  0  cs_enhance_current = 1; ienhance = 0;
            {  0  ]
            {  0  ]"end of block for regions in which enhancement done"
            {  0  ELSE [ cs_enhance_current = 1; ienhance=0; ]
            {  0  }
               0
               0
               0  REPLACE {$SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;} WITH
               0  "        =================================================="
               0  {
            {  0  ;
            {  0  IF((IFPB.EQ.0).AND.(IFORCE.EQ.1))[
            {  0  GLE=LOG(EIN);
            {  0  DO IX=1,NR[
            {  0  PATHL=0.0;
            {  0  DO IZ=1,NZ[
            {  0  $GET-IRL(IZ,IX);MEDIUM=MED(IRL);
            {  0  IF(MEDIUM=0)["vacuum"
            {  0  DELTAP=0.;
            {  0  ]
            {  0  ELSE[
            {  0  $SET INTERVAL GLE,GE;
            {  0  $EVALUATE DELTAP USING GMFP(GLE);
            {  0  IF(IRAYLR(IRL).EQ.1)[
            {  0  $EVALUATE COHFAC USING COHE(GLE);
            {  0  ]
            {  0  ELSE[
            {  0  COHFAC=1.0;
            {  0  ]
            {  0  ]
            {  0  IF(DELTAP~=0) ["only add to path if not vacuum"
            {  0  DELTAP=(ZPLANE(IZ+1)-ZPLANE(IZ))/(COHFAC*DELTAP);
            {  0  PATHL=PATHL+DELTAP;
            {  0  ]
            {  0  IF(PATHL.LE.1.0E-3)[GWATE(IX)=PATHL*(1.-0.5*PATHL);]
            {  0  ELSE[GWATE(IX)=1.-EXP(-PATHL);]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0
               0
               0  ;
               0  "MACRO THAT GETS GEOMETRICAL (OR DOSE) ZONES FROM THE GEOMETRY (OR NDOSRG+1)
               0  "NUMBER WITH THE INPUT OF NZ (OR NZDOSE)
               0  REPLACE {$GET-IX-IZ(#);} WITH {;IX=({P1}-2)/NZ+1; IZ={P1}-1-NZ*(IX-1);}
               0  "        =============="
               0
               0  ;
               0  "MACRO THAT GETS THE GEOMETRY NUMBER FROM THE PLANAR AND RADIAL ZONES
               0  ;REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NZ*({P2}-1)+1;}
               0  "         =============="
               0
               0  ;
               0  " **** RANGE REJECTION MACRO****"
               0  "$USER-RANGE-DISCARD for local region has been replaced by EGSnrc's"
               0  "$RANGE-DISCARD"
               0
               0  "THE FOLLOWING FIVE MACROS ARE FOR STATISTICAL ANALYSIS.             "
               0  "THEY MAKE USE OF THE SUBROUTINE SIGMA FOUND IN THE NRCCAUX.MOR FILE."
               0  "MODE 0 => IGNORE 0 VALUES IN ANALYSIS                               "
               0  "     1 => INCLUDE 0 VALUES                                          "
               0  "     2 => ANALYSE FOR TOTAL VALUE, NOT AVERAGE VALUE PER BATCH      "
               0  "                                                                    "
               0  "ALL ROUTINES USE THREE ASSOCIATED ARRAYS, OF VARYING DIMENSIONS.    "
               0  "THE DIMENSIONS REFERRED TO ARE THOSE OF THE QUANTITY OF INTEREST.   "
               0  "                                                                    "
               0  "       ARRAYIS   ARRAY OF VALUES IN STATISTICAL BATCHES (INPUT)     "
               0  "       ARRAY     ARRAY OF AVERAGE OR TOTAL VALUES       (OUTPUT)    "
               0  "       ARRAYUN   ARRAY OF UNCERTAINTIES                 (OUTPUT)    "
               0  "                                                                    "
               0  "   UNCERTAINTIES ARE %, AND CAPPED AT 99.9%                         "
               0  "                                                                    "
               0  ;
               0
               0  REPLACE {$SCORE(#,#:#)} WITH {;
            {  0
            {  0  "Scoring macro used in AUSGAB for quantities other than DOSE and KERMA"
            {  0  "{P1}{P2}=scoring array (eg SCSTP)"
            {  0  "{P3}=quantity to be scored (eg 1)"
            {  0
            {  0  "If the (primary) history number, NHSTRY, is the same as the history"
            {  0  "that last scored in this array, {P1}_LAST{P2}, then {P3} is added"
            {  0  "to a temporary array, {P1}_TMP{P2}.  Otherwise, we add"
            {  0  "{P1}_TMP{P2} to {P1}{P2}, {P1}_TMP{P2}*{P1}_TMP{P2} to {P1}2{P2},"
            {  0  "set {P1}_TMP{P2}={P3}, and set {P1}_LAST{P2}=NHSTRY."
            {  0  "This scoring method allows us to calculate  uncorrelated value"
            {  0  "of {P1}2{P2} which is then used to calculate the uncertainty"
            {  0  "in {P1}{P2}.  This macro was copied over from BEAMnrc, but in this"
            {  0  "code it is only used for scoring no. of steps."
            {  0
            {  0  IF(NHSTRY={P1}_LAST{P2})[
            {  0  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
            {  0  ]
            {  0  ELSE[
            {  0  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
            {  0  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
            {  0  {P1}_TMP{P2}={P3};
            {  0  {P1}_LAST{P2}=NHSTRY;
            {  0  ]
            {  0  ;
            {  0  }
               0
               0  REPLACE {$SCOREDK(#,#:#)} WITH {;
            {  0
            {  0  "Scoring macro used in AUSGAB for DOSE and KERMA"
            {  0  "{P1}{P2}=scoring array (eg SCDOSE(IZD,IXD,IT))"
            {  0  "{P3}=quantity to be scored (eg FTMP)"
            {  0
            {  0  "Works similar to $SCORE macro above.  However, if we are scoring"
            {  0  "KERMA and we have moved on to a new primary history, then the KERMA"
            {  0  "accumulated over the previous primary history is stored in"
            {  0  "SCKERMA_TMPOLD{P2} and the previous primary history number is stored"
            {  0  "in SCKERMA_LASTOLD{P2}.  Then, if we are scoring DOSE and have just moved on"
            {  0  "to a new primary history, this macro checks to see if the previous"
            {  0  "primary history that deposited energy = the previous primary history that"
            {  0  "scored kerma.  If so, then the contents of SCDOSE_TMP{P2} are multiplied by"
            {  0  "SCKERMA_TMPOLD{P2} and added to SCDOSEtoKERMA2{P2}.  SCDOSEtoKERMA2{P2}"
            {  0  "is eventually used calculate the covariance DOSE and KERMA to obtain an"
            {  0  "estimate on the uncertainty on DOSE/KERMA."
            {  0
            {  0  IF(NHSTRY={P1}_LAST{P2})[
            {  0  {P1}_TMP{P2}={P1}_TMP{P2} + {P3};
            {  0  ]
            {  0  ELSE[
            {  0  {P1}{P2}={P1}{P2}+{P1}_TMP{P2};
            {  0  {P1}2{P2}={P1}2{P2} + {P1}_TMP{P2}*{P1}_TMP{P2};
            {  0  IF('{P1}'='SCKERMA')[
            {  0  SCKERMA_TMPOLD{P2}={P1}_TMP{P2};
            {  0  SCKERMA_LASTOLD{P2}={P1}_LAST{P2};
            {  0  ]
            {  0  ELSEIF('{P1}'='SCDOSE' & IKERMA=1 & {P1}_LAST{P2}=SCKERMA_LASTOLD{P2})[
            {  0  SCDOSEtoKERMA2{P2}=SCDOSEtoKERMA2{P2}+{P1}_TMP{P2}*
            {  0  SCKERMA_TMPOLD{P2};
            {  0  ]
            {  0  {P1}_TMP{P2}={P3};
            {  0  {P1}_LAST{P2}=NHSTRY;
            {  0  ]
            {  0  ;
            {  0  }
               0
               0  REPLACE {$ANALYZE(#,#:#)} WITH {;
            {  0
            {  0  "Macro to analyze uncertainty:"
            {  0  "{P1}{P2}=scoring array (eg SCDOSE(IDZ,IDX,ITDOSE))"
            {  0  "{P3}=quantity to normalize by (eg incident no. of particles)"
            {  0
            {  0  "Calculates the uncertainty on {P1}{P2}/{P3}.  The "
            {  0  "uncertainty is stored in {P1}2{P2} and is expressed as a percentage of"
            {  0  "{P1}{P2}/{P3} (max 99.9%).  Note that you must define the REAL*8 variable"
            {  0  "SCORE_TEMP in any subroutine where this macro is used.  This macro"
            {  0  "is only used in the analysis of dose and no. of steps."
            {  0  " IK: various compilers fail to compile the original version of this macro"
            {  0  "     (using the intrinsic max) because the arguments are sometimes of "
            {  0  "     different type"
            {  0
            {  0  SCORE_TEMP={P1}{P2}/{P3};
            {  0  {P1}2{P2}={P1}2{P2}/{P3};
            {  0  {P1}2{P2}=({P1}2{P2}-SCORE_TEMP*SCORE_TEMP)/({P3}-1);
            {  0  IF({P1}2{P2}>=0.) {P1}2{P2}= SQRT({P1}2{P2});
            {  0  IF(SCORE_TEMP~=0.)[
            {  0  {P1}2{P2} = {P1}2{P2}/SCORE_TEMP*100.;
            {  0  IF( {P1}2{P2} > 99.9 ) [ {P1}2{P2} = 99.9; ]
            {  0  "{P1}2{P2}= MIN({P1}2{P2}/SCORE_TEMP*100.,99.9);"
            {  0  ]
            {  0  ELSE[
            {  0  {P1}2{P2}=99.9;
            {  0  ]
            {  0  ;
            {  0  }
               0
1              0  %E     "dosrznrc.mortran"
               0  "                       COMMON BLOCK DEFINITIONS
               0  "                       ************************
               0
               0  $IMPLICIT-NONE;
               0
               0  " Declarations for implicit none added by IK, Jan 5 2000"
               0
               0  $LONG_INT ITEMP,NOSCAT,INOMSD;
               0  $INTEGER itmax,IORSTRT,i,ix,iz,it,ib,NBATCH,irl,izd,ixd,j,MEDNUM,
               0  LGLE,ISUMX,jj,IBATCH,IBTCH,ICASE,ipk,ICUM,
               0  IDSMAX,NDATA,IERR,I1,I2,I3,NETADJ,ISTAT;
               0  $REAL    DEPTH,VOLUME,RLOW2,
               0  PATHL,DELTAP,COHFAC,EK0,TIMEB,TIMCPU,BATCHT,
               0  TDSMAX,TDOS,TDOS2,RATIO,ETIMETOT,
               0  TEMP1,TEMP2,FMASS,aux;
               0  $INTEGER IRIN,NRCFLG;
               0  $REAL    EI,XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
               0
               0  ;
               0  "CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
               0  REPLACE {;COMIN/CHARS/;} WITH
               0  "       ================
               0  {;
            {  0  $TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
            {  0  TCHAR,UCHAR,VCHAR;
            {  0  COMMON/CHARS/
            {  0  BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
            {  0  }
               0
               0  ;
               0  "GEOMETRICAL INFORMATION"
               0  REPLACE {;COMIN/GEOM/;} WITH
               0  "       ===============          "
               0  {;$TYPE CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);
            {  0  COMMON/GEOM/ZPLANE($MAXZPLANE),RCYL(0:$MAXRADII),
            {  0  CYRAD2($MAXRADII1),
            {  0  NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,
            {  0  NZDMIN,NZDMAX,NRDMIN,NRDMAX,
            {  0  NTRACK($MXREG),CDSTBL,CTRTBL,CABSRB,IDSTBL($MXREG,2);
            {  0  $REAL    ZPLANE,RCYL,CYRAD2;
            {  0  $INTEGER NZ,NR,NREG,NDOSE,NZDOSE,NRDOSE,NPLANE,NZDMIN,NZDMAX,NRDMIN,NRDMAX,
            {  0  NTRACK,IDSTBL;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "
               0  "CDSTBL(IRL)='D' IF IRL IS A DOSE SCORING REGION
               0  "CTRTBL(IRL)='T' IF IRL IS A RANGE REJECTION TRACKING REGION
               0  "CABSRB(IRL)='A' IF IRL IS A TOTALLY ABSORBING REGION
               0  "ZPLANE(IZ) CONTAINS THE REAL VALUED COORDINATE OF THE IZ'TH PLANE
               0  "RCYL(IX) CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH CYL.
               0  "CYRAD2(IX)=RCYL(IX)**2
               0  "NZ/NR=NUMBER OF PLANAR SLABS/CYLINDRICAL REGIONS DEFINING THE TARGET
               0  "NREG=NZ*NR+1 (+1 FOR THE SURROUNDING VACUUM), NPLANE=NZ+1
               0  "NZDOSE/NRDOSE=NUMBER OF DOSE SCORING SLABS/CYLINDRICAL REGIONS
               0  "NDOSE=NZDOSE*NRDOSE, NUMBER OF DOSE SCORING REGIONS
               0  "NZ/NRDMIN/MAX, MIN/MAX PLANES/CYLINDERS DEFINING THE DOSE REGION
               0  "IDSTBL(IRL,1)=DOSE PLANAR SLAB NUMBER IF IRL IS IN DOSE REGION
               0  "IDSTBL(IRL,2)=DOSE CYLINDRICAL REGION NUMBER IF IRL IS IN DOSE REGION
               0  "NTRACK(IRL)=1 IF DOSE REGION ELSE =0
               0
               0  ;
               0  "FOUR COMMONS FOR INPUT AND OUTPUT"
               0  ;
               0  REPLACE {;COMIN/IODAT1/;} WITH
               0  "       =================
               0  {;
            {  0  CHARACTER*1 TITLE(80);  "This replaces an old LOGICAL*1 stmt"
            {  0  COMMON/IODAT1/TITLE;
            {  0  }
               0  "
               0  "TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
               0  "DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE
               0
               0  ;
               0  REPLACE {;COMIN/IODAT2/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/IODAT2/
            {  0  NCASE,NCASEO,NCASET,
            {  0  AMASS($MAXZREG,$MAXRADII),TMCPUO,TIMMAX,STATLM,EIN,EKMAX,
            {  0  IDAT,IRESTART,IQIN,NESTEP,NSMAX,IXXIN,JXXIN,IVAL,DATCOUNT;
            {  0  $REAL    AMASS,TMCPUO,TIMMAX,STATLM,EIN,EKMAX;
            {  0  $INTEGER IDAT,IRESTART,IQIN,NESTEP,NSMAX,
            {  0  IXXIN,JXXIN,IVAL,DATCOUNT;
            {  0  $LONG_INT NCASE,NCASEO,NCASET;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "
               0  "AMASS(IZ,IX)  mass of zone with coordinates (IZ,IX)
               0  "TMCPUO        CPU time used in previous sessions
               0  "TIMMAX        maximum allowed CPU hours for a given calculation
               0  "STATLM        target statistics in peak dose region used for an early EXIT
               0  "EIN           kinetic energy of the external beam
               0  "IDAT          = 0 store data arrays for re-use
               0  "              = 1 don't store them
               0  "NCASE         number of histories remaining to be done
               0  "NCASEO        number of histories done in previous sessions
               0  "NCASET        number of histories already done
               0  "IRESTART      = 0 => initial run
               0  "              = 1 => restarted run
               0  "              = 3 => data analysis only
               0  "              = 4 => read random number seeds
               0  "              = 5 => post-process distributed runs
               0  "IQIN          charge of the external beam
               0  "NESTEP        number of regions to alter estepe
               0  "NSMAX         number of regions to alter smax
               0  "IXXIN,JXXIN   input pointers for RNG
               0  "IVAL          counter used with get_inputs
               0  "DATCOUNT      no of parallel runs being recombined
               0
               0  ;
               0
               0  "printer controls"
               0  REPLACE {;COMIN/PRINTC/;} WITH {
            {  0  ;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
            {  0  $INTEGER       ICHPIN,ILPIN,IOUT,IPAGE;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "       =================
               0  "ICHPIN  NUMBER OF CHARACTERS PER INCH
               0  "ILPIN   NUMBER OF LINES PER INCH
               0  "IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
               0  "IPAGE   =1 => PAGE THROW
               0
               0  ;
               0  "common used for transmitting geometrical info from HOWFAR to AUSGAB
               0  REPLACE {;COMIN/NRCNEW/;} WITH {
            {  0  ;COMMON/NRCNEW/NEWNRC,DECISION;
            {  0  $INTEGER       NEWNRC,DECISION;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "       =================
               0  "NEWNRC = 0 if the particle is about to leave the geometry
               0  "NEWNRC = 10,20,30 or 40 depending on whether the particle in question is
               0  "         about to enter a new region via the front wall, outer wall, back
               0  "         wall or inner wall respectively
               0  "NEWNRC = 50 if the particle is in the source region and never left
               0  "DECISION = 1 if ustep = 0 and region number changes--this ensures that
               0  "           LATCH bit gets set to reflect NEWNRC before dose is deposited
               0
               0  ;
               0  "common used for scoring in AUSGAB
               0  REPLACE {;COMIN/SCORE/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/SCORE/
            {  0  SCDOSE($MAXZREG,$MAXRADII,$MAXIT),SCDOSE2($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCKERMA($MAXZREG,$MAXRADII,$MAXIT),SCKERMA2($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCDOSEtoKERMA2($MAXZREG,$MAXRADII,$MAXIT),SCPDST($EBIN),SCPDST2($EBIN),
            {  0  SCPCUM($EBIN),SCPCUM2($EBIN),SCPTOT,SCPTOT2,SCPHEN,SCPHEN2,
            {  0  SCDFBK(4),SCDFBK2(4),SCDFEP(4),SCDFEP2(4),SCDFDIFF(4),SCDFDIFF2(4),
            {  0  SCSTP,SCSTP2,SCDSTP,SCDSTP2, PIISTP,
            {  0  SCSTP_LAST, SCDSTP_LAST,SCDOSE_LAST($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCKERMA_LAST($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCKERMA_LASTOLD($MAXZREG,$MAXRADII,$MAXIT),SCPDST_LAST,
            {  0  IHSTRY,
            {  0  DFEN(4,4), PHENER,WT1OLD,BINTOP($EBIN),SLOTE,DELTAE,
            {  0  SCDOSE_TMP($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCKERMA_TMP($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCKERMA_TMPOLD($MAXZREG,$MAXRADII,$MAXIT),
            {  0  SCSTP_TMP,SCDSTP_TMP,
            {  0  MXNP,IFULL,ISTORE,IKERMA, IWATCH,IOOPTN,IOUTSP,
            {  0  IPHR($MXREG),MAXBIN,NCOMPT,during_pe_compt,during_eii,IDC;
            {  0  real*8 SCDOSE,SCDOSE2,SCKERMA,SCKERMA2,SCDOSEtoKERMA2,SCPDST,SCPDST2,
            {  0  SCPCUM,SCPCUM2,SCPTOT,SCPTOT2,SCPHEN,SCPHEN2,
            {  0  SCDFBK,SCDFBK2,SCDFEP,SCDFEP2,SCDFDIFF,SCDFDIFF2,
            {  0  SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
            {  0  $LONG_INT SCSTP_LAST, SCDSTP_LAST, SCDOSE_LAST, SCKERMA_LAST,
            {  0  SCKERMA_LASTOLD,SCPDST_LAST, IHSTRY;
            {  0  $REAL DFEN, PHENER,WT1OLD,BINTOP,SLOTE,DELTAE,
            {  0  SCDOSE_TMP,SCKERMA_TMP,SCKERMA_TMPOLD,SCSTP_TMP,SCDSTP_TMP;
            {  0  $INTEGER MXNP,IFULL,ISTORE,IKERMA,
            {  0  IWATCH,IOOPTN,IOUTSP,
            {  0  IPHR,MAXBIN,NCOMPT,during_pe_compt,during_eii;
            {  0  LOGICAL IDC;
            {  0  }
               0  "
               0  "SCDOSE(2)       accumulates energy deposited (energy deposited^2),
               0  "                eventually holds dose (uncertainty in dose)
               0  "SCKERMA(2)      accumulates energy of electrons created (energy of electrons
               0  "                created^2), eventually holds kerma (uncertainty in kerma)
               0  "SCDOSEtoKERMA2  accumulates (energy deposited)*(energy of electrons created)
               0  "                summed over all primary histories, eventually holds uncertainty
               0  "                in dose/kerma
               0  "SCPDST(2)       accumulates counts (counts^2) in each energy bin of pulse
               0  "                height sensitive region, eventually holds pulse height distn
               0  "                (uncertainty in pulse height distn)
               0  "SCPCUM(2)       accumulates sum of counts (counts^2) in all bins <= current bin
               0  "                in pulse height region, eventually holds cumulative pulse
               0  "                height distn (uncertainty in cumulative pulse height distn)
               0  "SCPTOT(2)       accumulates all counts (counts^2) in all bins in pulse height
               0  "                region, eventually holds total of all counts (uncertainty on
               0  "                total) and is used to normalize scpdst, scpcum and scdfep
               0  "SCPHEN(2)       accumulates total energy (energy^2) deposited in pulse height
               0  "                region, eventuall holds energy deposited in pulse height region
               0  "                (uncertainty on energy in pulse height region) per incident
               0  "                particle
               0  "SCDFBK(2)       accumulates background counts (counts^2) for each peak in pulse
               0  "                height distribution, will be subtracted from scdfep below
               0  "SCDFEP(2)       accumulates counts (counts^2) in each energy peak in pulse
               0  "                height distribution
               0  "SCDFDIFF(2)     accumulates difference (difference^2) between peak and
               0  "                background counts for each peak in pulse height distribution,
               0  "                gets used to determine covariance between scptot and
               0  "                (SCDFEP-SCDFBK) so we can calculate the uncertainty on the
               0  "                final value of SCDFEP
               0  "SCSTP(2)        accumulates total particle steps (particle steps^2) in phantom,
               0  "                eventually, scstp2 holds uncertainty on this number
               0  "SCDSTP(2)       accumulates total particle steps (particle steps^2) in dose
               0  "                region of phantom, eventually, scdstp2 holds uncertainty on
               0  "                this number
               0  "PIISTP          holds no. of presta-ii steps from previous runs
               0  "SCSTP_LAST      last primary history to score a particle step in phantom
               0  "SCDSTP_LAST     last primary history to score a step in the dose region of the
               0  "                phantom
               0  "SCDOSE_LAST     last primary history to deposit energy in each dose region of
               0  "                the phantom
               0  "SCKERMA_LAST    last primary history to deposit kerma in each region of
               0  "                phantom
               0  "SCKERMA_LASTOLD second last primary history to deposit kerma in each region
               0  "                of phantom.  used to calculate scdose*sckerma for covariance
               0  "                in uncertainty on dose/kerma
               0  "SCPDST_LAST     last primary history to score energy in pulse height region
               0  "SCDOSE_TMP      accumulates energy deposited in each region by current primary
               0  "                history
               0  "SCKERMA_TMP     accumulates energy of electrons created in each region by
               0  "                current primary history
               0  "SCKERMA_TMPOLD  energy of electrons created in each region by last primary
               0  "                history.  used to calculate scdose*sckerma for covariance
               0  "                in uncertainty on dose/kerma
               0  "SCSTP_TMP    accumulates charged particle steps in current primary history
               0  "SCDSTP_TMP   accumulates charged particle steps in dose region in current
               0  "             primary history
               0  "DFEN         energy limits for four peak area and backgrounds
               0  "MXNP         maximum level to which the stack of daughter particles from an
               0  "             incident particle rises (stack may include incident particle)
               0  "IFULL        = 0 just calculate total dose and that due to stoppers
               0  "                 and discards (the default)
               0  "             = 1 above analyse where the dose is coming from
               0  "             = 2 IFULL = 0 scoring plus pulse height distributions
               0  "             = 3 score the scatter fraction instead of stoppers
               0  "ISTORE       = 0 do not store the initial random numbers (the default)
               0  "             = 1 store the initial random number for last history
               0  "             = 2 store initial random numbers for all histories
               0  "IKERMA       = 0 do not score kerma
               0  "             = 1 score kerma
               0  "IWATCH       = 0 for normal output (the default)
               0  "             = 1 output on every discrete interaction
               0  "             = 2 output on every electron/photon step as well
               0  "             = 3 prints out only when energy is deposited
               0  "             = 4 prints out file for graphics
               0  "IHSTRY       counter for total number of histories successfully simulated
               0  "IOOPTN       = 0 short output (the default) -just dose grid(dg)
               0  "             = 1 output dose summary only (ds)
               0  "             = 2 output material summary grid(mg) + dg
               0  "             = 3 output mg + ds
               0  "             = 4 output mg + ds + dg
               0  "IOUTSP       = 0 no energy input spectrum data in output summary
               0  "             = 1 include energy inout spectrum data in output summary
               0  "PHENER       energy deposited in sensitive volume for current history only
               0  "WT1OLD       stores value of WT(1) from last history for scoring phd
               0  "IPHR         flag array for each region, non-zero only if pulse height
               0  "             distribution wanted in this geometric region
               0  "BINTOP       tops of energy bins for pulse height distribution
               0  "MAXBIN       number of energy bins for pulse height distribution
               0  "SLOTE        >0, width of pulse height distribution energy bins
               0  "             else flag to use bintop
               0  "DELTAE       width of energy bins used for peak efficiencies
               0
               0
               0  ;
               0
               0  "COMMONS used for non-monoenergetic beam data                             "
               0  "       NOTE MONOEN is passed in user                                     "
               0  "                                                                         "
               0  REPLACE {$NENSRC} WITH {300}     "max # of points in energy distribution  "
               0  "        =======                                                          "
               0  REPLACE {$INVDIM} WITH {1000}    "dimension controls grid size for inverse"
               0  "        =======                                                          "
               0  ;
               0  REPLACE {;COMIN/SPECTR/;} WITH
               0  "       ================="
               0  {;
            {  0  COMMON/SPECTR/
            {  0  CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
            {  0  NENSRC;
            {  0  $INTEGER NENSRC;
            {  0  $REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
               0  "SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION
               0
               0  ;
               0  "common used for russian roulette
               0  REPLACE {;COMIN/RUSROU/;} WITH
               0  "       =================
               0  {;
            {  0  LOGICAL RUSROU;
            {  0  COMMON/RUSROU/RRZ,RRCUT,RUSROU;
            {  0  $REAL         RRZ,RRCUT;
            {  0  }
               0  "
               0  "RRZ      COORDINATE OF PLANE AT WHICH RUSSIAN ROULETTE IS PLAYED
               0  "RRCUT    SURVIVAL PROBABILITY AFTER CROSSING THE PLANE
               0  "RUSROU   = .FALSE. => RUSSIAN ROULETTE WILL NOT BE PLAYED
               0  "         = .TRUE.  => RUSSIAN ROULETTE WILL BE PLAYED
               0
               0  ;
               0  "common used for plotting routine
               0  REPLACE {;COMIN/PLOTC/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/PLOTC/
            {  0  IPLOTR($MAXRADII),IPLOTZ($MAXZREG),IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
            {  0  $INTEGER IPLOTR,IPLOTZ,IOPLOT,IPLTLP,IPLTPL,IPLPHB,NPLOTR,NPLOTZ;
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0  }
               0  "IPLOTR(IX) = 0 NO PLOTS FOR CYLINDRICAL DOSE REGION IX
               0  "           = 1 PLOTS FOR CYLINDRICAL DOSE REGION IX
               0  "IPLOTZ(IX) = 0 NO PLOTS FOR PLANAR DOSE SLAB IZ
               0  "           = 1 PLOTS FOR PLANAR DOSE SLAB IZ
               0  "IOPLOT     = 0  NO PLOTS OR PLOT FILES TO BE PREPARED
               0  "           = 1  PLOTTING TO BE PREPARED OR PRINTED
               0  "IPLTLP     = 0  DON'T PLOT IN EXECUTION OUTPUT
               0  "           = 1  DO PLOT IN EXECUTION OUTPUT
               0  "IPLTPL     = 0  DON'T PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
               0  "           = 1  PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
               0  "IPLPHB     = 1  POINT PLOT ON EXTERNAL PLOTTER
               0  "           = 2  HISTOGRAM ON EXTERNAL PLOTTER
               0  "           = 3  BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
               0  "NPLOTR     NUMBER OF RADIAL PLOTS
               0  "NPLOTZ     NUMBER OF Z-AXIS PLOTS
               0
               0  ;
               0  REPLACE {;COMIN/USER/;} WITH
               0  "       =============="
               0  {;
            {  0  COMMON/USERRR/ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN, MINZ,MAXZ,MINR,MAXR,IREJCT;
            {  0  $REAL    ZMINR,ZMAXR,RMINR,RMAXR,ESAVEIN;
            {  0  $INTEGER MINZ,MAXZ,MINR,MAXR,IREJCT;
            {  0  "                                                                            "
            {  0  "common used for range rejection                                             "
            {  0  "Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
            {  0  "              FOR RANGE REJECTION                                           "
            {  0  "ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
            {  0  "MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
            {  0  "FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
            {  0  ;
            {  0  COMMON/USERMI/EXPMFP,GWTOLD,ICSDA;
            {  0  $INTEGER ICSDA;
            {  0  $REAL    EXPMFP,GWTOLD;
            {  0  "                                                                       "
            {  0  "COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR DOSRZnrc                 "
            {  0  "EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING       "
            {  0  "GWTOLD   OLD WEIGHT                                                    "
            {  0  "ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
            {  0  ;
            {  0
            {  0  ;COMMON/USERVR/
            {  0  CEXPTR,GWAIT,IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN,
            {  0  cs_enhance,cs_enhance_current,ienhance,iefl($MXREG),ics_enhance,
            {  0  do_fast_step;
            {  0  $INTEGER ienhance,iefl,ics_enhance,
            {  0  IFORCE,NFMIN,NFMAX,NFTIME,ISOURC,IFPB,IQINC,MONOEN;
            {  0  $REAL    CEXPTR,GWAIT,cs_enhance,cs_enhance_current;
            {  0  $LOGICAL do_fast_step;
            {  0
            {  0  "COMIN/USER-VARIANCE-REDUCTION"
            {  0  "       CEXPTR       C VARIABLE FOR EXPONENTIAL PATHLENGTH TRANSFORMATION"
            {  0  "       GWAIT        WEIGHT ADJUSTMENT IN FORCING INTERACTIONS MACRO     "
            {  0  "       IFORCE       ONLY FORCE PHOTON INTERACTIONS IF THIS IS NON-ZERO  "
            {  0  "       NFMIN,NFMAX,NFTIME  FOR FORCE PHOTON INTERACTIONS MACRO          "
            {  0  "       IFPB         FLAGS IF ISOURC = 0,2 OR 4                          "
            {  0  "       IQINC        INCIDENT CHARGE                                     "
            {  0  "       MONOEN = 0 IF MONOENERGETIC BEAM, = ELSE IF SOURCE DIST'N INPUT  "
            {  0  "       ics_enhance  flag to indicate if both some regions are asked     "
            {  0  "                    and the enhancement factor is > 1.001               "
            {  0  "       cs_enhance   cross section enhancement factor as input by user   "
            {  0  "       ienhance     flag indicating whether an interaction in enhanced  "
            {  0  "                    region occurred                                     "
            {  0  "       iefl(ir)     flag indicating whether in a specific region        "
            {  0  "                    enhancing should occur, set to 1 if yes 0 if no     "
            {  0  "       do_fast_step If iforce is set to 1 and the source is a front     "
            {  0  "                    parallel beam, the photon forcing macro uses        "
            {  0  "                    pre-calculated path-lengths and mfp's to sample the "
            {  0  "                    photon interaction distance for the first forced    "
            {  0  "                    photon. This is a bug if the incident particle is   "
            {  0  "                    an electron! To avoid this problem, do_fast_step    "
            {  0  "                    is set to .false. in this case. IK, April 2000      "
            {  0
            {  0  "Added type declaration, IK, Jan 5 2000"
            {  0
            {  0  }
               0
               0  "THIS MACRO ALLOW THE USER TO SWITCH ON CSDA CALCULATIONS.             "
               0  "THE MEAN FREE PATH IS SET TO INFINITY AND THE PROPER CSDA STOPPING    "
               0  "POWERS SHOULD BE USED HAVING BEEN CREATED BY PEGS4 VIA IUNRST = N.    "
               0  ;
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {;
            {  0  IF(ICSDA.EQ.0)[
            {  0  ;$RANDOMSET RNNE1;IF(RNNE1.EQ.0.0)[RNNE1=1.E-30;]
            {  0  DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);
            {  0  ]
            {  0  ELSE[ DEMFP=VACDST; ]
            {  0  ;}
               0
               0  ;
               0
               0  "END OF MACRO DEFINITIONS
               0
               0  "                       DATA DECLARATIONS
               0  "                       *****************
               0  "
               0  REPLACE {$NMAX} WITH {100}  "max number of inputs"
               0  REPLACE {$NVALUE} WITH {100}  "max number of values per input"
               0
               0  INTEGER MAKE_IT_AN_INT,JTEMP;
               0  CHARACTER*80 TEXT;
               0  $LONG_INT JCASE;
               0
               0  $DECLARE_TIMING_VARIABLES;
               0
               0  $REAL
               0  GWATE($MAXRADII); "PHOTON INTERACTION FORCING WEIGHTING FACTORS FOR
               0  "NORMALLY INCIDENT PARALLEL BEAMS
               0
               0  $REAL SCORE_NORM_NUM,
               0  SCORE_TEMP;    "variables for uncertainty analysis + normalization"
               0
               0  REAL*8 SCORE_TEMP2;
               0
               0
               0  ;COMIN/
               0  BOUNDS,CHARS,EDGE,ELECIN,EPCONT,GEOM,IODAT1,IODAT2,
               0  MEDIA,MISC,NRCNEW,PHOTIN,PLOTC,PRINTC,RUSROU,SCORE,SOURCE,SPECTR,
               0  STACK,THRESH,UPHIOT,USEFUL,USER,RANDOM,GetInput,BREMPR,EGS-VARIANCE-REDUCTION,
               0  RWPHSP,CH-Steps,EGS-IO/;
               0
               0  external combine_results;
               0
               0  " I/O stuff "
               0  $INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;
               0
               0  "IK: New parallel processing implementation. Only used if there is a
               0  "    working C compiler.
               0
               0  $HAVE_C_COMPILER(#);
               0
               0  #ifdef HAVE_C_COMPILER;
               0  $REAL   part_dose, part2_dose, current_result, current_uncertainty;
               0  $LONG_INT n_run,n_tot,n_last;
               0  $INTEGER  n_job;
               0  $LOGICAL first_time;
               0  #endif;
               0
               0  $LOGICAL is_finished;
               0
               0  "                       START OF EXECUTABLE CODE
               0  "                       ************************
               0
               0  call egs_init;
               0
               0  "following from egsnrc_git/dosrznrc_DR_IDCtrue.mortran - added Oct 2018"
               0  "IDC is a hack to allow compilation with or without counting kerma from"
               0  "         photons from radiative events   I Double Count"
               0  "         passed in comin score so it can be printed in isumry"
               0  "         only active in ausgab
               0
               0  IDC = .true.;    "false means there is no double counting (bit 8 set)"
               0  "true means there is double counting of e-+ set in motion by"
               0  "photons created by e-+ already counted in kerma "
               0  "(i.e. bit 8 not set)"
               0
               0
               0
               0  ;
               0  "INITIALIZE THE CHARACTER ARRAY"
               0  BLANK=' ';     ASTER='*';     ACHAR='A';     BCHAR='B';
               0  CCHAR='C';     DCHAR='D';     ICHAR='I';     MCHAR='M';
               0  RCHAR='R';     SCHAR='S';     TCHAR='T';     UCHAR='U';     VCHAR='V';
               0
               0  $SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"
               0
               0  OUTPUT ' '; (//1x,79('*')/ / 9X,a,$);
               0  call egs_fdate(6);
               0  OUTPUT; (//1x,79('*')/);
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " CALL DATE(DATEN);CALL TIME(TIMEN);
               0  " OUTPUT DATEN,TIMEN; (//1x,79('*')/ / 10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT/
               0  "     / ' ',79('*')/);
               0
               0  OUTPUT  $MAXZREG,$MAXRADII; (
               0  ' *',T34,'************',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'* DOSRZnrc *',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'************',T80,'*'//
               0  '   Developed by National Research Council of Canada',/
               0  '   '$VERSION' on '$MACHINE/
               0  / ' Number of planar regions      = ',I3/
               0  ' Number of cylindrical regions = ',I3 /);
               0
               0  JTEMP = 2*$EBIN;
               0  IF (JTEMP > $MXDATA) [ "the user has a huge number of bins in their"
               1      "spectrum and needs to enlarge stats array to"
               1      "handle it
               1      OUTPUT $EBIN;(///' *********************************************'/
               1      ' You have used such a large value of EBIN(=',I6,' ) that you must use'/
               1      ' the alternative form of the REPLACE {$MXDATA} macro near the top of'/
               1      ' dosrznrc.mortran and then recompile',
               1      ///' *********************************************'///);
               1      STOP;
               1      ]
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 1 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"
               0
               0  CALL INPUTS;
               0  IF (ERROR_FLAG=1) [
               1      GOTO :END:;
               1      ]
               0
               0  " Open a file to read/write random numbers, if necessary "
               0  " IK: use explicit file names instead of fort.* "
               0  IF( istore > 0 ) [ "We want to store the rng state in a file"
               1      rng_unit = egs_open_file(2,0,1,'.egsrns');
               1      ]
               0  ELSE IF( irestart = 4 ) [ "We well read RN's from a file"
               1      rng_unit = egs_open_datfile(2,0,1,'.egsrns');
               1      ]
               0
               0  " This is copied directly from below.  Don't know why it needs "
               0  " repeating, but it does.  -- JT "
               0  IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
               0  ELSE[ITMAX=$MAXIT;]
               0
               0  " THE IRESTART=5 case, post-processing for distributed runs, goes here
               0  " ADDED BY JT, NOV.98
               0  IF(IRESTART.EQ.5)[
               1
               1      "IK: the egs_combine_runs subroutine checks for files named "
               1      "    output_file_wiii.egsdat (iii=1,99) in the user code directory "
               1      "    For each file found, it calls the subroutine combine_results "
               1      "    with the name of the file as argument. The combine_results
               1      "    subroutine is essentially a cut-and-paste of what used to be "
               1      "    in this block, short of the creation of a script that checks "
               1      "    for existing .egsdat files. The egs_combine_runs subroutine "
               1      "    is now part of EGSnrc and can be found in egs_utilities.mortran "
               1      "    The reason for this change is cross-platform portability "
               1      "    (the script is obviously not going to work under Windows) "
               1
               1      call egs_combine_runs(combine_results,'.egsdat');
               1
               1      NBATCH=0; "DON'T WANT IT TO RUN ANY HISTORIES"
               1      NCASET=NCASEO;
               1      ] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
               0  ELSE [
               1      IF(NCASE/$NBATCH=0)[NCASE=$NBATCH;]
               1      JCASE=NCASE/$NBATCH; NCASE=JCASE*$NBATCH;"number of histories per batch"
               1      ]
               0
               0  DECISION=0; "this is for howfar and ausgab when IFULL=1"
               0  MXNP=0; "reset the maximum stack indicator"
               0  IHSTRY=NCASEO; "reset the number of histories counter"
               0
               0  NHSTRY=0; "start the no. of primary histories counter at zero"
               0
               0  "SET UP THE BROAD PARALLEL BEAM DEFAULTS"
               0  IF (ISOURC.EQ.2)[
               1      NR=1;RCYL(1)=1000.;NREG=NZ+1;CYRAD2(1)=RCYL(1)**2;
               1      ]
               0
               0  NDOSE=NZDOSE*NRDOSE;     "NUMBER OF DOSE SCORING REGIONS"
               0
               0  IF(IFULL.EQ.1)[ITMAX=$MAXIT;]ELSE[ITMAX=2;] "# OF DOSE COMPONENTS"
               0
               0  IF(IREJCT = 1)[
               1      "GET COORDINATES USED BY HOWFAR FOR RANGE REJECTION"
               1      ZMINR=ZPLANE(MINZ);                              "lesser plane position"
               1      ZMAXR=ZPLANE(MAXZ);                              "greater plane position"
               1      IF(MINR.EQ.0)[RMINR=0.0;]ELSE[RMINR=RCYL(MINR);] "inner cylinder radius"
               1      RMAXR=RCYL(MAXR);                                "outer cylinder radius"
               1      ]
               0
               0  ;
               0  "Set up tables corresponding to dose and range rejection tracking regions"
               0  "for geometrical region number 'IRL' a dose scoring region then IDSTBL(IRL,1)"
               0  "assigned dose coordinate IZD and IDSTBL(IRL,2) assigned dose coordinate IXD"
               0  "and CDSTBL(IRL) assigned 'D'. If region IRL within tracking region for"
               0  "range rejection then CTRTBL(IRL) assigned 'T'"
               0  "Also set up table NTRACK with entry of 1 for dose scoring zone else 0. This"
               0  "is redundant in view of CDSTBL and is only used in macro 'COUNT-NOSCAT-IN"
               0  "-CAVITY' but is less dangerous than introducing a new array to EGS"
               0  CTRTBL(1)=BLANK;
               0  CDSTBL(1)=BLANK;
               0  DO IZ=1,NZ[
               1      DO IX=1,NR[
               2          $GET-IRL(IZ,IX); "DERIVE CORRESPONDING DOSE ZONE NUMBERS"
               2          IZD=IZ+1-NZDMIN;IXD=IX-NRDMIN;
               2          IF(
               2          (IZD.LE.0).OR.
               2          (IZD.GT.NZDOSE).OR.
               2          (IXD.LE.0).OR.
               2          (IXD.GT.NRDOSE))[
               3              CDSTBL(IRL)=BLANK;
               3              IDSTBL(IRL,1)=0;
               3              IDSTBL(IRL,2)=0;
               3              NTRACK(IRL)=0;
               3              ]
               2          ELSE[
               3              CDSTBL(IRL)=DCHAR;
               3              IDSTBL(IRL,1)=IZD;
               3              IDSTBL(IRL,2)=IXD;
               3              NTRACK(IRL)=1;
               3              ]
               2          IF(
               2          (IZ.LT.MINZ).OR.
               2          (IZ.GE.MAXZ).OR.
               2          (IX.LE.MINR).OR.
               2          (IX.GT.MAXR)
               2          )[
               3              CTRTBL(IRL)=BLANK;
               3              ]
               2          ELSE[
               3              CTRTBL(IRL)=TCHAR;
               3              ]
               2          ]
               1      ]
               0
               0  ;
               0  "SET UP AUSGAB CALLS"
               0  DO J=1,5[IAUSFL(J)=1;]DO J=6,$MXAUS[IAUSFL(J)=0;] "NORMAL EXECUTION"
               0
               0  IF(IFULL = 1 | IFULL = 3 | IKERMA = 1) [
               1      "need to call ausgab to set flag after photon interactions"
               1      "IKERMA=1 means scoring KERMA"
               1      "for KERMA, rayleigh scatter has no effect"
               1      iausfl(6) = 1; "after each step"
               1      iausfl(10) = 1; "after Moller (to count radiative losses due to EII)"
               1      iausfl(17) = 1; "after pair"
               1      iausfl(18) = 1; "before compt"
               1      iausfl(19) = 1; "after compt"
               1      iausfl(20) = 1; "before photo"
               1      iausfl(21) = 1; "after photo"
               1      iausfl(25) = 1; "after Rayleigh"
               1      iausfl(32) = 1; "before eii"
               1      iausfl(33) = 1; "after eii"
               1      iausfl(34) = 1; "after sub-threshold fluorescent photon discarded"
               1      iausfl(35) = 1; "after sub-threshold Auger"
               1      ]
               0
               0  IF(IFULL = 4) [
               1      iausfl(8)  = 1; "After bremsstrahlung"
               1      "iausfl(14) = 1;" "A positron has annihilated in-flight"
               1      "iausfl(15) = 1;" "A positron has annihilated at rest"
               1      ]
               0
               0  IF(cs_enhance > 1.0001) [
               1      write(6,*) 'flagged all photon intereaction types';
               1      iausfl(16) = 1; "Before pair"
               1      iausfl(18) = 1; "Before Compton"
               1      iausfl(19) = 1; "After Compton"
               1      iausfl(20) = 1; "Before photoelectric"
               1      iausfl(21) = 1; "After photoelectric"
               1      iausfl(24) = 1; "Before Rayleigh"
               1      iausfl(25) = 1; "After Rayleigh"
               1      iausfl(30) = 1; "Before Photonuclear"
               1      iausfl(31) = 1; "After Photonuclear"
               1      ]
               0  ELSE [ DO j=1,$MXREG [ iefl(j) = 0; ] ]
               0
               0
               0  "HATCH CALL PREPARATION AND EXECUTION"
               0  "-------------------------------------
               0
               0  DUNIT=1; "SET LENGTH UNITS TO cm"
               0
               0  OUTPUT; (/' CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was: CALL TIME(TIMEN); " "GET THE TIME OF DAY"
               0  " OUTPUT TIMEN;(/' CALL TO HATCH AT  ',$TIMEN_FORMAT);
               0
               0  CALL HATCH; "INPUT THE PEGS GENERATED DATA"
               0
               0  OUTPUT; (/' HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was: CALL TIME(TIMEN);OUTPUT TIMEN;(/' HATCH COMPLETED AT ',$TIMEN_FORMAT);
               0
               0  IF(MONOEN.EQ.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.23) [
               1      "MONOENERGETIC INPUT BEAM"
               1      IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
               1      EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
               1      ]
               0  ELSEIF (MONOEN.EQ.1) [ "ENERGY SPECTRUM"
               1      CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
               1      EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
               1      ]
               0  ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22) ["FULL PHASE-SPACE INFORMATION PROVIDED"
               1      EKMAX=EKSRCM; "MAXIMUM KINETIC ENERGY IN THE FILE"
               1      ]
               0
               0  "CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
               0  DO I=1,NMED[
               1      IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
               2          OUTPUT I,EKMAX,UP(I),UE(I);
               2          (//1X,50('*')//
               2          ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MeV'/
               2          ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MeV'/
               2          '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
               2          1X,50('*')//);
               2          GOTO :END-OF-RUN:;
               2          ]
               1      ] "END OF LOOP OVER MEDIA"
               0
               0  "CALCULATE THE MASS OF EACH ZONE (AREAL MASS FOR ISOURC=2 OR 4)
               0  DO IZ=1,NZ[
               1      DEPTH=ZPLANE(IZ+1)-ZPLANE(IZ);
               1      DO IX=1,NR[
               2          $GET-IRL(IZ,IX);
               2          MEDNUM=MED(IRL);
               2          IF(MEDNUM.NE.0)[
               3              IF((ISOURC.EQ.2).OR.(ISOURC.EQ.4))[VOLUME=DEPTH;]
               3              ELSE[
               4                  IF(IX.EQ.1)[RLOW2=0.0;]
               4                  ELSE[RLOW2=CYRAD2(IX-1);]
               4                  VOLUME=PI*DEPTH*(CYRAD2(IX)-RLOW2);
               4                  ]
               3              AMASS(IZ,IX)=RHOR(IRL)*VOLUME;
               3              ]
               2          ELSE[AMASS(IZ,IX)=0.0;]
               2          ]"END OF IX LOOP"
               1      ]"END OF IZ LOOP"
               0
               0  "CALCULATE ONE-TIME-ONLY CONSTANTS FOR SOURCE"
               0  CALL SRCOTO(WEIGHT);
               0  IF((IFPB.EQ.0).AND.(IFORCE.NE.0).AND.(IQIN.EQ.0).AND.(MONOEN.EQ.0))[
               1      OUTPUT;
               1      (/' ********* Initializing front parallel beam for photons *******'/);
               1      $SELECT-MEAN-FREE-PATHS-FOR-FRONTAL-PARALLEL-BEAM;
               1      do_fast_step = .true.;
               1      ]
               0  ELSE [ do_fast_step = .false.; ]
               0
               0  EK0=EIN;
               0  "For source=21,22 we input EIN in SRCRZ"
               0
               0  CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"
               0
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 2 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
               0  "EACH HISTORY AND DO THE SIMULATION
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  "WRITE THE HEADER"
               0
               0  write(iout,100) ' '; call egs_fdate(iout); write(iout,*);
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " CALL DATE(DATEN);CALL TIME(TIMEN);WRITE(IOUT,100) TITLE,TIMEN,DATEN;
               0
               0  WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"
               0
               0  "PRINT EXECUTION MODE"
               0  IF(IRESTART .EQ.0)[WRITE(6,201);WRITE(IOUT,201);]
               0  ELSEIF(IRESTART .EQ.1)[
               1      WRITE(6,202) NCASE,NCASEO;
               1      write(6,'(21x,a,$)') 'New RNG state: ';
               1      $SHOW-RNG-STATE(6); write(6,*);
               1      WRITE(IOUT,202) NCASE,NCASEO;
               1      write(iout,'(21x,a,$)') 'New RNG state: ';
               1      $SHOW-RNG-STATE(iout); write(iout,*);
               1      ]
               0  ELSEIF(IRESTART .EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :END-SIM:;]
               0  ELSEIF(IRESTART.EQ.4)[ WRITE(6,206); WRITE(IOUT,206); ]
               0  ELSEIF(IRESTART.EQ.5)[WRITE(6,205);WRITE(IOUT,205);GO TO :END-SIM:;]
               0
               0  "INITIALIZE IWATCH ROUTINE"
               0  IF(IWATCH.NE.0) CALL WATCH(-99,IWATCH);
               0
               0  "SET CLOCK AT THE BEGINNING OF SIMULATIONS"
               0  $SET_ELAPSED_CPUTIME(CPUT1);
               0  $INITIALIZE_ELAPSED_TOTAL_TIME;
               0  ETIMETOT=0;
               0  TIMEB=0;
               0  NETADJ=0;
               0
               0  " IK: Open a file for data storage, if requested "
               0  "     The egs_open_file function opens a file named output_file.egsdat "
               0  "     in the temporary working directory. The unit 4 (first argument) is"
               0  "     tried first, but if it is already in use, it picks the first Fortran I/O"
               0  "     unit available. The other two integer arguments tell egs_open_file to "
               0  "     open the .egsdat file for formated sequential I/O (the zero) and to "
               0  "     exit with an error message if something goes wrong (the 1)."
               0  "     If the third argument is zero instead, egs_open_file will return with
               0  "     a negative error code and it is up to the user to deal with the error."
               0  "
               0  IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');
               0
               0  "IK: New parallel processing implementation. Only used if there is a
               0  "    working C compiler.
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  n_tot = ncaseo; first_time = .true.; is_finished = .false.;
               0  /part_dose,part2_dose/=0;
               0  "I'm not sure what is a good quantity to put into the job control file =>"
               0  "just use 0 for now"
               0
               0  :start_parallel_loop:;
               0
               0  IF( n_parallel > 0 ) [  "Job is part of a parallel run "
               1
               1      call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
               1      current_result, current_uncertainty);
               1      IF( n_run = 0 ) [
               2          write(6,'(//a,a//)') '****** No histories left in job control file',
               2          '       => end simulation';
               2          goto :END-SIM:;
               2          ]
               1      jcase = n_run/$NBATCH;
               1      IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
               1      IF( first_time ) [
               2          first_time = .false.; n_last = n_run;
               2          write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
               2          ]
               1      ELSE [
               2          write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
               2          write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
               2          '      current result including previous runs and other parallel jobs: ',
               2          current_result, ' +/- ',current_uncertainty,' %',
               2          '      will run another ',n_run,' histories';
               2          ]
               1      ]
               0  #endif;
               0
               0
               0  "OUTPUT BATCHES. EXECUTION STOPS IF THE DESIRED STATISTICAL ACCURACY IS"
               0  "OBTAINED OR THERE IS NOT ENOUGH TIME TO DO ANOTHER BATCH."
               0
               0  DO IBATCH=1,$NBATCH[
               1
               1      IBTCH=IBATCH;
               1      IF(IBATCH.EQ.1)[
               2          OUTPUT ' ';
               2          (/' BATCH #',2X,'time-elapsed',2X,'total cputime',2X,'ratio',2X,
               2          'time of day',2X,'peak region stats(%)'//
               2          ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',3X,a,$);
               2          call egs_time(6);
               2          " ********** IK: using wrapper for date and time routines.
               2          " Was:
               2          " CALL TIME(TIMEN);OUTPUT TIMEN;
               2          " (/' BATCH #',2X,'time-elapsed',2X,'total cputime',2X,'ratio',2X,
               2          " 'time of day',2X,'peak region stats(%)'//
               2          " ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',4X,$TIMEN_FORMAT,$);
               2
               2          "IK: it is annoing that for batch runs we don't see the progress"
               2          "    info in the log file until the job is finished. This is because"
               2          "    Fortran uses buffered I/O. The following flushes unit 6 so that"
               2          "    we can see the progress of the calculation. "
               2          $FLUSH_UNIT(6);
               2          ]
               1      ELSE[
               2          $SET_ELAPSED_TOTAL_TIME(TIMEB);
               2          ETIMETOT=ETIMETOT+TIMEB;
               2          $SET_ELAPSED_CPUTIME(CPUT2);
               2          TIMCPU=CPUT2-CPUT1;
               2          OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
               2          (' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,3X,' ',$);
               2          call egs_time(6);
               2          " ********** IK: using wrapper for date and time routines.
               2          " Was:
               2          " CALL TIME(TIMEN);
               2          " OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU,TIMEN;
               2          " (' ',3X,I2,5X,F8.1,7X,F8.1,2X,F8.2,4X,$TIMEN_FORMAT,$);
               2          "CHECK THERE IS TIME LEFT FOR ANOTHER BATCH"
               2
               2          "IK: it is annoing that for batch runs we don't see the progress"
               2          "    info in the log file until the job is finished. This is because"
               2          "    Fortran uses buffered I/O. The following flushes unit 6 so that"
               2          "    we can see the progress of the calculation. "
               2          $FLUSH_UNIT(6);
               2
               2          BATCHT=TIMCPU/dble(IBATCH-1);"TIME PER BATCH SO FAR"
               2          IF(TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)[
               3              "NOT ENOUGH TIME FOR ANOTHER BATCH"
               3              "PRINT MESSAGE AND EXIT SIMULATION LOOP"
               3              WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
               3              WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
               3              "ADJUST THE INCIDENT FLUENCE"
               3              "EMH: Must be at the end of all possible exits from the shower loop"
               3              "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
               3              GO TO :END-SIM:;
               3              ]
               2          ]
               1
               1      DO ICASE=1,JCASE[
               2
               2          IF( ISOURC ~= 23 ) IHSTRY=IHSTRY+1; "INCREMENT HISTORY COUNTER"
               2          " For source 23 ihstry is set in srchst "
               2
               2          NFTIME=0; "RESET THE PHOTON FORCED INTERACTION COUNTER"
               2
               2          IF(IRESTART=4) [
               3              $RETRIEVE RNG STATE FROM UNIT rng_unit;
               3              ]
               2
               2          "STORE INITIAL RANDOM #S FOR LAST HISTORY IF REQUESTED"
               2          IF(ISTORE.EQ.1)[
               3              $STORE RNG STATE ON UNIT rng_unit;
               3              ]
               2          ELSEIF(ISTORE.EQ.2)[
               3              "STORE THE INITIAL RANDOM NUMBER SEED"
               3              $PUT RNG STATE ON UNIT rng_unit;
               3              ]
               2
               2          "CALCULATE THE SOURCE DEPENDANT VALUES WHICH CHANGE FOR EACH
               2          "HISTORY THESE INCLUDE :
               2          "ENTRY POINT INTO TARGET,
               2          "INITIAL DIRECTION COSINES,
               2          "STATISTICAL WEIGHT,
               2          "ENTRY FLAG(NRCFLG)
               2          CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               2
               2          "CALCULATE THE INITIAL ENERGY IF A DISTRIBUTION IS TO BE USED"
               2          IF(MONOEN.NE.0.AND.ISOURC.NE.21.AND.ISOURC.NE.22.AND.ISOURC.NE.23)[
               3              "IF EQUAL TO 0, IT IS MONOENERGETIC"
               3              "IF ISOURC=21 FULL PHASE SPACE DATA IS USED"
               3              CALL ENSRCH(EIN);   "RETURNS K.E. FROM DISTRIBUTION"
               3              IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]  "TOTAL ENERGY"
               3              " THERE WAS A CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY
               3              "RANGE REQUIRED, THE LOCATION OF IT WILL EVENTUALLY BE IN
               3              "ESRCIN.MOR
               3              ]
               2          ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22.OR.ISOURC.EQ.23)[EI=EIN;]
               2
               2          IF((ISOURC=21 | ISOURC=22 | ISOURC=23) & IFULL=2 & WEIGHT<1.)[
               3              OUTPUT WEIGHT; (//' ****WARNING****'/
               3              ' A particle of weight ',F10.5,' from the phase space source is being used'/
               3              ' Pulse height distribution only makes sense if all particles have'/
               3              ' weight=1.  Will run simulation with IFULL= dose and stoppers'//);
               3              WRITE(1,'(//'' ****WARNING****''/
            '  3              '' A particle of weight '',F10.5,'' from the phase space source is being used''/
            '  3              '' Pulse height distribution only makes sense if all particles have''/
            '  3              '' weight=1.  Will run simulation with IFULL= dose and stoppers''//)');
               3              IFULL=0;
               3              ]
               2
               2          "Set photon weights if gamma interactions are to be forced in the
               2          "target in the frontal parallel beam case if monoenergetic
               2          IF( do_fast_step )[
               3              IX=(IRIN-2)/NZ+1;
               3              GWAIT=GWATE(IX);
               3              WEIGHT=GWAIT;
               3              ]
               2          "For an input energy spectrum, detailed forcing macro is used"
               2
               2          LATCHI=0;
               2
               2          "Set initial dose components"
               2          IF(IFULL.EQ.1)[
               3              NEWNRC=NRCFLG;
               3              LATCHI=IBSET(LATCHI,NRCFLG/10);
               3              ]
               2
               2          IF((IWATCH ~= 0) & (IWATCH ~= 4))[
               3              OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
               3              (/' INITIAL SHOWER VALUES',T36,':',
               3              I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
               3              ]
               2
               2          "all initial shower variables are set, call the SHOWER routine"
               2
               2          CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
               2
               2          "signal the end of a history if watch mode is set"
               2          IF(IWATCH > 0) CALL WATCH(-1,IWATCH);
               2
               2          ] "END OF THE ICASE LOOP"
               1
               1      "Succesful completion of a batch. Delete the raw data from the last batch"
               1      "and record the new batch only if requested"
               1      IF(IDAT.EQ.0)[
               2          "add unscored portions of _TMP arrays before writing"
               2          SCSTP=SCSTP+SCSTP_TMP;
               2          SCSTP2=SCSTP2+SCSTP_TMP*SCSTP_TMP;
               2          SCSTP_TMP=0;
               2          SCDSTP=SCDSTP+SCDSTP_TMP;
               2          SCDSTP2=SCDSTP2+SCDSTP_TMP*SCDSTP_TMP;
               2          SCDSTP_TMP=0;
               2          DO IZ=1,NZDOSE[
               3              DO IX=1,NRDOSE[
               4                  DO IT=1,ITMAX[
               5                      SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
               5                      SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
               5                      SCDOSE_TMP(IZ,IX,IT);
               5                      IF(IKERMA=1)[
               6                          SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT);
               6                          SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT)*
               6                          SCKERMA_TMP(IZ,IX,IT);
               6                          IF(SCDOSE_LAST(IZ,IX,IT)=SCKERMA_LAST(IZ,IX,IT))[
               7                              "same history being scored, include these in"
               7                              "uncertainty estimate"
               7                              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
               7                              SCDOSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT);
               7                              ]
               6                          SCKERMA_TMP(IZ,IX,IT)=0.;
               6                          ]
               5                      SCDOSE_TMP(IZ,IX,IT)=0.;
               5                      ]
               4                  ]
               3              ]
               2          "OPEN(UNIT=4,file='fort.4',STATUS='UNKNOWN');"
               2          "IK: the .egsdat file is opened before the shower loop."
               2          "    The only reason for opening and closing the I/O unit is to "
               2          "    overwrite data from previous batches, but we can do this "
               2          "    by rewinding the unit"
               2          rewind(data_unit);
               2          WRITE(data_unit,*)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP+count_pII_steps;
               2          WRITE(data_unit,*)
               2          (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               2          WRITE(data_unit,*)
               2          (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               2          IF(IKERMA=1)[
               3              WRITE(data_unit,*)
               3              (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               3              WRITE(data_unit,*)
               3              (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               3              WRITE(data_unit,*)
               3              (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               3              ]
               2          IF(IFULL=2)[
               3              IF(PHENER>0.)[
               4                  "FIND WHAT BIN WE ARE IN"
               4                  IF(SLOTE.GT.0.0)[
               5                      "EQUAL ENERGY BINS CASE"
               5                      IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
               5                      ]
               4                  ELSE[
               5                      IB = MAXBIN;
               5                      UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
               5                      ]
               4
               4                  "ACCUMULATE THE PULSE HEIGHT DISTRIBUTION"
               4                  SCPDST(IB)=SCPDST(IB)+WT1OLD;
               4                  SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
               4                  "add to cumulative distn"
               4                  DO ICUM=IB,MAXBIN[
               5                      SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
               5                      SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
               5                      ]
               4
               4                  IF(IWATCH.EQ.3)[
               5                      OUTPUT PHENER,IB,1;
               5                      (' PULSE HEIGHT ENERGY=',
               5                      F10.4,' MeV, IN BIN',I3,' WITH WEIGHT',1PE10.3);
               5                      ]
               4
               4                  "NOW SCORE PROBABILITIES FOR COUNTS IN PEAKS"
               4                  DO IPK=1,4[
               5                      "FOR EACH PEAK, F.E., ESCAPES AND 511"
               5                      IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
               6                          "IT IS IN THE PEAK"
               6                          SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
               6                          SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
               6                          SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
               6                          SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
               6                          IF(IWATCH.EQ.3)[
               7                              OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
               7                              ]
               6                          ]
               5                      ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
               6                          "IT IS IN THE BKGD"
               6                          SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
               6                          SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
               6                          SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
               6                          SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
               6                          ]
               5                      ]"END IPK LOOP"
               4                  PHENER=0;
               4                  ]
               3              WRITE(data_unit,*)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN);
               3              WRITE(data_unit,*)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN);
               3              WRITE(data_unit,*)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4);
               3              WRITE(data_unit,*)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4);
               3              WRITE(data_unit,*)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,4);
               3              ]
               2          ]"end of conditional data storage"
               1
               1      $SET_ELAPSED_CPUTIME(CPUT2);
               1      TIMCPU=CPUT2-CPUT1+TMCPUO;
               1      IF(IDAT.EQ.0)[
               2          $PUT RNG STATE ON UNIT data_unit;
               2          WRITE(data_unit,*) IHSTRY,TIMCPU,NNREAD;
               2          write(data_unit,*) SCOMEG,SCOMEG2;
               2          "IK: don't need to close, see ebove. CLOSE(UNIT=4);"
               2          ]
               1
               1      "Do statistical analysis on the peak dose region to see if we quit early"
               1      TDSMAX=0.0;
               1      DO IRL=2,NREG[
               2          IF(CDSTBL(IRL).EQ.DCHAR)[
               3              IZD=IDSTBL(IRL,1);IXD=IDSTBL(IRL,2);
               3              FMASS=AMASS(IZD+NZDMIN-1,IXD+NRDMIN);
               3              IF((SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS.GT.TDSMAX)[
               4                  TDSMAX=(SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1))/FMASS;
               4                  IDSMAX=IRL;
               4                  ]
               3              ]
               2          ]
               1      "Now do stats on the peak region"
               1      IF(TDSMAX.GT.0.0)[
               2          IZD=IDSTBL(IDSMAX,1);IXD=IDSTBL(IDSMAX,2);
               2          TDOS=SCDOSE(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1);
               2          TDOS2=SCDOSE2(IZD,IXD,1)+SCDOSE_TMP(IZD,IXD,1)*SCDOSE_TMP(IZD,IXD,1);
               2          "normalize by incident no. of primary histories--so far"
               2          IF(ISOURC=21|ISOURC=22)[
               3              SCORE_NORM_NUM=
               3              dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
               3              ]
               2          ELSE[
               3              SCORE_NORM_NUM=dble(IHSTRY);
               3              ]
               2          IF(SCORE_NORM_NUM>1.)[
               3              TDOS=TDOS/SCORE_NORM_NUM;
               3              TDOS2=TDOS2/SCORE_NORM_NUM;
               3              TDOS2=(TDOS2-TDOS*TDOS)/(SCORE_NORM_NUM-1);
               3              IF(TDOS2>=0.) TDOS2=SQRT(TDOS2);
               3              TDOS2=MIN(TDOS2/TDOS*100.,99.9);
               3
               3              IF( (TDOS2 <= STATLM) & (STATLM ~= 0.0) )[
               4                  "Reached objective - Print message and jump out of simulation loop"
               4                  WRITE(6,230)IDSMAX,TDOS2,IBTCH;WRITE(IOUT,230)IDSMAX,TDOS2,IBTCH;
               4                  "EMH: Must be at the end of all possible exits from the shower loop"
               4                  "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET); FIX NORM ON EARLY EXIT"
               4                  GO TO :END-SIM:;
               4                  ]
               3              ]
               2          ]
               1      OUTPUT TDOS2;(' ',9X,F6.3);
               1
               1      ] "END OF SIMULATIONS, ie IBATCH loop"
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]
               0
               0  #endif;
               0
               0  "PRINT INSUFFICIENT STATS WARNING"
               0  WRITE(IOUT,240) STATLM,TDOS2,IBTCH;WRITE(6,240) STATLM,TDOS2,IBTCH;
               0
               0  :END-SIM:;
               0
               0  write(6,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
               0  $SHOW-RNG-STATE(6); write(6,'(a)') '  *********';
               0  write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
               0  $SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';
               0
               0  $SET_ELAPSED_TOTAL_TIME(TIMEB);
               0  ETIMETOT=ETIMETOT+TIMEB;
               0  $SET_ELAPSED_CPUTIME(CPUT2);
               0  TIMCPU=CPUT2-CPUT1+TMCPUO;
               0  IF(TMCPUO.EQ.0)[RATIO=ETIMETOT/TIMCPU;]ELSE[RATIO=0.;] "ONLY FOR SINGLE RUN"
               0  IF(IRESTART=3)["just analyzing data--no elapsed time"
               1      WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
               1      WRITE(6,250)TMCPUO,TMCPUO/3600;
               1      WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      ]
               0  ELSEIF(IRESTART=5)["output time results for parallel runs"
               1      WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
               1      WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
               1      WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      ]
               0  ELSE[
               1      IF(RATIO.NE.0.0)["I.E. WE HAVE CORRECT ELAPSED TIME"
               2          WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          ]
               1      ELSE[
               2          WRITE(IOUT,270) TIMCPU,TIMCPU/3600.;
               2          WRITE(6,270) TIMCPU,TIMCPU/3600.;
               2          ]
               1      IF((IHSTRY.NE.0).AND.(TIMCPU.NE.0.0))["THIS SHOULD ALWAYS HAPPEN"
               2          WRITE(IOUT,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
               2          WRITE(6,280)TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
               2          ]
               1      ]
               0  ;
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 3 ***
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  "STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"
               0
               0  "------------------------------------------------------------------------------
               0
               0  :STATS-ANAL:;
               0
               0  IF(ISOURC=21|ISOURC=22)[
               1      SCORE_NORM_NUM=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/
               1      dble(NCASE_PHSP)*NINCSRC;
               1      ]
               0  ELSE[
               1      SCORE_NORM_NUM=dble(IHSTRY);
               1      ]
               0
               0  $ANALYZE(SCSTP, :SCORE_NORM_NUM);
               0  $ANALYZE(SCDSTP, :SCORE_NORM_NUM);
               0
               0  IF(IDAT=1)["add unscored portions to _TMP arrays"
               1      DO IT=1,ITMAX[
               2          DO IX=1,NRDOSE[
               3              DO IZ=1,NZDOSE[
               4                  SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT);
               4                  SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+SCDOSE_TMP(IZ,IX,IT)*
               4                  SCDOSE_TMP(IZ,IX,IT);
               4                  IF(IKERMA=1)[
               5                      SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+SCKERMA_TMP(IZ,IX,IT);
               5                      SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+
               5                      SCKERMA_TMP(IZ,IX,IT)*
               5                      SCKERMA_TMP(IZ,IX,IT);
               5                      IF(SCDOSE_LAST(IZ,IX,IT)=SCKERMA_LAST(IZ,IX,IT))[
               6                          SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
               6                          SCDOSE_TMP(IZ,IX,IT)*SCKERMA_TMP(IZ,IX,IT);
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      IF(IFULL=2)[
               2          IF(PHENER>0.)[
               3              "FIND WHAT BIN WE ARE IN"
               3              IF(SLOTE.GT.0.0)[
               4                  "EQUAL ENERGY BINS CASE"
               4                  IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
               4                  ]
               3              ELSE[
               4                  IB = MAXBIN;
               4                  UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
               4                  ]
               3
               3              "ACCUMULATE THE PULSE HEIGHT DISTRIBUTION"
               3              SCPDST(IB)=SCPDST(IB)+WT1OLD;
               3              SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
               3              "also add to cumulative distn"
               3              DO ICUM=IB,MAXBIN[
               4                  SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
               4                  SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
               4                  ]
               3
               3
               3              IF(IWATCH.EQ.3)[
               4                  OUTPUT PHENER,IB,1;
               4                  (' PULSE HEIGHT ENERGY=',
               4                  F10.4,' MeV, IN BIN',I3,' WITH WEIGHT',1PE10.3);
               4                  ]
               3              "NOW SCORE PROBABILITIES FOR COUNTS IN PEAKS"
               3              DO IPK=1,4[
               4                  "FOR EACH PEAK, F.E., ESCAPES AND 511"
               4                  IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
               5                      "IT IS IN THE PEAK"
               5                      SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
               5                      SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
               5                      SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
               5                      SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
               5                      IF(IWATCH.EQ.3)[
               6                          OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
               6                          ]
               5                      ]
               4                  ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
               5                      "IT IS IN THE BKGD"
               5                      SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
               5                      SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
               5                      SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
               5                      SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
               5                      ]
               4                  ]"END IPK LOOP"
               3              PHENER=0;
               3              ]
               2          ]
               1      ]
               0
               0  "FOR ISOURC=4 WE NEED THE DATA FOR CIRCLES, NOT RINGS, SO ADD IT UP"
               0  IF((ISOURC.EQ.4).AND.(NR.GT.1))[
               1      OUTPUT AINFLU,NCASET,SCORE_NORM_NUM;
               1      ('ISOURC 4 AINFLU,NCASET,SCORE_NORM_NUM:',1PE10.3,I12,1PE10.3);
               1      DO IT=1,ITMAX[
               2          DO IX=2,NRDOSE[
               3              DO IZ=1,NZDOSE[
               4                  SCDOSE(IZ,IX,IT)=
               4                  SCDOSE(IZ,IX,IT)+SCDOSE(IZ,IX-1,IT);
               4                  SCDOSE2(IZ,IX,IT)=
               4                  SCDOSE2(IZ,IX,IT)+SCDOSE2(IZ,IX-1,IT);
               4                  SCKERMA(IZ,IX,IT)=
               4                  SCKERMA(IZ,IX,IT)+SCKERMA(IZ,IX-1,IT);
               4                  SCKERMA2(IZ,IX,IT)=
               4                  SCKERMA2(IZ,IX,IT)+SCKERMA2(IZ,IX-1,IT);
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  "AT THIS POINT, SCDOSE CONTAINS THE ENERGY (IN MeV) DEPOSITED"
               0  "IN EACH MODE. TO GET THE AVERAGE ENERGY DEPOSITED IN THE       "
               0  "PULSE HEIGHT DETECTOR REGION, WE SUM THE IT=1 VALUES FOR ALL         "
               0  "REGIONS IN THE DETECTOR. (FOR IFULL=2 ONLY)                          "
               0  IF(IFULL.EQ.2)[
               1      DO IX = 1,NRDOSE[
               2          DO IZ=1,NZDOSE[
               3              $GET-IRL(IZ,IX);
               3              IF(IPHR(IRL).NE.0) [
               4                  "THIS REGION IS IN DETECTOR"
               4                  SCPHEN=SCPHEN+SCDOSE(IZ,IX,1);
               4                  SCPHEN2=SCPHEN2+SCDOSE2(IZ,IX,1);
               4                  ] "END TEST FOR INSIDE THE DETECTOR"
               3              ]
               2          ] "END LOOPS OVER REGIONS"
               1      ] "END OF IFULL = 2 BLOCK"
               0
               0  "STATISTICAL ANALYSES ON THE RAW DATA"
               0  IF(ISOURC = 4)[ OUTPUT AINFLU,NCASET,SCORE_NORM_NUM;
               1      ('ISOURC 4 before ANALYZE:AINFLU,NCASET,SCORE_NORM_NUM:',
               1      1PE10.3,I12,1PE10.3);
               1      ]
               0
               0  DO IT=1,ITMAX[
               1      DO IX=1,NRDOSE[
               2          DO IZ=1,NZDOSE[
               3              $ANALYZE(SCDOSE,(IZ,IX,IT):SCORE_NORM_NUM);
               3              IF(IKERMA=1)[
               4                  $ANALYZE(SCKERMA,(IZ,IX,IT):SCORE_NORM_NUM);
               4                  "now analyze the uncertainty on the dose/kerma ratio"
               4                  "first set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)"
               4                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
               4                  SCORE_NORM_NUM-
               4                  SCDOSE(IZ,IX,IT)*
               4                  SCKERMA(IZ,IX,IT)/
               4                  (SCORE_NORM_NUM**2);
               4                  "now set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)/"
               4                  "                                  (dose*kerma)"
               4                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
               4                  (SCDOSE(IZ,IX,IT)*SCKERMA(IZ,IX,IT)/
               4                  (SCORE_NORM_NUM**2));
               4                  "now set SCDOSEtoKERMA2(IZ,IX,IT)=cov(dose,kerma)/"
               4                  "                                 (dose*kerma)/(N-1)"
               4                  SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)/
               4                  (SCORE_NORM_NUM-1);
               4                  "now estimate the uncertainty on dose/fluence"
               4                  SCDOSEtoKERMA2(IZ,IX,IT)=(SCDOSE2(IZ,IX,IT)/100.)**2+
               4                  (SCKERMA2(IZ,IX,IT)/100.)**2-
               4                  2*SCDOSEtoKERMA2(IZ,IX,IT);
               4                  IF(SCDOSEtoKERMA2(IZ,IX,IT)>0.)[
               5                      SCDOSEtoKERMA2(IZ,IX,IT)=
               5                      100*SQRT(SCDOSEtoKERMA2(IZ,IX,IT));
               5                      ]
               4                  IF( SCDOSEtoKERMA2(IZ,IX,IT) > 99.9 ) [
               5                      SCDOSEtoKERMA2(IZ,IX,IT) = 99.9;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  $ANALYZE(SCOMEG, :dble(IHSTRY));
               0  SCOMEG = SCOMEG/dble(IHSTRY);"Corrected, IK May 4 1999"
               0
               0  OUTPUT SCOMEG,SCOMEG2;(/' OMEG =',1PE12.3,'(',0PF5.1,'%)'/);
               0
               0  "ANALYSIS OF THE PULSE HEIGHT DISTRIBUTIONS"
               0  IF(IFULL.EQ.2)[
               1
               1      DO IB=1,MAXBIN[
               2          SCPTOT=SCPTOT+SCPDST(IB);
               2          SCPTOT2=SCPTOT2+SCPDST2(IB);
               2          ]
               1
               1      $ANALYZE(SCPTOT, :SCORE_NORM_NUM);
               1      $ANALYZE(SCPHEN, :SCORE_NORM_NUM);
               1
               1      DO IPK=1,4[
               2          $ANALYZE(SCDFEP,(IPK):SCORE_NORM_NUM);
               2          $ANALYZE(SCDFBK,(IPK):SCORE_NORM_NUM);
               2
               2          "subtract background from peak"
               2          SCDFEP(IPK)=SCDFEP(IPK)-SCDFBK(IPK);
               2
               2          "estimate uncertainty on this subtracted value"
               2          SCDFEP2(IPK)=(SCDFEP2(IPK)*SCDFEP(IPK)/SCORE_NORM_NUM/100.)**2+
               2          (SCDFBK2(IPK)*SCDFBK(IPK)/SCORE_NORM_NUM/100.)**2+
               2          2/(SCORE_NORM_NUM**2)*(SCDFEP(IPK)*SCDFBK(IPK))/
               2          (SCORE_NORM_NUM-1);
               2          IF(SCDFEP2(IPK)>0.) [
               3              SCDFEP2(IPK)=SQRT(SCDFEP2(IPK))/(SCDFEP(IPK)/SCORE_NORM_NUM);
               3              ]
               2          IF( SCDFEP2(IPK) > 0.999 ) [ SCDFEP2(IPK) = 0.999; ]
               2
               2          SCDFEP(IPK)=SCDFEP(IPK)/SCPTOT;
               2
               2          "now estimate the uncertainty on this quotient"
               2          SCDFEP2(IPK)=SCDFEP2(IPK)**2+(SCPTOT2/100.)**2-
               2          2*(SCDFDIFF2(IPK)/SCORE_NORM_NUM - SCDFDIFF(IPK)*SCPTOT/
               2          (SCORE_NORM_NUM)**2)/
               2          (SCDFDIFF(IPK)*SCPTOT/(SCORE_NORM_NUM)**2)/(SCORE_NORM_NUM-1);
               2          IF(SCDFEP2(IPK)>0.)SCDFEP2(IPK)=100*SQRT(SCDFEP2(IPK));
               2          IF(SCDFEP2(IPK)>99.9) SCDFEP2(IPK)=99.9;
               2          ]
               1      DO IB=1,MAXBIN[
               2
               2          "save SCPDST2(IB) since it is also equal to SCPDST(IB)*SCPTOT summed"
               2          "over all primary histories and will be used later"
               2          SCORE_TEMP2=SCPDST2(IB);
               2          $ANALYZE(SCPDST,(IB):SCORE_NORM_NUM);
               2
               2          "now estimate the uncertainty on scpdst(IB)/scptot"
               2          SCPDST2(IB)=(SCPDST2(IB)/100.)**2+(SCPTOT2/100.)**2-
               2          2*(SCORE_TEMP2/SCORE_NORM_NUM-SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/
               2          (SCPDST(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1);
               2
               2          IF(SCPDST2(IB)>0.)SCPDST2(IB)=100*SQRT(SCPDST2(IB));
               2          IF(SCPDST2(IB)>99.9) SCPDST2(IB)=99.9;
               2
               2          SCPDST(IB)=SCPDST(IB)/SCPTOT;
               2
               2          "save SCPCUM2(IB) since it is also equal to SCPCUM(IB)*SCPTOT summed"
               2          "over all primary histories and will be used later"
               2          SCORE_TEMP2=SCPCUM2(IB);
               2          $ANALYZE(SCPCUM,(IB):SCORE_NORM_NUM);
               2
               2          "now estimate the uncertainty on this quotient"
               2          SCPCUM2(IB)=(SCPCUM2(IB)/100.)**2+(SCPTOT2/100.)**2-
               2          2*(SCORE_TEMP2/SCORE_NORM_NUM-SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/
               2          (SCPCUM(IB)*SCPTOT/(SCORE_NORM_NUM**2))/(SCORE_NORM_NUM-1);
               2
               2          IF(SCPCUM2(IB)>0.)SCPCUM2(IB)=100*SQRT(SCPCUM2(IB));
               2          IF(SCPCUM2(IB)>99.9) SCPCUM2(IB)=99.9;
               2
               2          SCPCUM(IB)=SCPCUM(IB)/SCPTOT;
               2          ]
               1
               1      SCPTOT=SCPTOT/SCORE_NORM_NUM; "NORMALIZE TOTAL TO PER HISTORY"
               1      SCPHEN=SCPHEN/SCORE_NORM_NUM; "NORMALIZE TO ENERGY PER HISTORY"
               1
               1      ] "END IFULL=2 BLOCK"
               0
               0  "CONVERT DOSE FROM MeV PER REGION PER BATCH TO GRAY PER UNIT INCIDENT FLUENCE"
               0  IF(ISOURC=21|ISOURC=22)[
               1      "normalize dose to number of incident particles from primary source
               1      AINFLU=dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC;
               1      "we estimate the total number of particles from the primary source (original"
               1      "non-phase space source) by taking the ratio of the total number of"
               1      "particles read from the phase source in this simulation to the total number"
               1      "of particles in the phase space source and multiply this by the number of"
               1      "particles from the primary source that were used to obtain this phase space"
               1      "source."
               1      ]
               0  ELSEIF(ISOURC=23)[
               1      "have to set AINFLU to no. of primary histories
               1      AINFLU=dble(IHSTRY);
               1      ]
               0  ELSE["EMH: adjust incident fluence to actual number of histories"
               1      AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);
               1      ]
               0
               0  "RECALL 1 MeV = 1.602E-06 erg, 1 rad=100 ergs/g, 1 rad=0.01 Gy"
               0  "THE UNIT OF DOSE IS Gy-cm**2"
               0  DO IT=1,ITMAX[
               1      DO IX=1,NRDOSE[
               2          DO IZ=1,NZDOSE[
               3              IF(SCDOSE(IZ,IX,IT).NE.0.0)[
               4                  FMASS=AMASS(IZ+NZDMIN-1,IX+NRDMIN);
               4                  IF(FMASS.EQ.0.0)FMASS=1.0; "AVOIDS /0 FOR VACUUM"
               4                  SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)*1.602E-10/(FMASS*AINFLU);
               4                  IF(SCKERMA(IZ,IX,IT) ~= 0) [
               5                      SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)*1.602E-10/(FMASS*AINFLU);
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  CALL OSUMRY; "PRINT THE OUTPUT SUMRY"
               0
               0  :END-OF-RUN:;
               0  ;
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 4 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "THE CONCLUSION"
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  :END:;
               0
               0  OUTPUT ' '; (/ ' End of run',9X,a,$);
               0  call egs_fdate(6);
               0  OUTPUT; (//1x,79('*')/1x,79('*')/);
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " CALL DATE(DATEN);CALL TIME(TIMEN);
               0  " OUTPUT DATEN,TIMEN; ( / ' End of run',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT/
               0  "     / ' ',79('*')/ ' ',79('*')/);
               0
               0  "Now print the error file at the end of run to draw users attention to it"
               0  "This reports the errors on the input and defaults used etc"
               0  IF (ERROR_FLAG=1) [
               1      OUTPUT ;(//' **********  ERRORS AND WARNING MESSAGES  ********** '//);
               1      ]
               0  rewind (i_errors);
               0  9998 CONTINUE;
               0  READ (i_errors, END=9999, FMT='(A80)') TEXT;
               0  WRITE (*,'(A79)') TEXT;
               0  GOTO 9998;
               0  9999 CONTINUE;
               0  backspace(i_errors);
               0  write(i_errors,'(/a,9x,a,$)') ' '; call egs_fdate(i_errors); write(i_errors,*);
               0  write(iout,'(/a,9x,a,$)') ' ';     call egs_fdate(iout);     write(iout,*);
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " WRITE(15 , 400) DATEN,TIMEN;
               0  " WRITE(IOUT,400) DATEN,TIMEN;
               0
               0  call egs_finish;
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 & ~is_finished ) [
               1      call egs_pjob_finish(n_job);
               1      IF( n_job = 0 ) [
               2          is_finished = .true.;
               2          call isumry;
               2          call egs_combine_runs(combine_results,'.egsdat');
               2          NCASET=NCASEO;  IHSTRY=NCASET;
               2          CALL SRCOTO(WEIGHT);
               2          goto :END-SIM:;
               2          ]
               1      ]
               0  #endif;
               0
               0  call SRCEND;
               0
               0  $CALL_EXIT(0);
               0
               0  "FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
               0  %I0                                                                            ;
               0  100  FORMAT(' ',80A1//' CALCULATION USING DOSRZnrc(EGSnrc) '$VERSION' ',
               0               /'ON '$MACHINE' ',T54,a,$);
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " 100  FORMAT(' ',80A1//' CALCULATION USING DOSRZnrc(EGSnrc) '$VERSION' ',
               0  "              /'ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);
               0  200  FORMAT(/' ',79('*')/
               0              /' ',T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
               0              /' ',79('*')/
               0              /' USING DOSRZnrc(EGSnrc) '$VERSION' ');
               0  201  FORMAT(/' ********* NEW INPUT FILE *********'/);
               0  202  FORMAT(/' ********* RESTARTED INPUT FILE ********* '/
               0               ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
               0               ' ',20X,'NEW RN SEEDS=',$);
               0  204  FORMAT(/' ********* DATA ANALYSIS ONLY *********'/);
               0  205  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
               0  206  FORMAT(/' ********* READING RANDOM NUMBER STATE FROM UNIT 2 ****'/);
               0  210  FORMAT(/' ********* Not enough time to finish within',
               0       ' limit of',F8.2,' hours *******'/'*********',I5,' batches used********'/
               0       ' ',I12,' histories run, ',I12,' histories analyzed'//);
               0  220  FORMAT(I12,1X,2I1);
               0  230  FORMAT(/' DESIRED STATISTICAL ACCURACY OBTAINED.'/
               0              ' STATS IN PEAK DOSE REGION (REGION ',I3,')= ',F6.3,
               0              ' AFTER ',I2,' BATCHES');
               0  240  FORMAT(/' *********DESIRED STATISTICAL ACCURACY OF ',F6.3,'%',
               0              ' NOT REACHED*********'/
               0              ' STATS IN PEAK DOSE REGION= ',F6.3,' % AFTER ',I2,' BATCHES');
               0  250  FORMAT(/' FOR OLD RUN:'/
               0               ' ----------- '/
               0               ' Total cputime =',F8.1,'s (=',F5.2,' h)');
               0  255  FORMAT(/' FOR PARALLEL RUNS:'/
               0               ' ----------------- '/
               0               ' On ',I5,' machines '/
               0               ' Total cputime =',F8.1,'s (=',F8.2,' h), cputime/machine =',
               0                F8.1,'s');
               0  260  FORMAT(/' Finished simulations: elapsed,cputime',
               0               ',ratio= ',2F8.1,'(=',F5.2,'h)',F8.2);
               0  270  FORMAT(/' Finished simulations: cputime=',F8.1,'(=',F5.2,' h)');
               0  280  FORMAT(/' cputime per history =',F10.5,' sec. number of histories per',
               0               1x,' hour =',F12.0);
               0  "400  FORMAT(/' End of run',10X,$DATEN_FORMAT,1X,$TIMEN_FORMAT);
               0
               0  END; "END OF MAIN ROUTINE-DOSRZ"
               0
               0  %C80                                                                           ;
               0  %I4                                                                            ;
               0  %Q1                                                                            ;
1              0  %E     "start of AUSGAB in DOSRZnrc.mortran"
               0
               0  ;
               0  "******************************************************************************
               0  "
               0  "
               0  "                               **********
               0  "                               *        *
               0  "                               * AUSGAB *
               0  "                               *        *
               0  "                               **********
               0  "
               0  "
               0  "     AN AUSGAB ROUTINE TO BE USED WITH DOSRZnrc.mortran
               0  "
               0  "     Called with IARG = -1 after each history is over in order to
               0  "     score things for the pulse height distribution when IFULL = 2.
               0  "
               0  "     For IFULL = 2 (passed in COMIN SCORE), the parameter phener keeps
               0  "     track of the energy deposited in the sensitive volume defined by non-
               0  "     zero elements in the array IPHR($MXREG) (passed IN SCORE).
               0  "
               0  "     This routine scores the dose in a finite, azimuthally symmetric
               0  "     cylindrical geometry which the user defines via plane and radial
               0  "     coordinates. The user must specify both the target geometry as well
               0  "     as the planes and radii between which the dose is to be scored. All
               0  "     the geometrical checks for crossing 'geometrical' or 'dose' regions
               0  "     are handled by the subroutine  HOWFAR.
               0  ;
               0  "     FOR IT = 1      total dose is scored
               0  "            = 2      dose less stopped/discarded particles is scored
               0  "                     For IFULL = 3 the scattered dose for incident photons
               0  "            = 3      dose due to particles entering the dose region from
               0  "                     the front wall
               0  "            = 4      dose due to particles entering the dose region from
               0  "                     the side wall
               0  "            = 5      dose due to particles entering the dose region from
               0  "                     the back wall
               0  "            = 6      dose due to particles entering the dose region from
               0  "                     the inside wall
               0  "            = 7      dose due to particles originates from within an
               0  "                     isotropically radiating disk buried in the geometry
               0  "                     which have not yet strayed outside the source region
               0  "
               0  "     Some of the logic
               0  "             Bit 6 of latch is set for all photons scattered after Compton
               0  "             Bit 7 of LATCH is set for all photons after photoeffect
               0  "   XXX       Bit 8 of LATCH is no longer set. Not clear what it was for
               0  "             Bit 8 of LATCH is set for any charged particle created.
               0  "                            This is done to optionally be able to avoid
               0  "                            including k.e. released by any bremsstrahlung
               0  "                            or 511 photons.
               0  "                            This was originally always done but I(DR) removed
               0  "                            it in 2011 as I didn't understand what it was for.
               0  "                            I have made a hack so if IDC=.false., this is not
               0  "                            included but if IDC=.true. it is.
               0  "                            IDC  I double count.
               0  "
               0  "******************************************************************************
               0  ;
               0
               0  SUBROUTINE AUSGAB(IARG);
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER  IARG;
               0
               0  REAL*8 FTMP;
               0
               0  ;
               0  COMIN/CHARS,EPCONT,GEOM,NRCNEW,RUSROU,SCORE,STACK,USEFUL,USER,RANDOM,
               0  BREMPR,EGS-VARIANCE-REDUCTION,SOURCE,IODAT2/;
               0
               0  $INTEGER  IRL,IZD,IXD,IQL,ip,IX,IZ,IGEOM,IB,IPK,I,II,ICUM;
               0  $REAL     aux1,R1,XSI;
               0
               0  LOGICAL BTEST;
               0  INTEGER IBSET,IBCLR;
               0
               0  "I don't know about the purpose of IGBUG1,2 but they should be declared,"
               0  "make static and initialized to zero as they seem to count bugs, IK"
               0  $INTEGER  IGBUG1,IGBUG2,count_strange;
               0  save      IGBUG1,IGBUG2,count_strange;
               0
               0  data      IGBUG1/0/,IGBUG2/0/,count_strange/0/;
               0
               0  MXNP=MAX(MXNP,NP);"keep track of how deep stack is"
               0  "should print out MXNP"
               0
               0  IF (ienhance = 1) [" Option to enhance photon cross section in some region"
               1      "write(6,*) 'in ausgab to recreate photon';"
               1      IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 | iarg = 29) [
               2          "Just before pair/Compton/photoelectric/Rayleigh/photonuclear event"
               2          np = np + 1; "Boost the stack"
               2          IF(np > $MXSTACK) [
               3              OUTPUT $MXSTACK; (
               3              ' Enhance cs unable to add to stack'/
               3              '       since exceeding $MXSTACK=',I6/
               3              ' Stopping.'/ 1x,80('*')/);
               3              stop;
               3              ]
               2          "Create an identical photon"
               2          $TRANSFER PROPERTIES TO (np) FROM (np - 1);
               2          e(np)  =  e(np - 1);
               2          u(np)  =  u(np - 1);
               2          v(np)  =  v(np - 1);
               2          w(np)  =  w(np - 1);
               2          iq(np) = iq(np - 1);
               2          $RANDOMSET R1;
               2          aux1 = 1 - 1./cs_enhance_current;
               2          IF( R1 > aux1 ) [ wt(np-1) = 0; e(np-1) = 0; dnear(np-1) = -1; ]
               2          wt(np) = wt(np)*1.0/cs_enhance_current;
               2          "write(6,*) ' Creating an unscattered photon! ',ir(np),wt(np),wt(np-1);
               2          return;
               2          ]"end of block after photon events"
               1
               1      " Play Russian Roulette with scattered photons to avoid transport
               1      " of many low weight particles.
               1      " Now there is a stack pointer NPold which points to the particle "
               1      " before the last discrete interaction. This change was necessary "
               1      " for the implementation of atomic relaxations. So, check all particles"
               1      " between NPold and NP for RR"
               1      IF ( (  iarg = 18               " Compton has occured"
               1      | iarg = 20               " After photo-absorption "
               1      | iarg = 24               " After Rayleigh "
               1      | iarg = 30)              " After photonuclear "
               1      & ienhance = 1 )
               1      [
               2          ienhance=0;
               2          "write(6,*) ' iarg = ',iarg,' NP NPold: ',NP,NPold;
               2
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [
               4                  $RANDOMSET R1;
               4                  IF(R1.LT.1.0/cs_enhance_current)[
               5                      "PARTICLE SURVIVES"
               5                      WT(ip)=WT(ip)*cs_enhance_current;
               5                      "write(6,*) ' iarg = ',iarg,' particle has survived ',
               5                      "     wt(ip),ip;
               5                      ]
               4                  ELSE [
               5                      wt(ip) = 0; e(ip) = 0; dnear(ip) = -1;
               5                      "write(6,*) ' Have killed particle ',ip,
               5                      " ' after iarg = ',iarg;
               5                      ]
               4                  ]
               3              ]
               2          return;
               2          ]
               1
               1      ] "end of ienhance block"
               0
               0
               0  "Check if particle is leaving the transport geometry"
               0  IRL=IR(NP);  "local region number"
               0  IF(IRL = 1)[
               1      IF(IWATCH > 0) CALL WATCH(IARG,IWATCH); "signal watch routine if active"
               1      RETURN; "outside the chamber, howfar will discard"
               1      ]
               0
               0  "obtain frequently used local variables"
               0  IRL=IR(NP);IF(IRL.EQ.1) RETURN; "outside the chamber"
               0  IZD=IDSTBL(IRL,1); IXD=IDSTBL(IRL,2);   "dose zone coordinates"
               0  IQL=IQ(NP); "local variable"
               0  "write(1,*) ' In AUSGAB: iarg iq edep = ',iarg,iql,edep
               0
               0  IF(IARG = 0)["about to transport a particle"
               1      IF(IQL.NE.0)[
               2          $SCORE(SCSTP, :1);"count charged particle steps taken"
               2          IF(CDSTBL(IRL).EQ.DCHAR)[$SCORE(SCDSTP, :1);]
               2          "count steps in dose region"
               2          ]
               1      ELSE["photon step - play russian roulette?"
               2          IF(RUSROU.AND.(W(NP).GT.0.0))["yes, play if crosses RRZ "
               3              IF((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))["crosses"
               4                  $RANDOMSET XSI;
               4                  IF(XSI.LT.RRCUT)["it survives" WT(NP)=WT(NP)/RRCUT;]
               4                  ELSE["discard it on next call to HOWFAR" WT(NP)=0.0;]
               4                  ] "end test if crosses russian roulette plane"
               3              ] "end test for playing russian roulette"
               2          ] "end test for photon step"
               1      ] "end test for IARG = 0"
               0
               0  IF(IWATCH.GT.0) CALL WATCH(IARG,IWATCH); "signal WATCH routine if active"
               0
               0  IF(IFULL = 1)[ "dose components by origin in each voxel"
               1      "check to see if any electrons created BY PHOTONS"
               1      "if so, set bit 5 to 1 (ie dose from inside). If e- created by e-"
               1      "(ie moller, bhaba), just pass latch value on.  This is"
               1      "our arbitrary definition of where dose comes from."
               1
               1      IF(IARG=16 | IARG=18 | IARG=20)[" after pair production,compton or p.e event"
               2          IF(NP>=NPold)[ "needed for p.e. case where russian roulette may have"
               3              "eliminated ALL electrons"
               3              DO II=NPold,NP [
               4                  IF(IQ(II)~=0)[
               5                      "first, clear latch bits 1-5"
               5                      DO I=1,5[LATCH(II)=IBCLR(LATCH(II),I);]
               5                      "now set latch bit 5"
               5                      LATCH(II)=IBSET(LATCH(II),5);
               5                      ]
               4                  ]  "end loop over II"
               3              ]
               2          ] "end block after photon event"
               1
               1      ELSEIF(IQ(NP)=0 & (IARG=1 | IARG=2))[
               2          "In the rare case that a photon is terminated "
               2          "because E<PCUT or E<AP.  We also want"
               2          "this to show as dose originating from"
               2          "within the volume"
               2          "first, clear latch bits 1-5"
               2          DO I=1,5[LATCH(NP)=IBCLR(LATCH(NP),I);]
               2          "now set latch bit 5"
               2          LATCH(NP)=IBSET(LATCH(NP),5);
               2          ]
               1
               1      ELSEIF(((IARG.EQ.5).AND.(IRNEW.NE.IROLD)).OR.DECISION.EQ.1)[
               2          "set LATCH for a particle entering a new region during a step"
               2          "used to be below, but found that bit setting was wrong for particles"
               2          "ending their track on a region boundary"
               2          DO I=1,5[LATCH(NP)=IBCLR(LATCH(NP),I);]
               2          LATCH(NP)=IBSET(LATCH(NP),NEWNRC/10);
               2          "NEWNRC = 10,20,30 OR 40 depending on if particle in question is"
               2          "         about to enter a new region via front, outer, back    "
               2          "         or inner wall respectively                            "
               2          DECISION=0;
               2          ]
               1      ]
               0  ELSEIF(IFULL = 3)["score scattered dose separately"
               1      "LATCH currently set as follows:
               1      "   scattered dose includes:
               1      "         any dose from compton scattered photons
               1      "         any dose from fluorescent photon which is re-absorbed
               1      "
               1      " This counts as primary any dose after bremsstrahlung  from e- Why???
               1      "      and dose from fluorescent photons when not transported.
               1      "
               1      "Reminder i_survived_RR = 0=> all particles survived RR
               1      "                       = n=> n particles eliminated by RR in interaction"
               1
               1      IF( iarg = 18 ) [ "After Compton. With binding effects and subsequent "
               2          "atomic relaxations implemented, there may be 0, 1  "
               2          "or more additional particles on the stack. NPold   "
               2          "is a current addition to STACK. It is set to NP    "
               2          "at the beginning of every scattering routine       "
               2
               2          IF( NP > NPold | i_survived_rr > 0 ) [ " Flag all photons as scattered "
               3              DO ip=NPold,NP [
               4                  IF( iq(ip) = 0 ) [ latch(ip) = IBSET(latch(ip),6); ]
               4                  ]
               3              ]
               2          " NPold = NP & i_survived_rr>0 after Compton means the interaction"
               2          "      occurred but russian roulette got rid of all electrons but "
               2          "      the scattered photon is on the stack => flag it            "
               2          " NPold = NP & i_survived_rr=0 after Compton means the interaction"
               2          "      was rejected due to binding effects                       "
               2          "      => emerging photon is not scattered => don't flag it       "
               2          ]
               1      ELSE IF( iarg = 20 ) [ "A photo-absorption has occured. "
               2          "If NPold = NP, no particles with energies above "
               2          "the specified thresholds resulted from the "
               2          "relaxation cascade. If NPold < NP, there were "
               2          "such particles emitted. Check them and flag all"
               2          "fluorescent photons as secondaries"
               2          IF( NP > NPold | i_survived_rr>0 ) [
               3              DO ip=NPold,NP ["particle at NPold is photo-electron if not rr'd"
               4                  IF( iq(ip) = 0 ) [ latch(ip) = IBSET(latch(ip),7); ]
               4                  ]
               3              ]
               2          ]
               1      ELSE IF( iarg = 24 ) [ "Raylegh scattering has occured"
               2          latch(NP) = IBSET(latch(NP),7);
               2          ] "end iarg = 24 block"
               1      ] " end IFULL=3 "
               0
               0  "IKERMA=1 option will not work with new photon physics!!!"
               0  "I intend to fix it in the future, IK January 1999"
               0  "July 2011 DR I think I have fixed what was here. Someone had tried to"
               0  "make it work since Iwan made the above comment, but it was buggy!"
               0
               0  IF (IKERMA = 1) ["want to score KERMA"
               1      "we score kerma for scattered component too if ifull=3"
               1      "the kerma is part of scattered kerma if latch of initial photon is not zero"
               1
               1      "Here we keep track of whether we are currently inside a PE/Compton"
               1      "event, or EII. This lets us use edep_local to account for kerma"
               1      "contributions below threshold energies depending on the interaction type."
               1      IF( iarg = 19 | iarg = 17 ) [ "before photoelectric or compton interaction"
               2          during_pe_compt = 1;
               2          return;
               2          ]
               1      IF( iarg = 20 | iarg = 18 ) ["after photoelectric or compton interaction"
               2          during_pe_compt = 0;   "clear flag"
               2          ]
               1      IF( iarg = 31 ) [
               2          during_eii = 1;
               2          return;
               2          ]
               1      IF( iarg = 32 ) [
               2          during_eii = 0;
               2          return;
               2          ]
               1
               1      "depositing sub-threshold energy for PE & Compton"
               1      "Auger only"
               1      IF( iarg = 33 | iarg = 34 ) [
               2          "33=>sub-threshold fluorescence being deposited"
               2          "34=>sub-threshold Auger being deposited"
               2          "if as a result of pe or compt this is k.e. transferred to e-"
               2          "in case of fluorescence, think of what would happen if the photon
               2          "was abve PCUT, then it would mostly have a pe event and create an e-
               2          "and its energy would be part of kerma
               2          "The iarg=33 was only added in Aug 2020"
               2
               2          "test on latch bit 8 is to see if this is from a radiative event"
               2          "bit 8 of LATCH  is set for every created charged particle after any
               2          "      photon interaction, BUT only if IDC is false
               2          "If IDC is true, bit 8 is not set and any subsequent bremm etc is
               2          "      counted in the kerma.
               2          IF( during_pe_compt = 1 & ~BTEST(LATCH(NP),8) ) [
               3              $SCOREDK(SCKERMA,(IZD,IXD,1):WT(NP)*edep_local);
               3              IF(IFULL=3 & (BTEST(LATCH(NP),6) | BTEST(LATCH(NP),7)))[
               4                  $SCOREDK(SCKERMA,(IZD,IXD,2):WT(NP)*edep_local);
               4                  ]
               3              return;
               3              ] ELSE [ return; ]
               2          ] "end iarg=33 or 34 block"
               1
               1      IF (IARG = 16)["pair event just occured"
               2          IF(NP>NPold | i_survived_rr > 0)[
               3              "i_survived_rr, 0=> all particles survive RR,"
               3              "               n=> n particles were removed"
               3              "so the only reason for the i_survived_rr > 0 possibility"
               3              "  is for the case one particle discarded, NP=NPOLD and there"
               3              "  is one charged particle to account for"
               3              "If both eliminated, NP=NPOLD-1 and so nothing done"
               3              DO IP=NPold,NP[
               4                  IF(IQ(IP)~=0 & ~BTEST(LATCH(IP),8))[
               5                      $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP)-PRM));
               5                      IF (IFULL = 3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
               6                          $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
               6                          ]
               5                      IF(~IDC)["if IDC is false, we don't double count so we"
               6                          "set bit 8 which is tested for whenever kerma is scored"
               6                          LATCH(IP)=IBSET(LATCH(IP),8);" Flag to avoid double counting"
               6                          ]
               5
               5                      ]
               4                  ]
               3              ]
               2          ]"end of pair case"
               1
               1      IF (IARG = 18)["compton event just occured"
               2          "must score kerma for all resultant electrons"
               2          IF(NP>NPold)["compton occurred and we have not cleared the stack with"
               3              "russian roulette since if we had, NP=NPOLD"
               3              "also, if bound compton and rejected NP=NPOLD"
               3              "note any relaxation particles are included in NP"
               3              DO IP=NPold,NP[
               4                  IF(IQ(IP) ~= 0 & ~BTEST(LATCH(IP),8)) ["score kerma for e+- only if"
               5                      "bit 8 not set, i.e., if this is not from a photon created by"
               5                      "an earlier e- or e+ and if IDC is false.
               5                      $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP) - PRM));
               5                      IF(IFULL=3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
               6                          $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
               6                          ] "end IFULL block"
               5                      IF(~IDC)["if IDC is false, we don't double count so we"
               6                          "set bit 8 which is tested for whenever kerma is scored"
               6                          LATCH(IP)=IBSET(LATCH(IP),8);" Flag to avoid double counting"
               6                          ]"end IDC block"
               5                      ]"end charged particle block"
               4                  ]"end loop on IP"
               3              ]"end block with some e- on stack"
               2          ]"end of compton case"
               1
               1      IF (IARG = 20)["photoelectric event just occured"
               2          DO IP=NPold,NP[
               3              IF(IQ(IP)~=0 & ~BTEST(LATCH(IP),8))[
               4                  $SCOREDK(SCKERMA,(IZD,IXD,1):WT(IP)*(E(IP) - PRM));
               4                  IF(IFULL = 3 & (BTEST(LATCH(IP),6) | BTEST(LATCH(IP),7)))[
               5                      $SCOREDK(SCKERMA,(IZD,IXD,2):WT(IP)*(E(IP)-PRM));
               5                      ]
               4                  IF(~IDC)["if IDC is false, we don't double count so we"
               5                      "set bit 8 which is tested for whenever kerma is scored"
               5                      LATCH(IP)=IBSET(LATCH(IP),8);" Flag to avoid double counting"
               5                      ]
               4                  ]
               3              ]"end loop on IP"
               2          ]"end of photoelectric case"
               1      ]"end of IKERMA = 1, kerma scoring block"
               0
               0  "do some basic checks to see if scoring is needed"
               0  IF(IARG.GE.5.OR.EDEP.EQ.0) RETURN;
               0
               0  "score total energy deposited"
               0  "============================="
               0
               0  FTMP=WT(NP)*EDEP;
               0
               0  IF(CDSTBL(IRL).EQ.DCHAR)[ "in a dose scoring region"
               1      "score total energy deposited"
               1      $SCOREDK(SCDOSE,(IZD,IXD,1):FTMP);
               1      IF((IFULL = 3) & (BTEST(LATCH(NP),6) | BTEST(LATCH(NP),7)))[
               2          "bit 6 and 7 set when photons scatter"
               2          $SCOREDK(SCDOSE,(IZD,IXD,2):FTMP);
               2          ]
               1      IF(IARG.EQ.0)[ "step about to occur but not discard"
               2          "score total energy deposited less stopped/discarded"
               2          IF(IFULL.NE.3)[$SCOREDK(SCDOSE,(IZD,IXD,2):FTMP);]
               2          ]
               1      IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
               2          OUTPUT FTMP,IRL,IARG;
               2          (9x,' ***weighted dose deposition  = ',1PE14.7,
               2          ' MeV. IRL= ',I3, ' IARG= ',I3);
               2          ]
               1      ]
               0  ;
               0  IF(IFULL.EQ.1)[
               1      "Score total energy into bins according to which wall the particle came"
               1      "from. Corner shots attributed to planar wall : see assignments in howfar"
               1      IF(CDSTBL(IRL).EQ.DCHAR)[ "in a dose scoring region"
               2          $GET-IX-IZ(IRL);
               2          DO I=1,5[
               3              IF(BTEST(LATCH(NP),I))[
               4                  IGEOM=I*10;
               4                  EXIT;
               4                  ]
               3              ]
               2          IF(IGEOM.EQ.10)[    $SCOREDK(SCDOSE,(IZD,IXD,3):FTMP); "front wall"   ]
               2          ELSEIF(IGEOM.EQ.20)[$SCOREDK(SCDOSE,(IZD,IXD,4):FTMP); "outside wall" ]
               2          ELSEIF(IGEOM.EQ.30)[$SCOREDK(SCDOSE,(IZD,IXD,5):FTMP); "back wall"    ]
               2          ELSEIF(IGEOM.EQ.40)[
               3              $SCOREDK(SCDOSE,(IZD,IXD,6):FTMP); "inside wall"
               3              IF(IX.EQ.1)[ "BUG"
               4                  IGBUG2=IGBUG2+1;
               4                  IF(IGBUG2.LE.100)[
               5                      "OUTPUT IGBUG2,IGE0M; changed 92/11/09"
               5                      OUTPUT IGBUG2,IGEOM;
               5                      (' **** INSIDE DOSE???. BUG NO.',I3,' IGEOM=',I3);
               5                      ]
               4                  ]
               3              ]
               2          ELSEIF(IGEOM.EQ.50)[$SCOREDK(SCDOSE,(IZD,IXD,7):FTMP); "inside source"]
               2          ELSE[ "bug"
               3              IGBUG1=IGBUG1+1;
               3              IF(IGBUG1.LE.100)[
               4                  "OUTPUT IGBUG1,IGE0M; changed 92/11/09"
               4                  OUTPUT IGBUG1,IGEOM;
               4                  (' **** LOST REGION. BUG NO.',I3,' IGEOM=',I3);
               4                  ]
               3              ]
               2          ]
               1
               1      "recover region orientation flag if particle will be discarded"
               1      IF((NP.GT.1).AND.(IARG.GE.1).AND.(IARG.LE.3))[
               2          DO I=1,5[
               3              IF(BTEST(LATCH(NP-1),I))[
               4                  NEWNRC=I*10;
               4                  EXIT;
               4                  ]
               3              ]
               2          ]
               1
               1      ] "end of IFULL=1 components by wall"
               0
               0  IF(IFULL=2 & IPHR(IRL)~=0)[
               1      IF(NHSTRY=SCPDST_LAST)["same primary history"
               2          "keep adding energy in pulse height sensitive region"
               2          PHENER=PHENER+EDEP;
               2          WT1OLD=WT(1);
               2          ]
               1      ELSE[
               2          IF(PHENER>0.)[
               3              "we either have a new history depositing or are at the end of a batch/run"
               3              "find appropriate bin for pulse height"
               3              "distn and add initial particle weight to it"
               3              "FIND WHAT BIN WE ARE IN"
               3              IF(SLOTE.GT.0.0)[
               4                  "EQUAL ENERGY BINS CASE"
               4                  IB=MIN0(int(PHENER/SLOTE+0.999),$EBIN);
               4                  ]
               3              ELSE[
               4                  IB = MAXBIN;
               4                  UNTIL((IB.EQ.1).OR.(BINTOP(IB-1).LT.PHENER)) [IB=IB-1;]
               4                  ]
               3
               3              "accumulate the pulse height distribution"
               3              "use WT(1) from history that contributed since we may have forcing"
               3              "on for a primary source in the case of a phsp source WT(1) must be 1"
               3              SCPDST(IB)=SCPDST(IB)+WT1OLD;
               3              SCPDST2(IB)=SCPDST2(IB)+WT1OLD*WT1OLD;
               3              "also add this to the cumulative pulse height distn"
               3              DO ICUM=IB,MAXBIN[
               4                  SCPCUM(ICUM)=SCPCUM(ICUM)+WT1OLD;
               4                  SCPCUM2(ICUM)=SCPCUM2(ICUM)+WT1OLD*WT1OLD;
               4                  ]
               3
               3
               3              IF(IWATCH.EQ.3)[
               4                  OUTPUT PHENER,IB,1;
               4                  (' Pulse height energy=',
               4                  F10.4,' MeV, in bin',I3,' with WEIGHT',1PE10.3);
               4                  ]
               3
               3              "now score probabilities for counts in peaks"
               3              DO IPK=1,4[
               4                  "FOR EACH PEAK, F.E., ESCAPES AND 511"
               4                  IF((PHENER.GE.DFEN(IPK,2)).AND.(PHENER.LE.DFEN(IPK,3)))[
               5                      "IT IS IN THE PEAK"
               5                      SCDFEP(IPK) = SCDFEP(IPK)+WT1OLD;
               5                      SCDFEP2(IPK) = SCDFEP2(IPK)+WT1OLD*WT1OLD;
               5                      SCDFDIFF(IPK)=SCDFDIFF(IPK)+WT1OLD;
               5                      SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+WT1OLD*WT1OLD;
               5                      IF(IWATCH.EQ.3)[
               6                          OUTPUT IPK;(T50,'IT WAS IN ONE OF THE PEAKS,IPK=',I3/);
               6                          ]
               5                      ]
               4                  ELSEIF((PHENER.GE.DFEN(IPK,1)).AND.(PHENER.LT.DFEN(IPK,2)))[
               5                      "IT IS IN THE BKGD"
               5                      SCDFBK(IPK)=SCDFBK(IPK)+WT1OLD;
               5                      SCDFBK2(IPK)=SCDFBK2(IPK)+WT1OLD*WT1OLD;
               5                      SCDFDIFF(IPK)=SCDFDIFF(IPK)-WT1OLD;
               5                      SCDFDIFF2(IPK)=SCDFDIFF2(IPK)-WT1OLD*WT1OLD;
               5                      ]
               4                  ]"END IPK LOOP"
               3              ]
               2          SCPDST_LAST=NHSTRY;
               2          PHENER=EDEP;
               2          WT1OLD=WT(1);
               2          ]
               1      ]
               0
               0  RETURN;
               0
               0  END;  "end of subroutine AUSGAB"
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E     "start of HOWFAR "
               0
               0  ;
               0  "*******************************************************************************
               0  "
               0  "                               **********
               0  "                               *        *
               0  "                               * HOWFAR *
               0  "                               *        *
               0  "                               **********
               0  "
               0  "       A general purpose cylindrical geometry routine for use with the EGSnrc
               0  "       code system adapted for use with DOSRZnrc.
               0  "
               0  "       For particle NP on the STACK in region IR(NP), this routine
               0  "       determines if the particle can go a distance USTEP without changing
               0  "       zones. if USTEP causes a zone crossing, it is reduced to place it on
               0  "       the boundry and IRNEW is set to the zone number on the far side of
               0  "       the boundary. If IR(NP) is 1 then the particle has escaped the region
               0  "       of interest and the history is terminated.(IDISC is set to 1.)
               0  "
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  ;
               0  "OUTEND =       .TRUE.  =>      particle may transmit or backscatter out ends
               0  "       =       .FALSE. =>      particle stays within the end boundaries
               0  "OUTSID =       .TRUE.  =>      particle may transmit out the sides
               0  "       =       .FALSE. =>      particle stays within the side boundary
               0  "IRL    =       starting region number the particle is in
               0  "IZ     =       starting planar zone number the particle is in.
               0  "               the particle is between ZPLANE(IZ) and ZPLANE(IZ+1).
               0  "IX     =       starting cylindrical zone number the particle is in.
               0  "               the particle is between RCYL(IX-1) and RCYL(IX).
               0  "
               0  "       COMMON/GEOM/
               0  "               ZPLANE(IZ)      Z values of planes
               0  "                               1<=IZ<=NZ+1
               0  "               RCYL(IRR)       radii of cylinders
               0  "                               1<=IRR<=NR
               0  "               CYRAD2(IRR)     =RCYL(IRR)**2
               0  "               NZ              # planar geometrical zones (NPLANE-1)
               0  "                               ZONE(I) is between ZPLANE(I) and ZPLANE(I+1)
               0  "               NR              # cylindrical geometrical zones
               0  "                               ZONE(I) is between RCYL(I-1) and RCYL(I)
               0  "               NREG            total # geometrical zones =NR*NZ +1
               0  "                                       +1 for vacuum envelope
               0  "               CABSRB(IRL)     absorbing region flags
               0  "                               =' ' non-absorbing
               0  "                               ='A' absorbing
               0  ;
1              0  %E     "dosrznrc.mortran"
               0  "       DEFINITIONS OF REGION NUMBER, PLANAR ZONE, CYLINDRICAL ZONE
               0  "       ===========================================================
               0  "               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
               0  "
               0  "
               0  "                                       1
               0  "
               0  "
               0  "       --------------------------------------------------------- RCYL(NR)
               0  "       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NZ | NR*NZ |    IX=NR
               0  "       | *NZ+2 | *NZ+3 | *NZ+4 |               |       |   +1  |
               0  "       --------------------------------------------------------- RCYL(NR-1)
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       --------------------------------------------------------- RCYL(2)
               0  "       |  NZ+2 |  NZ+3 |  NZ+4 |    . . . .    |  2NZ  | 2NZ+1 |    IX=2
               0  "       --------------------------------------------------------- RCYL(1)
               0  "..1....|...2...|...3...|...4...|...............|...NZ..|..NZ+1.|....IX=1..1..
               0  ;"      ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       ---------------------------------------------------------
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       |       |       |       |               |       |       |
               0  "       ---------------------------------------------------------
               0  "         IZ=1    IZ=2    IZ=3                   IZ=NZ-1  IZ=NZ
               0  "
               0  "                                       1
               0  "
               0  "
               0  "
               0  "       VERSION 1       ADAPTED FROM CAVITY HOWFAR          06/84  ERIC FOX
               0  "       VERSION 2       THE SUBROUTINE CALLS TO PLANES AND  10/87  AFB
               0  "                       CYLINDER HAVE BEEN REPLACED BY MACROS
               0  "                       TO SPEED THINGS UP
               0  "
               0  "
               0  "******************************************************************************
               0  ;
1              0  %E     "start of geometry macros"
               0  "THE MACRO REPLACING THE CALL TO CYLNDR
               0  "*****************************************************************************
               0  "
               0  "                               ***********
               0  "                               *         *
               0  "                               * $CYLNDR *
               0  "                               *         *
               0  "                               ***********
               0  "
               0  "MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
               0  "A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
               0  "OF THE STANDARD NRCC DISTRIBUTION
               0  "
               0  "FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT CYLINDERS,
               0  "THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A CYLINDER.
               0  "THE CYLINDERS ARE ASSUMED TO BE ALIGNED AND CENTERED ALONG THE Z-AXIS.
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  "
               0  "{P1} = ICYL  = THE NUMBER OF THE OUTER CYLINDER
               0  "{P2} = IHITC = 1 => PARTICLE HITS THE OUTER SURFACE
               0  "             = 0 => PARTICLE MISSES THE SURFACES
               0  "             =-1 => PARTICLE HITS THE INNER SURFACE
               0  "{P3} = TCYL  = DISTANCE TO SURFACE IF IT HITS
               0  "CYRAD2(ICYL) = RADIUS**2 OF THE OUTER CYLINDER
               0  "
               0  "THIS CODE IS OPTIMIZED FOR SPEED, NOT SIZE.
               0  "
               0  "FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
               0  "FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TCYL=0.
               0  "
               0  "MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
               0  "
               0  "
               0  "******************************************************************************
               0  "
               0  REPLACE {$CYLNDR(#,#,#);} WITH {
            {  0  ;
            {  0  U1=U(NP);V1=V(NP);A=U1*U1+V1*V1;
            {  0  IF(A.EQ.0.0)[{P2}=0;{P3}=1.0E30;]
            {  0  ELSE[
            {  0  X1=X(NP);Y1=Y(NP);B=X1*U1+Y1*V1;B2=B*B;
            {  0  COUT=X1*X1+Y1*Y1-CYRAD2({P1});
            {  0  IF(COUT.GT.0.0)[
            {  0  IF(IWATCH > 0 & IWATCH < 4 )[OUTPUT COUT;(' COUT=',E11.3);]
            {  0  COUT=0.0;
            {  0  ]
            {  0  IF(B.GT.0.0)[{P2}=1;
            {  0  IF(COUT/B2.GT.-1.0E-3)[{P3}=-0.5*COUT/B;]
            {  0  ELSE[{P3}=-COUT/(SQRT(B2-A*COUT)+B);]
            {  0  ]
            {  0  ELSEIF(B.LT.0.0)[{P2}=1;
            {  0  IF(COUT/B2.GT.-1.0E-3)[{P3}=-2.*B/A*(1.-0.25*A*COUT/B2);]
            {  0  ELSE[{P3}=(SQRT(B2-A*COUT)-B)/A;]
            {  0  IF({P1}.NE.1)[
            {  0  CIN=X1*X1+Y1*Y1-CYRAD2({P1}-1);
            {  0  IF(CIN.LT.0.0)[
            {  0  IF(IWATCH > 0 & IWATCH < 4 )[OUTPUT CIN;(' CIN=',E11.3);]
            {  0  CIN=0.0;
            {  0  ]
            {  0  RAD=B2-A*CIN;
            {  0  IF(RAD.GE.0.0)[
            {  0  {P2}=-1;
            {  0  IF(CIN/B2.LT.1.0E-3)[{P3}=-0.5*CIN/B;]
            {  0  ELSE[{P3}=CIN/(SQRT(RAD)-B);]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  {P2}=1;
            {  0  {P3}=SQRT(-COUT/A);
            {  0  ]
            {  0  ]
            {  0  ;
            {  0  }
               0
               0  "THE MACRO REPLACING THE CALL TO PLANES
               0  "******************************************************************************
               0  "
               0  "                               ***********
               0  "                               *         *
               0  "                               * $PLANES *
               0  "                               *         *
               0  "                               ***********
               0  "
               0  "PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
               0  "A FULLY DOCUMENTED SUBROUTINE VERSION IS CONTAINED IN NRCCAUX.MOR, PART
               0  "OF THE STANDARD NRCC DISTRIBUTION
               0  "
               0  "FOR A PARTICLE TRAVELLING INSIDE TWO PARALLEL, INFINITE PLANES WITH NORMALS
               0  "ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
               0  "IT MUST GO TO HIT ONE OF THE PLANES
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  "
               0  "{P1}           =       THE NUMBER OF THE INNER PLANE (LESSER Z-COORDINATE)
               0  "                       IT MUST BE .GE. 1
               0  "{P2}           =       THE NUMBER OF THE OUTER PLANE (GREATER Z-COORDINATE)
               0  "                       IT MUST BE .GE. 2
               0  "{P3} = IHITP   =       1  => PARTICLE HITS THE OUTER PLANE
               0  "               =       0  => PARTICLE MISSES BOTH PLANES
               0  "               =       -1 => PARTICLE HITS THE INNER PLANE
               0  "{P4} = TPLANE  =       DISTANCE TO THE PLANE THAT IT HITS
               0  "ZPLANE(IPLANE) =       Z-COORDINATE OF THE OUTER PLANE
               0  "
               0  "MACRO VERSION 1             A.F.BIELAJEW NRCC             87/10
               0  "
               0  "
               0  "******************************************************************************
               0  "
               0  REPLACE {$PLANES(#,#,#,#);} WITH {
            {  0  ;
            {  0  WL=W(NP);
            {  0  IF (WL.GT.0.0) [{P3}=1;{P4}=(ZPLANE({P2})-Z(NP))/WL;]
            {  0  ELSEIF (WL.LT.0.0) [{P3}=-1;{P4}=(ZPLANE({P1})-Z(NP))/WL;]
            {  0  ELSE[{P3}=0;{P4}=1.0E30;]
            {  0  ;
            {  0  }
               0
1              0  %E     "dosrznrc.mortran"
               0  %Q0                                                                            ;
               0
               0  SUBROUTINE HOWFAR;
               0
               0  $IMPLICIT-NONE;
               0
               0  ;
               0  "MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
               0  REPLACE {$SET NEW REGION(#,#);} WITH {
            {  0  "       ======================"
            {  0  ;
            {  0  IF({P1}.LE.USTEP)[
            {  0  USTEP={P1};IRNEW={P2};IMSOFF=0;NEWNRC=NWNRCL;
            {  0  IF(USTEP=0 & IRNEW~=IROLD) DECISION=1;
            {  0  ]
            {  0  RETURN
            {  0  ;}
               0
               0  ;COMIN/CHARS,EPCONT,GEOM,MISC,NRCNEW,SCORE,STACK/;
               0
               0  $LOGICAL OUTEND,OUTSID;
               0  $INTEGER IQL,IRL,IX,IZ,IHITP,IHITC,IZNEW,IXNEW,NWNRCL,IMSOFF;
               0  $REAL    WL,TPLANE,TCYL,U1,V1,A,X1,Y1,B,B2,C,COUT,CIN,RAD;
               0
               0  "DISCARD ZERO WEIGHT PARTICLES"
               0  IF(WT(NP).EQ.0.0)[IDISC=1;RETURN;]
               0
               0  OUTEND=.FALSE.;OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"
               0  IQL=IQ(NP);IRL=IR(NP); "LOCAL VARIABLES"
               0
               0  "DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY OR OF THE REGION IS TOTALLY"
               0  "ABSORBING"
               0  IF ((IRL.EQ.1).OR.(CABSRB(IRL).EQ.ACHAR))[IDISC=1;RETURN;]
               0
               0  $GET-IX-IZ(IRL); "GET PLANAR AND CYLINDRICAL ZONES NUMBERS"
               0
               0  "CALCULATE DNEAR"
               0  "Note this is same as $CALL-HOWNEAR-FOR-NRCC-CYLINDRICAL-GEOMETRY(DNEAR(NP))"
               0  "It is redundant if PRESTA is being used since DNEAR is calculated on"
               0  "every step anyway"
               0
               0  $PLANES(IZ,IZ+1,IHITP,TPLANE);"GET DISTANCE TO PLANE"
               0  "IHITP  =  1 => HITS GREATER Z PLANE"
               0  "       =  0 => MISSES BOTH PLANES"
               0  "       = -1 => HITS LESSER Z PLANE"
               0
               0  $CYLNDR(IX,IHITC,TCYL);"GET DISTANCE TO CYLINDER"
               0  "       IHITC   =  1 => HITS OUTER CYLINDER"
               0  "               =  0 => MISSES BOTH CYLINDERS"
               0  "               = -1 => HITS INNER CYLINDER"
               0
               0  IZNEW=IZ+IHITP;                                  "GET NEW PLANAR REGION"
               0  IF((IZNEW.LT.1).OR.(IZNEW.GT.NZ)) OUTEND=.TRUE.; "FLAG IF LEAVES BY THE ENDS"
               0
               0  IXNEW=IX+IHITC;                "GET NEW CYLINDRICAL REGION"
               0  IF(IXNEW.GT.NR) OUTSID=.TRUE.; "FLAG IF LEAVES BY THE SIDES"
               0
               0  "DO MOST PROBABLE CASE FIRST WHERE A PLANE AND A CYLINDER CAN BE HIT"
               0  IF((IHITP.NE.0).AND.(IHITC.NE.0))[
               1      IF(TPLANE.LT.TCYL)["HITS PLANE FIRST"
               2          IF(OUTEND)[NWNRCL=0;$SET NEW REGION(TPLANE,1);]
               2          ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TPLANE,IRL+IHITP);]
               2          ]
               1      ELSEIF(TCYL.LT.TPLANE)["HITS CYLINDER FIRST"
               2          IF(OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
               2          ELSE[NWNRCL=30+10*IHITC;$SET NEW REGION(TCYL,IRL+NZ*IHITC);]
               2          ]
               1      ELSE["ODD CASE TCYL=TPLANE:HITS PLANE AND CYLINDER TOGETHER"
               2          IF(OUTEND.OR.OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
               2          ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TCYL,IRL+IHITP+NZ*IHITC);]
               2          ]
               1      ]
               0
               0  "DO ODD CASE-PARTICLE CAN HIT PLANE BUT NOT CYLINDER"
               0  ELSEIF(IHITP.NE.0)[
               1      IF(OUTEND)[NWNRCL=0;$SET NEW REGION(TPLANE,1);]
               1      ELSE[NWNRCL=20-10*IHITP;$SET NEW REGION(TPLANE,IRL+IHITP);]
               1      ]
               0
               0  "DO ODD CASE-PARTICLE CAN HIT CYLINDER BUT NOT PLANE"
               0  ELSE[
               1      IF(OUTSID)[NWNRCL=0;$SET NEW REGION(TCYL,1);]
               1      ELSE[NWNRCL=30+10*IHITC;$SET NEW REGION(TCYL,IRL+NZ*IHITC);]
               1      ]
               0
               0  "AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
               0  "HAS ALREADY BEEN TRANSFERRED TO EGS"
               0
               0  END; "END OF SUBROUTINE HOWFAR"
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E     "start of subroutine INPUTS"
               0
               0  "******************************************************************************
               0  "
               0  "
               0  "                               **************
               0  "                               *            *
               0  "                               * INPUTS.MOR *
               0  "                               *            *
               0  "                               **************
               0  "
               0  "
               0  "       AN INPUT FILE USED WITH DOSRZ. THE INPUTS ARE DEFINED AS THEY ARE
               0  "       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
               0  "
               0  "       VERSION 1       E.F.    7/84            ADAPTED FROM CAVITY
               0  "       VERSION 2       A.M.    4/98            NEW INPUT ROUTINE(GET_INPUTS)
               0  "       VERSION 3       IK      1/00         Deleted unnecessary input
               0  "                                            and changed mc transport parameter
               0  "                                            to be handled in a seprate routine
               0  "                                            (get_transport_parameter)
               0  ;
               0  "******************************************************************************
               0  "
               0  SUBROUTINE INPUTS;
               0
               0  $IMPLICIT-NONE;
               0
               0  "DECLERATION OF COMIN BLOCKS
               0  "***************************
               0  ;COMIN/BOUNDS,
               0  CHARS,EDGE,ELECIN,GEOM,IODAT1,IODAT2,MEDIA,MISC,PLOTC,
               0  RUSROU,SCORE,SOURCE,SPECTR,USEFUL,USER,RANDOM,GetInput,ET-Control,
               0  COMPTON-DATA,BREMPR,EGS-VARIANCE-REDUCTION,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                         User defined MACROS                             *"
               0  "***************************************************************************"
               0  REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
               0
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0  $INTEGER INEXT;
               0
               0  $INTEGER MODEIN;                       "source input"
               0  $REAL TEMP1,TEMP2,TEMP3,TEMP4;         "source input"
               0
               0  $INTEGER IFLUOR;                       "transport control"
               0  $INTEGER IZ, IREGLO, IREGHI;           "transport control"
               0  $INTEGER IESTEP;                       "transport control"
               0  $REAL ESTEP, SMAX;                     "transport control"
               0  $REAL FESTEP;                          "transport control"
               0
               0  $REAL ADDING;
               0  $INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM, lux_level;
               0
               0  "***************************************************************************"
               0  "*                Variables used to point to the inputs                    *"
               0  "***************************************************************************"
               0  $INTEGER NUM_TITLE,
               0
               0  "I/O Contol"
               0  NUM_IWATCH,
               0  NUM_STRAND,
               0  NUM_IRESTART ,
               0  NUM_OUTOPTS,
               0  NUM_STORE,
               0  NUM_ETRANS,
               0  NUM_DZMIN,
               0  NUM_DZMAX,
               0  NUM_DRMIN,
               0  NUM_DRMAX,
               0
               0  "M-C Input"
               0  NUM_HIST,
               0  NUM_SEEDS,
               0  NUM_MXTIME,
               0  NUM_IFULL,
               0  NUM_STATLM,
               0  NUM_SCKERMA,
               0  NUM_BREMDST,
               0
               0  "Pulse height distribution"
               0  NUM_REGSVOL,
               0  NUM_SLOTE,
               0  NUM_DELTAE,
               0  NUM_TOPEBIN,
               0
               0  "Tranport Control"
               0  NUM_ESTEPE,
               0  NUM_SMAX,
               0  NUM_ECUT,
               0  NUM_PCUT,
               0  NUM_RAYLEIGH,
               0  NUM_IREJCT,
               0  NUM_HOWFAR,
               0  NUM_ESAVEIN,
               0  NUM_IFLUOR,
               0  NUM_FLUIZ,
               0  NUM_FREGSTART,
               0  NUM_FREGSTOP,
               0  NUM_RRPARAM,
               0  NUM_RRMINPL,
               0  NUM_RRMAXPL,
               0  NUM_RRMINRA,
               0  NUM_RRMAXRA,
               0  NUM_RUSROU,
               0  NUM_RUSFRAC,
               0  NUM_XTRANSF,
               0  NUM_FORCE,
               0  NUM_STRTFRC,
               0  NUM_STPFRC,
               0  NUM_NESTEP,
               0  NUM_NSMAX,
               0  NUM_ADJEREG,
               0  NUM_ADJSLREG,
               0  NUM_ADJUSTED,
               0  NUM_NENH,
               0  NUM_NENHLO,
               0  NUM_NENHHI,
               0  NUM_FRAKESTEP,
               0  num_compton,i_bound_compton,
               0  num_pe_ang,i_pe_ang,num_spin,i_spin,
               0
               0  "variance reduction"
               0  NUM_BREMSPLIT,
               0  NUM_BREMPEVEN,
               0  NUM_I_PLAY_RR;
               0
               0  $REAL   EPHTOP,fsmax;
               0  $INTEGER IPK,JJ,ii,ics_start,ics_stop,ismax,ib,it,itmax,ix;
               0
               0  $INTEGER egs_open_datfile, data_unit; "IK: using explicit file names"
               0
               0  "---------------------------------------------------------------------------"
               0  IVAL=0;  "number of the value_sought"
               0
               0  ERROR_FLAG=0;   "Initialization of bad input flag"
               0
               0  DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"
               0
               0  OUTPUT; (//' DOSRZnrc(EGSnrc) '$VERSION' ON '$MACHINE' '/)
               0
               0  "*********************************************************"
               0  "* set up the VALUES_SOUGHT(IVAL) and echo inputs to screen *"
               0  "*********************************************************"
               0  "*********"
               0  "* TITLE *"
               0  "*********"
               0  IVAL=IVAL+1;
               0  NUM_TITLE=IVAL;
               0  VALUES_SOUGHT(IVAL)='TITLE';
               0  TYPE(IVAL)=2;
               0  NVALUE(IVAL)=1;
               0
               0  DELIMETER='NONE';
               0  $GET_INPUT(NUM_TITLE);
               0
               0  $SKIP-LINE;$SKIP-LINE;
               0  OUTPUT;(' *** INPUT CARD I01 ***');
               0  READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
               0  WRITE (*,:FMT:) (TITLE(I),I=1,79);
               0  :FMT: FORMAT ('TITLE: ',79A1);
               0  $SKIP-LINE;
               0
               0  "********************************************************************"
               0  "* INPUT/OUTPUT CONTROL *"
               0  "************************"
               0
               0  DELIMETER='I/O CONTROL';
               0
               0  IVAL=IVAL+1;
               0  NUM_IWATCH=IVAL;
               0  VALUES_SOUGHT(IVAL)='IWATCH';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
               0  ALLOWED_INPUTS(IVAL,2)='STEPS';
               0  ALLOWED_INPUTS(IVAL,3)='DEPOSITED';
               0  ALLOWED_INPUTS(IVAL,4)='GRAPH';
               0
               0  IVAL=IVAL+1;
               0  NUM_STRAND=IVAL;
               0  VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='NO';
               0  ALLOWED_INPUTS(IVAL,1)='LAST';
               0  ALLOWED_INPUTS(IVAL,2)='ALL';
               0
               0  IVAL=IVAL+1;
               0  NUM_IRESTART =IVAL;
               0  VALUES_SOUGHT(IVAL)='IRESTART';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='FIRST';
               0  ALLOWED_INPUTS(IVAL,1)='RESTART';
               0  ALLOWED_INPUTS(IVAL,3)='ANALYZE';
               0  ALLOWED_INPUTS(IVAL,4)='START-RNS';
               0  ALLOWED_INPUTS(IVAL,5)='PARALLEL';
               0
               0  IVAL=IVAL+1;
               0  NUM_OUTOPTS=IVAL;
               0  VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='SHORT';
               0  ALLOWED_INPUTS(IVAL,1)='DOSE SUMMARY';
               0  ALLOWED_INPUTS(IVAL,2)='MATERIAL SUMMARY';
               0  ALLOWED_INPUTS(IVAL,3)='MATERIAL AND DOSE SUMMARY';
               0  ALLOWED_INPUTS(IVAL,4)='LONG';
               0
               0  IVAL=IVAL+1;
               0  NUM_STORE=IVAL;
               0  VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='YES';
               0  ALLOWED_INPUTS(IVAL,1)='NO';
               0
               0  IVAL=IVAL+1;
               0  NUM_ETRANS=IVAL;
               0  VALUES_SOUGHT(IVAL)='ELECTRON TRANSPORT';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='NORMAL';
               0  ALLOWED_INPUTS(IVAL,1)='NO INTERACTIONS';
               0
               0  IVAL=IVAL+1;
               0  NUM_DZMIN=IVAL;
               0  VALUES_SOUGHT(IVAL)='DOSE ZBOUND MIN';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=1;
               0  VALUE_MAX(IVAL)=$MAXZREG;
               0  DEFAULT(IVAL)=1;
               0
               0  IVAL=IVAL+1;
               0  NUM_DZMAX=IVAL;
               0  VALUES_SOUGHT(IVAL)='DOSE ZBOUND MAX';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=2;
               0  VALUE_MAX(IVAL)=$MAXZREG+1;
               0  DEFAULT(IVAL)=$MAXZREG+1;   "Actual default set below GEOMRZ.MORTRAN"
               0
               0  IVAL=IVAL+1;
               0  NUM_DRMIN=IVAL;
               0  VALUES_SOUGHT(IVAL)='DOSE RBOUND MIN';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=$MAXRADII-1;
               0  DEFAULT(IVAL)=0;
               0
               0  IVAL=IVAL+1;
               0  NUM_DRMAX=IVAL;
               0  VALUES_SOUGHT(IVAL)='DOSE RBOUND MAX';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=1;
               0  VALUE_MAX(IVAL)=$MAXRADII;
               0  DEFAULT(IVAL)=$MAXRADII;    "Actual default set below GEOMRZ.MORTRAN"
               0
               0  "********************************************************************"
               0  DELIMETER='I/O CONTROL';
               0  $GET_INPUTS(NUM_IWATCH,NUM_DRMAX);
               0  "********************************************************************"
               0
               0  OUTPUT;(' *** INPUT CARD IO2 ***');
               0  IWATCH=VALUE(NUM_IWATCH,1);
               0  ISTORE=VALUE(NUM_STRAND,1);
               0  IRESTART =VALUE(NUM_IRESTART ,1);
               0  IOOPTN=VALUE(NUM_OUTOPTS,1);
               0  IDAT=VALUE(NUM_STORE,1);
               0  ICSDA=VALUE(NUM_ETRANS,1);
               0  NZDMIN=VALUE(NUM_DZMIN,1);
               0  NZDMAX=VALUE(NUM_DZMAX,1);
               0  NRDMIN=VALUE(NUM_DRMIN,1);
               0  NRDMAX=VALUE(NUM_DRMAX,1);
               0  NZDOSE=NZDMAX-NZDMIN;
               0  NRDOSE=NRDMAX-NRDMIN;
               0  OUTPUT IWATCH,ISTORE,IRESTART ,IOOPTN,IDAT,ICSDA;
               0  ( /
               0  ' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T72,I4/
               0  ' DO NOT STORE(0) OR STORE(1,2) INITIAL RANDOM #s:',T72,I4/
               0  ' FIRST RUN(0),RESTARTED(1),ANALYZE(3),start-RNS(4),parallel(5):',
               0  T72,I4/
               0  ' OUTPUT OPTION (1 THRU 4):',T72,I4/
               0  ' STORE DATA(0) OR NOT(1):',T72,I4/
               0  ' CSDA CALCULATION(1) OR NOT(0)':,T72,I4/);
               0  OUTPUT ;(/' ******DOSE SCORING BOUNDARIES******');
               0  OUTPUT NZDMIN,NZDMAX,NRDMIN,NRDMAX;
               0  (' NZDMIN,NZDMAX,NRDMIN,NRDMAX: ',3(I5,','),I5/);
               0  $SKIP-LINE;
               0
               0  IF(IDAT.EQ.1)[INEXT=0;]ELSE[INEXT=1;]
               0  IF(IRESTART .EQ.4) [
               1      IDAT=1;   "DO NOT STORE OUTPUT IN THIS CASE TO AVOID BIASING"
               1      ISTORE=0; "DO NOT STORE THE STARTING RANDOM NUMBERS EITHER"
               1      ]
               0
               0  "                       MONTE CARLO CONTROL INPUT
               0  "                       *************************
               0  IVAL=IVAL+1;
               0  NUM_HIST=IVAL;
               0  VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=1;
               0  VALUE_MAX(IVAL)=4.611686e18;; "This is the largest integer handled=2^62"
               0  DEFAULT(IVAL)=20000;
               0
               0  IVAL=IVAL+1;
               0  NUM_MXTIME=IVAL;
               0  VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=1000;
               0  DEFAULT(IVAL)=999.;
               0
               0  IVAL=IVAL+1;
               0  NUM_IFULL=IVAL;
               0  VALUES_SOUGHT(IVAL)='IFULL';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS';
               0  ALLOWED_INPUTS(IVAL,1)='ENTRANCE REGIONS';
               0  ALLOWED_INPUTS(IVAL,2)='PULSE HEIGHT DISTRIBUTION';
               0  ALLOWED_INPUTS(IVAL,3)='SCATTER FRACTION';
               0  ALLOWED_INPUTS(IVAL,4)='OFMET Fricke';  "To score quantities of interest"
               0  "for the OFMET Fricke experiments"
               0  "e.g. brems loss, backscatter loss etc"
               0
               0  IVAL=IVAL+1;
               0  NUM_STATLM=IVAL;
               0  VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.0;
               0  VALUE_MAX(IVAL)=100.0;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_SCKERMA=IVAL;
               0  VALUES_SOUGHT(IVAL)='SCORE KERMA';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='NO';
               0  ALLOWED_INPUTS(IVAL,1)='YES';
               0
               0  "********************************************************************"
               0  DELIMETER='MONTE CARLO INPUTS';
               0  $GET_INPUTS(NUM_HIST,NUM_SCKERMA);
               0  "********************************************************************"
               0
               0  $RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',ixxin,jxxin);
               0  IF( i_parallel > 0 ) jxxin = jxxin - 1 + i_parallel;
               0
               0
               0  $INITIALIZE RNG USING ixxin AND jxxin;
               0
               0  "************"
               0  "* CARD MC1 *"
               0  "************"
               0  OUTPUT;(/,' *** INPUT CARD MC1 ***');
               0  NCASE=VALUE(NUM_HIST,1);
               0  TIMMAX=VALUE(NUM_MXTIME,1);
               0  IFULL=VALUE(NUM_IFULL,1);
               0  STATLM=VALUE(NUM_STATLM,1);
               0  IKERMA=VALUE(NUM_SCKERMA,1);
               0  during_pe_compt=0;
               0  during_eii=0;
               0
               0  IF(IWATCH=0 & NCASE < $NCASEMIN)[NCASE=$NCASEMIN;]
               0
               0  OUTPUT NCASE,IXXIN,JXXIN,TIMMAX,IFULL,STATLM,IKERMA;
               0  ( / ' # OF HISTORIES:',T60,I12/
               0  $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
               0  ' MAXIMUM CPU TIME ALLOWED:'      ,T60,F10.2,'HRS'/
               0  ' SCORING OPTION IFULL (0,1,2,3):'  ,T60,I12/
               0  ' STATISTICAL ACCURACY DESIRED:'  ,T60,F10.4,'%'/
               0  ' KERMA WILL(1) or WILL NOT(0) be scored:',T60,I2);
               0
               0
               0  IF (ERROR_FLAG=1) [GOTO :FINISHED:;]
               0
               0  "                CYLINDRICAL GEOMETRY AND MATERIAL INPUT
               0  "                ***************************************
               0  "EXECUTED FROM SUBROUTINE GEOMRZ(ERROR_FLAG)"
               0
               0  CALL GEOMRZ;
               0
               0  IF(NMED>$MXMED)[
               1      OUTPUT $MXMED;(//' *****************ERROR******************'/
               1      ' No. of media > max. no. of media allowed (',I4,')'/
               1      ' Increase $MXMED in srcrznrc.mortran, recompile'/
               1      ' and try again.'//);
               1      ERROR_FLAG=1;
               1      ]
               0
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMRZ************';
               1      GOTO :FINISHED:;
               1      ]
               0
               0  "Actual defaults for dose boundaries are set here"
               0
               0  "-------------------------------------------------------------"
               0  "- Check for valid minimum scoring plane/cylinder number added"
               0  "- Output values in case they have to  be reset               "
               0
               0  "                                              EMH, 22/03/2002"
               0  "-------------------------------------------------------------"
               0  IF ( NZDMAX > NZ+1 ) [
               1      NZDMAX=NZ+1;
               1      OUTPUT NZDMAX;(/'===> MAX. SCORING PLANE # RESET TO: ',I6);
               1      ]
               0  IF ( NZDMIN >= NZDMAX ) [
               1      NZDMIN = NZDMAX -1;
               1      OUTPUT NZDMIN;(/'===> MIN. SCORING PLANE # RESET TO: ',I6);
               1      ]
               0
               0  IF ( NRDMAX > NR ) [
               1      NRDMAX=NR;
               1      OUTPUT NRDMAX;(/'===> MAX. SCORING CYLINDER # RESET TO: ',I6);
               1      ]
               0  IF ( NRDMIN >= NRDMAX ) [
               1      NRDMIN = NRDMAX -1;
               1      OUTPUT NRDMIN;(/'===> MIN. SCORING CYLINDER # RESET TO: ',I6);
               1      ]
               0  "-------------------------------------------------------------"
               0  "with the above checks: "
               0  "NZDMIN will never be < 1 since NZDMAX is never < 2"
               0  "NRDMIN will never be < 0 since NRDMAX is never < 1"
               0  "-------------------------------------------------------------"
               0
               0  NZDOSE=NZDMAX-NZDMIN;
               0  NRDOSE=NRDMAX-NRDMIN;
               0
               0  IF (NZDOSE>$PLTDIM)[
               1      $egs_warning('(a,i5/,a,i5/,a/,a)',
               1      'INPUTS: Number of dose scoring slab regions NZDOSE =',NZDOSE,
               1      'is larger than plotting arrays size $PLTDIM = ',$PLTDIM,
               1      'Setting NZDOSE to $PLTDIM.',
               1      'You can reset $PLTDIM in dosrznrc.mortran.');
               1      NZDOSE=$PLTDIM;
               1      ]
               0  IF (NRDOSE>$PLTDIM)[
               1      $egs_warning('(a,i5/,a,i5/,a/,a)',
               1      'INPUTS: Number of dose scoring cyl. regions NRDOSE =',NRDOSE,
               1      'is larger than plotting arrays size $PLTDIM = ',$PLTDIM,
               1      'Setting NZDOSE to $PLTDIM.',
               1      'You can reset $PLTDIM in dosrznrc.mortran.');
               1      NRDOSE=$PLTDIM;
               1      ]
               0
               0  "                 PULSE HEIGHT DISTRIBUTION INPUT
               0  "                 *******************************
               0  IF(IFULL.EQ.2)[
               1      OUTPUT;(/' INPUT FOR PULSE HEIGHT DISTRIBUTION'/);
               1      "INITIALIZE FLAGS TO NO PULSE HEIGHT DISTRIBUTION IN EACH REGION"
               1      DO J=1,NREG [IPHR(J)=0;]
               1
               1      "**************************"
               1      "* CARD PHD1 (IF IFULL=2) *"
               1      "**************************"
               1      IVAL=IVAL+1;
               1      NUM_REGSVOL=IVAL;
               1      VALUES_SOUGHT(IVAL)='REGION OF SENSITIVE VOLUME';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=1;
               1      VALUE_MAX(IVAL)=NREG;
               1      DEFAULT(IVAL)=NREG;
               1
               1      "*************"
               1      "* CARD PHD2 *"
               1      "*************"
               1      IVAL=IVAL+1;
               1      NUM_SLOTE=IVAL;
               1      VALUES_SOUGHT(IVAL)='SLOTE';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=-10000.0;
               1      VALUE_MAX(IVAL)=10000.0;
               1      DEFAULT(IVAL)=1.25;
               1
               1      IVAL=IVAL+1;
               1      NUM_DELTAE=IVAL;
               1      VALUES_SOUGHT(IVAL)='DELTAE';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=1.e-20;
               1      VALUE_MAX(IVAL)=100000.0;
               1      DEFAULT(IVAL)=0.005;
               1
               1      "********************************************************************"
               1      DELIMETER='PULSE HEIGHT DISTRIBUTION INPUT';
               1      $GET_INPUTS(NUM_REGSVOL, NUM_DELTAE);
               1      "********************************************************************"
               1
               1      OUTPUT;(/' *** INPUT CARD PHD1 ***'/);
               1      DO J=1, NVALUE(NUM_REGSVOL) [
               2          REGNUM=VALUE(NUM_REGSVOL,J);
               2          IPHR(REGNUM)=1;
               2          OUTPUT REGNUM,MED(REGNUM); (/T10,' REGION',I4,'  HAS MEDIUM',I3);
               2          ]
               1      $SKIP-LINE;
               1
               1      OUTPUT;(/' *** INPUT CARD PHD2 ***'/);
               1      SLOTE=VALUE(NUM_SLOTE,1);
               1      DELTAE=VALUE(NUM_DELTAE,1);
               1      IF (SLOTE > 0.0) [
               2          OUTPUT SLOTE,SLOTE*dble($EBIN);
               2          (/' EQUAL BINS OF',F10.4,' MeV WILL COVER UP TO',F10.3,' MeV');
               2          "NOTE THAT LATER, WHEN WE KNOW THE MAXIMUM ENERGY IN THE"
               2          "INPUT SPECTRUM, WE WILL INCREASE SLOTE TO MAKE SURE IT WORKS"
               2          ]
               1      ELSE [  "SLOTE <= 0.0 means we input energy bins"
               2          IVAL=IVAL+1;
               2          NUM_TOPEBIN=IVAL;
               2          VALUES_SOUGHT(IVAL)='TOPS OF ENERGY BINS';
               2          TYPE(IVAL)=1;
               2          VALUE_MIN(IVAL)=1.e-20;
               2          VALUE_MAX(IVAL)=100000.0;
               2          DEFAULT(IVAL)=1.25;
               2          $GET_INPUT(NUM_TOPEBIN);
               2          DO J=1, NVALUE(NUM_TOPEBIN) [BINTOP(J)=VALUE(NUM_TOPEBIN,J);]
               2          MAXBIN = NVALUE(NUM_TOPEBIN);
               2
               2          IF (NVALUE(NUM_TOPEBIN) > $EBIN+1) [
               3              OUTPUT $EBIN;
               3              (/' ****Tried to use more than max number of energy bins ',I5/
               3              '     Either increase $EBIN or reduce number of bins');
               3              STOP;
               3              ]
               2          OUTPUT NVALUE(NUM_TOPEBIN),(BINTOP(J),J=1,NVALUE(NUM_TOPEBIN));
               2          (/' READ A TOTAL OF',I4,' ENERGY BINS'/ (5F15.4) );
               2          ]
               1
               1      "used to DO SOME CHECKS ON PULSE HEIGHT DISTRIBUTION BINS here"
               1      "but these failed since didn't know EIN yet!  DR"
               1      ] "end of IFULL=2 block"
               0
               0  "                       SOURCE CONFIGURATION INPUT
               0  "                       **************************
               0  "************"
               0  "* CARD SC1 *"
               0  "************"
               0  "EXECUTED FROM SUBROUTINE SRCRZ(ERROR_FLAG)"
               0  CALL SRCRZ;  "Get source data"
               0  CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE SRCRZ************';
               1      GOTO :FINISHED:;
               1      ]
               0
               0
               0  "************
               0  "* CARD TC1 *"
               0  "************"
               0  "EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
               0  IF (ISOURC=21.OR.ISOURC=22.OR.ISOURC=23) [MONOEN=0;]
               0  "no need to input monoen for source 21,22,23"
               0  ELSE [CALL ENSRC;] "Get data re-source energies"
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
               1      GOTO :FINISHED:;
               1      ]
               0
               0  $SKIP-LINE;
               0  IF(IFULL = 3 & IQIN ~= 0)[ "only allow option 3 for pure photon beam"
               1      "                           could modify for full phase space if needed"
               1      OUTPUT;
               1      (// 1x,70('@')/'  Changed IFULL to 0 from 3 since photon beam not input');
               1      IFULL = 0;
               1      ]
               0
               0  IF(IFULL=2)["for pulse height distribution"
               1      "DO SOME CHECKS ON PULSE HEIGHT DISTRIBUTION BINS"
               1      IF(IQIN.EQ.1)[EPHTOP=EIN+1.022;"INCLUDE ANNIHILATION FOR POSITRONS IN"]
               1      ELSE[EPHTOP=EIN;]
               1      IF(SLOTE.GT.0.0)[
               2          UNTIL(SLOTE*dble($EBIN).GT.1.05*EPHTOP)[
               3              SLOTE=SLOTE*2.;
               3              OUTPUT SLOTE;
               3              (/' ***HAVE DOUBLED SLOTE TO',F12.4,
               3              ' MeV TO REACH MAXIMUM INPUT ENERGY');
               3              ]
               2          MAXBIN=int(1.05*EPHTOP/SLOTE+0.999);
               2          OUTPUT MAXBIN;(/' MAXBIN set to',I5,' to cover spectrum'/);
               2          ] "end of SLOTE>0 block"
               1      ELSE[
               2          IF(BINTOP(MAXBIN).LE.EPHTOP)[
               3              OUTPUT MAXBIN,EPHTOP;
               3              (/' ***CHANGED BINTOP(',I3,') TO REACH', F10.3,' MeV***');
               3              BINTOP(MAXBIN)=EPHTOP;
               3              ]
               2          ]"end SLOTE<=0 block"
               1
               1      "Set up energy bins for peak efficiency calculation"
               1      "This only makes sense if beam is monoenergetic"
               1      DFEN(1,2)=EPHTOP-DELTAE;DFEN(2,2)=DFEN(1,2)-PRM;
               1      DFEN(3,2)=DFEN(1,2)-1.022;DFEN(4,2)=PRM-DELTAE;
               1      "I.E. WE SET LOWER ENERGIES FOR FULL ENERGY, SINGLE ESCAPE, DOUBLE"
               1      "ESCAPE AND THE 511 KEV LINE"
               1      DO IPK = 1,4 [
               2          DFEN(IPK,1) = DFEN(IPK,2) - DELTAE;
               2          DFEN(IPK,3) = DFEN(IPK,2) +2*DELTAE;
               2          DFEN(IPK,4) = DFEN(IPK,3) +DELTAE;
               2          ]
               1      ]"end of pulse height dist'n block"
               0
               0  "
               0  "      Start of inputs for transport control delimeter
               0  "      ===============================================
               0
               0  call get_transport_parameter(6); " This will scan the input file for
               0  " transport parameter input and then
               0  " output all settings to unit 6
               0
               0
               0  "*************************************************************************"
               0  "                variance reduction section                               "
               0  "*************************************************************************"
               0
               0  IVAL = IVAL + 1;
               0  NUM_BREMSPLIT = IVAL;
               0  VALUES_SOUGHT(IVAL)='BREM SPLITTING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0
               0  IVAL = IVAL + 1;
               0  NUM_BREMPEVEN = IVAL;
               0  VALUES_SOUGHT(IVAL)='NUMBER OF BREMS PER EVENT';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=$MAXBRSPLIT;
               0  DEFAULT(IVAL)=$MAXBRSPLIT;
               0
               0  IVAL = IVAL + 1;
               0  NUM_I_PLAY_RR = IVAL;
               0  VALUES_SOUGHT(IVAL)='CHARGED PARTICLE RUSSIAN ROULETTE';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0
               0  IVAL=IVAL+1;
               0  NUM_IREJCT=IVAL;
               0  VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0
               0
               0  IVAL=IVAL+1;
               0  NUM_ESAVEIN=IVAL;
               0  VALUES_SOUGHT(IVAL)='ESAVEIN';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.;
               0  VALUE_MAX(IVAL)=EIN+PRM;  "EIN is max k.e. of particles set in "
               0  "srcrz for ISOURC 21,22 and ine ensrc for the others"
               0  DEFAULT(IVAL) =EIN+PRM;  "This means that if a too high number "
               0  "is input, it is reduced to the max needed."
               0
               0  "********************************************************************"
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_BREMSPLIT,NUM_ESAVEIN);
               0  "********************************************************************"
               0
               0  IBRSPL=VALUE(NUM_BREMSPLIT,1);
               0  nbr_split =VALUE(NUM_BREMPEVEN,1);
               0  IF(IBRSPL = 1)["brems splitting requested"
               1      "default bremsstrahlung splitting to maximum"
               1      "IF((nbr_split  <= 0) | (nbr_split  > $MAXBRSPLIT)) nbr_split =$MAXBRSPLIT;"
               1      "To allow bremsstrahlung and annihilation radiation to be turned off"
               1      IF((nbr_split  > $MAXBRSPLIT)) nbr_split =$MAXBRSPLIT;"
               1      ]
               0  ELSE ["no bremsstrahlung splitting" nbr_split = 1;]
               0  "note the above is needed since BREMS only checks nbr_split, not IBRSPL"
               0
               0  I_PLAY_RR=VALUE(NUM_I_PLAY_RR,1);
               0  IF(I_PLAY_RR=1)[PROB_RR=1./dble(nbr_split);]
               0  ELSE[PROB_RR=1.;]
               0
               0  IREJCT=VALUE(NUM_IREJCT,1);  "note IREJCT and ESAVE are defined in USERRR"
               0  ESAVEIN=VALUE(NUM_ESAVEIN,1);
               0  IF(IREJCT = 1 )[ "set parameters for all regions"
               1      DO ii = 1,$MXREG [
               2          i_do_rr(ii) = 1;
               2          e_max_rr(ii) = ESAVEIN;
               2          ]
               1      ]
               0
               0  OUTPUT IBRSPL,nbr_split,I_PLAY_RR,PROB_RR,IREJCT,ESAVEIN;
               0  (
               0  /
               0  ' BREMSSTRAHLUNG SPLITTING OFF(0) OR ON(1):'          ,T60,I12/
               0  ' EACH BREMSSTRAHLUNG SPLIT INTO:'                    ,T60,I12//
               0  ' CHARGED PARTICLE RUSSIAN ROULETT OFF(0) OR ON(1):'  ,T60,I12/
               0  ' PROBABILITY OF SURVIVAL:'                           ,T60,F10.4//
               0  ' WITHOUT(0) OR WITH(1) RANGE REJECTION:'             ,T60,I12/
               0  ' ESAVEIN CUTOFF VALUE FOR regional RANGE REJECTION :' ,T60,F10.4,' MeV'/
               0
               0  );
               0
               0  IF(IFULL=2 & nbr_split > 1)[ "cannot have this"
               1      OUTPUT;(//' ****WARNING****'/
               1      ' You cannot calculate a pulse height distribution with'/
               1      ' bremsstrahlung splitting on.  Will run simulation with'/
               1      ' IFULL= dose and stoppers'//);
               1      WRITE(1,'(//'' ****WARNING****''/
            '  1      ''You cannot calculate a pulse height distribution with''/
            '  1      '' bremsstrahlung splitting on.  Will run simulation with''/
            '  1      '' IFULL= dose and stoppers''//)');
               1      IFULL=0;
               1      ]
               0
               0
               0  IVAL=IVAL+1;
               0  NUM_RUSROU=IVAL;
               0  VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e10;
               0  VALUE_MAX(IVAL)=1.e10;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_RUSFRAC=IVAL;
               0  VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e10;
               0  VALUE_MAX(IVAL)=1.e10;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_XTRANSF=IVAL;
               0  VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e10;
               0  VALUE_MAX(IVAL)=1.e10;
               0  DEFAULT(IVAL)=0.0;
               0
               0  "********************************************************************"
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_RUSROU,NUM_XTRANSF);
               0  "********************************************************************"
               0
               0  "*************"
               0  "* CARD TC2C *"
               0  "*************"
               0  OUTPUT;(' *** INPUT CARD TC2C ***');
               0  RRZ=VALUE(NUM_RUSROU,1);
               0  RRCUT=VALUE(NUM_RUSFRAC,1);
               0  CEXPTR=VALUE(NUM_XTRANSF,1);
               0  RUSROU=.FALSE.;IF(RRZ+RRCUT.NE.0.0)RUSROU=.TRUE.;
               0  IF(RUSROU)[
               1      OUTPUT RRZ,RRCUT;
               1      (/' RUSSIAN ROULETTE WILL BE PLAYED'/
               1      ' RUSSIAN ROULETTE PLANE:',T30,E14.7/
               1      ' SURVIVAL PROBABILITY:',T30,E14.7/)
               1      ]
               0  ELSE [OUTPUT;(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/);]
               0  IF (CEXPTR.EQ.0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE'/);]
               0  ELSEIF(CEXPTR.GE.1) [
               1      OUTPUT;(//' *****************ERROR******************'/
               1      ' INVALID  PATHLENGTH BIASING EXPONENTIAL TRANSFORM C'/
               1      ' C must be < 1'//);
               1      OUTPUT CEXPTR;(' CEXPTR PARAMETER:',T30,E14.7/);
               1      ERROR_FLAG=1;
               1      GOTO :FINISHED:;
               1      ]
               0  ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMETER:',T30,E14.7/);]
               0
               0  IF(IFULL=2 & RUSROU)[
               1      OUTPUT;(//' ****WARNING****'/
               1      ' You cannot calculate a pulse height distribution with'/
               1      ' Russian Roulette on.  Will run simulation with'/
               1      ' IFULL= dose and stoppers'//);
               1      WRITE(1,'(//'' ****WARNING****''/
            '  1      '' You cannot calculate a pulse height distribution with''/
            '  1      '' Russian Roulette on.  Will run simulation with''/
            '  1      '' IFULL= dose and stoppers''//)');
               1      IFULL=0;
               1      ]
               0  IF(IFULL=2 & CEXPTR~=0)[
               1      OUTPUT;(//' ****WARNING****'/
               1      ' You cannot calculate a pulse height distribution with'/
               1      ' pathlength biasing.  Will run simulation with'/
               1      ' IFULL= dose and stoppers'//);
               1      WRITE(1,'(//'' ****WARNING****''/
            '  1      '' You cannot calculate a pulse height distribution with''/
            '  1      '' pathlength biasing.  Will run simulation with''/
            '  1      '' IFULL= dose and stoppers''//)');
               1      IFULL=0;
               1      ]
               0
               0  IVAL=IVAL+1;
               0  NUM_FORCE=IVAL;
               0  VALUES_SOUGHT(IVAL)='PHOTON FORCING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  DEFAULT(IVAL)=0;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0
               0  IVAL=IVAL+1;
               0  NUM_STRTFRC=IVAL;
               0  VALUES_SOUGHT(IVAL)='START FORCING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0
               0  IVAL=IVAL+1;
               0  NUM_STPFRC=IVAL;
               0  VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(NUM_STPFRC)=0;
               0  VALUE_MAX(NUM_STPFRC)=NREG+1;
               0  DEFAULT(NUM_STPFRC)=1;
               0
               0  "********************************************************************"
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_FORCE,NUM_STPFRC);
               0  "********************************************************************"
               0
               0  "************"
               0  "* CARD TC3 *"
               0  "************"
               0  OUTPUT;(' *** INPUT CARD TC3 ***');
               0  IFORCE=VALUE(NUM_FORCE,1);
               0  NFMIN=VALUE(NUM_STRTFRC,1);
               0  NFMAX=VALUE(NUM_STPFRC,1);
               0  IF(IFORCE.EQ.0) [
               1      "NFMIN=0;NFMAX=0;"
               1      OUTPUT;(/' NO INTERACTION FORCING IS IN EFFECT'/);
               1      ]
               0  ELSE [
               1      IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
               1      OUTPUT NFMIN,NFMAX;
               1      (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
               1      ' # INTERACTIONS'/);
               1      ]
               0
               0  IF(IFULL=2 & (NFMAX>NFMIN | NFMIN>1))[
               1      OUTPUT;(//' ****WARNING****'/
               1      ' You cannot calculate a pulse height distribution with'/
               1      ' more than 1 interaction forced or if the forced interaction'/
               1      ' is > the first interaction.  Will run simulation with'/
               1      ' IFULL= dose and stoppers'//);
               1      WRITE(1,'(//'' ****WARNING****''/
            '  1      '' You cannot calculate a pulse height distribution with''/
            '  1      '' more than 1 interaction forced or if the forced interaction''/
            '  1      '' is > the first interaction.  Will run simulation with''/
            '  1      '' IFULL= dose and stoppers''//)');
               1      IFULL=0;
               1      ]
               0
               0  $SKIP-LINE;
               0
               0  IVAL=IVAL+1;
               0  NUM_NENH=IVAL;
               0  VALUES_SOUGHT(IVAL)='CS ENHANCEMENT FACTOR';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=1.0;
               0  VALUE_MAX(IVAL)=10000.0;
               0  DEFAULT(IVAL)=200.0;
               0
               0  IVAL = IVAL + 1;
               0  NUM_NENHLO = IVAL;
               0  VALUES_SOUGHT(IVAL)='CS ENHANCEMENT START REGION';
               0  NVALUE(IVAL)=0;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0
               0  IVAL = IVAL + 1;
               0  NUM_NENHHI = IVAL;
               0  VALUES_SOUGHT(IVAL)='CS ENHANCEMENT STOP REGION';
               0  NVALUE(IVAL)=0;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0
               0  "********************************************************************"
               0  $GET_INPUTS(NUM_NENH,NUM_NENHHI);
               0  "********************************************************************"
               0
               0  cs_enhance = VALUE(NUM_NENH,1);
               0
               0  DO jj=1,NREG [iefl(jj)=0;]
               0  DO ii=1,NVALUE(NUM_NENHLO) [
               1      ics_start=VALUE(NUM_NENHLO,ii);
               1      ics_stop=VALUE(NUM_NENHHI,ii);
               1      DO jj=ics_start,ics_stop [ iefl(jj)=1;]
               1      ]
               0  COUNT=0;
               0  DO jj=2,NREG[COUNT = COUNT + iefl(jj);]
               0  "We don't care about region 1 since outside geometry"
               0  IF(COUNT > 0 & (cs_enhance > 1.0001) ) ["there is enhancement somewhere"
               1      OUTPUT; ('Cross section enhancement in regions ');
               1      OUTPUT (iefl(jj),jj=1,NREG); (20 I4);
               1      OUTPUT cs_enhance;
               1      ( ' Cross section enhancement factor: ',T60,F6.1/);
               1      ics_enhance = 1;
               1      ]
               0  ELSE [
               1      OUTPUT; (' No cross section enhancement');
               1      ics_enhance = 0; ]
               0
               0  IF(IFULL=2 & ics_enhance=1)[
               1      OUTPUT;(//' ****WARNING****'/
               1      ' You cannot calculate a pulse height distribution with'/
               1      ' cross section enhancement.  Will run simulation with'/
               1      ' IFULL= dose and stoppers'//);
               1      WRITE(1,'(//'' ****WARNING****''/
            '  1      '' You cannot calculate a pulse height distribution with''/
            '  1      '' cross section enhancement.  Will run simulation with''/
            '  1      '' IFULL= dose and stoppers''//)');
               1      IFULL=0;
               1      ]
               0
               0  "                       PLOTTING CONTROLS
               0  "                       *****************
               0
               0  "INPUT CARDS FOR PLOTTING ROUTINE
               0  CALL PLOTSN;
               0
               0
               0  IF (ERROR_FLAG=1) [GOTO :FINISHED:;]
               0  "
               0  "                        SCORING ARRAY INITIALISATION
               0  "                        ****************************
               0  "
               0
               0  "CALCULATE THE NUMBER OF DOSE COMPONENTS"
               0  IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
               0  ELSE[ITMAX=$MAXIT;]
               0
               0  NCASEO=0;NCASET=0;TMCPUO=0;
               0
               0  IF(IRESTART.EQ.0.OR.IRESTART.EQ.5)[ "0-FRESH START, SET EVERYTHING TO"
               1      "ZERO OR 5- INITIALIZE ALL ARRAYS TO 0 FOR PARALLEL POST-PROCESSING"
               1
               1      NNREAD=0; "have not read any particles from phase space source"
               1
               1      SCSTP=0; SCSTP2=0; SCSTP_TMP=0; SCSTP_LAST=0;
               1      SCDSTP=0; SCDSTP2=0; SCDSTP_TMP=0; SCDSTP_LAST=0;
               1      PIISTP=0;
               1
               1      DO IT=1,ITMAX[
               2          DO IX=1,NR[
               3              DO IZ=1,NZ[
               4                  SCDOSE(IZ,IX,IT)=0.0;
               4                  SCDOSE2(IZ,IX,IT)=0.0;
               4                  SCDOSE_TMP(IZ,IX,IT)=0.0;
               4                  SCDOSE_LAST(IZ,IX,IT)=0;
               4                  IF(IKERMA=1)[
               5                      SCKERMA(IZ,IX,IT)=0.0;
               5                      SCKERMA2(IZ,IX,IT)=0.0;
               5                      SCKERMA_TMP(IZ,IX,IT)=0.0;
               5                      SCKERMA_LAST(IZ,IX,IT)=0;
               5                      SCDOSEtoKERMA2(IZ,IX,IT)=0.0;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      IF(IFULL=2)[
               2          DO IB=1,MAXBIN[
               3              SCPDST(IB)=0.0;
               3              SCPDST2(IB)=0.0;
               3              SCPCUM(IB)=0.0;
               3              SCPCUM2(IB)=0.0;
               3              ]
               2          DO IPK=1,4[
               3              SCDFEP(IPK)=0.0;
               3              SCDFEP2(IPK)=0.0;
               3              SCDFBK(IPK)=0.0;
               3              SCDFBK2(IPK)=0.0;
               3              SCDFDIFF(IPK)=0.0;
               3              SCDFDIFF2(IPK)=0.0;
               3              ]
               2          SCPTOT=0.0;
               2          SCPTOT2=0.0;
               2          SCPDST_LAST=0;
               2          ]
               1      ] "END OF IRESTART =0 OR 5"
               0
               0  ELSEIF(IRESTART.EQ.4)[ "retrieve random numbers from .egsrns file"
               1      OUTPUT;(/' Will READ RANDOM NUMBER PARAMETERS FROM UNIT 2:');
               1      ]
               0
               0  ELSE[
               1      "RESTART OR STATS ANALYSIS ONLY, READ OLD DATA FROM UNIT 4"
               1      "OPEN UNIT 4 AS AN OLD FILE"
               1      OUTPUT;(/' ***START READING DATA FILE from PREVIOUS RUN***'/);
               1      "IK: we don't wont ro rely upon a symbolic link to the .egsdat file "
               1      "    to have been made for us before running dosrznrc. "
               1      "    We therefore open the .egsdat file using a file name. "
               1      "    The egs_open_datfile function opens the file named output_file.egsdat"
               1      "    (or input_file.egsdat) where output_file and input_file are the "
               1      "    command line arguments to the -o and -i options."
               1      "OPEN(UNIT=4,file='fort.4',STATUS='OLD');"
               1      data_unit = egs_open_datfile(4,0,1,'.egsdat');
               1      READ(data_unit,*,END=:EOFA:)SCSTP,SCSTP2,SCDSTP,SCDSTP2,PIISTP;
               1      READ(data_unit,*,END=:EOFA:)
               1      (((SCDOSE(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               1      READ(data_unit,*,END=:EOFA:)
               1      (((SCDOSE2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               1      IF(IKERMA=1)[
               2          READ(data_unit,*,END=:EOFA:)
               2          (((SCKERMA(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               2          READ(data_unit,*,END=:EOFA:)
               2          (((SCKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               2          READ(data_unit,*,END=:EOFA:)
               2          (((SCDOSEtoKERMA2(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               2          ]
               1      IF(IFULL=2)[
               2          READ(data_unit,*,END=:EOFA:)(SCPDST(IB),SCPDST2(IB),IB=1,MAXBIN);
               2          READ(data_unit,*,END=:EOFA:)(SCPCUM(IB),SCPCUM2(IB),IB=1,MAXBIN);
               2          READ(data_unit,*,END=:EOFA:)(SCDFEP(IPK),SCDFEP2(IPK),IPK=1,4);
               2          READ(data_unit,*,END=:EOFA:)(SCDFBK(IPK),SCDFBK2(IPK),IPK=1,4);
               2          READ(data_unit,*,END=:EOFA:)(SCDFDIFF(IPK),SCDFDIFF2(IPK),IPK=1,4);
               2          ]
               1      $RETRIEVE RNG STATE FROM UNIT data_unit;
               1      READ(data_unit,*,END=:EOFA:)NCASEO,TMCPUO,NNREAD;
               1      " Read solid angle information as well, IK May 4 1999"
               1      READ(data_unit,*,END=:OMEGA-NOT-THERE:) SCOMEG,SCOMEG2;
               1      goto :OMEGA-THERE:;
               1      :OMEGA-NOT-THERE:
               1      OUTPUT;('  Warning: Solid angle information not in data file');
               1      OUTPUT;('           This may cause errors in absolute normalizations!');
               1      :OMEGA-THERE:
               1      CLOSE(data_unit);
               1      ]
               0
               0  IF(IRESTART .EQ.3)[NCASE=0;]
               0
               0  NCASET=NCASE+NCASEO;
               0
               0  :FINISHED: CONTINUE;
               0  "************************"
               0  "* Check for any errors *"
               0  "************************"
               0  IF(ERROR_FLAG.EQ.0) [
               1      OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' *************************************************';
               1      WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
               1      WRITE (15,*) ' *************************************************';
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' ';
               1      DO J=1,5[$SKIP-LINE;]
               1
               1      RETURN; "NORMAL RETURN"
               1      ]
               0
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) '************************************************';
               1      WRITE(15,*) '********UNSUCCESSFUL INPUTS ACCOMPLISHED********';
               1      WRITE(15,*) '************************************************';
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) ' ';
               1      OUTPUT;(/' ERROR_FLAG=1 => INPUT DATA IS NOT CORRECT! see error file');
               1      RETURN; "ERROR RETURN"
               1      ]
               0
               0  "BAD DATA FILE, STOP AND PRINT MESSAGE
               0  :EOFA:OUTPUT;(/' End of egsdat file from previous run encountered before',
               0  ' it was all read in - have to quit ');
               0  ERROR_FLAG=1;
               0  RETURN; "END OF DAT FILE RETURN"
               0
               0  END; "END OF SUBROUTINE INPUTS
               0
1              0  %E     "start of subroutine ISUMRY"
               0
               0  "***************************************************************************
               0  "
               0  SUBROUTINE ISUMRY;
               0  "
               0  "           AFB       10/88     MACHINE-INDEPENDENT VARIABLE FORMAT CODED
               0  "
               0  "*************************************************************************
               0
               0  $IMPLICIT-NONE;
               0
               0  ;
               0  COMIN/
               0  BOUNDS,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,
               0  MEDIA,MISC,RUSROU,SCORE,SOURCE,SPECTR,
               0  THRESH,USEFUL,USER,RANDOM,BREMPR,EGS-VARIANCE-REDUCTION/;
               0  ;
               0
               0  $INTEGER   IOUT,j,isumx,jj,i,ii;
               0  $REAL      EK0;
               0
               0  $LOGICAL   start_fluor;
               0  $INTEGER   i_start,i_stop;
               0
               0  IOUT=1;    "OUTPUT ON FORTRAN UNIT 1"
               0  WRITE (IOUT, *) '\f'; "page break"
               0
               0  "WRITE THE HEADER"
               0
               0  write(iout,100) title;
               0  100 FORMAT(
               0  ' ',80A1,/1X,79('*')/ ' *',T80, '*'/
               0  ' *',T80, '*'/
               0  ' *',T34,'************',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'* DOSRZnrc *',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'************',T80,'*'/
               0  ' *',T80, '*'/
               0  ' *           Cylindrical-geometry dose-scoring EGSnrc user-code ', T80,'*'/
               0  ' *',T80, '*'/
               0  ' *   DOSRZnrc was developed by the National Research Council of Canada',
               0  T80,'*'/
               0  ' *',T80, '*'/
               0  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
               0  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
               0  T80,'*'/
               0  ' *             running on '$MACHINE' ',T80,'*'/
               0  ' *',T80, '*'/
               0  ' *',  T54,' ',$);
               0  call egs_fdate(iout);
               0  write(iout,'(" *",/1X,79("*"))');
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " CALL DATE(DATEN);CALL TIME(TIMEN);
               0  " WRITE(IOUT,100) TITLE,TIMEN,DATEN;
               0  " 100  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
               0  "   ' *',T80, '*'/
               0  "   ' *',T34,'************',T80,'*'/
               0  "   ' *',T34,'*          *',T80,'*'/
               0  "   ' *',T34,'* DOSRZnrc *',T80,'*'/
               0  "   ' *',T34,'*          *',T80,'*'/
               0  "   ' *',T34,'************',T80,'*'/
               0  "   ' *',T80, '*'/
               0  "   ' *           Cylindrical-geometry dose-scoring EGSnrc user-code ', T80,'*'/
               0  "   ' *',T80, '*'/
               0  "   ' *   DOSRZnrc was developed by the National Research Council of Canada',
               0  "                                                                       T80,'*'/
               0  "   ' *',T80, '*'/
               0  "   ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
               0  "   ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
               0  "                                                                       T80,'*'/
               0  "   ' *             running on '$MACHINE' ',T80,'*'/
               0  "   ' *',T80, '*'/
               0  "   ' *',  T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT,T80,'*'/1X,79('*'));
               0
               0  call show_transport_parameter(iout); " print the transport parameter settings"
               0  " settings on unit IOUT"
               0
               0  "MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"
               0  WRITE(IOUT,200) NCASE,NCASET,IQIN;
               0  IF(MONOEN.EQ.0.AND.(ISOURC.LT.21.OR.ISOURC.GT.23))[WRITE(IOUT,201) EIN;]
               0  ELSEIF(MONOEN.EQ.1)[CALL ENSRCO;]
               0  ELSEIF(ISOURC.EQ.21.OR.ISOURC.EQ.22)[WRITE(IOUT,202) EKSRCM;]
               0  "IF(estepe.EQ.0.0)[WRITE(IOUT,210);]ELSE[WRITE(IOUT,211)estepe;]
               0  "WRITE(IOUT,220) smaxir($MXREG),ECUTIN,PCUTIN;"
               0  "Now we check to see if ECUT(i) is the same for all regions"
               0  "If so, we print the value"
               0  "Note that this is a fudge for the RZ codes so that even if we "
               0  "SET ECUT(1) = 0.0 to avoid warning messages, there is still a fixed ECUT"
               0  DO I=2,NREG [ IF( (ECUT(I) ~= ECUT(2)) |(PCUT(I) ~= PCUT(2)) ) [
               2          "we failed at least one test, so this means there really are"
               2          "varying ECUTs and these will be printed in the grid if we want them"
               2          "print the first 10 ECUT & PCUT just to be sure"
               2          jj = MIN(12,NREG);
               2          WRITE(IOUT,'( ''First ECUTs:''/(6(F12.3)))') (ECUT(ii),ii=2,jj);
               2          WRITE(IOUT,'( ''First PCUTs:''/(6(F12.3)))') (PCUT(ii),ii=2,jj);
               2          GO TO :past:]]
               0  "if we get here, they were all the same"
               0  WRITE(IOUT,220) ECUT(2),PCUT(2);
               0  :past:
               0
               0  IF(IFORCE.NE.0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]
               0
               0  IF(ics_enhance = 1)[ WRITE(IOUT,235) cs_enhance,(j,iefl(j),j=2,NREG);]
               0  ELSE [WRITE(IOUT,236);]
               0  IF(IREJCT.EQ.0)[ WRITE(IOUT,243); ]
               0  ELSE[ WRITE(IOUT,242) ESAVEIN; ]
               0  DO I=1,NREG[
               1      IF(IRAYLR(I)=1)[
               2          WRITE(IOUT,244);
               2          EXIT;
               2          ]
               1      ]
               0  WRITE(IOUT,260) TIMMAX,STATLM,IXXIN,JXXIN;
               0
               0  IF(IBRSPL = 0)[WRITE(IOUT,312);]
               0  ELSE[WRITE(IOUT,313) nbr_split;]
               0
               0  IF(I_PLAY_RR = 0)[WRITE(IOUT,314);]
               0  ELSE[WRITE(IOUT,315) PROB_RR;]
               0
               0  IF(RUSROU) WRITE(IOUT,265)RRZ,RRCUT;
               0  IF(CEXPTR.NE.0) WRITE(IOUT,266)CEXPTR;
               0  IF(ESAVEIN > 0.0) WRITE(IOUT,267)ESAVEIN;
               0  IF(NESTEP.EQ.0)[       WRITE(IOUT,282);      ]
               0  ELSEIF(NESTEP.EQ.NREG)[WRITE(IOUT,283);      ]
               0  ELSE[                  WRITE(IOUT,284)NESTEP;]
               0  IF(NSMAX.EQ.0)[        WRITE(IOUT,285);      ]
               0  ELSEIF(NSMAX.EQ.NREG)[ WRITE(IOUT,286);      ]
               0  ELSE[                  WRITE(IOUT,287)NSMAX; ]
               0  IF(ICSDA.EQ.0)[WRITE(IOUT,289);]ELSE[WRITE(IOUT,290);]
               0
               0  "PATCH FOR FLUORESCENT X-RAYS"
               0  ISUMX=0;
               0  DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ);"NON-ZERO IF X-RAYS ANYWHERE"]
               0  IF(ISUMX.EQ.0)[WRITE(IOUT,307);]
               0
               0  ELSE[
               1
               1      WRITE(IOUT,306);
               1
               1      start_fluor = .false.;
               1      DO jj=1,NREG [
               2          IF( IEDGFL(JJ) > 0 & IEDGFL(JJ) <= $MXELEMENT ) [
               3              IF( ~start_fluor ) [
               4                  start_fluor = .true.; i_start = jj;
               4                  ]
               3              ELSE [ i_stop = jj; ]
               3              ]
               2          ELSE [
               3              IF( start_fluor ) [
               4                  write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_stop;
               4                  start_fluor = .false.;
               4                  ]
               3              ]
               2          ]
               1      IF( start_fluor ) write(iout,'(24x,i5,a,i5)') i_start,' -- ',i_stop;
               1
               1      ]
               0
               0  IF(IDC)[write(iout,203);]
               0  ELSE [write(iout,204);]
               0
               0  EK0=EIN;
               0  $PRESTA-INPUT-SUMMARY; "OUTPUT THE PRESTA INPUT VARIABLES"
               0
               0  "MATERIAL INPUT SUMMARY"
               0  "====================="
               0
               0  WRITE(IOUT,300) NMED;
               0  DO I=1,NMED[
               1      WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);
               1      ]
               0
               0  CALL GEOMRZ_ISUMRY(IOUT);
               0
               0  CALL SRCOUT;
               0
               0  IF(IOOPTN.GE.2)[ "PRINT A GRID OF THE ZONE DEPENDENT VARIABLES"
               1      CABSRB(1)='0';
               1      CALL MATERIALGRID(NR, NZ, AMASS, 1, ECUT, PCUT,
               1      RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB);
               1      ]   "END OF CONDITIONAL MATERIAL GRID OUTPUT"
               0
               0  "SUMMARY OF REGIONS IN SENSITIVE VOLUME"
               0  IF(IFULL.EQ.2)[
               1      OUTPUT (I,IPHR(I),I=1,NREG);
               1      (///' PULSE HEIGHT DISTRIBUTION IS SCORED IN ',
               1      'THOSE REGIONS DENOTED WITH A 1'/(10(I3,'(',I1,'), ')));
               1      WRITE(IOUT,311)(I,IPHR(I),I=1,NREG);
               1      ] "END IFULL=2 BLOCK"
               0
               0  WRITE (IOUT, *) '\f'; "page break"
               0
               0  RETURN;
               0  %I0                                                                            ;
               0  "FORMATS"
               0  200  FORMAT (
               0      ' ',T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/ / ' ',79('*')//
               0      ' ',T20,'MAX # OF HISTORIES TO RUN',T53,I12/
               0      ' ',T20,'MAX # OF HISTORIES TO ANALYZE',T53,I12/
               0      ' ',T20,'INCIDENT CHARGE',T63,I2);
               0  201  FORMAT(' ',T20,'INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
               0  202  FORMAT(' ',T20,'MAXIMUM INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
               0  203  FORMAT(/' ',T10,'IDC true=> kerma scored following radiative',
               0              ' events'/);
               0  204  FORMAT(/' ',T10,'IDC false=> kerma not scored following radiative',
               0              ' events'/);
               0
               0  210  FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT');
               0  211  FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3);
               0  220  FORMAT(' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
               0                       T56,0PF9.3,' (MeV)'/
               0               ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
               0                       T56,F9.3,' (MeV)');
               0  230  FORMAT(' ',T20,'MIN/MAX PHOTON STEP FORCED',T60,I6,'/',I6);
               0  231  FORMAT(' ',T20,'PHOTON FORCE INTERACTION SWITCH',T60,'OFF');
               0  235  FORMAT(T20,'Cross section enhancement factor of',T56,F8.1/
               0              T20,'In regions with a 1:'/
               0              (T10, 10('(',I3,',',I1,')')));
               0  236  FORMAT(T20,'No cross section enhancement used');
               0  242  FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'ON'/
               0                  T20,'  Range rejection for energy  <',T56,F9.3,' (MeV)'/
               0                  T20,'  Ranges determined internally from stopping powers');
               0  243  FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF');
               0  244  FORMAT(' ',T20,'RAYLEIGH SCATTERING INCLUDED');
               0  "250  FORMAT(' ',T20,'RANGE REJECTION PARAMETERS:'/
               0  "             ' ',T12,F9.3,' (MeV) TO ',F9.3,' (MeV)',T51,E14.7,'/',E14.7/
               0  "             ' ',T12,F9.3,' (MeV) TO ',F9.3,' (MeV)',T51,E14.7,'/',E14.7);
               0  "255  FORMAT(T20,'DISCARDS E- EXTERIOR TO PLANES',I3,' AND',I3/
               0  "            T30,'AND CYLINDERS',I2,' AND',I3,' for E<',F7.3,' MeV');
               0  260  FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (HRS)'/
               0              ' ',T20,'STATS IN PEAK REGION OBJECTIVE',T59,F6.2,' %'/
               0              ' ',T20,'1ST INITIAL RANDOM NUMBER SEED',T57,I12/
               0              ' ',T20,'2ND INITIAL RANDOM NUMBER SEED',T57,I12);
               0  265  FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'/
               0                  T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4);
               0  266  FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/
               0                  T25,'VARIABLE FOR FORWARD GOING PHOTNS: ',T60,F10.3);
               0  267  FORMAT(' ',T20,'DISCARD ALL ELECTRONS BELOW:',T60,F7.3/
               0                  T25,'IF TOO FAR FROM CLOSEST BOUNDRY');
               0  270  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'NONE');
               0  271  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,'ALL');
               0  272  FORMAT(' ',T20,'# ZONES MULT SCATTERING SWITCHED OFF',T60,I2);
               0  273  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'NONE');
               0  274  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,'ALL');
               0  275  FORMAT(' ',T20,'# ZONES MOLL SCATTERING SWITCHED OFF',T60,I2);
               0  276  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'NONE');
               0  277  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,'ALL');
               0  278  FORMAT(' ',T20,'# ZONES BREM SCATTERING SWITCHED OFF',T60,I2);
               0  279  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'NONE');
               0  280  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,'ALL');
               0  281  FORMAT(' ',T20,'# ZONES BHAB SCATTERING SWITCHED OFF',T60,I2);
               0  282  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'NONE');
               0  283  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,'ALL');
               0  284  FORMAT(' ',T20,'# ZONES ELEC ENERGY LOSS/STEP ALTERED',T60,I2);
               0  285  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'NONE');
               0  286  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,'ALL');
               0  287  FORMAT(' ',T20,'# ZONES MAX ELEC STEP SIZE ALTERED',T60,I2);
               0  289  FORMAT(' ',T20,'NORMAL ELECTRON TRANSPORT WITH DISCRETE INTERACTIONS');
               0  290  FORMAT( /
               0      ' ',T20,'NO DISCRETE ELECTRON INTERACTIONS SAMPLED'/
               0      ' ',T20,'========================================='/);
               0  300 FORMAT( ' ',79('*')/ /
               0      ' ',T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/ / ' ',79('*')//
               0      ' # MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
               0            9X,'UE(MeV)',4X,'UP(MeV)'/
               0      ' - --------  ----------------',6X,'-------',4X,'-------',
               0            9X,'-------',4X,'-------');
               0  305  FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3);
               0  306  FORMAT(T20,' The following regions have atomic relaxations on: ');
               0  307  FORMAT(T20,' Atomic relaxations are off');
               0  310  FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));
               0  311  FORMAT(///' PULSE HEIGHT DISTRIBUTION IS SCORED IN THOSE REGIONS',
               0               ' DENOTED WITH A 1'/(10(I3,'(',I1,'), ')));
               0  312   FORMAT(T20,'Bremsstrahlung splitting',T60,'OFF');
               0  313   FORMAT(T20,'Bremsstrahlung splitting',T60,'ON'/T20,
               0       'Initially, each bremsstrahlung photon split into ',I3,' photons');
               0  314  FORMAT(T20,'Charged particle Russian Roulette',T60,'OFF');
               0  315  FORMAT(T20,'Charged particle Russian Roulette',T60,'ON'/T20,
               0                  'With probability of survival =',T60,F9.3);
               0  END; "LAST LINE OF SUBROUTINE ISUMRY"
               0
               0
1              0  %E     "start of subroue OSUMRY"
               0
               0  "*************************************************************************
               0  "
               0  SUBROUTINE OSUMRY;
               0  "
               0  "           AFB       10/88     MACHINE-INDEPENDENT VARIABLE FORMAT CODED
               0  "
               0  "************************************************************************
               0
               0  $IMPLICIT-NONE;
               0
               0  ;
               0  REPLACE {$IRL} WITH {IZD+NZDMIN+NZDOSE*(IXD+NRDMIN-1)}
               0
               0  ;
               0  "for the grid output"
               0  $INTEGER NCOMP;
               0  $REAL RESULTS($MAXZREG, $MAXRADII, $MAXCMPTS),
               0       UNCRTY($MAXZREG, $MAXRADII, $MAXCMPTS),
               0       RADIAL_BINS($MAXRADII),DEPTH_BINS($MAXZPLANE);
               0  CHARACTER*60 EXPLANATIONS($MAXCMPTS);
               0  CHARACTER*4 LABELS($MAXCMPTS);
               0
               0  $REAL FRACS($MAXZREG,$MAXRADII,3:6);
               0  $INTEGER IXD,IZD,IT,IZ,IX,IRL,I,IR;
               0  $REAL    TEMP;
               0
               0  ;COMIN/CHARS,GEOM,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,SOURCE,USER,
               0  BREMPR,EGS-VARIANCE-REDUCTION,CH-Steps/;
               0
               0  $INTEGER egs_open_file, dose_unit;
               0
               0  IF(IFULL.EQ.2)[
               1      "PULSE HEIGHT DISTRIBUTION OUTPUT"
               1      "IF(MAXBIN.LT.45)[CALL PRNTER(13,6,1,1);]ELSE[CALL PRNTER(13,8,1,1);]"
               1      write(1,'(a)') '\f';
               1      write(iout,101) title; call egs_fdate(iout);
               1      write(iout,104);
               1
               1  " ********** IK: using wrapper for date and time routines.
               1  " Was:
               1  "    WRITE(IOUT,101) TITLE, DATEN,TIMEN;
               1
               1      CALL PLOTPH(TITLE,SCPDST,SCPDST2,SCPCUM,SCPCUM2,
               1          SCPTOT,SCPTOT2,SCDFEP,SCDFEP2,MAXBIN,SLOTE,BINTOP,
               1          IHSTRY,SCOMEG,SCOMEG2,SCPHEN,SCPHEN2);
               1  ]"END OF IFULL= 2 BLOCK"
               0
               0  "CALL PRNTER(12,6,IOUT,1); SET UP THE PRINTER AND PAGE THROW"
               0  write(1,'(a)') '\f';
               0
               0  write(iout,100) title; call egs_fdate(iout); write(iout,105);
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " WRITE(IOUT,100)TITLE,DATEN,TIMEN;" "HEADER"
               0
               0  "Print out final bremsstrahlung splitting number"
               0  IF(IBRSPL = 1)[WRITE(IOUT,90) nbr_split;]
               0
               0  "PRINT # CHARGED PARTICLE STEPS"
               0  IF(ISOURC=21|ISOURC=22)[
               1    WRITE(IOUT,200) SCSTP,SCSTP2,
               1          SCSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC),
               1                    SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
               1  ]
               0  ELSE[
               1    WRITE(IOUT,200) SCSTP,SCSTP2,SCSTP/dble(IHSTRY),
               1                    SCSTP2,(count_pII_steps+PIISTP)/SCSTP,SCSTP2;
               1  ]
               0
               0  "PRINT # CHARGED PARTICLE STEPS IN DOSE REGION"
               0  IF(ISOURC=21|ISOURC=22)[
               1    WRITE(IOUT,210) SCDSTP,SCDSTP2,
               1         SCDSTP/(dble(NNREAD+NRCYCL*(NNREAD-IHSTRY))/dble(NCASE_PHSP)*NINCSRC),
               1                    SCDSTP2,(count_pII_steps+PIISTP)/SCDSTP,SCDSTP2;
               1  ]
               0  ELSE[
               1    WRITE(IOUT,210) SCDSTP,SCDSTP2,
               1                    SCDSTP/dble(IHSTRY),
               1                    SCDSTP2,(count_pII_steps+PIISTP)/SCDSTP,SCDSTP2;
               1  ]
               0
               0  "SCALE DOSE FRACTIONS"
               0  IF(IFULL.EQ.1)[
               1      DO IXD=1,NRDOSE[
               2          DO IZD=1,NZDOSE[
               3              TEMP=SCDOSE(IZD,IXD,1);
               3              IF(TEMP.EQ.0)[DO IT=3,6[FRACS(IZD,IXD,IT)=0.0;]]
               3              ELSE[DO IT=3,6[FRACS(IZD,IXD,IT)=100.*SCDOSE(IZD,IXD,IT)/TEMP;]]
               3          ]
               2      ]
               1  ]
               0
               0  "PRINT A SUMMARY OF THE DOSE REGION RESULTS"
               0  IF((IOOPTN.EQ.1).OR.(IOOPTN.GT.2))[
               1
               1      "A COMPACT VERSION IF ONLY ONE DOSE REGION ZONE"
               1      IF(NDOSE.EQ.1)[
               2          IZ=NZDMIN;IX=NRDMAX;
               2          $GET-IRL(IZ,IX);
               2          IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               3             WRITE(IOUT,299) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT=1,2);
               3          ]
               2          ELSE[
               3             WRITE(IOUT,300) IRL,IZ,IX,(SCDOSE(1,1,IT),SCDOSE2(1,1,IT),IT=1,2);
               3          ]
               2          IF(IFULL.EQ.1)[
               3              WRITE(IOUT,302)
               3                  (SCDOSE(1,1,IT),SCDOSE2(1,1,IT),FRACS(1,1,IT),IT=3,6);
               3              IF(ISOURC.EQ.3)[
               4                  IF(IRL.EQ.NSRCRG)[
               5                      WRITE(IOUT,303)SCDOSE(1,1,7),SCDOSE2(1,1,7);
               5                  ]
               4              ]
               3          ]
               2      ]
               1      ELSE[ "OUTPUT FOR MORE THAN 1 SCORING ZONE"
               2          WRITE(IOUT,400);
               2          IF(IFULL.NE.3)[
               3              IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[WRITE(IOUT,399);]
               3              ELSE[WRITE(IOUT,401);]
               3          ]
               2          IF(IFULL.EQ.1)["dose per entrance region"
               3              WRITE(IOUT,410);
               3              ICHPIN=12;IPAGE=0;
               3              "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);  SET UP THE PRINTER"
               3              WRITE(IOUT,411);
               3              DO IXD=1,NRDOSE[
               4                  DO IZD=1,NZDOSE[
               5                      IZ=IZD-1+NZDMIN;IX=IXD+NRDMIN;
               5                      $GET-IRL(IZ,IX);
               5                      WRITE(IOUT,412) IRL,IZ,IX,
               5                          (SCDOSE(IZD,IXD,IT),IT=1,$MAXIT-1),
               5                          (SCDOSE2(IZ,IX,IT),IT=1,$MAXIT-1),
               5                          (FRACS(IZ,IX,IT),IT=3,6);
               5                  ]
               4              ]
               3              IF(ISOURC.EQ.3)[
               4                  IF(CDSTBL(NSRCRG).EQ.DCHAR)[
               5                      $GET-IX-IZ(NSRCRG);IZD=IZ-NZDMIN+1;IXD=IX-NRDMIN;
               5                      WRITE(IOUT,304)NSRCRG,IZ,IX,
               5                          SCDOSE(IZD,IXD,7),SCDOSE2(IZD,IXD,7);
               5                  ]
               4              ]
               3          ]
               2          ELSE["no dose per entrance region"
               3              IF(IFULL.EQ.3)[
               4                 IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[WRITE(IOUT,:F399B:);]
               4                 ELSE[WRITE(IOUT,:F401B:);]
               4                 WRITE(IOUT,:F402B:);
               4              ]
               3              ELSE [WRITE(IOUT,402);]
               3              "Now output the results"
               3              DO IXD=1,NRDOSE[
               4                  DO IZD=1,NZDOSE[
               5                      IZ=IZD-1+NZDMIN;IX=IXD+NRDMIN;
               5                      $GET-IRL(IZ,IX);
               5                      WRITE(IOUT,403)
               5                      IRL,IZ,IX,(SCDOSE(IZD,IXD,IT),SCDOSE2(IZD,IXD,IT),IT=1,2);
               5                  ]
               4              ]
               3              "Here we output a brief summary to unit 10 for a database"
               3              dose_unit = egs_open_file(10,0,1,'.egsdose');
               3              WRITE(dose_unit,'(80A1)') TITLE;
               3              WRITE(dose_unit,
               3                '('' There are'',I5,'' radial zones, midpoints:'')')NR;
               3              WRITE(dose_unit,'( 8(F9.4,'',''))')((RCYL(I-1)+RCYL(I))/2., I=1,NR);
               3              WRITE(dose_unit,'('' There are '',I5,'' depth regions'')') NZ;
               3              DO IZ = 1,NZ[
               4                WRITE(dose_unit,'('' Depth centered at: '',F12.3)')
               4                     (ZPLANE(IZ)+ZPLANE(IZ+1))/2.;
               4                WRITE(dose_unit,'( 4(1PE10.3,''+/-'',0PF5.2,''% ''))')
               4                     (SCDOSE(IZ,IR,1),SCDOSE2(IZ,IR,1), IR=1,NR);
               4              ]
               3              close(dose_unit);
               3          ]
               2      ] "END OF DOSE SUMMARY"
               1  ] "END OF CONDITIONAL SUMMARY OF DOSE"
               0
               0  IF((IOOPTN.EQ.0).OR.(IOOPTN.EQ.2).OR.(IOOPTN.EQ.4))[
               1     " OUTPUT GRID ONLY IF REQUESTED"
               1     "Grid routine by Aaron Merovitz, 1998"
               1
               1     "1) Set up the arrays"
               1     DO IXD=1, NRDOSE [
               2         DO IZD=1, NZDOSE [
               3             RESULTS(IZD,IXD,1)=SCDOSE(IZD,IXD,1);
               3             RESULTS(IZD,IXD,2)=SCDOSE(IZD,IXD,2);
               3             RESULTS(IZD,IXD,3)=SCKERMA(IZD,IXD,1);
               3             RESULTS(IZD,IXD,4)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
               3             UNCRTY(IZD,IXD,1)=SCDOSE2(IZD,IXD,1);
               3             UNCRTY(IZD,IXD,2)=SCDOSE2(IZD,IXD,2);
               3             UNCRTY(IZD,IXD,3)=SCKERMA2(IZD,IXD,1);
               3             UNCRTY(IZD,IXD,4)=SCDOSEtoKERMA2(IZD,IXD,1);
               3             IF ((IFULL=1)&(IKERMA=0)) [
               4                DO IT=3, 6 [
               5                   RESULTS(IZD,IXD,IT-1)=FRACS(IZD,IXD,IT);
               5                   UNCRTY(IZD,IXD,IT-1)=SCDOSE2(IZD,IXD,IT);
               5                ]
               4             ]
               3             IF ((IFULL=1)&(IKERMA=1)) [
               4                RESULTS(IZD,IXD,2)=SCKERMA(IZD,IXD,1);
               4                RESULTS(IZD,IXD,3)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
               4                UNCRTY(IZD,IXD,2)=SCKERMA2(IZD,IXD,1);
               4                UNCRTY(IZD,IXD,3)=SCDOSEtoKERMA2(IZD,IXD,1);
               4                DO IT=4, 7 [
               5                   RESULTS(IZD,IXD,IT)=FRACS(IZD,IXD,IT-1);
               5                   UNCRTY(IZD,IXD,IT)=SCDOSE2(IZD,IXD,IT-1);
               5                ]
               4             ]
               3             IF (IFULL=3) [
               4                RESULTS(IZD,IXD,4)=SCKERMA(IZD,IXD,2);
               4                RESULTS(IZD,IXD,5)=SCDOSE(IZD,IXD,1)/SCKERMA(IZD,IXD,1);
               4                RESULTS(IZD,IXD,6)=SCDOSE(IZD,IXD,2)/SCKERMA(IZD,IXD,2);
               4                UNCRTY(IZD,IXD,4)=SCKERMA2(IZD,IXD,2);
               4                UNCRTY(IZD,IXD,5)=SCDOSEtoKERMA2(IZD,IXD,1);
               4                UNCRTY(IZD,IXD,6)=SCDOSEtoKERMA2(IZD,IXD,2);
               4             ]
               3         ]
               2     ]
               1     "2) Determine the number of components"
               1     IF (IKERMA=1) [
               2        IF (IFULL=0) [NCOMP=4;]
               2        IF (IFULL=1) [NCOMP=7;]
               2        IF (IFULL=2) [NCOMP=4;]
               2        IF (IFULL=3) [NCOMP=6;]
               2     ]
               1     IF (IKERMA=0) [
               2        IF (IFULL=1) [NCOMP=5;]
               2        ELSE [NCOMP=2;]
               2     ]
               1
               1     "3) Set up the bin indicators"
               1     DO IX=1,NRDOSE+1 [RADIAL_BINS(IX)=RCYL(IX+NRDMIN-1);]
               1     DO IZ=1,NZDOSE+1 [DEPTH_BINS(IZ)=ZPLANE(IZ+NZDMIN-1);]
               1
               1     "4) Set up the labels and the explanations"
               1     IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               2       EXPLANATIONS(1)='Total dose (Gray/incident particle)';
               2     ]
               1     ELSE[
               2       EXPLANATIONS(1)='Total dose (Gray/incident fluence)';
               2     ]
               1     LABELS(1)='T  :';
               1     IF (IFULL=3) [
               2        EXPLANATIONS(2)='Scatter dose (after Compton or fluorecent reabsorbed)';
               2        LABELS(2)='Sca:';
               2     ]
               1     ELSE [EXPLANATIONS(2)='Total dose minus stoppers';LABELS(2)='T-S:';]
               1     EXPLANATIONS(3)='Kerma';LABELS(3)='K  :';
               1     IF (IFULL~=3) [EXPLANATIONS(4)='Dose to kerma';LABELS(4)='D/K:';]
               1     ELSE [EXPLANATIONS(4)='Kerma scatter';LABELS(4)='Ksc:';
               2           EXPLANATIONS(5)='Dose to kerma';lABELS(5)='D/K:';
               2           EXPLANATIONS(6)='Dose to kerma scatter';LABELS(6)='DsKs';
               2     ]
               1     IF (IFULL=1)&(IKERMA=0) [
               2        EXPLANATIONS(2)='% dose from front wall (error is % OF %)';
               2                           LABELS(2)='FT :';
               2        EXPLANATIONS(3)='% dose from outer wall';LABELS(3)='OUT:';
               2        EXPLANATIONS(4)='% dose from back wall';LABELS(4)='BK :';
               2        EXPLANATIONS(5)='% dose from inner wall';LABELS(5)='IN :';
               2     ]
               1     IF (IFULL=1)&(IKERMA=1) [
               2        EXPLANATIONS(2)='Total kerma';LABELS(2)='K  :';
               2        EXPLANATIONS(3)='Total dose to kerma';LABELS(3)='D/K:';
               2        EXPLANATIONS(4)='% dose from front wall (error is % of %)';
               2                         LABELS(4)='FT :';
               2        EXPLANATIONS(5)='% dose from outer wall';LABELS(5)='OUT:';
               2        EXPLANATIONS(6)='% dose from back wall';LABELS(6)='BK :';
               2        EXPLANATIONS(7)='% dose from inner wall';LABELS(7)='IN :';
               2     ]
               1
               1     "5) Make the grid"
               1     CALL ZONEGRID(NRDOSE, NZDOSE, NRDMIN, NZDMIN, NZ, RESULTS,
               1                   UNCRTY, NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS);
               1  ] "end IF IOOPTN=0, 2 or 4"
               0
               0  IF(ILPIN.NE.6)[ write(iout,'(a)') '\f'; "CALL PRNTER(13,6,IOUT,1);"]
               0  IF(IOPLOT.EQ.1)CALL PLOTEN;
               0  "CALL PRNTER(13,6,IOUT,0);"
               0
               0  RETURN;
               0  %I0                                                                            ;
               0  "FORMATS"
               0
               0  90    FORMAT(/' Final bremsstrahlung photons split into ',I3,' photons'/);
               0  100  FORMAT(' ',80A1/' ',T59,$);
               0  105  FORMAT(///T30,'SUMMARY OF DOSE REGION RESULTS'/
               0               ' ',T30,'******************************');
               0  101  FORMAT(' ',80A1/' ',T55,$);
               0  104  FORMAT(/// T30,'Summary of pulse height distribution'/
               0                  T30,'************************************');
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " 100  FORMAT(' ',80A1/' ',T59,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
               0  "        T30,'SUMMARY OF DOSE REGION RESULTS'/
               0  "              ' ',T30,'******************************');
               0  " 101  FORMAT(' ',80A1/' ',T59,$DATEN_FORMAT,1X,$TIMEN_FORMAT//
               0  "        T30,'Summary of pulse height distribution'/
               0  "        T30,'************************************');
               0
               0  200  FORMAT(/' ',T26,'Total # charged particle steps',T58,
               0               1PE10.3,' +/-',0PF6.3,'%'/
               0               ' ',T13,'# of charged particle steps/initial history',T58,
               0               1PE10.3,' +/-',0PF6.3,'%'/
               0               ' ','# of presta-II steps/total # of charged particle steps',
               0                   T61,F7.3,' +/-',0PF6.3,'%');
               0  210  FORMAT(/' ',T19,'# charged particle steps in dose reg.'
               0               ,T58,1PE10.3,' +/-',0PF6.3,'%'/
               0               ' ',T17,'# of steps in dose reg./initial history'
               0               ,T58,1PE10.3,' +/-',0PF6.3,'%'/
               0               ' ',T12,'# of presta-II steps/# of steps in dose reg.',
               0                T61,F7.3,' +/-',0PF6.3,'%');
               0  299  FORMAT(/' Geometrical zone number:',T53,I10/
               0               ' Planar zone number:',T53,I10/
               0               ' Cylndrical zone number:',T53,I10//
               0               ' Total dose (Gray/(source particle)):',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%'/
               0               ' Total dose minus stoppers:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%');
               0  300  FORMAT(/' Geometrical zone number:',T53,I10/
               0               ' Planar zone number:',T53,I10/
               0               ' Cylndrical zone number:',T53,I10//
               0               ' Total dose (Gray/(incident fluence)):',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%'/
               0               ' Total dose minus stoppers:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%');
               0  302  FORMAT( ' Total dose from front planar wall:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
               0               ' Total dose from outside curved wall:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
               0               ' Total dose from back planar wall:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)'/
               0               ' Total dose from inner curved wall:',
               0                       T50,1PE11.4,' +/- ',0PF6.3,'%',1X,'(',0PF5.1,'%)');
               0  303  FORMAT(' Total dose deposited by particles emergent ',
               0               'from the dose/source region:',
               0               T50,1PE11.4,' +/- ',0PF6.3,'%');
               0  304  FORMAT(/' ','Dose scored in source region due to emergent ',
               0              'particles : Z# P# C#    Dose    uncertainty'/' ',
               0              57X,I2,I3,I3,E11.3,E12.3);
               0  400  FORMAT(/' ',T20,'Z# : Geometrical zone number'/
               0               ' ',T20,'P# : Planar zone number'/
               0               ' ',T20,'C# : Cylndrical zone number');
               0  399  FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/
               0               ' ',T20,'T-S: Total dose minus stoppers');
               0  :F399B:  FORMAT(' ',T20,'T  : Total dose (Gray/(source particle))'/
               0               ' ',T20,
               0               'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ');
               0  401  FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/
               0               ' ',T20,'T-S: Total dose minus stoppers');
               0  :F401B:  FORMAT(' ',T20,'T  : Total dose (Gray/(incident fluence))'/
               0               ' ',T20,
               0               'Sca: Scatter dose (after Compton or fluorecent  reabsorbed ');
               0  402  FORMAT(/'  Z# P# C#          T                  T-S'/
               0               ' --- -- -- ------------------- -------------------');
               0  :F402B:  FORMAT(/'  Z# P# C#          T                  Sca'/
               0               ' --- -- -- ------------------- -------------------');
               0  403  FORMAT(' ',I3,2(1X,I2),1X,2(1PE11.4,' +/-',0PF6.3,'% '));
               0  410  FORMAT(' ',T20,'F  : TOTAL DOSE FROM FRONT PLANAR WALL'/
               0               ' ',T20,'O  : TOTAL DOSE FROM OUTSIDE CURVED WALL'/
               0               ' ',T20,'B  : TOTAL DOSE FROM BACK PLANAR WALL'/
               0               ' ',T20,'I  : TOTAL DOSE FROM INNER CURVED WALL');
               0  411  FORMAT(/'  Z# P# C# ',
               0               '     T         T-S         F          O     ',
               0               '     B          I'/
               0               ' --- -- -- ',
               0               '---------- ---------- ---------- ---------- ',
               0               '---------- ----------');
               0  412  FORMAT(' ',I3,2(1X,I2),1X,1PE11.4,5(1X,E10.3)/
               0               '   %ERROR=',
               0               6(3X,0PF6.3,4X)/
               0               '    %DOSE=',21X,4(2X,0PF7.3,2X));
               0  %I4                                                                            ;
               0  END; "END OF SUBROUTINE OSUMRY"
               0  %Q1                                                                            ;
1              0  %E     "dosrznrc.mortran"
               0
               0  "THIS FUNCTION COMPRESSES NON-HOLLERITH STRINGS"
               0  CHARACTER*(*) FUNCTION CMPRES(UNCOMP);
               0  $IMPLICIT-NONE;
               0  CHARACTER*(*) UNCOMP;
               0  $LOGICAL HOLRTH;
               0  $INTEGER INDX,NARG,I,NRES;
               0  HOLRTH=.FALSE.;
               0  INDX=1;
               0  NARG=LEN(UNCOMP);
               0  DO I=1,NARG[
               1      IF(UNCOMP(I:I).EQ.'''') HOLRTH=.NOT.HOLRTH; "HOLLERITH DETECTION"
               1      IF(HOLRTH)["STRING IS HOLLERITH, WRITE ALL CHARACTERS"
               2          CMPRES(INDX:INDX)=UNCOMP(I:I);INDX=INDX+1;
               2          ]
               1      ELSE["STRING IS NON-HOLLERITH, TRANSCRIBE ONLY NON-BLANKS"
               2          IF(UNCOMP(I:I).NE.' ')[CMPRES(INDX:INDX)=UNCOMP(I:I);INDX=INDX+1;]
               2          ]
               1      ]
               0  "FILL WITH BLANKS"
               0  NRES=LEN(CMPRES);
               0  IF(INDX.LE.NRES)[DO I=INDX,NRES[CMPRES(I:I)=' ';]]
               0  RETURN;
               0  END; "END OF FUNCTION CMPRES"
               0  %Q1                                                                            ;
1              0  %E     "dosrznrc.mortran"
               0
               0  ;
               0  "***************************************************************************
               0  "
               0  "                               PLOTPH"
               0  "                               ======
               0  "
               0  SUBROUTINE PLOTPH(TITLE,PDST,PDSTUN,PCUM,PCUMUN,PTOT,PTOTUN,DFEP,DFEPUN,
               0  MAXBIN,SLOTE,BINTOP,IHSTRY,OMEG,OMEGUN,PHEN,PHENUN);
               0  "
               0  "       ROUTINE PLOTS SPECTRUM ON LINEPRINTER AND CREATES A DISK FILE
               0  "       MAXBIN IS NUMBER OF BINS IN SPECTRUM
               0  "       BINTOP IS USED ONLY IF SLOTE IS NON-ZERO
               0  "       SPECTRUM IS NORMALIZED TO PEAK OF UNITY FOR PLOTTING
               0  "
               0  "       OUTPUT FILE ON UNIT 9.
               0  "       FORMAT FOR EACH CALL:
               0  "           TITLE
               0  "           NUMBER OF ENERGY BINS (I5)
               0  "           TOP OF ENERGY BIN, FRACTION OF SPECTRUM IN THIS BIN,UNCERTAINTY
               0  "              ABOVE LINE LOOPED FOR EACH BIN 3(E12.4)
               0  "           HEADER LINE
               0  "           FULL ENRGY PEAK EFFICIENCY PER COUNT IN SPECTRUM, UNCERTAINTY
               0  "           SAME FOR SINGLE ESCAPE, DOUBLE ESCAPE AND 511 KEV PEAKS 2(E12.4)
               0  "
               0  "***************************************************************************
               0
               0  ;
               0  $IMPLICIT-NONE;
               0
               0  CHARACTER SPACE,BAR,LINE(61),SYMBOL(6);
               0  REAL*8 PDST($EBIN),PDSTUN($EBIN),PTOT,PTOTUN,DFEP(4),DFEPUN(4),
               0  PCUM($EBIN),PCUMUN($EBIN),omeg,omegun,phen,phenun;
               0  $REAL BINTOP($EBIN),xplot($EBIN),yplot($EBIN),
               0  errplot($EBIN),SLOTE;
               0  $LONG_INT ihstry;
               0  $INTEGER maxbin;
               0  COMIN/IODAT2/;
               0  character*1 TITLE(80);
               0  character*60 xtitle,ytitle,subtitle,seriestitle,plottitle;
               0  character*80 graphtitle;
               0
               0  $INTEGER  NHIST,IOUT,IB,j,ilev,ipk,iunit,icurvenum,iplttype,iaxistype;
               0  $REAL     HIST,sfac,eb,sum,uncert,binw,histmin;
               0  $INTEGER  egs_open_file;
               0  DATA SPACE/' '/,BAR/'|'/,SYMBOL/$S'*+$-#@'/;
               0  DATA NHIST/61/,HIST/61./,IOUT/1/;
               0
               0  "GET PEAK IN SPECTRUM"
               0  sfac=0;
               0  "********* IK: on many compilers, arguments to the MAX intrinsic MUST be
               0  "              of the same type. "
               0  "DO IB=1,MAXBIN[SFAC = MAX(PDST(IB),SFAC);]"
               0  DO IB=1,MAXBIN [
               1      IF( PDST(IB) > sfac ) [ sfac = PDST(IB); ]
               1      ]
               0
               0  WRITE(IOUT,4) IHSTRY;
               0  WRITE(IOUT,5);  "HEADER FOR PLOT"
               0
               0  DO IB=1,MAXBIN[
               1      IF(SLOTE.GT.0.0)[EB=IB*SLOTE;]ELSE[EB=BINTOP(IB);]
               1      DO J=1,NHIST[LINE(J)=SPACE;"BLANK ENTIRE LINE EACH TIME"]
               1      ILEV=0;
               1      IF(PDST(IB).GT.0.0)[
               2          ILEV=HIST+DLOG10(PDST(IB)/SFAC)*20.+0.5;
               2          "RUNS FROM 1 TO 61 FOR 0.0 TO 1.0"
               2          ]
               1      IF((ILEV.GT.0).AND.(ILEV.LE.NHIST))[LINE(ILEV)=SYMBOL(1);]
               1      "ADD REFERENCE BARS"
               1      DO J=1,4[
               2          ILEV=20*J-19;
               2          IF(LINE(ILEV).EQ.SPACE) LINE(ILEV)=BAR;
               2          ]
               1      WRITE(IOUT,10) LINE,EB,PDST(IB),PDSTUN(IB),PCUM(IB),PCUMUN(IB);
               1      ]"END OF IB LOOP"
               0
               0  WRITE(IOUT,30);
               0  SUM=0.0; DO IPK=1,4[SUM=SUM+DFEP(IPK);]
               0  IF(SUM.GE.0.00005 )[
               1      "THERE ARE SOME COUNTS IN THE PEAKS"
               1      WRITE(IOUT,40) (DFEP(IPK),DFEPUN(IPK),IPK=1,4);
               1      ]
               0  IF(OMEG.EQ.0.0)[
               1      "THIS IS A PARALLEL EXTERNAL BEAM OR INTERNAL SOURCE CASE"
               1      WRITE(IOUT,50) PTOT,PTOTUN;
               1      ]
               0  ELSE[
               1      "EXTERNAL POINT SOURCE GEOMETRY"
               1      UNCERT=SQRT(PTOTUN**2 + OMEGUN**2); "UNCERTAINTY ON RATIO"
               1      WRITE(IOUT,60) OMEG,OMEGUN,PTOT/(4.*3.141593),PTOTUN,PTOT/OMEG,UNCERT;
               1      ]
               0  WRITE(IOUT,70) PHEN,PHENUN;
               0
               0  "
               0  "  OUTPUT RESULTS TO DISK FILE ON UNIT 9
               0  "
               0  "IUNIT=9;"
               0  "OPEN(UNIT=9,file='fort.9',STATUS='UNKNOWN'); "
               0  "needed by absoft compiler for some reason"
               0
               0  "IK: open the plot file using a file name instead of fort.9 "
               0  iunit = egs_open_file(9,0,1,'.egseff');
               0
               0  WRITE(IUNIT,75) TITLE;
               0  WRITE(IUNIT,80)MAXBIN;
               0  "Feb 1992 corrected to output cts/MeV in bin and get file right"
               0  "Jan 99 changed uncertainties to be absolute so plotxvgr can handle"
               0  DO IB=1,MAXBIN[
               1      IF(SLOTE.GT.0.0)[EB=IB*SLOTE;BINW=SLOTE;]
               1      ELSE[
               2          EB=BINTOP(IB);IF(IB=1)[BINW=BINTOP(1);]ELSE[BINW=EB-BINTOP(IB-1);]
               2          ]"end block for SLOTE"
               1      IF(BINW=0.0)[BINW = 1E-9;]
               1      xplot(IB) = EB;
               1      yplot(IB) = PDST(IB)/BINW;
               1      IF (PDST(IB) ~= 0.0) [errplot(IB)=PDSTUN(IB)*PDST(IB)/(BINW*100.);]
               1      ELSE [errplot(IB) = 0.0;]
               1      WRITE(IUNIT,90) EB,PDST(IB)/BINW,errplot(IB);
               1      ]
               0  WRITE(IUNIT,100) (DFEP(IPK),DFEPUN(IPK),IPK=1,4),PTOT,PTOTUN;
               0  close(iunit);
               0
               0  "Now setup to create a proper xvgr plot of the spectrum on unit 22"
               0  iunit = egs_open_file(22,0,1,'.plotphd');
               0
               0  DO J=1,80[graphtitle(j:j)=title(j);]
               0
               0  xtitle='energy/MeV';
               0  ytitle='cts/MeV';
               0  subtitle='pulse height distribution from dosrznrc';
               0  icurvenum=0;
               0  iplttype=1; "histogram=1, XY-plot=0"
               0  histmin=0.0;
               0  iaxistype = 0; "no logs"
               0  seriestitle=' ';
               0  call xvgrplot(xplot,yplot,errplot,MAXBIN,icurvenum,seriestitle,
               0  xtitle,ytitle,graphtitle,subtitle,iunit,iplttype,histmin,iaxistype);
               0  "iaxistype is not set, is this intended??? "
               0  close(iunit);
               0
               0  "FORMATS"
               0  4    FORMAT(/I12,' HISTORIES ANALYSED'/);
               0  5    FORMAT(/65X,'EBIN'/' 3',19X,'2',19X,'1',7X,
               0  '-LOG',8X,'0    TOP',9X,'PDST              CUMULATIVE');
               0  10   FORMAT(1X,61A1,F8.4,1X,2(0PF11.4,' (',F6.3,'%)'));
               0  20   FORMAT(/62X,'TOTALS',2X,6(I4,3X));
               0  30   FORMAT(/' PLOT NORMALIZED TO PEAK OF ONE, ',
               0  'PDST IS NORMALIZED TO UNIT AREA'/);
               0  40   FORMAT(' PEAK EFFICIENCIES PER COUNT IN SPECTRUM'//
               0  ' FULL ENERGY PEAK',T30,F10.4,'(+-',F6.3,'%)'/
               0  ' SINGLE ESCAPE PK',T30,F10.4,'(+-',F6.3,'%)'/
               0  ' DOUBLE ESCAPE PK',T30,F10.4,'(+-',F6.3,'%)'/
               0  ' 511 KEV PK'      ,T30,F10.4,'(+-',F6.3,'%)'/);
               0  50   FORMAT(/'  FRACTION OF INITIAL PARTICLES (HITTING DETECTOR HOUSING ',
               0  '(if parallel beam) WHICH CAUSE PULSE = ',0PF14.4,'(',F6.3,'%)');
               0  60   FORMAT(/' SOLID ANGLE SUBTENDED BY DETECTOR HOUSING =                    ',
               0  1PE13.3,'(',0PF5.1,'%)'/
               0  /' FRACTION OF PARTICLES INTO 4-PI WHICH CAUSE A PULSE =          ',
               0  1PE13.3,'(',0PF5.1,'%)'/
               0  /' FRACTION OF PARTICLES INCIDENT ON HOUSING WHICH CAUSE A PULSE =',
               0  1PE13.3,'(',0PF5.1,'%)');
               0  70   FORMAT(/'  ENERGY DEPOSITED IN DETECTOR PER INITIAL PARTICLE:',
               0  0PF14.5,' MeV (+-',F6.3,'%)');
               0  75   FORMAT(1X,80A1);
               0  80   FORMAT(I5,T40,'# energy bins to follow, bin top,cts/MeV,uncertainty(abs)');
               0  90   FORMAT(3(E12.4,','));
               0  100  FORMAT( 1X,'NOW INDIVIDUAL PEAK AND TOTAL EFFICIENCIES'/ (2E12.4));
               0
               0  RETURN;END;
               0
1              0  %E     "dosrznrc.mortran"
               0  "******************************************************************************
               0  "
               0  "                       PLOTSN
               0  "
               0  "       THIS ROUTINE WILL PREPARE A PLOT AND/OR FILE OF DATA POINTS OF
               0  "       DOSE VS. DEPTH CORRESPONDING TO A NUMBER OF CHOSEN RADIAL AND
               0  "       PLANAR ZONES
               0  "
               0  "
               0  "  PLOT CONTROL DELIMETERS:   :start plot control:
               0  "                             :stop plot control:
               0  "
               0  "*******************************************************************************
               0  "                             PLOT CONTROL INPUTS
               0  "                             *******************
               0  "*******************************************************************************
               0  "
               0  "CARD PL1
               0  "
               0  "   PLOTTING
               0  "          = Off         (0)   NO PLOTS OR PLOT FILES TO BE PREPARED
               0  "          = On          (1)   PLOTTING TO BE PREPARED OR PRINTED
               0  "
               0  "
               0  "CARD PL2       (ONLY IF   PLOTTING= On)
               0  "
               0  "   LINE PRINTER OUTPUT
               0  "          = Off         (0)   DON'T PLOT IN EXECUTION OUTPUT
               0  "          = On          (1)   DO PLOT IN EXECUTION OUTPUT
               0  "
               0  "
               0  "CARD PL3       (ONLY IF   PLOTTING= On)
               0  "
               0  "   EXTERNAL PLOTTER OUTPUT
               0  "          = Off         (0)   DON'T PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
               0  "          = On          (1)   PREPARE PLOT FILES FOR AN EXTERNAL PLOTTER
               0  "
               0  "
               0  "CARD PL4       (ONLY IF   EXTERNAL PLOTTER OUTPUT= On)
               0  "
               0  "   EXTERNAL PLOT TYPE
               0  "          = Point       (1)   POINT PLOT ON EXTERNAL PLOTTER
               0  "          = Histogram   (2)   HISTOGRAM ON EXTERNAL PLOTTER
               0  "          = Both        (3)   BOTH POINT PLOT AND HISTOGRAM ON EXTERNAL PLOTTER
               0  "
               0  "
               0  "CARD PL5       (ONLY IF   PLOTTING= On)
               0  "
               0  "   PLOT RADIAL REGION IX  (M)  RADIAL PLANE NUMBERS TO PLOT
               0  "                               (= 0 FOR NO PLOTS)
               0  "
               0  "
               0  "CARD PL6       (ONLY IF   PLOTTING= On)
               0  "
               0  "   PLOT PLANAR REGION IZ  (M)  PLANAR SLAB NUMBERS TO PLOT
               0  "                               (= 0 FOR NO PLOTS)
               0  "
               0  "
               0  "       VERSION 01      ADAPTED FROM DOSRZ                           6/84  E.F.
               0  "       VERSION 02      MACHINE-INDEPENDENT VARIABLE FORMAT CODED   10/88  AFB
               0  "       VERSION 03      NEW INPUT ROUTINE (GET_INPUTS)              04/25 AM/DR
               0  "
               0  "
               0  "*******************************************************************************
               0  ;SUBROUTINE PLOTSN;
               0
               0  $IMPLICIT-NONE;
               0
               0  COMIN/GetInput/;
               0
               0  "***************************************************************************"
               0  "*                         User defined MACROS                             *"
               0  "***************************************************************************"
               0  REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0
               0  "***************************************************************************"
               0  "*                Variables used to point to the inputs                    *"
               0  "***************************************************************************"
               0  INTEGER NUM_IOPLOT,
               0  NUM_IPLTLP,
               0  NUM_IPLTPL,
               0  NUM_IPLPHB,
               0  NUM_IPLTRAD,
               0  NUM_IPLTPLN;
               0  "--------------------------------------------------------------------------"
               0  ;
               0  INTEGER I;
               0  INTEGER ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM, CHECK;
               0  integer int;
               0  INTEGER IX2CHAR, IZ2CHAR;
               0  LOGICAL NEGVAL;
               0  CHARACTER*103 FMT120;
               0  CHARACTER*103 FMT121;
               0  CHARACTER*4 CH_IX, CH_IZ;
               0  CHARACTER*1 a(3);
               0  CHARACTER*60 SERIESTITLE, XTITLE, YTITLE, SUBTITLE;
               0  CHARACTER*80 GRAPHTITLE;
               0  "CHARACTER*103 CMPRES,FMT;"
               0  CHARACTER CMPRES*103,FMT*103;
               0  $REAL XCOORD($PLTDIM), YCOORD($PLTDIM), UNCERT($PLTDIM);
               0  $TYPE HCHAR,PCHAR;
               0  $TYPE DIGITS(10);
               0  COMIN/GEOM,IODAT1,IODAT2,PRINTC,PLOTC,SCORE,USER/;
               0
               0  " Added declarations for implicit none, IK Jan 5 2000"
               0  $INTEGER IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR,IZ,IZZ;
               0  $REAL    TDSMAX,HISTXMIN;
               0
               0  $INTEGER egs_open_file;
               0
               0  DATA DIGITS /'0','1','2','3','4','5','6','7','8','9'/;
               0  DATA HCHAR/'H'/,PCHAR/'P'/;
               0
               0  " IK: "
               0  " With the new EGSnrc version we can not any longer rely on variables "
               0  " being static. I'm too lazy to figure out which variables need to be "
               0  " static here => save them all"
               0  save NUM_IOPLOT,NUM_IPLTLP,NUM_IPLTPL,NUM_IPLPHB,NUM_IPLTRAD,NUM_IPLTPLN,
               0  I,ICOL1, ICOL2, NPTS, PLTYPE, IAXISTYPE, UNITNUM, CURVENUM, CHECK,
               0  IX2CHAR, IZ2CHAR, NEGVAL, FMT120, FMT121, CH_IX, CH_IZ, a,
               0  SERIESTITLE, XTITLE, YTITLE, SUBTITLE, FMT,
               0  XCOORD,YCOORD,UNCERT,HCHAR,PCHAR,DIGITS,
               0  IPLTUNX,IPLTUN,J,IZD,IXD,NPPAGE,IX,ICOUNT,IXR,IZ,IZZ,
               0  TDSMAX,HISTXMIN,int;
               0
               0  "CHARACTER ARRAYS REQUIRED FOR RUN-TIME FORMATTING"
               0  ;
               0
               0  "THE <> SYNTAX IS VALID VAX-ENTENDED FORTRAN AND MAY BE USED DIRECTLY."
               0  "FOR STANDARD FORTRAN, THE <> STRUCTURES ARE REPLACED DURING EXECUTION."
               0  ;
               0  DATA FMT120/
               0  *'(1X,F7.3,T10,''|'',T35,''|'',T59,''|'',T83,''|'',T107,
               0  *''|'',T131,''|'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
               0  DATA FMT121/
               0  *'(1X,F7.3,T10,''+'',T35,''+'',T59,''+'',T83,''+'',T107,
               0  *''+'',T131,''+'',T<ICOL2+10>,''S'',T<ICOL1+10>,''T'')'/
               0  ;
               0
               0  DELIMETER='PLOT CONTROL';
               0
               0  IVAL=0;
               0  IVAL=IVAL+1;
               0  NUM_IOPLOT=IVAL;
               0  VALUES_SOUGHT(IVAL)='PLOTTING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0  $GET_INPUT(NUM_IOPLOT);
               0  IOPLOT=VALUE(NUM_IOPLOT,1);
               0
               0  OUTPUT;(/' *** INPUT for plotting ***');
               0  IF (IOPLOT.EQ.1) [OUTPUT;(/'PLOTTING WILL BE DONE');]
               0
               0  IF(IOPLOT.EQ.0)[
               1      OUTPUT;(/' NO PLOTTING OR PLOT PREPARATION WILL BE DONE');
               1      ]
               0  ELSE [
               1      OUTPUT;(//' *** INPUT which types of plots ***');
               1
               1      IVAL=IVAL+1;
               1      NUM_IPLTLP=IVAL;
               1      VALUES_SOUGHT(IVAL)='LINE PRINTER OUTPUT';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      ALLOWED_INPUTS(IVAL,0)='OFF';
               1      ALLOWED_INPUTS(IVAL,1)='ON';
               1
               1      $GET_INPUT(NUM_IPLTLP);
               1      IPLTLP=VALUE(NUM_IPLTLP,1);
               1
               1      IF(IPLTLP=0) [OUTPUT;(/' NO LINEPRINTER PLOTS WILL BE DRAWN');]
               1      ELSE [OUTPUT;(/' LINEPRINTER PLOTS WILL BE DRAWN');]
               1
               1      IVAL=IVAL+1;
               1      NUM_IPLTPL=IVAL;
               1      VALUES_SOUGHT(IVAL)='EXTERNAL PLOTTER OUTPUT';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      ALLOWED_INPUTS(IVAL,0)='OFF';
               1      ALLOWED_INPUTS(IVAL,1)='ON';
               1
               1      $GET_INPUT(NUM_IPLTPL);
               1      IPLTPL=VALUE(NUM_IPLTPL,1);
               1
               1      IF (IPLTPL=0) [OUTPUT;(/' No plotter files will be prepared');]
               1      ELSE [
               2          OUTPUT;(/' Files will be prepared for external plotter');
               2          IPLTUNX=23; "xvgr plot file"
               2          IPLTUN=3; "OUTPUT TO UNIT 3 FOR PLOTTER"
               2          OUTPUT;(/' *** INPUT type of plot ***');
               2
               2          IVAL=IVAL+1;
               2          NUM_IPLPHB=IVAL;
               2          VALUES_SOUGHT(IVAL)='EXTERNAL PLOT TYPE';
               2          NVALUE(IVAL)=1;
               2          TYPE(IVAL)=3;
               2          ALLOWED_INPUTS(IVAL,1)='POINT';
               2          ALLOWED_INPUTS(IVAL,2)='HISTOGRAM';
               2          ALLOWED_INPUTS(IVAL,3)='BOTH';
               2
               2          $GET_INPUT(NUM_IPLPHB);
               2          IPLPHB=VALUE(NUM_IPLPHB,1);
               2
               2          OUTPUT IPLPHB;
               2          (/' POINT PLOT(1)/HISTOGRAM(2)/BOTH(3) WILL BE PREPARED:',I2);
               2          ]
               1
               1      OUTPUT;(/' *** INPUT which plots to do ***');
               1
               1      IVAL=IVAL+1;
               1      NUM_IPLTRAD=IVAL;
               1      VALUES_SOUGHT(IVAL)='PLOT RADIAL REGION IX';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=NR;
               1      DEFAULT(IVAL)=NR;
               1      NVALUE(IVAL)=0;
               1
               1      $GET_INPUT(NUM_IPLTRAD);
               1      NPLOTR=NVALUE(NUM_IPLTRAD);
               1      IF (VALUE(NUM_IPLTRAD,1) > 0) [
               2          DO J=1, NPLOTR [
               3              IPLOTR(J)=VALUE(NUM_IPLTRAD,J);
               3              IF (IPLOTR(J).LT.NRDMIN+1.OR.IPLOTR(J).GT.NRDMAX) [
               4                  OUTPUT IPLOTR(J);(
               4                  ' ******************************************************'/
               4                  ' ** WARNING: DOSE IS NOT SCORED IN RADIAL REGION ',I3,' **'/
               4                  ' **          DOSE WILL NOT BE PLOTTED FOR THIS REGION *'/
               4                  ' ******************************************************'/)
               4                  IPLOTR(J)=0;
               4                  ]
               3              ELSE[
               4                  OUTPUT IPLOTR(J);('PLOTTING RADIAL ZONE ', I3);
               4                  IPLOTR(J)=IPLOTR(J)-NRDMIN;
               4                  ]
               3
               3              ]
               2          $SKIP-LINE;
               2          ]
               1      ELSE [NPLOTR=0;]
               1
               1      IVAL=IVAL+1;
               1      NUM_IPLTPLN=IVAL;
               1      VALUES_SOUGHT(IVAL)='PLOT PLANAR REGION IZ';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=NZ;
               1      DEFAULT(IVAL)=NZ;
               1      NVALUE(IVAL)=0;
               1
               1      $GET_INPUT(NUM_IPLTPLN);
               1      NPLOTZ=NVALUE(NUM_IPLTPLN);
               1      IF (VALUE(NUM_IPLTPLN,1) > 0) [
               2          DO J=1, NPLOTZ [
               3              IPLOTZ(J)=VALUE(NUM_IPLTPLN,J);
               3              IF (IPLOTZ(J).LT.NZDMIN.OR.IPLOTZ(J).GE.NZDMAX) [
               4                  OUTPUT IPLOTZ(J);(
               4                  ' ******************************************************'/
               4                  ' ** WARNING: DOSE IS NOT SCORED IN PLANAR REGION ',I3,' **'/
               4                  ' **          DOSE WILL NOT BE PLOTTED IN THIS REGION **'/
               4                  ' ******************************************************'/)
               4                  IPLOTZ(J)=0;
               4                  ]
               3              ELSE[
               4                  OUTPUT IPLOTZ(J);('PLOTTING PLANAR ZONE ', I3);
               4                  IPLOTZ(J)=IPLOTZ(J)-NZDMIN+1;
               4                  ]
               3
               3              ]
               2          $SKIP-LINE;
               2          ]
               1      ELSE [NPLOTZ=0;]
               1      ]  "END IOPLOT = 1"
               0
               0  RETURN;
               0
               0  ENTRY PLOTEN;
               0  "============"
               0
               0  "CALL PRNTER(16,6,IOUT,0);"
               0
               0  TDSMAX=0.0;
               0  DO IZD=1,NZDOSE[
               1      DO IXD=1,NRDOSE[
               2          "GET GLOBAL MAXIMUM"
               2          IF(TDSMAX.LT.SCDOSE(IZD,IXD,1))[TDSMAX=SCDOSE(IZD,IXD,1);]
               2          ]
               1      ]
               0
               0  IF(IPLTLP.EQ.1)[ "Do lineprinter plots"
               1      IF(NPLOTR.NE.0)[
               2          "PLOT DEPTH-DOSE"
               2          write(iout,100) title; call egs_fdate(iout); write(iout,106) tdsmax;
               2
               2          " ********** IK: using wrapper for date and time routines.
               2          " Was:
               2          " WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;
               2
               2          IF(TDSMAX.EQ.0.0)[WRITE(IOUT,130);RETURN; "NO DATA TO PLOT"]
               2          NPPAGE=(66-3-2)/(4+NZDOSE);
               2          IX=1;ICOUNT=0;
               2          DO IXR=1,NPLOTR[
               3              IX=IPLOTR(IXR);
               3              IF(IX>0)[
               4                  IF(ICOUNT.GE.NPPAGE)[
               5                      ICOUNT=0;
               5                      write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
               5                      " ********** IK: using wrapper for date and time routines.
               5                      " Was:
               5                      " WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;
               5                      ]
               4                  ICOUNT=ICOUNT+1;
               4                  IF((ISOURC.EQ.2).OR.(ISOURC.EQ.4))[WRITE(IOUT,110) RCYL(IX+NRDMIN);]
               5                      ELSE[WRITE(IOUT,102)IX+NRDMIN,RCYL(IX+NRDMIN);]
               4                  DO IZ=1,NZDOSE[
               5                      ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999);
               5                      ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999);
               5                      IF(MOD(IZ,5).NE.0)[
               6                          WRITE(FMT120(72:81),'(I10)')ICOL2+10;
               6                          WRITE(FMT120(88:97),'(I10)')ICOL1+10;
               6                          FMT=CMPRES(FMT120);
               6                          WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN);
               6                          ]
               5                      ELSE[
               6                          WRITE(FMT121(72:81),'(I10)')ICOL2+10;
               6                          WRITE(FMT121(88:97),'(I10)')ICOL1+10;
               6
               6                          FMT=CMPRES(FMT121);
               6                          WRITE(IOUT,FMT)ZPLANE(IZ+NZDMIN);
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1
               1      "PLOT RADIUS-DOSE"
               1
               1      IF(NPLOTZ.NE.0)[
               2          write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
               2          " ********** IK: using wrapper for date and time routines.
               2          " Was: WRITE(IOUT,100) TITLE,TIMEN,DATEN,TDSMAX;
               2          NPPAGE=(66-3-2)/(4+NRDOSE);
               2          IZ=1;ICOUNT=0;
               2          DO IZZ=1,NPLOTZ[
               3              IZ=IPLOTZ(IZZ);
               3              IF(IZ>0)[
               4                  IF(ICOUNT.GE.NPPAGE)[
               5                      ICOUNT=0;
               5                      write(iout,100); call egs_fdate(iout); write(iout,106) tdsmax;
               5                      " ********** IK: using wrapper for date and time routines.
               5                      " Was: WRITE(IOUT,100)TITLE,TIMEN,DATEN,TDSMAX;
               5                      ]
               4                  ICOUNT=ICOUNT+1;
               4                  WRITE(IOUT,103)IZ+NZDMIN-1,ZPLANE(IZ+NZDMIN-1),ZPLANE(IZ+NZDMIN);
               4                  DO IX=1,NRDOSE[
               5                      ICOL1=IDINT(SCDOSE(IZ,IX,1)/TDSMAX*120.+.999);
               5                      ICOL2=IDINT(SCDOSE(IZ,IX,2)/TDSMAX*120.+.999);
               5                      IF(MOD(IX,5).NE.0)[
               6                          WRITE(FMT120(72:81),'(I10)')ICOL2+10;
               6                          WRITE(FMT120(88:97),'(I10)')ICOL1+10;
               6
               6                          FMT=CMPRES(FMT120);
               6                          WRITE(IOUT,FMT)RCYL(IX+NRDMIN);
               6                          ]
               5                      ELSE[
               6                          WRITE(FMT121(72:81),'(I10)')ICOL2+10;
               6                          WRITE(FMT121(88:97),'(I10)')ICOL1+10;
               6
               6                          FMT=CMPRES(FMT121);
               6                          WRITE(IOUT,FMT)RCYL(IX+NRDMIN);
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ] "end of lineprinter plots"
               0
               0  "IPLPHB     = 1  point plot on external plotter
               0  "           = 2  histogram on external plotter
               0  "           = 3  do both
               0
               0  IF(IPLTPL.EQ.1) [ "plots for external plotter (0 if none)"
               1
               1      DO I=1,80[GRAPHTITLE(I:I)=TITLE(I);]
               1
               1      J=0; "J keeps track of which plot we are on"
               1      CURVENUM=0;  "counter for the curve # of the graph"
               1      IF(NPLOTR > 0) [ "there are depth-dose plots on plotter"
               2          IPLTUNX = egs_open_file(23,0,1,'_dd.plotdat');
               2          "write to unit IPLTUNX "
               2          DO IXR=1,NPLOTR [
               3              IX=IPLOTR(IXR);
               3              IF(IX>0)[
               4
               4                  " For point plots "
               4
               4                  IF((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3)) [ "do point plot"
               5                      "Put out a data set to be read by xvgr: AM Jan 98"
               5                      DO IZ = 1, NZDOSE [
               6                          XCOORD(IZ) = (ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
               6                          YCOORD(IZ) = SCDOSE(IZ,IX,1);
               6                          UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
               6                          ]
               5
               5                      "Convert radial zone number(IX) to a character string"
               5                      IX2CHAR=IX+NRDMIN; $CONVERT_INT(IX2CHAR)_TO_CHAR(CH_IX);
               5
               5                      "For complete summary of the following variables see"
               5                      "xvgrplot.mortran"
               5
               5                      NPTS=NZDOSE;            "number of points per graph"
               5                      SERIESTITLE='dose at r # ' // CH_IX;
               5                      XTITLE='depth/cm';
               5                      IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               6                          YTITLE='dose per incident particle/Gy';
               6                          ]
               5                      ELSE[
               6                          YTITLE='dose per incident fluence/Gy cm\S2\N';
               6                          ]
               5                      " --------------------------> "
               5                      call egs_get_fdate(SUBTITLE);
               5                      SUBTITLE='dose vs. depth on '//SUBTITLE(1:24);
               5                      UNITNUM=IPLTUNX;        "Output file"
               5                      PLTYPE=0;               "histogram=1, XY-plot=0"
               5                      HISTXMIN=ZPLANE(1);     "value of lower X-bin (histograms only)"
               5                      IAXISTYPE=0;            "0 for no logs"
               5
               5                      "plot XY-graph"
               5                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               5                      NPTS, CURVENUM, SERIESTITLE,
               5                      XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               5                      UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               5
               5                      CURVENUM=CURVENUM+1;
               5
               5                      IF(IKERMA = 1)["scored kerma so plot it too"
               6
               6                          "set up the arrays that are to be passed to XVGR"
               6                          DO IZ=1, NZDOSE [
               7                              XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
               7                              YCOORD(IZ)=SCKERMA(IZ,IX,1);
               7                              UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
               7                              ]
               6
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='kerma at r # ' // CH_IX;
               6
               6                          "plot XY-graph"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          DO IZ=1, NZDOSE [
               7                              XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;
               7                              IF(SCKERMA(IZ,IX,1)~=0.0)[
               8                                  YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
               8                                  UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)*
               8                                  (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
               8                                  ]
               7                              ELSE[
               8                                  YCOORD(IZ)=0.;
               8                                  UNCERT(IZ)=0.;
               8                                  ]
               7                              ]
               6
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='dose/kerma at r # ' // CH_IX;
               6
               6                          "plot XY-graph"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          ] "end IKERMA = 1 block within point plots"
               5
               5                      ] "end of IPLPHB=1 OR 3 i.e. end of point plots
               4
               4                  "Now plot histograms if requested"
               4
               4                  IF((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3)) ["do histograms"
               5                      "Put out a data set to be read by xvgr  AM Jan 98"
               5                      DO IZ = 1, NZDOSE [
               6                          XCOORD(IZ) = ZPLANE(IZ+NZDMIN);
               6                          YCOORD(IZ) = SCDOSE(IZ,IX,1);
               6                          UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
               6                          "absolute uncertainty needed for plotting"
               6                          ]
               5
               5                      "Convert radial zone number(IX) to a character string"
               5                      IX2CHAR=IX+NRDMIN; $CONVERT_INT(IX2CHAR)_TO_CHAR(CH_IX);
               5
               5                      "For complete summary of the following variables see"
               5                      "xvgrplot.mortran"
               5
               5                      NPTS=NZDOSE;            "number of points per graph"
               5                      SERIESTITLE='dose at r # ' // CH_IX;
               5                      XTITLE='depth/cm';
               5                      IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               6                          YTITLE='dose per incident particle/Gy';
               6                          ]
               5                      ELSE[
               6                          YTITLE='dose per incident fluence/Gy cm\S2\N';
               6                          ]
               5                      " ----------------------- >
               5                      call egs_get_fdate(SUBTITLE);
               5                      SUBTITLE='dose vs. depth on '//SUBTITLE(1:24);
               5                      UNITNUM=IPLTUNX;        "Output file"
               5                      PLTYPE=1;               "histogram=1, XY-plot=0"
               5                      HISTXMIN=ZPLANE(1);     "value of lower X-bin(for HIST. only)"
               5                      IAXISTYPE=0;            "0 for no logs"
               5
               5                      "plot histogram"
               5                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               5                      NPTS, CURVENUM, SERIESTITLE,
               5                      XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               5                      UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               5
               5                      CURVENUM=CURVENUM+1;
               5
               5                      IF(IKERMA = 1)[  "plot kerma results too if there"
               6                          "set up the arrays that are to be passed to XVGR"
               6                          DO IZ=1, NZDOSE [
               7                              XCOORD(IZ)=ZPLANE(IZ+NZDMIN);
               7                              YCOORD(IZ)=SCKERMA(IZ,IX,1);
               7                              UNCERT(IZ)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
               7                              ]
               6
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='kerma at r # ' // CH_IX;
               6
               6                          "plot histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          "now plot ratio of D on K "
               6
               6                          DO IZ=1, NZDOSE [
               7                              "XCOORD(IZ)=(ZPLANE(IZ+NZDMIN-1)+ZPLANE(IZ+NZDMIN))/2.;"
               7                              XCOORD(IZ)=ZPLANE(IZ+NZDMIN);  "fixed July 2011 DWOR"
               7                              IF(SCKERMA(IZ,IX,1)~=0.)[
               8                                  YCOORD(IZ)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
               8                                  UNCERT(IZ)=SCDOSEtoKERMA2(IZ,IX,1)*
               8                                  (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
               8                                  ]
               7                              ELSE[ "kerma = 0 case" YCOORD(IZ)=0.;UNCERT(IZ)=0.;]
               7                              ]
               6
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='dose/kerma at r # ' // CH_IX;
               6
               6                          "plot histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          ]"end of kerma output"
               5
               5                      IF(IFULL = 3)[  "plot scatter primary results"
               6                          "set up the arrays that are to be passed to XVGR"
               6                          "first get primary dose as  difference"
               6                          DO IZ = 1, NZDOSE [
               7                              XCOORD(IZ) = ZPLANE(IZ+NZDMIN);
               7                              YCOORD(IZ) = SCDOSE(IZ,IX,1) - SCDOSE(IZ,IX,2);"tot-scat"
               7                              "following being lazy, just using uncert on total"
               7                              UNCERT(IZ) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
               7                              "absolute uncertainty needed for plotting"
               7                              ]
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='primary dose at r # ' // CH_IX;
               6
               6                          "plot histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6                          "now get just scatter dose"
               6                          DO IZ = 1, NZDOSE [
               7                              XCOORD(IZ) = ZPLANE(IZ+NZDMIN);
               7                              YCOORD(IZ) = SCDOSE(IZ,IX,2);
               7                              UNCERT(IZ) = SCDOSE2(IZ,IX,2)*SCDOSE(IZ,IX,2)/100.;
               7                              "absolute uncertainty needed for plotting"
               7                              ]
               6
               6                          NPTS=NZDOSE;
               6                          SERIESTITLE='scatter dose at r # ' // CH_IX;
               6
               6                          "plot histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          ]"end of primary/scatter components output"
               5
               5
               5                      ] "END OF IPLPHB=2 OR 3"
               4                  ] "END OF IF IX>0"
               3              ] "END OF IXR LOOP"
               2          close(23);
               2          ] "end of NPLOTR.NE.0"
               1
               1      CURVENUM=0;
               1      IF(NPLOTZ > 0) [ "RADIAL PLOTS FOR PLOTTER"
               2          IPLTUNX = egs_open_file(23,0,1,'_rad.plotdat');
               2          DO IZZ=1,NPLOTZ [
               3              IZ=IPLOTZ(IZZ);
               3              IF(IZ>0)[
               4                  IF((IPLPHB.EQ.1).OR.(IPLPHB.EQ.3)) [
               5                      "POINT PLOTS"
               5                      "Put out a data set to be read by xvgr  AM Jan 98"
               5                      "OPEN(UNIT=IPLTUNX, file='fort.23', STATUS='UNKNOWN');"
               5
               5                      "set up the arrays that are to be passed to XVGR"
               5                      DO IX = 1, NRDOSE ["recall NRDMIN default is 0 check?"
               6                          "rcyl(0) is handled below as HISTXMIN"
               6                          "this is for point plots"
               6                          XCOORD(IX) = (RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;
               6                          YCOORD(IX) = SCDOSE(IZ,IX,1);
               6                          UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
               6                          ]
               5
               5                      "Convert planar zone number(IZ) to a character string"
               5                      IZ2CHAR=IZ+NZDMIN-1; $CONVERT_INT(IZ2CHAR)_TO_CHAR(CH_IZ);
               5
               5                      "For complete summary of the following variables see"
               5                      "XVGRPLOT.MORTRAN"
               5
               5                      NPTS=NRDOSE;            "number of points per graph"
               5                      SERIESTITLE='dose at z # ' // CH_IZ;
               5                      XTITLE='radius/cm';
               5                      IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               6                          YTITLE='dose per incident particle/Gy';
               6                          ]
               5                      ELSE[
               6                          YTITLE='dose per incident fluence/Gy cm\S2\N';
               6                          ]
               5                      " -------------------------- >
               5                      call egs_get_fdate(SUBTITLE);
               5                      SUBTITLE='dose vs. radius on '//SUBTITLE(1:24);
               5                      UNITNUM=IPLTUNX;        "Output file"
               5                      PLTYPE=0;                 "histogram=1, XY-plot=0"
               5                      HISTXMIN=RCYL(NRDMIN);       "value of lower X-bin(HIST only)"
               5                      IAXISTYPE=0;             "0 for no logs"
               5
               5                      "plot XY-graph"
               5                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               5                      NPTS, CURVENUM, SERIESTITLE,
               5                      XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               5                      UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               5
               5                      CURVENUM=CURVENUM+1;
               5
               5                      IF(IKERMA = 1)[
               6                          "set up the arrays that are to be passed to XVGR"
               6                          "we are doing point plots"
               6                          DO IX=1, NRDOSE [
               7                              XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;
               7                              YCOORD(IX)=SCKERMA(IZ,IX,1);
               7                              UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
               7                              ]
               6
               6                          SERIESTITLE='kerma at z # ' // CH_IZ;
               6
               6                          "plot kerma plot"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          "now plot dose/kerma"
               6                          DO IX=1, NRDOSE [
               7                              "following redundant since use same values as just above"
               7                              "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
               7                              IF(SCKERMA(IZ,IX,1)~=0.)[
               8                                  YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
               8                                  UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)*
               8                                  (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
               8                                  "SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)*100.;
               8                                  ]
               7                              ELSE[ YCOORD(IX)=0.; UNCERT(IX)=0.; ]
               7                              ]
               6
               6                          SERIESTITLE='dose/kerma at z # ' // CH_IZ;
               6
               6                          "plot dose/kerma graph"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          ]"end of kerma plot"
               5                      ] "END OF IPLPHB=1 OR 3 LOOP for point plots"
               4
               4                  IF((IPLPHB.EQ.2).OR.(IPLPHB.EQ.3)) [ "now do histogram plots"
               5                      "Put out a data set to be read by xvgr  AM Jan 98"
               5                      DO IX = 1, NRDOSE [
               6                          XCOORD(IX) = RCYL(NRDMIN+IX);
               6                          YCOORD(IX) = SCDOSE(IZ,IX,1);
               6                          UNCERT(IX) = SCDOSE2(IZ,IX,1)*SCDOSE(IZ,IX,1)/100.;
               6                          ]
               5
               5                      "Convert planar zone number(IZ) to a character string"
               5                      IZ2CHAR=IZ+NZDMIN-1; $CONVERT_INT(IZ2CHAR)_TO_CHAR(CH_IZ);
               5
               5                      "For complete summary of the following variables see"
               5                      "XVGRPLOT.MORTRAN"
               5
               5                      NPTS=NRDOSE;            "number of points per graph"
               5                      SERIESTITLE='dose at z # ' // CH_IZ;
               5                      XTITLE='radius/cm';
               5                      IF(ISOURC=3|ISOURC=21|ISOURC=22|ISOURC=23)[
               6                          YTITLE='dose per incident particle/Gy';
               6                          ]
               5                      ELSE[
               6                          YTITLE='dose per incident fluence/Gy cm\S2\N';
               6                          ]
               5                      " ------------------------- >
               5                      call egs_get_fdate(SUBTITLE);
               5                      SUBTITLE='dose vs radius on '//SUBTITLE(1:24);
               5                      UNITNUM=IPLTUNX;        "Output file"
               5                      PLTYPE=1;                 "histogram=1, XY-plot=0"
               5                      HISTXMIN=RCYL(NRDMIN);       "value of lower X-bin"
               5                      IAXISTYPE=0;             "0 for no logs"
               5                      "plot histogram"
               5                      CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               5                      NPTS, CURVENUM, SERIESTITLE,
               5                      XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               5                      UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               5
               5                      CURVENUM=CURVENUM+1;
               5
               5                      IF(IKERMA = 1)[
               6                          "set up the arrays that are to be passed to XVGR"
               6                          "this is the histogram block"
               6                          DO IX=1, NRDOSE [
               7                              XCOORD(IX) = RCYL(NRDMIN+IX);
               7                              "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
               7                              YCOORD(IX)=SCKERMA(IZ,IX,1);
               7                              UNCERT(IX)=SCKERMA2(IZ,IX,1)*SCKERMA(IZ,IX,1)/100.;
               7                              ]
               6
               6                          SERIESTITLE='kerma at z # ' // CH_IZ;
               6
               6                          "plot kerma histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          "now plot kerma/dose histograms"
               6                          DO IX=1, NRDOSE [
               7                              "following wrong and redundant -use value just above"
               7                              "XCOORD(IX)=(RCYL(IX+NRDMIN-1)+RCYL(IX+NRDMIN))/2.;"
               7                              IF(SCKERMA(IZ,IX,1)~=0.)[
               8                                  YCOORD(IX)=SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1);
               8                                  UNCERT(IX)=SCDOSEtoKERMA2(IZ,IX,1)*
               8                                  (SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1))/100.;
               8                                  "SCDOSE(IZ,IX,1)/SCKERMA(IZ,IX,1)*100.;
               8                                  ]
               7                              ELSE[
               8                                  YCOORD(IX)=0.;
               8                                  UNCERT(IX)=0.;
               8                                  ]
               7                              ]
               6
               6                          SERIESTITLE='dose/kerma at z # ' // CH_IZ;
               6
               6                          "plot histogram"
               6                          CALL XVGRPLOT (XCOORD, YCOORD, UNCERT,
               6                          NPTS, CURVENUM, SERIESTITLE,
               6                          XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               6                          UNITNUM, PLTYPE, HISTXMIN, IAXISTYPE);
               6
               6                          CURVENUM=CURVENUM+1;
               6
               6                          ]"end of kerma plot"
               5                      ] "END OF IPLPHB=2 OR 3"
               4                  ] "END OF IF IZ>0"
               3              ] "END OF IZZ LOOP"
               2          close(23)
               2          ] "END CONDITIONAL BLOCK FOR RADIAL PLOTS"
               1
               1      ] "END OF IPLTPL=1"
               0
               0  RETURN;
               0  %I0                                                                            ;
               0  100   FORMAT(' ',80A1/
               0          /' NRC CALCULATION USING DOSRZnrc '$VERSION' ',40X, $);
               0  106   FORMAT(///' ',T60,'SCALED TO A MAX OF',1PE11.4,' Gy.cm**2');
               0
               0  " ********** IK: using wrapper for date and time routines.
               0  " Was:
               0  " 100   FORMAT(' ',80A1/
               0  "              /' NRC CALCULATION USING DOSRZnrc '$VERSION' ',40X,
               0  "                  $TIMEN_FORMAT,1X,$DATEN_FORMAT/
               0  "              /' ',T60,'SCALED TO A MAX OF',1PE11.4,' Gy.cm**2');
               0
               0  102   FORMAT(' '///
               0               ' ',11X,' DEPTH/DOSE PLOT FOR RADIAL DOSE ZONE #',I2
               0                  ,' TO RADIUS',F10.3);
               0  103   FORMAT(' '///
               0               ' ',11X,' RADIUS/DOSE PLOT FOR PLANAR DOSE REGION #',I2,
               0                  ' FROM',F10.3,' TO',F10.3,' cm');
               0  110   FORMAT(////
               0               ' ',14X,'CENTRAL AXIS DEPTH-DOSE FOR BEAM RADIUS',F12.3,' cm');
               0  130   FORMAT(' MAXIMUM DOSE = 0.000, NO PLOTTING WILL BE DONE');
               0
               0  END;  "LAST LINE OF SUBROUTINE PLOTSN"
               0
               0  "The following is the $CALL-HOWNEAR macro for PRESTA-II
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      call hownear({P1},x(np),y(np),z(np),ir(np));
            {  0  }
               0
               0  subroutine hownear(tperp,x,y,z,ir);
               0
               0  $IMPLICIT-NONE;
               0
               0  COMIN/GEOM/;
               0
               0  "Subroutine arguments
               0  $REAL
               0      tperp, "nearest distance to any boundary (output)
               0      x,     "x-position of the particle (input)
               0      y,     "y-position of the particle (input)
               0      z      "z-position of the particle (input)
               0  ;
               0  $INTEGER
               0      ir     "region number of the particle
               0  ;
               0
               0  "Local variables
               0
               0  $REAL
               0      r "cylindrical radius
               0  ;
               0  $INTEGER
               0      ix, "current cylindrical radius number
               0      iz  "current planar slab number
               0  ;
               0  r = sqrt(x**2 + y**2);
               0  ix = (ir - 2)/nz + 1;
               0  iz = ir - 1 - nz*(ix - 1);
               0  tperp = min(z - zplane(iz),zplane(iz + 1) - z,rcyl(ix) - r);
               0  IF(ix ~= 1)
               0  [
               1      tperp = min(tperp,r - rcyl(ix - 1));
               1  ]
               0
               0  return;
               0  end;
               0
               0  subroutine combine_results(file_name);
               0  implicit none;
               0  character*(*) file_name;
               0  ;COMIN/SCORE,RANDOM,IODAT2,GEOM,SOURCE/;
               0
               0  $INTEGER egs_get_unit,lnblnk1;
               0  $INTEGER ix,iz,it,ib,iorstrt,ipk,iout,itmax;
               0  REAL*8 TEMPSCSTP, TEMPSCSTP2, TEMPSCDSTP, TEMPSCDSTP2,
               0         TEMPSCR8($MAXZREG,$MAXRADII,$MAXIT),TEMPSCPDST($EBIN),
               0         TEMPSCPDST2($EBIN),TEMPSCPCUM($EBIN),TEMPSCPCUM2($EBIN),
               0         TEMPSCOMEG, TEMPSCOMEG2, TEMPSCPK(4), TEMPSCPK2(4),
               0         TEMPPIISTP;
               0  $REAL TEMPNCASE,TEMPTMCPU;
               0  $LONG_INT TEMPNNREAD;
               0
               0  $LOGICAL first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0
               0  iout = 1;
               0  IF((IFULL.EQ.0).OR.(IFULL.EQ.2).OR.(IFULL.EQ.3))[ITMAX=2;]
               0  ELSE[ITMAX=$MAXIT;]
               0
               0  IF( first_time ) [
               1
               1      first_time = .false.;
               1
               1      OUTPUT ;(/1X,'Summing the following .egsdat files');
               1      OUTPUT ; (1X,'------------------------------------'/);
               1      WRITE(IOUT,'(/1X,''Summing .egsdat files'')');
               1      WRITE(IOUT,'(1X,''---------------------''/)');
               1
               1      /SCSTP,SCSTP2,PIISTP,SCDSTP,SCDSTP2/=0;
               1      /TMCPUO,NCASEO,NNREAD,SCOMEG,SCOMEG2/=0;
               1
               1      DO iz=1,nzdose [ DO ix = 1,nrdose [ DO it = 1,itmax [
               4          /SCDOSE(IZ,IX,IT),SCDOSE2(IZ,IX,IT)/=0;
               4          /SCKERMA(IZ,IX,IT),SCKERMA2(IZ,IX,IT)/=0;
               4          SCDOSEtoKERMA2(IZ,IX,IT)=0;
               4      ] ] ]
               1      DO ib=1,MAXBIN [ /SCPDST(IB),SCPDST2(IB)/=0; ]
               1      DO ipk=1,4 [
               2          /SCDFEP(IPK),SCDFEP2(IPK),SCDFBK(IPK),SCDFBK2(IPK)/=0;
               2          /SCDFDIFF(IPK),SCDFDIFF2(IPK)/=0;
               2      ]
               1      DATCOUNT=0;
               1  ]
               0
               0  IORSTRT = egs_get_unit(4);
               0  WRITE(IOUT,'(A)') $cstring(file_name);
               0  WRITE(6,'(A)') $cstring(file_name);
               0  open(IORSTRT,file=file_name,status='old',err=:EOF_RS1:);
               0
               0  DATCOUNT=DATCOUNT+1;
               0
               0  READ(IORSTRT,*)TEMPSCSTP,TEMPSCSTP2,TEMPSCDSTP,TEMPSCDSTP2,TEMPPIISTP;
               0  SCSTP=SCSTP+TEMPSCSTP; SCSTP2=SCSTP2+TEMPSCSTP2; PIISTP=PIISTP+TEMPPIISTP;
               0  SCDSTP=SCDSTP+TEMPSCDSTP; SCDSTP2=SCDSTP2+TEMPSCDSTP2;
               0
               0  READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               0  DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
               2      DO IT=1,ITMAX[ SCDOSE(IZ,IX,IT)=SCDOSE(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
               2  ] ]
               0  READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               0  DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
               2      DO IT=1,ITMAX[ SCDOSE2(IZ,IX,IT)=SCDOSE2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
               2  ] ]
               0  IF(IKERMA=1)[
               1      READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               1      DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
               3          DO IT=1,ITMAX[ SCKERMA(IZ,IX,IT)=SCKERMA(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT); ]
               4      ] ]
               1      READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               1      DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
               3          DO IT=1,ITMAX[
               4              SCKERMA2(IZ,IX,IT)=SCKERMA2(IZ,IX,IT)+TEMPSCR8(IZ,IX,IT);
               4          ]
               3      ] ]
               1      READ(IORSTRT,*) (((TEMPSCR8(IZ,IX,IT),IT=1,ITMAX),IX=1,NRDOSE),IZ=1,NZDOSE);
               1      DO IZ=1,NZDOSE[ DO IX=1,NRDOSE[
               3          DO IT=1,ITMAX[
               4              SCDOSEtoKERMA2(IZ,IX,IT)=SCDOSEtoKERMA2(IZ,IX,IT)+
               4                                            TEMPSCR8(IZ,IX,IT);
               4          ]
               3      ] ]
               1  ]
               0  IF(IFULL=2)[
               1      READ(IORSTRT,*)(TEMPSCPDST(IB),TEMPSCPDST2(IB),IB=1,MAXBIN);
               1      READ(IORSTRT,*)(TEMPSCPCUM(IB),TEMPSCPCUM2(IB),IB=1,MAXBIN);
               1      DO IB=1,MAXBIN[
               2          SCPDST(IB)=SCPDST(IB)+TEMPSCPDST(IB);
               2          SCPDST2(IB)=SCPDST2(IB)+TEMPSCPDST2(IB);
               2          SCPCUM(IB)=SCPCUM(IB)+TEMPSCPCUM(IB);
               2          SCPCUM2(IB)=SCPCUM2(IB)+TEMPSCPCUM2(IB);
               2      ]
               1      READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
               1      DO IPK=1,4[
               2          SCDFEP(IPK)=SCDFEP(IPK)+TEMPSCPK(IPK);
               2          SCDFEP2(IPK)=SCDFEP2(IPK)+TEMPSCPK2(IPK);
               2      ]
               1      READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
               1      DO IPK=1,4[
               2          SCDFBK(IPK)=SCDFBK(IPK)+TEMPSCPK(IPK);
               2          SCDFBK2(IPK)=SCDFBK2(IPK)+TEMPSCPK2(IPK);
               2      ]
               1      READ(IORSTRT,*)(TEMPSCPK(IPK),TEMPSCPK2(IPK),IPK=1,4);
               1      DO IPK=1,4[
               2          SCDFDIFF(IPK)=SCDFDIFF(IPK)+TEMPSCPK(IPK);
               2          SCDFDIFF2(IPK)=SCDFDIFF2(IPK)+TEMPSCPK2(IPK);
               2      ]
               1  ]
               0  $RETRIEVE RNG STATE FROM UNIT IORSTRT;
               0  READ(IORSTRT,*) TEMPNCASE,TEMPTMCPU,TEMPNNREAD;
               0  TMCPUO=TMCPUO+TEMPTMCPU;
               0  NCASEO=NCASEO+TEMPNCASE;
               0  NNREAD=NNREAD+TEMPNNREAD;
               0  write(6,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total cpu = ',
               0    TMCPUO;
               0  write(iout,*) '  ncase = ',TEMPNCASE,' cpu = ',TEMPTMCPU,' total cpu = ',
               0    TMCPUO;
               0  READ(IORSTRT,*,END=:OMEGA-NOT-THERE1:) TEMPSCOMEG,TEMPSCOMEG2;
               0  SCOMEG=SCOMEG+TEMPSCOMEG;
               0  SCOMEG2=SCOMEG2+TEMPSCOMEG2;
               0  goto :OMEGA-THERE1:;
               0  :OMEGA-NOT-THERE1:
               0  OUTPUT;('  Warning: Solid angle information not in data file');
               0  OUTPUT;('           This may cause errors in absolute normalizations!');
               0  :OMEGA-THERE1:
               0  CLOSE(UNIT=IORSTRT);
               0  return;
               0  :EOF_RS1:;
               0  WRITE(6,*) 'Error opening file', $cstring(file_name);
               0  return; end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc ranmar random number generator                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The following is the initialization routine for the RANMAR random number   "
               0  "  generator (RNG) proposed by Marsaglia and Zaman and designed to be used    "
               0  "  with the EGSnrc system.                                                    "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  The use of RANMAR requires the file ranmar.macros (which defines the       "
               0  "  actual random number generation as a macro).                               "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  subroutine init_ranmar;
               0
               0  implicit none;
               0
               0  ;COMIN/RANDOM/;
               0
               0  integer*4 s,t;
               0  integer*4 i,j,k,l,m,ii,jj;
               0
               0  IF( ixx <= 0 | ixx > 31328 ) ixx = 1802; "Sets Marsaglia default"
               0  IF( jxx <= 0 | jxx > 30081 ) jxx = 9373; "sets Marsaglia default"
               0
               0  i = mod(ixx/177,177) + 2;
               0  j = mod(ixx,    177) + 2;
               0  k = mod(jxx/169,178) + 1;
               0  l = mod(jxx,    169)    ;
               0
               0  DO ii = 1,97 [
               1
               1      s = 0; t = 8388608;  "t is 2**23 i.e. half of the maximum allowed"
               1                           "(note that only 24 bits are used)          "
               1
               1      DO jj = 1,24 [
               2
               2                           "The if( fool_optimizer ...) statements below are"
               2                           "to prevent re-arangement of statements for high "
               2                           "level optimizations and thus different sequences"
               2                           "on different architectures                      "
               2
               2          m = mod(mod(i*j,179)*k,179);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          i = j;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          j = k;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          k = m;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          l = mod(53*l+1,169);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          IF(mod(l*m,64) >= 32) s = s + t;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          t = t/2;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2      ]
               1      urndm(ii) = s;
               1  ]
               0
               0  crndm  =   362436;
               0  cdrndm =  7654321;
               0  cmrndm = 16777213;
               0
               0  twom24 = 1./16777216.;
               0
               0  ixx = 97;
               0  jxx = 33;
               0
               0  rng_seed = $NRANMAR + 1;
               0
               0  return;
               0  end; "End of init_ranmar for EGSnrc"
               0
               0  subroutine ranmar_get;
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $INTEGER i,iopt;
               0  IF( rng_seed = 999999 ) call init_ranmar;
               0  DO i=1,$NRANMAR [
               1      iopt = urndm(ixx) - urndm(jxx);
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      urndm(ixx) = iopt;
               1      ixx = ixx - 1; jxx = jxx - 1;
               1      IF(ixx = 0)        [ ixx = 97; ]
               1      ELSE IF( jxx = 0 ) [ jxx = 97; ]
               1      crndm = crndm - cdrndm;
               1      IF(crndm < 0) crndm = crndm + cmrndm;
               1      iopt = iopt - crndm;
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      rng_array(i) = iopt;
               1  ]
               0  rng_seed = 1; return; end;
               0
               0  ;"       end of ranmar.mortran    "
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc source calculations in cylindrical geometry                         "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Eric Fox, 1984                                            "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Alex Bielajew                                             "
               0  "                   George Ding                                               "
               0  "                   Charlie Ma                                                "
               0  "                   Jan Seuntjens                                             "
               0  "                   Aaron Merovitz                                            "
               0  "                   Guoming Xiong                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This code was originally adapted from CAVITY by Eric Fox in 1984.          "
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This subroutine is dedicated exclusively to calculations related to the    "
               0  "  source configuration. It is accessed from four locations:                  "
               0  "                                                                             "
               0  "  1) from the INPUT SUBROUTINE. Control is transferred to this routine to    "
               0  "     read in source specific information. Control is transferred back to the "
               0  "     INPUT SUBROUTINE following these inputs                                 "
               0  "                                                                             "
               0  "  2) from the 'ONE TIME ONLY CONSTANTS' section of the main routine to scale "
               0  "     the geometry of the incident beam and calculate the fluence             "
               0  "                                                                             "
               0  "  3) from the histories loop of the main routine. A call is made prior to    "
               0  "     each history to set the point of entry into the target, the initial     "
               0  "     direction cosines, the initial energy and the statistical weight of the "
               0  "     incident particle.                                                      "
               0  "                                                                             "
               0  "  4) from the input summary routine to print source info                     "
               0  "                                                                             "
               0  "  Fluence is defined at the point on axis at the front face of the geometry. "
               0  "                                                                             "
               0  "  VERSION 01      E.F.      7/84    ADAPTED FROM CAVITY                      "
               0  "  VERSION 02      D.W.O.R.  4/85    EGS4, ISOURC=4, FRONT FACE FLUENCE       "
               0  "                  D.W.O.R.  9/85    CHANGED ISOURC=4 TO MAKE LAST R=1000     "
               0  "  VERSION 03      A.F.B.    5/86    PUT IN ISOURC=20, RADIAL DIST'N          "
               0  "  VERSION 04      A.F.B.   10/86    PUT IN ANGLED INCIDENCE PARALLEL BEAM    "
               0  "  VERSION 05      D.W.O.R.  1/87    ALLOWED NMED>1 FOR ISOURC=2,4            "
               0  "  VERSION 06      A.F.B.    4/87    GENERALIZED SAMPLING FOR ISOURC=20       "
               0  "  VERSION 07      D.W.O.R. 12/87    SCORE SOLID ANGLE FOR POINT SOURCES      "
               0  "  VERSION 08      A.F.B.    1/88    RESTRUCTURED AND FIXED ISOURC=12         "
               0  "  VERSION 09      A.F.B.    1/88    ISOURC=13 CODED                          "
               0  "  VERSION 10      A.F.B.    1/88    ZCOFST, ZSOFST PUT IN COMMON             "
               0  "  VERSION 11      A.F.B.    3/88    FIXED DOMEGA SAMPLING ERROR              "
               0  "  VERSION 12    D.W.O.R.    7/88    FIXED ISOURC=3 TO SET IRIN               "
               0  "  VERSION 13      A.F.B.    3/89    FIXED ISOURC=3 THAT WRONGLY              "
               0  "                                    CENTERED THE REGION AT ZERO              "
               0  "  VERSION 14    D.W.O.R     2/90    added ISOURC=14                          "
               0  "                            3/90    minor change to specify fluence          "
               0  "                                    is that at front face on axis            "
               0  "  VERSION 15      B.A.F.   12/90    added ISOURC=21                          "
               0  "  VERSION 16    D.W.O.R.    9/91    extended ISOURC=3 to be an               "
               0  "                                    arbitrary ring region                    "
               0  "  VERSION 17      G.X.D.    4/93    modify isource = 21 read from            "
               0  "                                    beam full phase space                    "
               0  "  VERSION 18     C.M. Ma   11/94    modified isource = 21, implemented       "
               0  "                                    new file format for phase space          "
               0  "  VERSION 19     C.M. Ma   11/94    added charge options for isource = 21    "
               0  "                                    iq can be either -1,0,1 or 2(=all)       "
               0  "  VERSION 20     C.M. Ma   05/95    modified isourc=21 to input max          "
               0  "                                    energy from phase space, not user        "
               0  "  VERSION 21     J.S.      04/98    upgraded srcrz_from_cavrz                "
               0  "                                                                             "
               0  "  VERSION 22     A.M       04/98    New input routine(GET_INPUTS)            "
               0  "  VERSION 23     I.K.      01/00    implicit none                            "
               0  "  VERSION 24     B.W.      02/01    added sourc 22 starting from NPL         "
               0  "                                    work by David Shipley.                   "
               0  "  VERSION 25     I.K.      04/01    Added source 15 and 16, modified         "
               0  "                                         source 22 to work from any angle    "
               0  "                                                                             "
               0  "  modifield at Carleton by Guoming Xiong to remove bug in radial dose        "
               0  "  distributions in source 20                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  ;
               0  "      DEFINE SOME LOCAL MACROS
               0  ;
               0  "MACRO $CHOOSE-POINT-IN-CIRCLE
               0  "      =======================
               0  "RANDOMLY SELECTS A POINT WITHIN A CIRCLE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  RBEAM  RADIUS WITHIN WHICH TO CHOOSE THE POINT
               0  "            RBEAM2 RBEAM**2
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            R2     XIN**2+YIN**2
               0  "            IXIN   RADIUS NUMBER IN WHICH THE SELECTED POINT RESIDES
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$CHOOSE-POINT-IN-CIRCLE;} WITH {;
            {  0  LOOP[
            {  0  $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
            {  0  $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
            {  0  R2=XIN**2+YIN**2;
            {  0  ] UNTIL R2.LE.RBEAM2;
            {  0  DO IX=1,NR[IXIN=IX;IF(R2.LE.CYRAD2(IX))EXIT;]
            {  0  ;
            {  0  }
               0  ;
               0  "MACRO $SELECT-POINT-IN-RECTANGLE
               0  "      ==========================
               0  "RANDOMLY SELECTS A POINT WITHIN A RECTANGLE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  XBEAM  HALF WIDTH OF THE RECTANGLE ALONG THE X-AXIS
               0  "            YBEAM  HALF WIDTH OF THE RECTANGLE ALONG THE Y-AXIS
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            R2     XIN**2+YIN**2
               0  "            IXIN   RADIUS NUMBER IN WHICH THE SELECTED POINT RESIDES
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$SELECT-POINT-IN-RECTANGLE;} WITH {;
            {  0  $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*XBEAM;
            {  0  $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*YBEAM;
            {  0  R2=XIN**2+YIN**2;
            {  0  DO IX=1,NR[IXIN=IX;IF(R2.LE.CYRAD2(IX))EXIT;]
            {  0  ;
            {  0  }
               0  ;
               0  "MACRO $ENTRY-FRONT-FACE
               0  "      =================
               0  "SPECIFIES ALL THE INPUT PHASE SPACE FOR A POINT SOURCE IRRADIATING A
               0  "FRONT FACE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  RBEAM  RADIUS WITHIN WHICH TO CHOOSE THE POINT
               0  "            RBEAM2 RBEAM**2
               0  "            RMINBM IS MINIMUM BEAM RADIUS FOR ISOURC=14
               0  "            DISTRH PERPENCICULAR DISTANCE OF THE POINT SOURCE OFF THE
               0  "                   SYMMETRY (Z) AXIS OF THE GEOMETRY
               0  "            DISTZ  PERPENCICULAR DISTANCE OF THE POINT SOURCE FROM THE
               0  "                   FIRST PLANE (ZPLANE(1) IN THE GEOMETRY)
               0  "            DISTZ2 DISTZ**2
               0  "            AFACE  AREA TO WHICH THE BEAM IS COLLIMATED ON THE FACE
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            ZIN    Z-COORDINATE SELECTED
               0  "            UIN    DIRECTION COSINE WITH RESPECT TO THE X-AXIS
               0  "            VIN    DIRECTION COSINE WITH RESPECT TO THE Y-AXIS
               0  "            WIN    DIRECTION COSINE WITH RESPECT TO THE Z-AXIS
               0  "            IRIN   REGION NUMBER OF THE ENTRANCE ELEMENT IN THE GEOMETRY
               0  "            WEIGHT WEIGHT OF THE PARTICLE
               0  "            NRCFLG = 10 => ENTRY IS FROM A FRONT FACE
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$ENTRY-FRONT-FACE;} WITH {;
            {  0  $CHOOSE-POINT-IN-CIRCLE;
            {  0  IRIN=2+(IXIN-1)*NZ;
            {  0  ZIN=ZPLANE(1);
            {  0  IF(ISOURC.EQ.14 .AND. R2.LE.RMINSQ)[
            {  0  WEIGHT=0.0;"I.E. GET HOWFAR TO TERMINATE HISTORY"]
            {  0  ELSE[
            {  0  IF(DISTRH.EQ.0.0)[D=SQRT(R2+DISTZ**2);]
            {  0  ELSE[D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2);]
            {  0  UIN=XIN/D;VIN=(YIN-DISTRH)/D;WIN=DISTZ/D;
            {  0  NRCFLG=10;
            {  0  WEIGHT=AFACE*DISTZ/(D**3)/PROBFC;
            {  0  SCOMEG=SCOMEG+WEIGHT;
            {  0  SCOMEG2=SCOMEG2+WEIGHT*WEIGHT;]
            {  0  }
               0  ;
               0  "MACRO $INCIDENT-FROM-FRONT
               0  "      ====================
               0  "SPECIFIES ALL THE INPUT PHASE SPACE FOR A POINT SOURCE IRRADIATING A
               0  "FRONT FACE IN THE NRCC RZ GEOMETRY
               0  " DEVELOPED FOR USE OF ISOURCE 17
               0  "    INPUTS  XBEAM  HALF WIDTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            YBEAM  HALF WIDTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            R2     XIN**2 + YIN**2
               0  "            DISTRH PERPENCICULAR DISTANCE OF THE POINT SOURCE OFF THE
               0  "                   SYMMETRY (Z) AXIS OF THE GEOMETRY
               0  "            DISTZ  PERPENCICULAR DISTANCE OF THE POINT SOURCE FROM THE
               0  "                   FIRST PLANE (ZPLANE(1) IN THE GEOMETRY)
               0  "            DISTZ2 DISTZ**2
               0  "            AFACE  AREA TO WHICH THE BEAM IS COLLIMATED ON THE FACE
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            ZIN    Z-COORDINATE SELECTED
               0  "            UIN    DIRECTION COSINE WITH RESPECT TO THE X-AXIS
               0  "            VIN    DIRECTION COSINE WITH RESPECT TO THE Y-AXIS
               0  "            WIN    DIRECTION COSINE WITH RESPECT TO THE Z-AXIS
               0  "            IRIN   REGION NUMBER OF THE ENTRANCE ELEMENT IN THE GEOMETRY
               0  "            WEIGHT WEIGHT OF THE PARTICLE
               0  "            NRCFLG = 10 => ENTRY IS FROM A FRONT FACE
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$INCIDENT-FROM-FRONT;} WITH {;
            {  0  $SELECT-POINT-IN-RECTANGLE;
            {  0  IRIN=2+(IXIN-1)*NZ;
            {  0  ZIN=ZPLANE(1);
            {  0  IF(DISTRH.EQ.0.0)[D=SQRT(R2+DISTZ**2);]
            {  0  ELSE[D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTZ**2);]
            {  0  UIN=XIN/D;VIN=(YIN-DISTRH)/D;WIN=DISTZ/D;
            {  0  NRCFLG=10;
            {  0  WEIGHT=AFACE*DISTZ/(D**3)/PROBFC;
            {  0  SCOMEG=SCOMEG+WEIGHT;
            {  0  SCOMEG2=SCOMEG2+WEIGHT*WEIGHT;
            {  0  }
               0  ;
               0  "MACRO $ENTRY-BACK-FACE
               0  "      ================
               0  "SPECIFIES ALL THE INPUT PHASE SPACE FOR A POINT SOURCE IRRADIATING A
               0  "BACK FACE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  RBEAM  RADIUS WITHIN WHICH TO CHOOSE THE POINT
               0  "            RBEAM2 RBEAM**2
               0  "            DISTRH PERPENCICULAR DISTANCE OF THE POINT SOURCE OFF THE
               0  "                   SYMMETRY (Z) AXIS OF THE GEOMETRY
               0  "            DISTB  PERPENCICULAR DISTANCE OF THE POINT SOURCE FROM THE
               0  "                   LAST PLANE (ZPLANE(NPLANE) IN THE GEOMETRY)
               0  "            DISTB2 DISTB**2
               0  "            AFACE  AREA TO WHICH THE BEAM IS COLLIMATED ON THE FACE
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            ZIN    Z-COORDINATE SELECTED
               0  "            UIN    DIRECTION COSINE WITH RESPECT TO THE X-AXIS
               0  "            VIN    DIRECTION COSINE WITH RESPECT TO THE Y-AXIS
               0  "            WIN    DIRECTION COSINE WITH RESPECT TO THE Z-AXIS
               0  "            IRIN   REGION NUMBER OF THE ENTRANCE ELEMENT IN THE GEOMETRY
               0  "            WEIGHT WEIGHT OF THE PARTICLE
               0  "            NRCFLG = 30 => ENTRY IS FROM THE BACK FACE
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$ENTRY-BACK-FACE;} WITH {;
            {  0  $CHOOSE-POINT-IN-CIRCLE;
            {  0  IRIN=1+IXIN*NZ;
            {  0  ZIN=ZPLANE(NPLANE);
            {  0  IF(DISTRH.EQ.0.0)[D=SQRT(R2+DISTB2);]
            {  0  ELSE[D=SQRT(R2+DISTRH*(DISTRH-2.0*YIN)+DISTB2);]
            {  0  UIN=XIN/D;VIN=(YIN-DISTRH)/D;WIN=-DISTB/D;
            {  0  NRCFLG=30;
            {  0  WEIGHT=AFACE*DISTB/(D**3)/PROBBK;
            {  0  SCOMEG=SCOMEG+WEIGHT;
            {  0  SCOMEG2=SCOMEG2+WEIGHT*WEIGHT;
            {  0  }
               0  ;
               0  "MACRO $CHOOSE-POINT-IN-RECTANGLE
               0  "      ==========================
               0  "RANDOMLY SELECTS A POINT WITHIN A RECTANGLE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  XBEAM  HALF-WIDTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            ZBEAM  HALF-DEPTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            ZCOFST Z OFFSET OF THE CENTER OF THE GEOMETRY
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            ZIN    Z-COORDINATE SELECTED
               0  "            IRIN   REGION NUMBER IN WHICH THE SELECTED POINT RESIDES
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$CHOOSE-POINT-IN-RECTANGLE;} WITH {;
            {  0  $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*XBEAM;
            {  0  $RANDOMSET ZIN;ZIN=(2.0*ZIN-1.0)*ZBEAM+ZCOFST;
            {  0  YIN=SQRT((RCYL1-XIN)*(RCYL1+XIN));
            {  0  DO IZ=2,NPLANE[IZ1=IZ;IF(ZIN.LE.ZPLANE(IZ))EXIT;]
            {  0  IRIN=(NR-1)*NZ+IZ1;
            {  0  ;
            {  0  }
               0  ;
               0  "MACRO $ENTRY-SIDE
               0  "      ===========
               0  "SPECIFIES ALL THE INPUT PHASE SPACE FOR A POINT SOURCE IRRADIATING THE
               0  "SIDE IN THE NRCC RZ GEOMETRY
               0  "    INPUTS  XBEAM  HALF-WIDTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            ZBEAM  HALF-DEPTH WITHIN WHICH TO CHOOSE THE POINT
               0  "            DISTRH Y OFFSET OF POINT SOURCE
               0  "            ZCOFST Z OFFSET OF THE CENTER OF THE GEOMETRY
               0  "            ZSOFST Z OFFSET OF THE SOURCE
               0  "    OUTPUTS XIN    X-COORDINATE SELECTED
               0  "            YIN    Y-COORDINATE SELECTED
               0  "            ZIN    Z-COORDINATE SELECTED
               0  "            UIN    DIRECTION COSINE WITH RESPECT TO THE X-AXIS
               0  "            VIN    DIRECTION COSINE WITH RESPECT TO THE Y-AXIS
               0  "            WIN    DIRECTION COSINE WITH RESPECT TO THE Z-AXIS
               0  "            IRIN   REGION NUMBER OF THE ENTRANCE ELEMENT IN THE GEOMETRY
               0  "            WEIGHT WEIGHT OF THE PARTICLE
               0  "            NRCFLG = 20 => ENTRY IS FROM A FRONT FACE
               0  "*** THIS MACRO IS DESIGNED TO WORK WITH THE STANDARD NRCC RZ GEOMETRY ***
               0  "*** ROUTINE ONLY                                                      ***
               0  ;
               0  REPLACE {$ENTRY-SIDE;} WITH {;
            {  0  $CHOOSE-POINT-IN-RECTANGLE;
            {  0  D=SQRT(RCYL2+DSTRH2-2.0*DISTRH*YIN+(ZIN-ZSOFST)**2);
            {  0  UIN=XIN/D;VIN=(YIN-DISTRH)/D;WIN=(ZIN-ZSOFST)/D;
            {  0  WEIGHT=ASIDE*(DISTRH-RCYL2/YIN)/(D**3)/PROBSD;
            {  0  SCOMEG=SCOMEG+WEIGHT;
            {  0  SCOMEG2=SCOMEG2+WEIGHT*WEIGHT;
            {  0  NRCFLG=20;
            {  0  }
               0  ;
               0  "***************************************************************************
               0  SUBROUTINE SRCRZ;             "toc:
               0  "***************************************************************************
               0  "This entry is used to set values which will be required later
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER LATCHM,NHSTRYM;   "dummy variables used when reading in phsp record"
               0  $REAL ZLASTM,EINM,WEIGHTM,XINM,YINM,UINM,VINM;
               0
               0  CHARACTER*5 LINE1;
               0
               0  $INTEGER K,IB;
               0  $REAL    TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM;
               0
               0  "There seems to be confusion of file names used for phase space and"
               0  "radial distribution, I declare here FILNAM (which was partially used"
               0  "but not declared as a character) to be the file name for rad. distr."
               0
               0  character*80 filnam;
               0
               0  "entry srcini declarations"
               0  $INTEGER ICORRL;
               0  $LONG_INT TEMPDIV;
               0  $REAL    SCARG1,SCARG2,SCARG3,SCARG4;
               0
               0  $INTEGER ICOUNT,IERROR;
               0  $REAL    RLAST;
               0
               0  "entry srcoto declarations"
               0  $REAL    WEIGHT;
               0
               0  $INTEGER IBNSOK,I,IRDIST;
               0  $REAL    COTANG,FACTOR,GRIDSZ,AK;
               0
               0  "entry srchst declarations"
               0  $INTEGER IRIN,NRCFLG;
               0  $REAL    XIN,YIN,ZIN,UIN,VIN,WIN;
               0
               0  $INTEGER IX,IXIN,IZ,IZ1,LATCHI;  "LATCHI is not used!"
               0  $REAL    R2,D,PHI,WHICH,RNNO1,RNNO2,ZLAST;
               0
               0  $INTEGER IZIN;
               0  $REAL    YTEMP,VTEMP,ZINC;
               0
               0  " Variables for source 22: phase space file from an arbitrary direction"
               0  $REAL    dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber_c,
               0  xoffset, yoffset;
               0  logical  check;
               0  $INTEGER count_phsp;
               0  real*8   tf,xtmp,ytmp,phbb,pha,phb,phd,radp;
               0  "The above are used in source 22 to check whether the particle"
               0  "gets in. As the phsp-plane may be far away from the geometry "
               0  "it is a good idea to use double precision variables          "
               0
               0  $INTEGER N_RUN_CHUNK; "stores current chunk of parallel run"
               0
               0  character*80 the_beam_code, the_pegs_file, the_input_file;
               0  $INTEGER     lnblnk1;
               0
               0  $LONG_INT tmp_mod;
               0
               0  "***************************************************************************"
               0  "*            Variables passed to the subroutine GET_INPUTS                *"
               0  "***************************************************************************"
               0  COMIN/GetInput/;
               0
               0  INTEGER NUM_IPART,
               0  NUM_SOURCE,
               0  NUM_SOPTS,
               0  NUM_MODEIN,
               0  NUM_RDFIL,
               0  NUM_NRDIST,
               0  NUM_RDISTF,
               0  NUM_RPDF,
               0  NUM_RDIOUTSP,
               0  NUM_FILSPC,
               0  NUM_BEAM_CODE,
               0  NUM_PEGS_FILE,
               0  NUM_IFILE, NUM_WW23, error_flag_save;
               0
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0  $INTEGER MODEIN;
               0
               0  "COMMIN BLOCK DECLERATIONS
               0  "*************************
               0  ;COMIN/GEOM,IODAT2,PRINTC,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM,RWPHSP,
               0  EGS-IO/;
               0
               0  $LONG_INT last_nhstry;
               0
               0  $REAL min_weight_23, max_weight_23, xin_tmp, yin_tmp, zin_tmp,Z_SOURCE,MUIDX;
               0  $INTEGER secret_option_23,ilen,ismode,IMUPHSP,IZSCORE;
               0
               0  " At least the following variables must be declared static "
               0  save TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,TEMP6,TEMP7,TEMP8,TEMP9,FNORM,IBNSOK,MODEIN,
               0  dist_phsp, theta_phsp, cost_phsp, sint_phsp, chamber_c,count_phsp,
               0  xoffset, yoffset, the_beam_code, the_pegs_file, the_input_file,
               0  last_nhstry,min_weight_23, max_weight_23, secret_option_23;
               0
               0
               0  "                        INPUT SOURCE PARAMETERS    ""toc:
               0  "                        =======================    ""toc:
               0
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  ;
               0  "*******************************************************************************
               0  "                            SOURCE INPUT
               0  "                            ************
               0  "*******************************************************************************
               0  " SOURCE DELIMETERS:    :start source inputs:
               0  "                       :stop source inputs:
               0  "
               0  "FOR ALL SOURCES
               0  "                                      Charge of the incident beam
               0  "  INCIDENT PARTICLE= electron   (-1)  electrons
               0  "                     photon     (0)   photons
               0  "                     positron   (1)   positrons
               0  "
               0  "  (for SOURCE 21,22,23)  all    (2)  include all of the particles
               0  "                                     in the phase space file
               0  "                                     [IQIN]
               0  "                    charged     (3)  include e+ and e-
               0  "
               0  "  SOURCE NUMBER                 (I)   number of the source
               0  "                                      [ISOURC]
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  0 <<<<<<<<
               0  "
               0  "     PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS) ""toc:
               0  "
               0  "
               0  "  SOURCE OPTIONS            (M4)  RBEAM, UINC, VINC, WINC
               0  "
               0  "               RBEAM          radius of parallel beam in cm
               0  "                              (defaults to max radius of geometry)
               0  "               UINC           incident x-axis direction cosine
               0  "               VINC           incident y-axis direction cosine
               0  "               WINC           incident z-axis direction cosine
               0  "                              NOTE: (UINC,VINC,WINC)
               0  "                              get automatically normalized
               0  "                              defaults to (0.0,0.0,1.0)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  1 <<<<<<<<
               0  "
               0  "     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, 0, 0
               0  "
               0  "               DISTZ          distance of the point source from the
               0  "                              front of the target in cm (DEFAULT 100.)
               0  "               RBEAM          radius of the beam at the front of the
               0  "                              target in cm (defaults to MAX radius)
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  2 <<<<<<<<
               0  "
               0  "        BROAD PARALLEL BEAM INCIDENT FROM FRONT (+VE Z-AXIS) ""toc:
               0  "               WITH UNIT AREA BEAM AND LARGE SCORING AREA
               0  "
               0  "  SOURCE OPTIONS          (M4)  0, 0, 0, 0
               0  "
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  3 <<<<<<<<
               0  "
               0  "     UNIFORM ISOTROPICALLY RADIATING DISK OF FINITE SIZE   ""toc:
               0  "            (MUST BE ALLOWED FOR IN THE GEOMETRICAL DEFINITIONS)
               0  "
               0  "  SOURCE OPTIONS                (M4)  RMINBM, RBEAM, ZSMIN, ZSMAX
               0  "
               0  "               RMINBM,RBEAM           inner and outer radii of source region
               0  "                                      must be inside geometry
               0  "               ZSMIN,ZSMAX            min and max z values for source
               0  "
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  4 <<<<<<<<
               0  "
               0  "     FOR CENTRAL AXIS FLUENCE VS BEAM RADIUS      ""toc:
               0  "
               0  "  SOURCE OPTIONS            (M4)  RCAXIS, 0, 0, 0
               0  "
               0  "               RCAXIS       radius of central axis scoring zone (cm)
               0  "
               0  "        NOTE: this source option treats the cylindrical radii input
               0  "              above as beam radii. the largest radius must be infinite
               0  "              and the phantom must be homogeneous (at least in each layer)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  10 <<<<<<<<
               0  "
               0  "     PARALLEL BEAM INCIDENT FROM THE SIDE (+VE Y-AXIS)    ""toc:
               0  "
               0  "  SOURCE OPTIONS           (M4)  XBEAM, ZBEAM, 0, 0
               0  "
               0  "               XBEAM             half-width of the rectangular beam in cm
               0  "                                 (defaults to max radius)
               0  "               ZBEAM             half-height of the rectangular beam in cm
               0  "                                 (defaults to max)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  11 <<<<<<<<
               0  "
               0  "     POINT SOURCE INCIDENT FROM THE SIDE     ""toc:
               0  "
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTRH, XBEAM, ZBEAM, 0
               0  "
               0  "               DISTRH                 distance of the source from the middle
               0  "                                      of the target in cm (defaults to 100.)
               0  "               XBEAM                  half-width of the beam at the center of
               0  "                                      the target in cm (defaults to max radius)
               0  "               ZBEAM                  half-height of the beam at the center of
               0  "                                      the target in cm (defaults to max)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  12 <<<<<<<<
               0  "
               0  "   POINT SOURCE OFF AXIS         ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTRH, DISTZ, 0, 0
               0  "
               0  "               DISTRH                 distance of the point source off the
               0  "                                      Z-axis.
               0  "               DISTZ                  perpendicular distance of the
               0  "                                      point source away from the front face.
               0  "                                      a negative value is permitted.
               0  "
               0  "                                      DISTZ > 0
               0  "                                      point located in front of front face
               0  "
               0  "                                      0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
               0  "                                      point located between front and rear face
               0  "
               0  "                                      DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
               0  "                                      point located rear of rear plane
               0  "
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  13 <<<<<<<<
               0  "
               0  "        PARALLEL BEAM FROM ANY ANGLE     ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  UINC, VINC, WINC, 0
               0  "
               0  "               UINC                   incident x-axis direction cosine
               0  "               VINC                   incident y-axis direction cosine
               0  "               WINC                   incident z-axis direction cosine
               0  "
               0  "                 NOTE: (UINC,VINC,WINC) get automatically normalized
               0  "                       default is (0.0,0.0,1.0)
               0  "
               0  "
               0  "-------------------------------------------------------------------------------
               0  "                     >>>>>>>> SOURCE  14 <<<<<<<<
               0  "
               0  "   POINT SOURCE ON AXIS INCIDENT FROM THE FRONT WITH ALL   ""toc:
               0  "    EVENTS INSIDE RMINBM NOT FOLLOWED (A FUDGE FOR COLLIMATOR STUDIES)
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTZ, RBEAM, RMINBM, IGNORED
               0  "
               0  "               DISTZ                  distance of the point source from the
               0  "                                      front of the target in cm
               0  "                                      (defaults to 100.)
               0  "               RBEAM                  radius of the beam at the front of the
               0  "                                      target in cm (defaults to max radius)
               0  "               RMINBM                 below this radius, all histories are
               0  "                                      terminated by the source routines by
               0  "                                      giving them zero weight.
               0  "                                      The howfar routines must check for this.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "
               0  "
               0  "                     >>>>>>>> SOURCE  15 <<<<<<<<
               0  "
               0  "  POINT SOURCE OFF AXIS. The same as source 12 but uses an alternative
               0  "  implementation for sampling points on the surface of the RZ-geomtry. The
               0  "  motivation for implementing this source was to check that source 12 is OK
               0  "  and to check the effect of varying weights from the source on the
               0  "  statistical uncertainty (contrary to source 12, source 16 produces
               0  "  essentially  constant weights if the geometry-to-source distance is large
               0  "  compared to the geometry dimension, a typical situation for ion chamber
               0  "  simulations)
               0  "
               0  "  SOURCE OPTIONS                (M4)  DIST, ANGLE, IGNORED, IGNORED
               0  "
               0  "             DIST                     distance of the centre of the geometry
               0  "                                      to the source in cm.
               0  "             ANGLE                    angle of rotation around the x-axis.
               0  "                                      (because of the cylindrical symetry,
               0  "                                      rotations around the x-axis and y-axis
               0  "                                      are indistinguishable). 0 degrees
               0  "                                      corresponds to a source above the front
               0  "                                      face (i.e. the same as source 1), 90
               0  "                                      degrees to a source from the side
               0  "                                      (i.e. the same as source 11).
               0  "                                      The source MUST be outside the geometry,
               0  "                                      otherwise the initialization routine
               0  "                                      will abort execution.
               0  "
               0  "           Note that if you are not actually rotating about the center of the
               0  "           geometry, you must calculate the angle and distance as if you
               0  "           were.
               0  "
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "
               0  "
               0  "                     >>>>>>>> SOURCE  16 <<<<<<<<
               0  "
               0  "           EXTENDED (CIRCULAR OR RECTANGULAR)  SOURCE OFF AXIS.
               0  "
               0  "  SOURCE OPTIONS                (M4)  DIST, ANGLE, TMP1, TMP2
               0  "
               0  "            DIST                      distance of geometry centre to source
               0  "                                      centre in cm.
               0  "
               0  "            ANGLE                     angle of rotation around the x-axis
               0  "                                      (see comments/explanations to source 15)
               0  "
               0  "            TMP1, if TMP2 <= 0        radius of the source (i.e., the emitting
               0  "        or  TMP2, if TMP1 <= 0        position is picked uniformly within the
               0  "                                      circle).
               0  "
               0  "            TMP1 and TMP2, if both    half-sizes of the radiating rectangle
               0  "            >= 0                      in x- and y-directions before rotation,
               0  "                                      i.e., initially x and y are picked
               0  "                                      within the rectangle and z is set to
               0  "                                      -DIST + geometry centre. Then a rotation
               0  "                                      around the x-axis is performed.
               0  "       In all cases the source plane is perpendicular to the line joining
               0  "       it to the center of the geometry.   Note that this introduces a
               0  "       slight error if the center of your geometry is not the true point
               0  "       of rotation.
               0  "
               0  "       Note: if TEMP1 <= 0 and TEMP2 <= 0, source 16 becomes a point-source
               0  "             off-axis, i.e. the same as source 12 and 15.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  17 <<<<<<<<
               0  "
               0  "     POINT SOURCE ON AXIS INCIDENT FROM THE FRONT    ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  DISTZ, XBEAM, YBEAM, 0
               0  "
               0  "               DISTZ          distance of the point source from the
               0  "                              front of the target in cm (DEFAULT 100.)
               0  "               XBEAM          half-width of the beam along x at the center
               0  "                              of the target in cm (defaults to MAX radius)
               0  "               YBEAM          half-width of the beam along y at the center
               0  "                              of the target in cm (defaults to MAX radius)
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  20 <<<<<<<<
               0  "
               0  "   RADIAL DISTRIBUTION INPUT      ""toc:
               0  "
               0  "  MODEIN= Local                 (0)   if radial distribution is to be input
               0  "                                      locally through the .egs4inp file
               0  "        = External              (1)   if the distribution is to be input
               0  "                                      via an external file
               0  "
               0  "                        -----------------------------
               0  " ONLY IF MODEIN= Local
               0  "
               0  "  NRDIST                        (I)   # radial bins in distribution histogram
               0  "  RDISTF                        (M)   top of radial bin.
               0  "                                      should be values for 1 to NRDIST.
               0  "  RPDF                          (M)   Probability of initial particle being
               0  "                                      in this bin.
               0  "                                      Probability doesn't need to be normalized
               0  "                                      but it should be in units cm**-2
               0  "                                      Should be values for 1 to NRDIST.
               0  "  RDIST IOUTSP= None            (0)   No distribution data in output summary
               0  "              = Include         (1)   include distribution data output summary
               0  "
               0  "                        -----------------------------
               0  "  ONLY IF MODEIN= External
               0  "
               0  "  RDIST FILENAME                (C)   filename(with ext) contains
               0  "                                      distribution information
               0  "
               0  "  RDIST IOUTSP= None            (0)   No distribution data in output summary
               0  "              = Include         (1)   include distribution data output summary
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  21 <<<<<<<<
               0  "
               0  "    FULL BEAM PHASE-SPACE BEAM DATA, INCIDENT ON FRONT FACE    ""toc:
               0  "
               0  "  SOURCE OPTIONS                (M4)  IMODE, NRCYCL, IPARALLEL, PARNUM
               0  "
               0  "               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
               0  "                                  2=> 8 variables/record: the above + ZLAST
               0  "              NRCYCL     Number of times to recycle each particle in a phase
               0  "                         space source.  Each particle in the phase space
               0  "                         file is used a total of NRCYCL+1 times before
               0  "                         going on to the next particle.
               0  "                         If NCASE > no. of particles in the phase space file,
               0  "                         then use of NRCYCL is essential for accurate
               0  "                         statistics.
               0  "                         If NRCYCL is set > 0, then the user-input value is
               0  "                         used.
               0  "                         If NRCYCL is set <=0 then NRCYCL is automatically
               0  "                         calculated to use the entire phase space file with no
               0  "                         restarts, unless INCIDENT PARTICLE= positron.
               0  "                         The calculated NRCYCL does not take into
               0  "                         account particles that are rejected because they
               0  "                         miss the geometry.  If the automatically-calculated
               0  "                         value of still results in restarts, then use the
               0  "                         following guideline for accurate statistics:
               0  "                         1. If there is only one restart and only a small
               0  "                            fraction of the source is re-used on the second
               0  "                            pass, the effect on statistics is unlikely to
               0  "                            be significant.
               0  "                         2. If there is one restart and a significant portion
               0  "                            of the source is re-used on the second pass, set
               0  "                            NRCYCL=2*NRCYCL_prev+1, where NRCYCL_prev is the
               0  "                            previous automatically-calculated value
               0  "                         3. If the source is restarted more than once, try
               0  "                            setting NRCYCL=(no. of restarts+1)*NRCYCL_prev+1
               0  "            IPARALLEL   set >1 if you are distributing the job among
               0  "                        IPARALLEL machines.  IPARALLEL is used with PARNUM
               0  "                        (see below) to partition a phase space source into
               0  "                        IPARALLEL equal parts.
               0  "            PARNUM      For each of the IPARALLEL parallel jobs, PARNUM
               0  "                        should have a different integer value in the range
               0  "                        1<=PARNUM<=IPARALLEL.  The partition of the phase
               0  "                        space source that is used for a particular job is
               0  "                        then given by:
               0  "                           (PARNUM-1)*(NCASE_PHSP/IPARALLEL)<NPHSPN<=
               0  "                                            (PARNUM)*(NCASE_PHSP/IPARALLEL)
               0  "                        where NCASE_PHSP is the total number of particles in
               0  "                        the phsp source and NPHSPN is the particle no. chosen.
               0  "
               0  "  FILSPC                        (C)   filename (with ext) contains
               0  "                                      phase space information
               0  "                                      (maximum of 256 characters)
               0  "                                      (assigned to unit 42)
               0  "
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  22 <<<<<<<<
               0  "
               0  "    FULL BEAM PHASE-SPACE BEAM DATA FROM ANY ANGLE, INSIDE OR OUTSIDE   ""toc:
               0  "
               0  "    PARTICLES ARE READ IN FROM A BEAM PHASE SPACE and placed on a plane
               0  "    described by the SOURCE OPTIONS inputs (see below). Then it is checked
               0  "    whether they are already inside the geometry. If yes, the region index
               0  "    is determined and the shower intiated. If not, it is checked whether
               0  "    the particle trajectory will intersect the geometry (assuming that the
               0  "    geometry is surrounded by vacuum). If not, the particle is rejected and
               0  "    the next one taken from the phase-space file. If yes, the particle
               0  "    is placed on the entry point and the shower is initiated.
               0  "
               0  "  SOURCE OPTIONS                (M9)  IMODE, DIST, ANGLE, ZOFFSET, NRCYCL,
               0  "                                      IPARALLEL, PARNUM, XOFFSET, YOFFSET
               0  "
               0  "               IMODE              0=> 7 variables/record: X,Y,U,V,E,WT,LATCH
               0  "                                  2=> 8 variables/record: the above + ZLAST
               0  "               DIST               Perpendicular distance of the phase-space
               0  "                                  plane to the point of rotation in cm.
               0  "               ANGLE              Angle of rotation in degrees. The rotation
               0  "                                  is performed around an axis that is parallel
               0  "                                  to the x-axis and passes through the point
               0  "                                  (x,y,z)=(0,0,ZOFFSET).
               0  "               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
               0  "                                  the centre of the geometry is taken as
               0  "                                  the point of rotation (but note that
               0  "                                  the maximum value allowed by the input
               0  "                                  routine is 1e6, so that |ZOFFSET| must
               0  "                                  be between 1e4 and 1e6 to use the centre
               0  "                                  of the geometry automatically).
               0  "
               0  "    Examples:
               0  "       - to place a phase-space on the upper z-face of the geometry,
               0  "         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
               0  "         This is the same as source 21
               0  "       - to place a phase space on the lower z-face of the geometry,
               0  "         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
               0  "       - to have a phase file incident from, say, 60 degrees with
               0  "         a distance to the centre of the geometry of 30 cm, use
               0  "         DIST=30, ANGLE=60, ZOFFSET=9999.
               0  "
               0  "              NRCYCL     Number of times to recycle each particle in a phase
               0  "                         space source.  Each particle in the phase space
               0  "                         file is used a total of NRCYCL+1 times before
               0  "                         going on to the next particle.
               0  "                         If NCASE > no. of particles in the phase space file,
               0  "                         then use of NRCYCL is essential for accurate
               0  "                         statistics.
               0  "                         If NRCYCL is set > 0, then the user-input value is
               0  "                         used.
               0  "                         If NRCYCL is set <=0 then NRCYCL is automatically
               0  "                         calculated to use the entire phase space file with no
               0  "                         restarts, unless INCIDENT PARTICLE= positron.
               0  "                         The calculated NRCYCL does not take into
               0  "                         account particles that are rejected because they
               0  "                         miss the geometry.  If the automatically-calculated
               0  "                         value of still results in restarts, then use the
               0  "                         following guideline for accurate statistics:
               0  "                         1. If there is only one restart and only a small
               0  "                            fraction of the source is re-used on the second
               0  "                            pass, the effect on statistics is unlikely to
               0  "                            be significant.
               0  "                         2. If there is one restart and a significant portion
               0  "                            of the source is re-used on the second pass, set
               0  "                            NRCYCL=2*NRCYCL_prev+1, where NRCYCL_prev is the
               0  "                            previous automatically-calculated value
               0  "                         3. If the source is restarted more than once, try
               0  "                            setting NRCYCL=(no. of restarts+1)*NRCYCL_prev+1
               0  "            IPARALLEL   set >1 if you are distributing the job among
               0  "                        IPARALLEL machines.  IPARALLEL is used with PARNUM
               0  "                        (see below) to partition a phase space source into
               0  "                        IPARALLEL equal parts.
               0  "            PARNUM      For each of the IPARALLEL parallel jobs, PARNUM
               0  "                        should have a different integer value in the range
               0  "                        1<=PARNUM<=IPARALLEL.  The partition of the phase
               0  "                        space source that is used for a particular job is
               0  "                        then given by:
               0  "                           (PARNUM-1)*(NCASE_PHSP/IPARALLEL)<NPHSPN<=
               0  "                                            (PARNUM)*(NCASE_PHSP/IPARALLEL)
               0  "                        where NCASE_PHSP is the total number of particles in
               0  "                        the phsp source and NPHSPN is the particle no. chosen.
               0  "    XOFFSET,YOFFSET     X and Y offset of phase space plane (cm).
               0  "                        Offset will be applied before rotating the source.
               0  "
               0  "  FILSPC                        (C)   filename (with ext) contains
               0  "                                      phase space information
               0  "                                      (maximum of 256 characters)
               0  "                                      (assigned to unit 42)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "                     >>>>>>>> SOURCE  23 <<<<<<<<
               0  "
               0  "    BEAM TREATMENT HEAD SIMULATION AS SOURCE INCIDENT FROM AND ANGLE,  ""toc:
               0  "    INSIDE OR OUTSIDE PHANTOM                                          ""toc:
               0  "
               0  "    PARTICLES ARE READ DIRECTLY FROM A BEAM SIMULATION COMPILED AS A
               0  "    SHARED LIBRARY.  Particles are read at the scoring plane in
               0  "    the BEAM simulation (although no phase space file is scored) and are
               0  "    tranlated/rotated by the inputs DIST, ANGLE, XOFFSET, YOFFSET, ZOFFSET,
               0  "    described below.  Then it is checked
               0  "    whether they are already inside the geometry. If yes, the region index
               0  "    is determined and the shower intiated. If not, it is checked whether
               0  "    the particle trajectory will intersect the geometry (assuming that the
               0  "    geometry is surrounded by vacuum). If not, the particle is rejected and
               0  "    the next one taken from the BEAM simulation (more histories are run in
               0  "    the BEAM simulation if required).  If yes, the particle
               0  "    is placed on the entry point and the shower is initiated.
               0  "
               0  "  BEAM CODE                     (C)  The name of the accelerator code being
               0  "                                     used as a source including the BEAM_
               0  "                                     prefix (ie BEAM_accelname).  This code
               0  "                                     must have been compiled as a shared
               0  "                                     library (see the BEAM manual for more
               0  "                                     details) and exist as
               0  "                                     libBEAM_accelname.so (for Linux/Unix) or
               0  "                                     libBEAM_accelname.dll (for Windows) in
               0  "                                     directory $EGS_HOME/bin/config.
               0  "
               0  "  INPUT FILE                    (C)  The name of a working input file
               0  "                                     (no .egsinp extension) for
               0  "                                     the BEAM code BEAM_accelname.  This
               0  "                                     input file must specify output of a
               0  "                                     phase space file at one scoring plane.
               0  "                                     Particles that would have been scored
               0  "                                     in the phase space file are extracted
               0  "                                     and used as the incident particles in
               0  "                                     the DOSXYZ simulation instead.  The
               0  "                                     input file must exist in the directory
               0  "                                     $EGS_HOME/BEAM_accelname.
               0  "
               0  "  PEGS FILE                     (C)  The name of the pegs4 data set (no
               0  "                                     .pegs4dat extension) used
               0  "                                     by BEAM_accelname with the input file
               0  "                                     specified by INPUT FILE.  The pegs4
               0  "                                     data set must exist in either
               0  "                                     $HEN_HOUSE/pegs4/data or in
               0  "                                     $EGS_HOME/pegs4/data.
               0  "
               0  "  WEIGHT WINDOW                 (M2)  MIN_WEIGHT_23, MAX_WEIGHT_23
               0  "
               0  "               MIN_WEIGHT_23         Min. weight of particles to use from
               0  "                                     the BEAM simulation (defaults to -1E30)
               0  "               MAX_WEIGHT_23         Max. weight of particles to use from
               0  "                                     the BEAM simulation (defaults to 1E30)
               0  "
               0  "  SOURCE OPTIONS                (M5)  DIST, ANGLE, ZOFFSET, XOFFSET, YOFFSET
               0  "
               0  "               DIST               Perpendicular distance of the phase-space
               0  "                                  plane to the point of rotation in cm.
               0  "               ANGLE              Angle of rotation in degrees. The rotation
               0  "                                  is performed around an axis that is parallel
               0  "                                  to the x-axis and passes through the point
               0  "                                  (x,y,z)=(0,0,ZOFFSET).
               0  "               ZOFFSET            Point of rotation. If |ZOFFSET| > 1e4,
               0  "                                  the centre of the geometry is taken as
               0  "                                  the point of rotation (but note that
               0  "                                  the maximum value allowed by the input
               0  "                                  routine is 1e6, so that |ZOFFSET| must
               0  "                                  be between 1e4 and 1e6 to use the centre
               0  "                                  of the geometry automatically).
               0  "               XOFFSET,YOFFSET    X and Y offset of scoring plane in BEAM
               0  "                                  simulation (cm).  Offsets are applied before
               0  "                                  rotating the source.
               0  "
               0  "    Examples:
               0  "       - to have BEAM simulation incident on the upper z-face of the geometry,
               0  "         use DIST=0, ANGLE=0, ZOFFSET=zplane(1)
               0  "         This is the same as source 21
               0  "       - to have BEAM simulation incident on the lower z-face of the geometry,
               0  "         use DIST=0, ANGLE=180, ZOFFSET=zplane(n)
               0  "       - to have BEAM simulation incident from, say, 60 degrees with
               0  "         a distance to the centre of the geometry of 30 cm, use
               0  "         DIST=30, ANGLE=60, ZOFFSET=9999.
               0  "
               0  "*******************************************************************************
               0  ;
               0  ENFLAG = 0;
               0  OUTPUT;(/' *** Source inputs read by srcrz ***'/);
               0  OUTPUT;(
               0  ' charge of the incident beam (-1,0,1 [& 2 with source 21]),'/
               0  ' source configuration'/
               0  '      (0) parallel beam incident from the front:(0),radius(cm)'/
               0  '                      incident direction cosines (U,V,W)'/
               0  '   or (1) point source on axis incident from the front(1)'/
               0  '                      source to front face distance,radius(cm)'/
               0  '   or (2) broad parallel beam incident from the front(2)'/
               0  '                      no configuration input necessary,unit area beam'/
               0  '   or (3) uniform isotropically radiating disk(3)'/
               0  '                      min,max radius, min,max Z'/
               0  '   or (4) axial fluence for various beam radii'/
               0  '                      radius of central axis region');
               0  "split here otherwise too many continuation lines"
               0  OUTPUT;
               0  (
               0  '   or (10) parallel beam incident from the side(10)'/
               0  '                      half-width,half-height of beam at center(cm)'/
               0  '   or (11) point source incident from the side(11)'/
               0  '                      source to center distance(cm)'/
               0  '                      half-width,half-height of beam at center(cm)'/
               0  '   or (12) point source incident from off axis(12)'/
               0  '                       perpendicular distance off central axis(cm)'/
               0  '                       perpendicular distance from front face(cm)'/
               0  '   or (13) broad parallel beam incident from any angle:(13)'/
               0  '                      incident direction cosines (U,V,W)'/
               0  '   or (14) point source on axis from front but restricted:(14),'/
               0  '                      source to front face dist, outer,inner radius(cm)'/
               0  '   or (20) parallel beam incident from the front with radial distribution'/
               0  '   or (21) full phase-space on front: each particle read from unit 42'/
               0  '                      file MODE (0. = default, 2. with ZLAST as well),'/
               0  '                      NRCYCL, IPARALLEL, PARNUM'/
               0  '   or (22) full phase-space from any angle: each particle read from unit 42'/
               0  '                      file MODE (0. = default, 2. with ZLAST as well),'/
               0  '                      distance from centre of source plane to point of'/
               0  '                      rotation, angle of rotation about Z axis, Z offset'/
               0  '                      of point of rotation, NRCYCL, IPARALLEL, PARNUM,'/
               0  '                      X offset of source, Y offset of source.'/
               0  '   or (23) BEAM treatment head simulation from any angle: name of BEAM'/
               0  '                      simulation (eg BEAM_accelname), name of BEAM input'/
               0  '                      file (no .egsinp extension), name of BEAM pegs data'/
               0  '                      (no .pegs4dat extension), min. and max. weights of'/
               0  '                      particles to use (defaults to -1e30 - 1e30),'/
               0  '                      distance from centre of BEAM scoring plane to point of'/
               0  '                      rotation, angle of rotation about Z axis, Z offset'/
               0  '                      of point of rotation, X offset of source, Y offset'/
               0  '                      of source.'//);
               0
               0  "--------------------------------------------------------------------------"
               0  "|                           Required inputs                              |"
               0  "--------------------------------------------------------------------------"
               0  "New input routine, by Aaron Merovitz, 04/98"
               0  DELIMETER='SOURCE INPUTS';
               0
               0  IVAL = IVAL + 1;   "IVAL is passed in IODAT2"
               0  NUM_IPART = IVAL;
               0  VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  DEFAULT(IVAL)=0;
               0  ALLOWED_INPUTS(IVAL,4)='ELECTRON';
               0  ALLOWED_INPUTS(IVAL,0)='PHOTON';
               0  ALLOWED_INPUTS(IVAL,1)='POSITRON';
               0  ALLOWED_INPUTS(IVAL,2)='ALL';
               0  ALLOWED_INPUTS(IVAL,3)='CHARGED';
               0  $GET_INPUT(NUM_IPART);
               0
               0  IVAL = IVAL + 1;
               0  NUM_SOURCE = IVAL;
               0  VALUES_SOUGHT(IVAL)='SOURCE NUMBER';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=23;
               0  DEFAULT(IVAL)=0;
               0  $GET_INPUT(NUM_SOURCE);
               0  ISOURC=VALUE(NUM_SOURCE,1);
               0
               0  IF (ISOURC~=20) [
               1      IVAL = IVAL + 1;
               1      NUM_SOPTS = IVAL;
               1      VALUES_SOUGHT(IVAL)='SOURCE OPTIONS';
               1      IF(ISOURC=22)[
               2          NVALUE(IVAL)=9;
               2          ]
               1      ELSE IF( ISOURC=23 ) [
               2          NVALUE(IVAL)=5;
               2          ]
               1      ELSE[
               2          NVALUE(IVAL)=4;
               2          ]
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=-999999;
               1      VALUE_MAX(IVAL)=999999;
               1      DEFAULT(IVAL)=1;
               1      $GET_INPUT(NUM_SOPTS);
               1      TEMP1=VALUE(NUM_SOPTS,1);
               1      TEMP2=VALUE(NUM_SOPTS,2);
               1      TEMP3=VALUE(NUM_SOPTS,3);
               1      TEMP4=VALUE(NUM_SOPTS,4);
               1      IF(ISOURC=22)[
               2          TEMP5=VALUE(NUM_SOPTS,5);
               2          TEMP6=VALUE(NUM_SOPTS,6);
               2          TEMP7=VALUE(NUM_SOPTS,7);
               2          TEMP8=VALUE(NUM_SOPTS,8);
               2          TEMP9=VALUE(NUM_SOPTS,9);
               2          ]
               1      IF( ISOURC=23 ) TEMP5=VALUE(NUM_SOPTS,5);
               1      ]
               0
               0
               0  "NMIN=NUM_IPART;
               0  "NMAX=NUM_SOPTS;
               0  "$GET_INPUTS(NMIN,NMAX);
               0
               0  IQIN=VALUE(NUM_IPART,1);
               0  "this is done because VALUE(I,IVAL) cannot have negative array indices"
               0  IF (IQIN=4) [IQIN=-1;]
               0  WRITE(*,*)' IQIN ',IQIN;
               0  "TEMP1=VALUE(NUM_SOPTS,1);
               0  "TEMP2=VALUE(NUM_SOPTS,2);
               0  "TEMP3=VALUE(NUM_SOPTS,3);
               0  "TEMP4=VALUE(NUM_SOPTS,4);
               0
               0  "--------------------------------------------------------------------------"
               0  "|                           optional inputs                              |"
               0  "--------------------------------------------------------------------------"
               0
               0  IF (ISOURC=20) [
               1      IVAL = IVAL + 1;
               1      NUM_MODEIN = IVAL;
               1      VALUES_SOUGHT(IVAL)='MODEIN';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=1;
               1      ALLOWED_INPUTS(IVAL,0)='LOCAL';
               1      ALLOWED_INPUTS(IVAL,1)='EXTERNAL';
               1      $GET_INPUT(NUM_MODEIN);
               1      MODEIN=VALUE(NUM_MODEIN,1);
               1
               1      IF (MODEIN=1) [
               2          IVAL = IVAL + 1;
               2          NUM_RDFIL = IVAL;
               2          VALUES_SOUGHT(IVAL)='RDIST FILENAME';
               2          NVALUE(IVAL)=1;
               2          TYPE(IVAL)=2;
               2          $GET_INPUT(NUM_RDFIL);
               2          ]
               1      ELSE[
               2          IVAL = IVAL + 1;
               2          NUM_NRDIST = IVAL;
               2          VALUES_SOUGHT(IVAL)='NRDIST';
               2          NVALUE(IVAL)=1;
               2          TYPE(IVAL)=0;
               2          VALUE_MIN(IVAL)=1;
               2          VALUE_MAX(IVAL)=100;
               2          DEFAULT(IVAL)=1;
               2          $GET_INPUT(NUM_NRDIST);
               2          NRDIST=VALUE(NUM_NRDIST,1);
               2
               2          IVAL = IVAL + 1;
               2          NUM_RDISTF = IVAL;
               2          VALUES_SOUGHT(IVAL)='RDISTF';
               2          NVALUE(IVAL)=NRDIST;
               2          TYPE(IVAL)=1;
               2          VALUE_MIN(IVAL)=0;
               2          VALUE_MAX(IVAL)=999999;
               2          DEFAULT(IVAL)=1.0;
               2
               2          IVAL = IVAL + 1;
               2          NUM_RPDF = IVAL;
               2          VALUES_SOUGHT(IVAL)='RPDF';
               2          NVALUE(IVAL)=NRDIST;
               2          TYPE(IVAL)=1;
               2          VALUE_MIN(IVAL)=0;
               2          VALUE_MAX(IVAL)=999999;
               2          DEFAULT(IVAL)=1.0;
               2
               2          NMIN=NUM_NRDIST;
               2          NMAX=NUM_RPDF;
               2          $GET_INPUTS(NMIN,NMAX);
               2          ]
               1
               1      IVAL = IVAL + 1;
               1      NUM_RDIOUTSP = IVAL;
               1      VALUES_SOUGHT(IVAL)='RDIST IOUTSP';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=0;
               1      ALLOWED_INPUTS(IVAL,0)='NONE';
               1      ALLOWED_INPUTS(IVAL,1)='INCLUDE';
               1      $GET_INPUT(NUM_RDIOUTSP);
               1      ] "end if isource = 20"
               0  IF ((ISOURC.EQ.21).OR.(ISOURC.EQ.22)) [
               1      IVAL = IVAL + 1;
               1      NUM_FILSPC = IVAL;
               1      VALUES_SOUGHT(IVAL)='FILSPC';
               1      TYPE(IVAL)=2;
               1      $GET_INPUT(NUM_FILSPC);
               1      ]
               0  IF( ISOURC = 23 ) [
               1
               1      IVAL = IVAL + 1;
               1      NUM_BEAM_CODE = IVAL;
               1      VALUES_SOUGHT(IVAL)='BEAM CODE';
               1      TYPE(IVAL)=2;
               1
               1      IVAL = IVAL + 1;
               1      NUM_PEGS_FILE = IVAL;
               1      VALUES_SOUGHT(IVAL)='PEGS FILE';
               1      TYPE(IVAL)=2;
               1
               1      IVAL = IVAL + 1;
               1      NUM_IFILE = IVAL;
               1      VALUES_SOUGHT(IVAL)='INPUT FILE';
               1      TYPE(IVAL)=2;
               1
               1      $GET_INPUTS(NUM_BEAM_CODE,NUM_IFILE);
               1
               1      IVAL = IVAL + 1;
               1      VALUES_SOUGHT(IVAL)='SECRET';
               1      nvalue(ival)        = 1;
               1      type(ival)          = 3;
               1      allowed_inputs(ival,0) = 'no';
               1      allowed_inputs(ival,1) = 'yes';
               1
               1      IVAL = IVAL + 1;
               1      NUM_WW23 = IVAL;
               1      VALUES_SOUGHT(IVAL)='WEIGHT WINDOW';
               1      NVALUE(IVAL)=2;
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=-1e30;
               1      VALUE_MAX(IVAL)= 1e30;
               1
               1      error_flag_save = error_flag;
               1      $GET_INPUTS(NUM_WW23-1,NUM_WW23);
               1      error_flag = error_flag_save;
               1
               1      IF( error_flags(NUM_BEAM_CODE) = 0 ) [
               2          READ (CHAR_VALUE(NUM_BEAM_CODE,1),FMT='(A)') the_beam_code;
               2          ] ELSE [ error_flag = 1; ]
               1      IF( error_flags(NUM_PEGS_FILE) = 0 ) [
               2          READ (CHAR_VALUE(NUM_PEGS_FILE,1),FMT='(A)') the_pegs_file;
               2          ] ELSE [ error_flag = 1; ]
               1      IF( error_flags(NUM_IFILE) = 0 ) [
               2          READ (CHAR_VALUE(NUM_IFILE,1),FMT='(A)') the_input_file;
               2          ] ELSE [ error_flag = 1; ]
               1      min_weight_23 = -1e30; max_weight_23 = 1e30;
               1      secret_option_23 = 0;
               1      IF( error_flags(NUM_WW23) = 0 ) [
               2          min_weight_23 = value(num_ww23,1); max_weight_23 = value(num_ww23,2);
               2          ]
               1      IF( error_flags(NUM_WW23-1) = 0 ) [
               2          secret_option_23 = value(NUM_WW23-1,1);
               2          ]
               1      ]
               0
               0
               0  IF (ISOURC=20) [
               1      IF (MODEIN=1) [ READ (CHAR_VALUE(NUM_RDFIL,1),FMT='(A)') FILNAM; ]
               1      ELSE[
               2          NRDIST=VALUE(NUM_NRDIST,1);
               2          DO K=1,NRDIST [
               3              RDISTF(K)=VALUE(NUM_RDISTF,K);
               3              RPDF(K)=VALUE(NUM_RPDF,K);
               3              ]
               2          ]
               1      IOUTSP=VALUE(NUM_RDIOUTSP,1);
               1      ]
               0
               0  IF ((ISOURC = 21) | (ISOURC = 22)) [
               1      READ (CHAR_VALUE(NUM_FILSPC,1),FMT='(256A1)') FILSPC;
               1      ]
               0
               0  OUTPUT IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4;(T10,'SRCRZ read:', 2I5,4F12.5);
               0  IF(ISOURC=22) OUTPUT TEMP5,TEMP6,TEMP7,TEMP8,TEMP9;(T10,'           ',5F12.5);
               0
               0  "Check IQIN is OK and set 0 if not acceptable value"
               0  IF((IQIN < -1) | (IQIN > 1 & (ISOURC < 21 | ISOURC > 23))
               0  | (IQIN > 3 & (ISOURC < 21 | ISOURC > 23))) IQIN = 0;
               0
               0  "these three lines to effect source correlation"
               0  "SVTMP1=TEMP1;SVTMP2=TEMP2;SVTMP2=TEMP2;SVTMP2=TEMP2;"
               0  "after jans"
               0  SVTMP1=TEMP1;SVTMP2=TEMP2;SVTMP3=TEMP3;SVTMP4=TEMP4;
               0
               0  RETURN;
               0
               0  ENTRY SRCINI(SCARG1,SCARG2,SCARG3,SCARG4,ICORRL);
               0
               0  NHSTRY=0; "initialize no. of primary histories"
               0  "will have to change this if we start storing this in .egsdat"
               0  "files"
               0  last_nhstry = 0;
               0
               0  IF(ISOURC = 0)[ "FRONTAL PARALLEL BEAM"
               1      RBEAM=TEMP1;
               1      FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
               1      IF(FNORM.EQ.0.0)[ UINC=0.0;VINC=0.0;WINC=1.0; ]
               1      ELSE[
               2          FNORM=SQRT(FNORM);
               2          UINC=TEMP2/FNORM;VINC=TEMP3/FNORM;WINC=TEMP4/FNORM;
               2          ]
               1      TEMP5=RCYL(NR);
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP5))RBEAM=TEMP5;
               1      OUTPUT IQIN,RBEAM,UINC,VINC,WINC;
               1      (/' Electric charge of the source:',T60,I12/
               1      ' Parallel beam incident from the front(+ve Z-axis)'/
               1      ' Radius of beam at the front face of the target:',T60,F10.4,' cm'/
               1      ' X-axis direction cosine:',T60,F10.4/
               1      ' Y-axis direction cosine:',T60,F10.4/
               1      ' Z-axis direction cosine:',T60,F10.4/);
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.1)[ "FRONTAL POINT SOURCE"
               1      DISTZ=TEMP1;RBEAM=TEMP2;TEMP3=RCYL(NR);
               1      IF(DISTZ.LE.0.0)DISTZ=100.;
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP3))RBEAM=TEMP3;
               1      OUTPUT IQIN,DISTZ,RBEAM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' POINT SOURCE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/
               1      ' SOURCE DISTANCE TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' RADIUS OF THE BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/);
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.2)[ "BROAD FRONTAL PARALLEL BEAM"
               1      RBEAM=0.0;
               1      NR=1;NREG=NPLANE;
               1      RCYL(1)=1000.0;CYRAD2(1)=1.0E6;
               1      OUTPUT IQIN,RBEAM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' BROAD PARALLEL BEAM INCIDENT FROM THE FRONT (+VE Z-AXIS)'/
               1      ' RADIUS OF THE BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/);
               1      IF(NMED.NE.1)[
               2          "EACH SLAB IN THE PHANTOM MUST BE HOMOGENEOUS"
               2          OUTPUT;(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL******'/);
               2          ]
               1      ]
               0  ELSEIF(ISOURC = 3)[ "ISOTROPICALLY RADIATING DISK"
               1      RBEAM=TEMP2;
               1      IF(RBEAM > RCYL(NR))[
               2          OUTPUT RBEAM, RCYL(NR);
               2          (//' ***  Source radius too big at',F10.3,' Reduced to',F10.3,' cm');
               2          RBEAM = RCYL(NR);
               2          ]
               1      RBEAM2 = RBEAM**2;
               1      RMINBM = TEMP1; IF(RMINBM > RBEAM)[RMINBM=RBEAM;]
               1      RMINSQ = RMINBM**2;
               1      ZSMIN=TEMP3;ZSMAX=TEMP4;
               1      IF(ZSMIN < ZPLANE(1))[ ZSMIN= ZPLANE(1);]
               1      IF(ZSMAX > ZPLANE(NPLANE))[ ZSMAX = ZPLANE(NPLANE);]
               1      OUTPUT IQIN,RMINBM,RBEAM,ZSMIN,ZSMAX;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' UNIFORM ISOTROPICALLY RADIATING RING: INNER,OUTER Radius',2F10.3 /
               1      '           FRONT,Back DEPTH:',T50,2F10.3 /);
               1      ]
               0  ELSEIF(ISOURC = 4)[ "POINT SOURCE WITH VARIOUS BEAM RADII"
               1      RBEAM=TEMP1;
               1      IF(RCYL(NR).LT.650.)[
               2          "MUST HAVE A BROAD PHANTOM changed limit to 650 cm April 1990 DR"
               2          IF(NR.LT.$MAXRADII)[NR=NR+1;NREG=NZ*NR+1;]
               2          ELSE[OUTPUT;(/' ***WARNING***  LAST RADIAL BIN INCREASED TO 1000cm'/);]
               2          RCYL(NR)=1000.0;CYRAD2(NR)=1.0E6;
               2          ]
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR))) RBEAM=RCYL(NR);
               1      OUTPUT IQIN,RBEAM;(/' ELECTRIC CHARGE OF BEAM:',T60,I12/
               1      ' CENTRAL AXIS FLUENCE VS BEAM RADIUS'/
               1      ' RADII INPUT ABOVE WILL BE CONSIDERED AS BEAM RADII'/
               1      ' RADIUS OF CENTRAL AXIS ZONE: ',T60,F10.4,' cm'/);
               1      IF(NMED.NE.1)[
               2          "EACH SLAB IN THE PHANTOM MUST BE HOMOGENEOUS"
               2          OUTPUT;(/' **** ALL REGIONS IN A SLAB MUST BE SAME MATERIAL******'/);
               2          ]
               1      ]
               0  ELSEIF(ISOURC = 10)[ "SIDE PARALLEL BEAM"
               1      XBEAM=TEMP1;ZBEAM=TEMP2;
               1      TEMP3=RCYL(NR);
               1      IF((XBEAM.LE.0.0).OR.(XBEAM.GT.TEMP3))XBEAM=TEMP3;
               1      TEMP3=0.5*(ZPLANE(NPLANE)-ZPLANE(1));
               1      IF((ZBEAM.LE.0.0).OR.(ZBEAM.GT.TEMP3))ZBEAM=TEMP3;
               1      OUTPUT IQIN,XBEAM,ZBEAM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' PARALLEL BEAM INCIDENT FROM THE SIDE'/
               1      ' HALF-WIDTH(X-AXIS) OF THE BEAM AT THE TARGET MIDPOINT',T60,F10.4,' cm'/
               1      ' HALF-HEIGHT(Z-AXIS/) OF THE BEAM AT THE TARGET MIDPOINT',
               1      T60,F10.4,' cm'/);
               1      ]
               0  ELSEIF(ISOURC = 11)[ "Side point source centered at target middle"
               1      DISTRH = TEMP1;
               1      IF(DISTRH < 0.0) DISTRH=-DISTRH;
               1      IF(DISTRH = 0.0) DISTRH=100.0;
               1      XBEAM = TEMP2;   ZBEAM = TEMP3;
               1      TEMP4 = RCYL(NR);
               1      IF(DISTRH <= TEMP4)[
               2          OUTPUT;(' SOURCE FROM WITHIN TARGET, INPUT IGNORED');
               2          ERROR_FLAG=1;
               2          ]
               1      "TEMP4 is the maximum 1/2 width of the beam by simple geometry"
               1      TEMP4=TEMP4*SQRT((DISTRH+TEMP4)*(DISTRH-TEMP4))/DISTRH; "SHADOWING"
               1      IF((XBEAM <= 0.0) | (XBEAM > TEMP4)) XBEAM=TEMP4;
               1      TEMP4=0.5*(ZPLANE(NPLANE)-ZPLANE(1));
               1      IF((ZBEAM <= 0.0) | (ZBEAM > TEMP4)) ZBEAM=TEMP4;
               1      IF(ICORRL = 0)[
               2          OUTPUT IQIN,DISTRH,XBEAM,ZBEAM;
               2          (/' Electric charge of the source:',T60,I12/
               2          ' Point source on axis incident from the side(Y-axis)'/
               2          ' Source distance to target midpoint:',T60,F10.4,' cm'/
               2          ' Half-width(X-axis) of the beam at the target midpoint',T60,F10.4,' cm'/
               2          ' Half-height(Z-axis/) of the beam at the target midpoint',
               2          T60,F10.4,' cm'/);
               2          ]
               1      ]
               0  ELSEIF(ISOURC = 12)[ "point source off axis"
               1      DISTRH=TEMP1;       "DISTRH is distance of source from center of geomety"
               1      IF(DISTRH < 0.0)DISTRH=-DISTRH;
               1      DISTZ=TEMP2;        "DISTZ is distance of source from front of geometry"
               1      "DISTZ > 0     point located in front of front face
               1      "0 > DISTZ > -(ZPLANE(NPLANE)-ZPLANE(1))
               1      "              point located between front, rear faces
               1      "DISTZ < -(ZPLANE(NPLANE)-ZPLANE(1))
               1      "              point located rear of rear plane
               1      RBEAM=RCYL(NR);
               1      IF(DISTRH > RBEAM)["the source is further away than the outer radius"
               2          "XBEAM    half-height of the beam at the center of the target"
               2          "         following is simple geometry-its really 1/2 width if you"
               2          "         think of Z as the height direction"
               2          XBEAM=RBEAM*SQRT((DISTRH-RBEAM)*(DISTRH+RBEAM))/DISTRH;
               2          "ZBEAM is half-width (height) of the beam at the center of the target"
               2          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1));
               2          ]
               1      ELSE[ "source either inside geometry (error caught below)"
               2          "or it just hits the top or bottom of the geometry, not the side"
               2          XBEAM=0.0; ZBEAM=0.0;
               2          ]
               1      IF((DISTRH <= RBEAM) & DISTZ >= ZPLANE(1)-ZPLANE(NPLANE) & DISTZ<=0.0) [
               2          "first condition => inside cylinder outer boundary"
               2          "2nd condition => it is above lower plane"
               2          "3rd condition => it is below front face"
               2          OUTPUT;(' Source from within target, input ignored');
               2          ERROR_FLAG=1;
               2          ]
               1      OUTPUT IQIN,DISTRH,DISTZ,RBEAM,XBEAM,ZBEAM;
               1      (/' Electric charge of the source:',T60,I12/
               1      ' Point source off axis'/
               1      ' Distance of source off the central axis',T60,F10.4,' cm'/
               1      ' Perpendicular distance of source from front plane',T60,F10.4,' cm'/
               1      ' Radius of the beam on the front face of the target:',T60,F10.4,' cm'/
               1      ' Half-width(X-axis) of the beam between the tangent points',
               1      T60,F10.4,' cm'/
               1      ' Half-height(z-axis) of the beam between the tangent points',
               1      T60,F10.4,' cm'/);
               1      ]
               0
               0  ELSEIF(ISOURC = 13)[ "Frontal parallel beam at any angle wrt the target"
               1      FNORM=TEMP1**2+TEMP2**2+TEMP3**2;
               1      IF(FNORM = 0.0)[ UINC=0.0;VINC=0.0;WINC=1.0; ]
               1      ELSE[
               2          "AT THIS POINT THE INCIDENT BEAM IS ROTATED SO THAT THE"
               2          "DIRECTION IS IN THE Y-Z PLANE AND POINTED IN THE      "
               2          "NEGATIVE Y DIRECTION. THE NEGATIVE DIRECTION IS CHOSEN"
               2          "BECAUSE THE ENTRANCE POINT IS CHOSEN TO BE ON THE     "
               2          "POSITIVE Y-SIDE OF THE CYLINDER. (SEE MACRO $CHOOSE-  "
               2          "POINT-IN-RECTANGLE.) THIS ROTATION IS PERMITTED       "
               2          "OF THE AZIMUTHAL SYMMETRY OF THE TARGET.THE REST OF   "
               2          "CODING IS LEFT GENERAL WHERE POSSIBLE TO ALLOW THE    "
               2          "SYMMETRY TO BE RELAXED.                               "
               2          FNORM=SQRT(FNORM);
               2          WINC=TEMP3/FNORM;
               2          VINC=-SQRT((1.0-WINC)*(1.0+WINC));
               2          UINC=0.0;
               2          ]
               1      RBEAM=RCYL(NR);
               1      IF(ABS(WINC).NE.1.0)[
               2          XBEAM=RBEAM;
               2          ZBEAM=0.5*(ZPLANE(NPLANE)-ZPLANE(1));
               2          ]
               1      ELSE[ XBEAM=0.0;ZBEAM=0.0; ]
               1      OUTPUT IQIN,UINC,VINC,WINC,RBEAM,XBEAM,ZBEAM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' PARALLEL BEAM AT ANY ANGLE WITH RESPECT TO THE TARGET'/
               1      ' X-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Z-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' RADIUS OF THE BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' HALF-WIDTH(X-AXIS) OF THE BEAM BETWEEN THE TANGENT POINTS',
               1      T60,F10.4,' cm'/
               1      ' HALF-HEIGHT(Z-AXIS) OF THE BEAM BETWEEN THE TANGENT POINTS',
               1      T60,F10.4,' cm'/);
               1      ]
               0  ELSEIF(ISOURC = 14)[
               1      "FRONTAL POINT SOURCE with all particles below some radius skipped"
               1      DISTZ=TEMP1;RBEAM=TEMP2;RMINBM=TEMP3;
               1      IF(DISTZ.LE.0.0)DISTZ=100.;
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.RCYL(NR)))RBEAM=RCYL(NR);
               1      IF(RMINBM=0.0)[OUTPUT;(/' ***WHY USE ISOURC=14 WITH RMINB=0.0?***');]
               1      OUTPUT IQIN,DISTZ,RBEAM,RMINBM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' POINT SOURCE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/
               1      ' SOURCE DISTANCE TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' RADIUS OF THE BEAM ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' INNER RADIUS OF BEAM ON FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/);
               1      ]
               0  ELSEIF(ISOURC = 15) [
               1      "Point source from an arbitrary distance and direction."
               1      "This uses an alternative coding to source 12 to avoid "
               1      "strongly varying weights in some cases "
               1      call src15_ini(temp1,temp2,temp3,temp4,ERROR_FLAG);
               1      ]
               0  ELSEIF(ISOURC = 16) [
               1      "A disk or a rectangle irradiating the geometry "
               1      "from an arbitrary distance or angle            "
               1      call src16_ini(temp1,temp2,temp3,temp4,ERROR_FLAG);
               1      ]
               0
               0  ELSEIF(ISOURC = 17)[ "FRONTAL POINT SOURCE"
               1      DISTZ=TEMP1;XBEAM=TEMP2;YBEAM=TEMP3;TEMP4=RCYL(NR);
               1      IF(DISTZ.LE.0.0)DISTZ=100.;
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.TEMP4))RBEAM=TEMP4;
               1      OUTPUT IQIN,DISTZ,XBEAM,YBEAM;
               1      (/' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' POINT SOURCE ON AXIS INCIDENT FROM THE FRONT(+VE Z-AXIS)'/
               1      ' SOURCE DISTANCE TO THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' X-AXIS HALF-WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' Y-AXIS HALF-WIDTH ON THE FRONT FACE OF THE TARGET:',T60,F10.4,' cm'/);
               1      ]
               0
               0  ELSEIF(ISOURC = 20)["Radial distribution"
               1      OUTPUT;(' Local input(0) or external file(1): ',$);
               1      "IF(MODEIN.NE.1) MODEIN=0;"  "DEFAULT"
               1      OUTPUT;(/' RADIAL DISTRIBUTION:');
               1      IF(MODEIN.EQ.0)[
               2          "INPUT FROM KEYBOARD OR .INP FILE"
               2          OUTPUT;(' Number of radial bins: ',$);
               2          IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
               3              OUTPUT;
               3              (/' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
               3              ' RESET TO 100 ***');
               3              NRDIST=100;
               3              ]
               2          OUTPUT NRDIST;(' INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT');
               2          OUTPUT;('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE');
               2          DO IB=1,NRDIST[
               3              "What is this?  DR"
               3              ]
               2          ]
               1      ELSE[
               2          "EXTERNAL FILE INPUT"
               2          OUTPUT;
               2          (' Input name of file with spectrum (up to 80 char with .ext): '/);
               2          "READ(5,600,END=:EOF_SRCRZ:)FILNAM;"
               2          OUTPUT FILNAM;(/' Read input radial distribution from: '/80A1);
               2          call replace_env(FILNAM);
               2          OPEN(UNIT=9,file=filnam,STATUS='OLD');
               2          READ(9,*)NRDIST;
               2          IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
               3              OUTPUT;
               3              (' *** Number radial bins out of range (<1 OR >100),',
               3              ' RESET TO 100 ***');
               3              NRDIST=100;
               3              ]
               2          DO IB=1,NRDIST [READ(9,*)RDISTF(IB),RPDF(IB);]
               2          CLOSE(UNIT=9);
               2          OUTPUT NRDIST;('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE');
               2          ]
               1
               1      "DO A CHECK ON THE RADIAL DISTRIBUTION"
               1      ICOUNT=0;
               1      RLAST=0;
               1      IERROR=0;
               1      :R-DIST-INPUT:LOOP[
               2          ICOUNT=ICOUNT+1;
               2          IF(ICOUNT.GT.NRDIST)[EXIT:R-DIST-INPUT:;]
               2          IF(RDISTF(ICOUNT).LE.RLAST)[
               3              IERROR=1;
               3              OUTPUT;
               3              (' *** RDISTF>=LAST ONE. NOT ALLOWED,',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT.');
               3              ]
               2          ELSEIF(RDISTF(ICOUNT).GT.RCYL(NR))[
               3              IERROR=1;
               3              OUTPUT RCYL(NR);
               3              (' *** RDISTF>',G14.7,', GEOMETRY SIZE.',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT');
               3              ]
               2          ELSEIF(RPDF(ICOUNT).LT.0.0)[
               3              IERROR=1;
               3              OUTPUT;(' PDF < 0 NOT ALLOWED,',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT');
               3              ]
               2          IF(IERROR.EQ.1)[
               3              ICOUNT=ICOUNT-1;
               3              IF(ICOUNT.EQ.0)[
               4                  OUTPUT;(' *** NO RADIAL DISTRIBUTION DEFINED,',
               4                  ' STOPPING EXECUTION ***');
               4                  STOP;
               4                  ]
               3              OUTPUT ICOUNT;
               3              (' RADIAL DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,',
               3              ' NRDIST RESET TO ',I12);
               3              NRDIST=ICOUNT;
               3              EXIT:R-DIST-INPUT:;
               3              ]
               2          RLAST=RDISTF(ICOUNT);
               2          ]
               1
               1      OUTPUT RDISTF(NRDIST);
               1      ('    RADIAL DISTRIBUTION RANGES FROM 0 TO',F12.3,' cm');
               1
               1      OUTPUT;(' PRINT DISTRIBUTION DATA IN OUTPUT SUMMARY, YES(1) OF NO(0): ',$);
               1      IF(IOUTSP.NE.1) IOUTSP=0;
               1      WRITE(6,'('' '')')
               1      ]
               0
               0  ELSEIF( ISOURC = 23 ) [ "A full treatment head simulation source using BEAM"
               1      dist_phsp = temp1; theta_phsp = temp2;
               1      cost_phsp = cos(theta_phsp*0.017453292222);
               1      sint_phsp = sin(theta_phsp*0.017453292222);
               1      chamber_c = temp3; xoffset = temp4; yoffset = temp5;
               1      ENFLAG=1;
               1      iqinc = iqin;
               1      OUTPUT iqinc,min_weight_23,max_weight_23,
               1      $cstring(the_beam_code),$cstring(the_pegs_file),
               1      $cstring(the_input_file),
               1      dist_phsp,theta_phsp,chamber_c,xoffset,yoffset;
               1      (/' Full treatment head simulation from an angle'/,
               1      '    Particle charge                               : ',i3,/
               1      '    Weight window                                 : ',2g15.6,/
               1      '    BEAMnrc user code                             : ',a,/
               1      '    PEGS data file                                : ',a,/
               1      '    Input file                                    : ',a,/
               1      '    Rotation point to phsp-plane midpoint distance: ',f10.4,/
               1      '    Incident angle (degrees)                      : ',f10.4,/
               1      '    Rotation point (will be set to chamber center'/,
               1      '      if greater than 1e4 or less than -1e4):     : ',g14.4,
               1      ' cm.'/
               1      '    X offset of phsp plane (before rotation)      : ',f10.4,' cm'/
               1      '    Y offset of phsp plane (before rotation)      : ',f10.4,' cm');
               1      write(6,'(//a)') 'About to call init_beamsource';
               1      call init_beamsource(i_parallel,n_parallel,i_log,$CONFIGURATION_NAME,
               1      hen_house,egs_home,the_beam_code,
               1      the_pegs_file,the_input_file);
               1      call maxenergy_beamsource(EKSRCM);
               1      EIN=EKSRCM;
               1      OUTPUT EKSRCM;
               1      ('    Max. kinetic energy of simulation             : ',f10.4,' MeV'/);
               1      ]
               0
               0  ELSEIF((ISOURC = 21) | (ISOURC = 22))["full phase space for each particle"
               1      IQINC=IQIN;"IQINC is used in SRCHST"
               1      IF(ISOURC = 22) [
               2          dist_phsp=TEMP2; theta_phsp = temp3;
               2          cost_phsp = cos(theta_phsp*0.017453292222); "convert to radians"
               2          sint_phsp = sin(theta_phsp*0.017453292222);
               2          chamber_c = temp4;
               2          count_phsp = 0;
               2          xoffset = TEMP8;
               2          yoffset = TEMP9;
               2          ]
               1      IMODE=TEMP1;"MODE OF THE PH-SP FILE"
               1      IF(ISOURC=21)[
               2          NRCYCL=TEMP2;
               2          IPARALLEL=TEMP3;
               2          PARNUM=TEMP4;
               2          ]
               1      ELSEIF(ISOURC=22)[
               2          NRCYCL=TEMP5;
               2          IPARALLEL=TEMP6;
               2          PARNUM=TEMP7;
               2          ]
               1      IF(IMODE.NE.2)IMODE=0;"DEFAULT TO MODE0"
               1      OUTPUT IMODE;
               1      (/' MODE',I2,' Phase-space file to be read from unit 42...'/
               1      ' Input name of file with phase space data (1 - 80 CHARS,',
               1      'with .EXT): ');
               1      OUTPUT FILSPC;(/' Reading phase space information from: '/10x,256A1);
               1      call replace_env(SPCNAM);
               1      i_iaea_in=0; "assume not IAEA format"
               1      ilen=lnblnk1(SPCNAM);
               1      IF(SPCNAM(ilen-8:ilen)='.IAEAphsp')[
               2          i_iaea_in=1;
               2          SPCNAM=SPCNAM(:ilen-9);
               2          ]
               1
               1      IF(i_iaea_in=1)[
               2          i_unit_in=42;
               2          $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,SPCNAM);
               2          $IAEA_READ_PHSP_HEADER(i_unit_in,NCASE_PHSP,NPHOTPHSP,TEMP2,NINCSRC,
               2          Z_SOURCE,ismode,IMUPHSP,IZSCORE);
               2          OUTPUT NCASE_PHSP,NPHOTPHSP,TEMP2,NINCSRC;
               2          (T10,' IAEA format Phase space source with:'/
               2          T5,'                    Total number of particles =',I13/
               2          T5,'                            Number of photons =',I13/
               2          T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
               2          T5,' # of particles incident from original source =',F13.1/);
               2          IF(IZSCORE=0)[
               3              OUTPUT Z_SOURCE;
               3              (T5,'                        Z where source scored =',F13.3,' cm'/);
               3              ]
               2          $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(i_unit_in);
               2          ]
               1      ELSE[
               2
               2          $OPEN_PHSP_FOR_READ(IMODE,42,SPCNAM,LINE1,NCASE_PHSP,
               2          NPHOTPHSP,TEMP2,TEMP3,NINCSRC);
               2
               2          "NCASE_PHSP: the total # of particles in the ph-sp file"
               2          "the 3rd variable is the number of photons"
               2          "the 4th variable is the maximum kinetic energy of all particles"
               2          "the 5th variable is the minimum kinetic energy of electrons"
               2          "the 6th variable is the # of incident partices from original source"
               2
               2          OUTPUT NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC;
               2          (' Total number of particles in file      :',I10/
               2          ' Total number of photons                :',I10/
               2          ' (the rest are electrons and positrons)'//
               2          ' Maximum kinetic energy of the particles:',F10.3,' MeV'/
               2          ' Minimum kinetic energy of the electrons:',F10.3,' MeV'/
               2          ' # particles incident when phase space created :',F15.0/);
               2          EKSRCM=TEMP2;EIN=TEMP2;"EIN WILL BE USED BY PRESTA LATER"
               2
               2          IF (NCASE_PHSP < 0 | NPHOTPHSP < 0 | TEMP2 <= 0 | TEMP3 <0 |
               2          NINCSRC <=0.0) ["This means something wrong "
               3              OUTPUT;( 3(1x,79('*')/)/' Something is wrong in the above'
               3              /'Likely the file is the wrong format (need to swap bytes)'/
               3              3(1x,79('*')/));
               3              STOP;
               3              ]
               2
               2          "read record 2 of phsp source, if NHSTRYM gets incremented, then we"
               2          "can read NHSTRY from this source."
               2          NHSTRYM=0;
               2          $READ_PHSP_RECORD(IMODE,42,2:
               2          NHSTRYM,ZLASTM,LATCHM,EINM,WEIGHTM,XINM,YINM,UINM,VINM);
               2          IF(NHSTRYM~=1)[
               3              DOSE_STAT=1;
               3              OUTPUT;(//' ***WARNING***'/
               3              ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
               3              ' Dose and fluence will be analyzed assuming each particle read from'/
               3              ' the ph-sp file is an independent history.  May result in an'/
               3              ' underestimate of uncertainties.'//);
               3              ]
               2
               2          ]"end of standard BEAMnrc phsp format"
               1
               1      IF( isourc = 22 ) [
               2          OUTPUT dist_phsp,theta_phsp,chamber_c,xoffset,yoffset;
               2          (/' Phase space file from an angle'/,
               2          '    Rotation point to phsp-plane midpoint distance: ',f10.4,/
               2          '    Incident angle (degrees)                      : ',f10.4,/
               2          '    Rotation point (will be set to chamber center'/,
               2          '      if greater than 1e4 or less than -1e4):     : ',g14.4,
               2          ' cm.'/
               2          '    X offset of phsp plane (before rotation)      : ',f10.4,' cm'/
               2          '    Y offset of phsp plane (before rotation)      : ',f10.4,' cm'/);
               2          ]
               1
               1      IF(IPARALLEL>1 & n_parallel>0)[
               2          OUTPUT IPARALLEL, n_parallel;
               2          (/' You have set IPARALLEL in the input file to ',I4,/
               2          ' But you are also running a C compiled code with n_parallel=',I4,/
               2          ' IPARALLEL will be reset to 1, and control of the parallel run '/
               2          ' will be from the code.'/);
               2          IPARALLEL=1;
               2          ]
               1
               1      IF(IPARALLEL<=0) IPARALLEL=1;
               1      IF(PARNUM<0) PARNUM=0;
               1      IF(IPARALLEL>1)[
               2          IF(PARNUM>=1 & PARNUM<=IPARALLEL)[
               3              OUTPUT IPARALLEL,INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1,
               3              INT(PARNUM*NCASE_PHSP/IPARALLEL);
               3              (/' This is one of ',I4,' parallel jobs.'/
               3              ' It will use from particle ',I12,' to particle ',I12,/
               3              ' from the phase space source in the simulation.'/);
               3              ]
               2          ELSE[
               3              OUTPUT IPARALLEL;
               3              (/' IPARALLEL input indicates that this is one of ',I4,' parallel jobs.'/
               3              ' But PARNUM is out of range (<1 or >IPARALLEL).  Therefore, phsp '/
               3              ' source will not be partitioned.'/);
               3              PARNUM=0;
               3              IPARALLEL=1;
               3              ]
               2          ]
               1      IF(NRCYCL<=0)[
               2          IF(IQIN=1)["cannot estimate NRCYCL"
               3              OUTPUT;(/' NRCYCL cannot be calculated automatically because'/
               3              ' INCIDENT PARTICLE= positrons '/);
               3              NRCYCL=0;
               3              ]
               2          ELSE[
               3              OUTPUT;(/' NRCYCL will be calculated automatically'/);
               3              IF(IQIN=-1 | IQIN=3)[
               4                  TEMPDIV=NCASE_PHSP-NPHOTPHSP;
               4                  ]
               3              ELSEIF(IQIN=0)[
               4                  TEMPDIV=NPHOTPHSP;
               4                  ]
               3              ELSEIF(IQIN=2)[
               4                  TEMPDIV=NCASE_PHSP;
               4                  ]
               3              IF(NINT(dble(IPARALLEL*NCASE)/dble(TEMPDIV))<=1)[
               4                  "IPARALLEL*NCASE slightly > TEMPDIV or < TEMPDIV"
               4                  NRCYCL=0;
               4                  ]
               3              ELSEIF(MOD(IPARALLEL*NCASE,TEMPDIV)=0)[
               4                  "IPARALLEL*NCASE is an exact multiple of TEMPDIV"
               4                  NRCYCL=(IPARALLEL*NCASE)/TEMPDIV-1;
               4                  ]
               3              ELSE[
               4                  NRCYCL=(IPARALLEL*NCASE)/TEMPDIV;
               4                  ]
               3              ]
               2          ]
               1      OUTPUT NRCYCL;
               1      (/' Particles will be recycled ',I4,' times before moving on to next one.'/);
               1
               1      CYCLNUM=0; "counts number of times a particle has been recycled"
               1      ENFLAG=1; "flag to tell ensrc that no questions needed re energy"
               1      N_RUN_CHUNK_OLD=0; "initialize for parallel runs"
               1      ]
               0  ELSE[ "defaults to parallel beam from the front"
               1      ISOURC=0;RBEAM=RCYL(NR);
               1      OUTPUT IQIN,RBEAM;
               1      (/
               1      ' Electric charge of the source:',T60,I12/
               1      ' Parallel beam incident from the front(+ve Z-axis)'/
               1      ' Radius of beam at the front face of the target:',T60,F10.4,' cm'/);
               1      ]
               0
               0  RETURN;  "normal return"
               0
               0  :EOF_SRCRZ:;  "bad input"
               0  ERROR_FLAG=1;RETURN;
               0
               0  "all data has now been fed into the routine"
               0
               0  "************************************************************************
               0
               0  ENTRY SRCOTO(WEIGHT);    "toc:
               0  "==================="
               0
               0  "Calculation of one time only constants that may vary with source type"
               0
               0  IFPB=1;"default flag to not being frontal parallel beam"
               0
               0  IF((ISOURC.EQ.0).OR.(ISOURC.EQ.2).OR.(ISOURC.EQ.4))[
               1      "frontal parallel beam source"
               1      IFPB=0;"set flag- passed in common source"
               1      IF((ISOURC.EQ.0).AND.(WINC.NE.1.)) IFPB=1; "not for angled incidence"
               1      RBEAM=RBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      RBEAM2=RBEAM**2;
               1      WEIGHT=1.0; "incident weight"
               1      "incident fluence"
               1      AFACE=PI*RBEAM2;
               1      IF(ISOURC = 0)[AINFLU=dble(NCASET)/AFACE;]
               1      ELSE[AINFLU=dble(NCASET);]
               1      ]
               0
               0  ELSEIF(ISOURC = 1)[ "frontal point source"
               1      RBEAM=RBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      RBEAM2=RBEAM**2;
               1      DISTZ2=DISTZ**2;
               1      DISTRH=0.0; "on-axis"
               1      ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               1      ZSOFST=ZPLANE(1)-DISTZ;
               1      AFACE=PI*RBEAM**2;
               1      PROBFC=1.0;
               1      "incident fluence times solid angle"
               1      "  the solid angle factor is cancelled by the weighting routine"
               1      "  see bielajew,rogers and nahum, phys med biol 1985 for details"
               1      AINFLU=dble(NCASET)/DISTZ2;
               1      ]
               0
               0  ELSEIF(ISOURC = 3)[ "isotropically radiating disk"
               1      WEIGHT=1.0;
               1      AINFLU=dble(NCASET);
               1      "   Following are used to sample Z easily
               1      ZSOFST=0.5*(ZSMAX - ZSMIN)+ ZSMIN;
               1      ZBEAM=0.5*(ZSMAX - ZSMIN);
               1      ]
               0
               0  ELSEIF(ISOURC = 10)[ "SIDE PARALLEL BEAM"
               1      XBEAM=XBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      ZBEAM=ZBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               1      RCYL1=RCYL(NR);
               1      RCYL2=RCYL1**2;
               1      ASIDE=4.0*XBEAM*ZBEAM;
               1      WEIGHT=1.; "INCIDENT WEIGHT"
               1      AINFLU=dble(NCASET)/ASIDE; "INCIDENT FLUENCE"
               1      ]
               0
               0  ELSEIF(ISOURC = 11)[ "SIDE POINT SOURCE CENTERED AT TARGET MIDDLE"
               1      XBEAM=XBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      ZBEAM=ZBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               1      ZSOFST=ZCOFST; "BEAM CENTERED ON TARGET MID-POINT"
               1      RCYL1=RCYL(NR);
               1      RCYL2=RCYL1**2;
               1      DSTRH2=DISTRH**2;
               1      ASIDE=4.0*XBEAM*ZBEAM;
               1      PROBSD=1.0;
               1      "INCIDENT FLUENCE AT THE CENTER OF THE GEOMETRY TIMES SOLID ANGLE"
               1      AINFLU = dble(NCASET)/DSTRH2;
               1      ]
               0
               0  ELSEIF(ISOURC = 12)[ "point source off axis"
               1      RBEAM = RBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      XBEAM = XBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      ZBEAM = ZBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      ZCOFST = 0.5*(ZPLANE(NPLANE)+ZPLANE(1));"Z-axis offset of center of geom"
               1      ZSOFST = ZPLANE(1)-DISTZ;  "Z-axis offset of the source"
               1      RBEAM2 = RBEAM**2;
               1      RCYL1 = RCYL(NR);
               1      RCYL2 = RCYL1**2;
               1      DSTRH2 = DISTRH**2;
               1      DISTZ2 = DISTZ**2;
               1      DISTB = DISTZ-(ZPLANE(NPLANE)-ZPLANE(1));
               1      "DISTB is distance of point source from back of geomery"
               1      DISTB2 = DISTB**2;
               1      AFACE = PI*RBEAM2;
               1      ASIDE = 4.0*XBEAM*ZBEAM;
               1      "Incident fluence referred to midpoint"
               1      AINFLU = NCASET/(DSTRH2+(ZCOFST-ZSOFST)**2);
               1      IF(DISTRH <= RCYL(NR))[ "either front or back face exclusively"
               2          PROBSD = 0;
               2          IF(DISTZ >= 0.0)["front face only" PROBFC = 1.0;PROBBK = 0.0; ]
               2          ELSEIF(DISTZ <= (ZPLANE(1)-ZPLANE(NPLANE)))["back face only"
               3              PROBFC = 0.0;PROBBK = 1.0;
               3              ]
               2          ]
               1      ELSEIF((DISTZ >= (ZPLANE(1)-ZPLANE(NPLANE)) & (DISTZ <= 0.0)))[
               2          "hits side exclusively"
               2          PROBFC = 0.0;PROBBK = 0.0;PROBSD = 1.0;
               2          ]
               1      ELSE[ "intermediate case - can hit two surfaces"
               2          COTANG = ZSOFST/DISTRH;
               2          IF(COTANG < 0.0)["incident from front and side"
               3              FACTOR = AFACE*ABS(COTANG)/ASIDE;
               3              PROBSD = 1.0/(1.0+FACTOR);
               3              PROBFC = FACTOR/(1.0+FACTOR);
               3              PROBBK = 0.0;
               3              ]
               2          ELSE["incident from back and side"
               3              FACTOR = AFACE*COTANG/ASIDE;
               3              PROBSD = 1.0/(1.0+FACTOR);
               3              PROBBK = FACTOR/(1.0+FACTOR);
               3              PROBFC = 0.0;
               3              ]
               2          ]"end two surface case"
               1      ]
               0
               0  ELSEIF(ISOURC = 15) [ call src15_oto(iout); ]
               0  ELSEIF(ISOURC = 16) [ call src16_oto(iout); ]
               0
               0  ELSEIF(ISOURC = 17)[ "frontal point source"
               1      XBEAM=XBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      YBEAM=YBEAM*$ONE-EPS; "scale down to insure a strike on the target"
               1      DISTZ2=DISTZ**2;
               1      DISTRH=0.0; "on-axis"
               1      ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               1      ZSOFST=ZPLANE(1)-DISTZ;
               1      AFACE=4.0*XBEAM*YBEAM;
               1      PROBFC=1.0;
               1      "incident fluence times solid angle"
               1      "  the solid angle factor is cancelled by the weighting routine"
               1      "  see bielajew,rogers and nahum, phys med biol 1985 for details"
               1      AINFLU=FLOAT(NCASET)/DISTZ2;
               1      ]
               0
               0  ELSEIF(ISOURC = 13)[ "BROAD PARALLEL BEAM AT ANY ANGLE wrt THE TARGET"
               1      RBEAM=RBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      XBEAM=XBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      ZBEAM=ZBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      RBEAM2=RBEAM**2;
               1      RCYL1=RCYL(NR);
               1      RCYL2=RCYL1**2;
               1      ZCOFST=0.5*(ZPLANE(1)+ZPLANE(NPLANE));
               1      AFACE=PI*RBEAM2;
               1      ASIDE=4.0*XBEAM*ZBEAM;
               1      WEIGHT=1.0; "INCIDENT WEIGHT"
               1      AINFLU=NCASET/(ABS(WINC)*AFACE+SQRT(UINC**2+VINC**2)*ASIDE);
               1      IF(WINC.EQ.1.0)[
               2          "FRONT FACE EXCLUSIVELY"
               2          PROBFC=1.0;PROBSD=0.0;PROBBK=0.0;
               2          ]
               1      ELSEIF(WINC.EQ.0.0)[
               2          "HITS SIDE EXCLUSIVELY"
               2          PROBFC=0.0;PROBSD=1.0;PROBBK=0.0;
               2          ]
               1      ELSEIF(WINC.EQ.-1.0)[
               2          "BACK FACE EXCLUSIVELY"
               2          PROBFC=0.0;PROBSD=0.0;PROBBK=1.0;
               2          ]
               1      ELSE[
               2          "INTERMEDIATE CASE - CAN HIT TWO SURFACES"
               2          IF(WINC.LT.0.0)["INCIDENT FROM BACK AND SIDE"
               3              FACTOR=AFACE*ABS(WINC)/(ASIDE*SQRT(UINC**2+VINC**2));
               3              PROBFC=0.0;
               3              PROBSD=1.0/(1.0+FACTOR);
               3              PROBBK=FACTOR/(1.0+FACTOR);
               3              ]
               2          ELSE["INCIDENT FROM FRONT AND SIDE"
               3              FACTOR=AFACE*WINC/(ASIDE*SQRT(UINC**2+VINC**2));
               3              PROBFC=FACTOR/(1.0+FACTOR);
               3              PROBSD=1.0/(1.0+FACTOR);
               3              PROBBK=0.0;
               3              ]
               2          ]
               1      ]
               0  ELSEIF(ISOURC = 14)[ "FRONTAL POINT SOURCE restricted radius"
               1      RBEAM=RBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      RBEAM2=RBEAM**2;
               1      RMINSQ=RMINBM**2;
               1      DISTZ2=DISTZ**2;
               1      DISTRH=0.0; "ON-AXIS"
               1      ZCOFST=0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               1      ZSOFST=ZPLANE(1)-DISTZ;
               1      AFACE=PI*RBEAM**2;
               1      PROBFC=1.0;
               1      "INCIDENT FLUENCE TIMES SOLID ANGLE"
               1      "  THE SOLID ANGLE FACTOR IS CANCELLED BY THE WEIGHTING ROUTINE"
               1      "  SEE BIELAJEW,ROGERS AND NAHUM, PHYS MED BIOL 1985 FOR DETAILS"
               1      AINFLU=dble(NCASET)/DISTZ2;
               1      ]
               0  ELSEIF(ISOURC = 20)[
               1      "CALCULATE THE CPDF FROM THE PDF AND NORMALIZE IT"
               1      "NOTE THAT THE RADIAL WEIGHTING IS INCLUDED AT THIS STAGE"
               1      RCDF(1)=0.5*RDISTF(1)**2*RPDF(1);
               1      DO IB=2,NRDIST[
               2          RCDF(IB)=RCDF(IB-1)+0.5*(RDISTF(IB)**2-RDISTF(IB-1)**2)*RPDF(IB);
               2          ]
               1      FNORM=1./RCDF(NRDIST);
               1      IBNSOK=0;
               1      GRIDSZ=1./dble($MXRDIST);
               1      DO IB=1,NRDIST[
               2          RCDF(IB)=FNORM*RCDF(IB);
               2          IF(IB.EQ.1)[IF(RCDF(1).LT.GRIDSZ )IBNSOK=1;]
               2          ELSEIF((RCDF(IB)-RCDF(IB-1)).LT.GRIDSZ)[IBNSOK=1.0;]
               2          ]"END OF LOOP ON IB"
               1      IF(IBNSOK.NE.0)[OUTPUT;(///' *******WARNING******'/
               2          T15,'SOME OF NORMALIZED BIN PROBABILITIES SO SMALL BINS MAY BE MISSED'/);]
               1      "CALCULATE RCDFIN - AN ARRAY WHICH ALLOWS THE RAPID SAMPLING FOR THE"
               1      "RADIAL BY PRECOMPUTING THE RESULTS FOR A FINE GRID"
               1      DO K=1,$MXRDIST[
               2          AK=dble(K)*GRIDSZ;
               2          DO I=1,NRDIST[ IRDIST=I;IF(AK.LE.RCDF(I))[GOTO :FOUND-R-BIN:;] ]
               2          "WE SHOULD NEVER FALL THROUGH TO HERE"
               2          OUTPUT;(' *** FELL THROUGH RADIAL SAMPLING ROUTINE *** ');
               2          :FOUND-R-BIN:
               2          IF(IRDIST.NE.1)[RCDFIN(K,1)=RDISTF(IRDIST-1)**2;]
               2          ELSE[RCDFIN(K,1)=0.0;]
               2          RCDFIN(K,2)=RDISTF(IRDIST)**2-RCDFIN(K,1);
               2          ]"END LOOP OVER K"
               1      "OUTPUT IF IWATCH IS ACTIVE"
               1      IF(IWATCH.NE.0)[
               2          OUTPUT;(/' RDISTF,   RPDF,   RCDF:'//);
               2          OUTPUT (RDISTF(IB),RPDF(IB),RCDF(IB),IB=1,NRDIST);(3E17.7);
               2          OUTPUT;(//);
               2          ]
               1      WEIGHT=1.0; "INCIDENT WEIGHT"
               1      "calculate incident fluence"
               1      AINFLU=dble(NCASET)/(PI*RDISTF(NRDIST)**2);
               1      ]
               0
               0  ELSEIF( ISOURC = 23 ) [
               1      AINFLU=dble(NCASET); WEIGHT=1.0;
               1      IF( chamber_c > 1e4 | chamber_c < -1e4 ) [
               2          chamber_c = 0.5*(zplane(1) + zplane(nplane));
               2          ]
               1      ]
               0
               0  ELSEIF((ISOURC = 21) | (ISOURC = 22))["full phase space"
               1      AINFLU=dble(NCASET); "number of incident particles"
               1      WEIGHT=1.0; "INCIDENT WEIGHT"
               1      IF( chamber_c > 1e4 | chamber_c < -1e4 ) [
               2          chamber_c = 0.5*(zplane(1) + zplane(nplane));
               2          ]
               1      "Note that the weight for each particle is picked up from the phase"
               1      "space file on the SRCHST call for these 2 sources"
               1
               1      "Now, calculate the initial value of NPHSPN, the no.-1 of the first"
               1      "particle to use"
               1      IF(IPARALLEL>1 & PARNUM > 0)["one of IPARALLEL runs"
               2          IF(IHSTRY<NCASE_PHSP/IPARALLEL)[
               3              NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+IHSTRY;
               3              ]
               2          ELSE[
               3              tmp_mod = NCASE_PHSP;
               3              NPHSPN=tmp_mod*(PARNUM-1)/IPARALLEL+
               3              MOD(IHSTRY,tmp_mod/IPARALLEL);
               3              ]
               2          ]
               1      ELSE["not a parallel run"
               2          IF(IHSTRY<NCASE_PHSP)[NPHSPN = IHSTRY; ]
               2          ELSE[ tmp_mod = NCASE_PHSP; NPHSPN=MOD(IHSTRY,tmp_mod); ]
               2          ]
               1      IF(i_iaea_in=1)[
               2          $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN+1);
               2          ]
               1      ]
               0
               0
               0  RETURN;
               0
               0  "************************************************************************
               0
               0  ENTRY SRCOUT;    "toc:
               0  "==========="
               0
               0  "                          DESCRIBE SOURCE"
               0  "                          ==============="
               0
               0  WRITE(IOUT,500);
               0  IF(ISOURC = 0)[WRITE(IOUT,510) RBEAM,UINC,VINC,WINC,AINFLU;]
               0  ELSEIF(ISOURC = 1)[WRITE(IOUT,520) DISTZ,RBEAM,AINFLU;]
               0  ELSEIF(ISOURC = 2)[WRITE(IOUT,560);]
               0  ELSEIF(ISOURC = 3)[WRITE(IOUT,570)RMINBM,RBEAM,ZSMIN,ZSMAX;]
               0  ELSEIF(ISOURC = 4) [WRITE(IOUT,590) RBEAM;]
               0  ELSEIF(ISOURC = 10)[WRITE(IOUT,530)XBEAM,ZBEAM;
               1      IF(((XBEAM/$ONE-EPS).LT.RCYL(NR)).OR.
               1      ((ZBEAM/$ONE-EPS).LT.(0.5*(ZPLANE(NPLANE)-ZPLANE(1)))))
               1      WRITE(IOUT,550);
               1      ]
               0  ELSEIF(ISOURC = 11)[WRITE(IOUT,540)DISTRH,XBEAM,ZBEAM;
               1      IF((XBEAM/$ONE-EPS.LT.(RCYL(NR)*SQRT(DISTRH**2-RCYL(NR)**2)/DISTRH)).OR.
               1      (ZBEAM/$ONE-EPS.LT.(0.5*(ZPLANE(NPLANE)-ZPLANE(1)))))
               1      WRITE(IOUT,550);
               1      ]
               0  ELSEIF(ISOURC = 12)[WRITE(IOUT,580)DISTRH,DISTZ;]
               0  ELSEIF(ISOURC = 15)[ call src15_describe(iout); ]
               0  ELSEIF(ISOURC = 16)[ call src16_describe(iout); ]
               0  ELSEIF(ISOURC = 17)[WRITE(IOUT,535) DISTZ,XBEAM,YBEAM,AINFLU;]
               0  ELSEIF(ISOURC = 13)[WRITE(IOUT,585) UINC,VINC,WINC,AINFLU;]
               0  ELSEIF(ISOURC = 14)[WRITE(IOUT,525) DISTZ,RMINBM,RBEAM,AINFLU;]
               0  ELSEIF(ISOURC = 20)[
               1      WRITE(IOUT,595);
               1      IF(IOUTSP.EQ.1)[
               2          WRITE(IOUT,610)NRDIST;
               2          DO IB=1,NRDIST[WRITE(IOUT,620)IB,RDISTF(IB),RPDF(IB),RCDF(IB);]
               2          ]
               1      IF(IBNSOK.NE.0.0) WRITE(IOUT,630);
               1      ]
               0  ELSEIF(ISOURC = 21)[WRITE(IOUT,640) FILSPC,ZPLANE(1),AINFLU;]
               0  ELSEIF(ISOURC = 22)[
               1      WRITE(IOUT,677) FILSPC,dist_phsp,theta_phsp,chamber_c,
               1      xoffset,yoffset,AINFLU;
               1      ]
               0  ELSEIF(ISOURC=23)[
               1      WRITE(IOUT,679) iqinc,min_weight_23,max_weight_23,
               1      $cstring(the_beam_code),$cstring(the_pegs_file),
               1      $cstring(the_input_file),
               1      dist_phsp,theta_phsp,chamber_c,xoffset,yoffset,EKSRCM;
               1      ]
               0
               0  IF (ISOURC = 21 | ISOURC = 22) [
               1      WRITE(IOUT,:abcd:) NCASE_PHSP,NPHOTPHSP,TEMP2,TEMP3,NINCSRC;
               1      :abcd: FORMAT(T15, ' Total number of particles in file      :',I10/
               1      T15, ' Total number of photons                :',I10/
               1      T15, ' (the rest are electrons and positrons)'//
               1      T15, ' Maximum kinetic energy of the particles:',F10.3,' MeV'/
               1      T15, ' Minimum kinetic energy of the electrons:',F10.3,' MeV'/
               1      T15, ' # particles incident when phase space created :',F12.0/);
               1      IF(DOSE_STAT=1)[" cannot read no. of primary histories from this phsp"
               2          " source"
               2          WRITE(IOUT,'(//'' ***WARNING***''/
            '  2          '' Cannot read no. of primary (non-phsp) histories from ph-sp source.''/
            '  2          '' Dose and fluence will be analyzed assuming each particle read from''/
            '  2          '' the ph-sp file is an independent history.  May result in an''/
            '  2          '' underestimate of uncertainties.''//)');
               2          ]
               1      IF(IPARALLEL>1)[
               2          IF(PARNUM>=1 & PARNUM<=IPARALLEL)[
               3              WRITE(IOUT,'(/'' This is one of '',I4,'' parallel jobs.''/
            '  3              '' It will use from particle '',I12,'' to particle '',I12,/
            '  3              '' from the phase space source in the simulation.''/)')
               3              IPARALLEL,INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1,
               3              INT(PARNUM*NCASE_PHSP/IPARALLEL);
               3              ]
               2          ]
               1      IF(NRCYCL>0)[
               2          WRITE(IOUT,'(/'' Particles will be recycled '',
            '  2          I4,'' times before moving on to next one.''/)') NRCYCL;
               2          ]
               1      ]
               0
               0  RETURN;
               0
               0  "************************************************************************
               0
               0
               0  "                    SAMPLE SOURCE EACH HISTORY     "
               0  "                    ==========================     "
               0
               0  ENTRY SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);    "toc:
               0  "======================================================="
               0
               0  IF(n_parallel>0 & (ISOURC=21 | ISOURC=22))[
               1      "set up chunk of phase space file to sample"
               1      "if this is the first chunk in this run, calculate no. of particles in a"
               1      "phsp chunk"
               1      IF(N_RUN_CHUNK_OLD=0) P_PER_PHSP_CHUNK=NCASE_PHSP/(n_parallel*$N_CHUNKS);
               1      N_RUN_CHUNK=(NCASE-N_LEFT)*n_parallel*$N_CHUNKS/NCASE;
               1      other_num_1=N_RUN_CHUNK*NCASE;
               1      other_num_2=(NCASE-N_LEFT)*n_parallel*$N_CHUNKS;
               1      IF(other_num_1<other_num_2)[
               2          "NCASE/(n_parallel*$N_CHUNKS) is not an integer"
               2          "and so no of histories in each chunk, has been rounded down"
               2          N_RUN_CHUNK=N_RUN_CHUNK+1;
               2          ]
               1      IF(N_RUN_CHUNK ~= N_RUN_CHUNK_OLD)["have moved on to a new run chunk"
               2          N_RUN_CHUNK_OLD=N_RUN_CHUNK;
               2          NPHSPN_MIN=(N_RUN_CHUNK-1)*P_PER_PHSP_CHUNK+1;
               2          IF(N_LEFT=0)["this is the last run just use up the rest of the"
               3              "phsp source"
               3              NPHSPN_MAX=NCASE_PHSP;
               3              ]
               2          ELSE["calculate the max value of INPHSP"
               3              NPHSPN_MAX=NPHSPN_MIN+P_PER_PHSP_CHUNK-1;
               3              ]
               2          NPHSPN=NPHSPN_MIN-1; "srchst later adds 1 to NPHSPN"
               2          IF(i_iaea_in=1)[
               3              $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN+1);
               3              ]
               2          CYCLNUM=0; "reset NRCYCL counter"
               2          write(6,'(/a/,a,i12,a,i12/,a//)')
               2          '      This simulation uses a phase space source.',
               2          '      This run will use from particle',NPHSPN_MIN,' to particle ',
               2          NPHSPN_MAX,
               2          '      in the source file.';
               2          ]
               1      ]
               0
               0  "Calculate the history dependent constants that may change depending on"
               0  "the source type"
               0  IF((ISOURC = 0) | (ISOURC = 2) |(ISOURC = 4))["frontal parallel beam source"
               1      IF(RBEAM = 0.0)[ "pencil source"
               2          /XIN,YIN/=0.0;
               2          IRIN=2;
               2          ]
               1      ELSE[ "choose a point randomly in a circle"
               2          $CHOOSE-POINT-IN-CIRCLE;
               2          IRIN=2+(IXIN-1)*NZ;
               2          ]
               1      ZIN=ZPLANE(1); "INCIDENT Z POSITION"
               1      IF(IFPB = 0)[UIN=0.0;VIN=0.0;WIN=1.0;]ELSE[UIN=UINC;VIN=VINC;WIN=WINC;]
               1      NRCFLG=10; "geometrical flag"
               1      WEIGHT=1.0; "this version needs to set the weight in case correlation"
               1      "changed it"
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 1 | ISOURC = 14)["frontal point source on axis"
               1      $ENTRY-FRONT-FACE;
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 3)[ "isotropically radiating disk"
               1      "choose z-coordinate for the generation of a particle within region NSRCRG"
               1      $RANDOMSET ZIN;
               1      ZIN=ZSOFST+(2.0*ZIN-1.0)*ZBEAM;
               1      DO IZ=1,NPLANE-1[IF(ZIN <= ZPLANE(IZ+1) & ZIN >= ZPLANE(IZ)) EXIT;]
               1      "choose a point randomly in a circle that has the radius of the source"
               1
               1      "choose a point randomly in a ring" "this is not the fastest way"
               1      LOOP[
               2          $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RBEAM;
               2          $RANDOMSET YIN;YIN=(2.0*YIN-1.0)*RBEAM;
               2          R2=XIN**2+YIN**2;
               2          ] UNTIL (R2 <= RBEAM2 & R2 >= RMINSQ);
               1
               1      DO IX=1,NR[IF(R2 <= CYRAD2(IX))EXIT;]
               1
               1      IRIN = IZ + NZ*(IX-1)+1;
               1
               1      "now determine initial direction cosines"
               1      $RANDOMSET COSTHE;   COSTHE=2.*COSTHE-1;
               1      SINTHE=SQRT(1.0-COSTHE**2);
               1      $RANDOMSET PHI;PHI=TWOPI*PHI;
               1      UIN=SINTHE*COS(PHI);VIN=SINTHE*SIN(PHI);WIN=COSTHE;
               1      NRCFLG=50;  "geometrical flag meaning particle generated within region"
               1      WEIGHT=1.0;
               1      NHSTRY=NHSTRY+1;
               1      ]
               0  ELSEIF(ISOURC = 10)[ "side parallel beam"
               1      "choose a point randomly in the rectangle"
               1      $CHOOSE-POINT-IN-RECTANGLE;
               1      UIN=0.0;VIN=-1.0;WIN=0.0; "incident angles"
               1      NRCFLG=20; "geometrical flag"
               1      WEIGHT=1.0; "this version needs to set the weight in case correlation"
               1      "changed it"
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 11)[ "SIDE POINT SOURCE CENTERED AT TARGET MIDDLE"
               1      "SIDE POINT SOURCE CENTERED AT TARGET MIDDLE"
               1      $ENTRY-SIDE;
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 12)[ "POINT SOURCE OFF AXIS"
               1      "POINT SOURCE OFF AXIS"
               1      "DECIDE WHICH SURFACE THE INCIDENT PARTICLE WILL HIT"
               1      IF(PROBFC.EQ.1.0)[$ENTRY-FRONT-FACE;]
               1      ELSEIF(PROBBK.EQ.1.0)[$ENTRY-BACK-FACE;]
               1      ELSEIF(PROBSD.EQ.1.0)[$ENTRY-SIDE;]
               1      ELSE[
               2          "MAY HIT EITHER FACE OR SIDE"
               2          $RANDOMSET WHICH;
               2          IF(WHICH.LE.PROBSD)[$ENTRY-SIDE;]
               2          ELSEIF(WHICH.LE.(PROBSD+PROBFC))[$ENTRY-FRONT-FACE;]
               2          ELSE[$ENTRY-BACK-FACE;]
               2          ]
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSE IF(ISOURC = 15) [
               1      call src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSE IF(ISOURC = 16) [
               1      call src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 17)["frontal point source on axis with square field"
               1      $INCIDENT-FROM-FRONT;
               1      NHSTRY=NHSTRY+1;
               1      ]
               0
               0  ELSEIF(ISOURC = 13)[ "BROAD PARALLEL BEAM AT ANY ANGLE wrt THE TARGET"
               1      "BROAD PARALLEL BEAM AT ANY ANGLE WITH RESPECT TO THE TARGET"
               1      UIN=UINC;VIN=VINC;WIN=WINC;
               1      "DECIDE WHICH SURFACE THE INCIDENT PARTICLE WILL HIT"
               1      IF(PROBFC.EQ.1.0)[
               2          $CHOOSE-POINT-IN-CIRCLE;
               2          IRIN=2+(IXIN-1)*NZ;
               2          ZIN=ZPLANE(1); "INCIDENT Z POSITION"
               2          NRCFLG=10; "GEOMETRICAL FLAG"
               2          ]
               1      ELSEIF(PROBBK.EQ.1.0)[
               2          $CHOOSE-POINT-IN-CIRCLE;
               2          IRIN=1+IXIN*NZ;
               2          ZIN=ZPLANE(NPLANE); "INCIDENT Z POSITION"
               2          NRCFLG=30; "GEOMETRICAL FLAG"
               2          ]
               1      ELSEIF(PROBSD.EQ.1.0)[
               2          $CHOOSE-POINT-IN-RECTANGLE;
               2          NRCFLG=20; "GEOMETRICAL FLAG"
               2          ]
               1      ELSE[
               2          "MAY HIT EITHER FACE OR SIDE"
               2          $RANDOMSET WHICH;
               2          IF(WHICH.LE.PROBSD)[
               3              $CHOOSE-POINT-IN-RECTANGLE;
               3              NRCFLG=20; "GEOMETRICAL FLAG"
               3              ]
               2          ELSEIF(WHICH.LE.(PROBSD+PROBFC))[
               3              $CHOOSE-POINT-IN-CIRCLE;
               3              IRIN=2+(IXIN-1)*NZ;
               3              ZIN=ZPLANE(1); "INCIDENT Z POSITION"
               3              NRCFLG=10; "GEOMETRICAL FLAG"
               3              ]
               2          ELSE[
               3              $CHOOSE-POINT-IN-CIRCLE;
               3              IRIN=1+IXIN*NZ;
               3              ZIN=ZPLANE(NPLANE); "INCIDENT Z POSITION"
               3              NRCFLG=30; "GEOMETRICAL FLAG"
               3              ]
               2          ]
               1      WEIGHT=1.0; "THIS VERSION NEEDS TO SET THE WEIGHT IN CASE CORRELATION"
               1      "CHANGED IT"
               1      NHSTRY=NHSTRY+1;
               1      ]
               0  "ISOURC=14 DONE WITH ISOURC=1"
               0  ELSEIF(ISOURC = 20)["RADIAL DISTRIBUTION, FRONT PARALLEL BEAM"
               1      "THIS ENTRY DOES THE ACTUAL SAMPLING OF THE INCIDENT RADIAL DISTRIBUTION"
               1      "THIS WILL RETURN A HISTOGRAM OF VALUES"
               1      $RANDOMSET RNNO1;$RANDOMSET RNNO2;
               1      "IN NEXT STATEMENT MIN AVOIDS K=$MXRDIST+1, ALMOST NEVER IMPLEMENTED"
               1      K=MIN(dble($MXRDIST)*RNNO1+1.,dble($MXRDIST));
               1      "THIS VERSION ONLY FOR CYLINDRICAL SYMMETRY"
               1      XIN=SQRT(RCDFIN(K,1)+RNNO2*RCDFIN(K,2));
               1      YIN=0.0;
               1      ZIN=ZPLANE(1); "INCIDENT POSITION"
               1      "NOW DO A SEQUENTIAL SEARCH FOR THE ENTRANCE REGION"
               1      DO IX=1,NR[IXIN=IX;IF(XIN.LE.RCYL(IX)) EXIT;]
               1      IRIN=2+(IXIN-1)*NZ;
               1      WIN=1.0;UIN=0.0;VIN=0.0; "INCIDENT ANGLES"
               1      NRCFLG=10; "GEOMETRICAL FLAG"
               1      WEIGHT=1.0; "THIS VERSION NEEDS TO SET THE WEIGHT IN CASE CORRELATION"
               1      "CHANGED IT"
               1      NHSTRY=NHSTRY+1;
               1      ]
               0  ELSEIF(ISOURC = 21)["Full phase space for each particle"
               1
               1      IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)["recycle this particle"
               2          CYCLNUM=CYCLNUM+1;
               2          XIN=XINOLD;
               2          YIN=YINOLD;
               2          ZIN=ZINOLD;
               2          UIN=UINOLD;
               2          VIN=VINOLD;
               2          WIN=WINOLD;
               2          IRIN=IRINOLD;
               2          NRCFLG=NRCFLGOLD;
               2          WEIGHT=WEIGHTOLD;
               2          "the rest of the parameters are global and unchanged"
               2          NNREAD=NNREAD+1;
               2          ]
               1      ELSE["get a new particle from the file"
               2          :READ-PARTICLE:;
               2
               2          NPHSPN=NPHSPN+1;
               2
               2          IF(IPARALLEL>1 & PARNUM>0 & NPHSPN > INT(PARNUM*NCASE_PHSP/IPARALLEL))[
               3              NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT;
               3              (' ***WARNING*** Used all particles from partition in source file.'/
               3              '               Restarting from first particle in partition.');
               3              WRITE(IOUT,
               3              '('' ***WARNING*** Used all particles from partition in source file.''/
            '  3              ''               Restarting from first particle in partition.'')');
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC/IPARALLEL;
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2          ELSEIF(n_parallel>0 & NPHSPN>NPHSPN_MAX)[
               3              "have reached the end of the phsp chunk in this parallel run"
               3              NPHSPN=NPHSPN_MIN;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT ;
               3              (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
               3              '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
               3              /1x,79('*')// );
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2          ELSEIF(NPHSPN>NCASE_PHSP)[
               3              NPHSPN=1;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT;
               3              (' ***WARNING*** Used all particles from source file.'/
               3              '               Restarting from first particle.');
               3              WRITE(IOUT,
               3              '('' ***WARNING*** Used all particles from source file.''/
            '  3              ''               Restarting from first particle.'')');
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC;
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2
               2          IF(OUTCNT>1000)["too many restart warnings"
               3              OUTPUT;(' ***ERROR*** >1000 restart warnings.');
               3              WRITE(IOUT,
               3              '('' ***ERROR*** >1000 restart warnings.'')');
               3              STOP;
               3              ]
               2
               2          IF(i_iaea_in=1)[
               3              $IAEA_READ_PHSP_RECORD(i_unit_in,NPASS,NHSTRY,LATCHI,IQIN,EIN,WEIGHT,
               3              XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               3              ]
               2          ELSE[
               3
               3              $READ_PHSP(IMODE,42,NPHSPN+1:NHSTRY,NPASS,IQIN,WIN,ZLAST,
               3              LATCHI,EIN,WEIGHT,XIN,YIN,UIN,VIN);
               3              ]
               2
               2          NNREAD=NNREAD+1;
               2
               2          IF(DOSE_STAT=1 | NHSTRY=0) NHSTRY=NHSTRY+1;
               2          "NHSTRY may also remain zero if this is a partition of a phase space"
               2          "file and it does not begin with a new primary history"
               2
               2          "We only use the forward particles."
               2          IF( NPASS=1 ) GOTO :READ-PARTICLE:; "...signals not 1st time crossing"
               2
               2          "check charge of this particle, IQIN, is what the user asked for, IQINC"
               2          "IQINC = 0 => photons only"
               2          "IQINC = -1 =>electrons only"
               2          "IQINC = +1 => positrons only"
               2          "IQINC = 2  => all particles"
               2          "IQINC = 3 => charged particles"
               2
               2          IF(IQIN =-1 & IQINC~=-1 & IQINC~=2 & IQINC ~=3)[ GOTO :READ-PARTICLE:;]
               2          IF(IQIN = 1 & IQINC~= 1 & IQINC~=2 & IQINC ~=3)[ GOTO :READ-PARTICLE:;]
               2          IF(IQIN = 0 & IQINC~= 0 & IQINC~=2)[ GOTO :READ-PARTICLE:;]
               2          "If it gets here, it is acceptable"
               2
               2          "Now do a sequential search for the entrance region"
               2          R2 = XIN**2 +YIN**2;
               2          "Check if particle is outside geometry"
               2          IF(R2 > CYRAD2(NR))[ GOTO :READ-PARTICLE:;]
               2          DO IX=1,NR[
               3              IXIN=IX;
               3              IF( R2 <=  CYRAD2(IX) ) EXIT;  "CYRAD2(IX) is RCYL(IX)**2 set in GEOMRZ"
               3              ]
               2          IRIN=2+(IXIN-1)*NZ;
               2          ZIN=ZPLANE(1);
               2          NRCFLG = 10; "GEOMETRICAL FLAG, SOURCE INCIDENT ON FRONT FACE"
               2          IF(NRCYCL>0)["store non-global parameters for recycling"
               3              CYCLNUM=1;
               3              XINOLD=XIN;
               3              YINOLD=YIN;
               3              ZINOLD=ZIN;
               3              UINOLD=UIN;
               3              VINOLD=VIN;
               3              WINOLD=WIN;
               3              IRINOLD=IRIN;
               3              NRCFLGOLD=NRCFLG;
               3              WEIGHTOLD=WEIGHT;
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF( ISOURC = 23 ) [ "full BEAM simulation"
               1
               1      LOOP [;
               2          :retry_sample_beamsource:;
               2          call sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iqin,latchi,
               2          nhstry,iphatin);
               2          IF( iqinc < 2 & iqin ~= iqinc ) goto :retry_sample_beamsource:;
               2          IF( iqinc = 3 & iqin = 0 ) goto :retry_sample_beamsource:;
               2          IF( weight < min_weight_23 | weight > max_weight_23 ) [
               3              "write(6,*) 'Not in weight window: ',weight,iqin,ein,xin,yin;"
               3              goto :retry_sample_beamsource:;
               3              ]
               2
               2          IF( secret_option_23 = 1 ) [
               3              IF( xin > 0 ) [ xin = -xin; uin = -uin; ]
               3              ]
               2
               2          xin_tmp = xin; yin_tmp = yin; zin_tmp = zin;
               2
               2          "apply the offset"
               2          xin=xin+xoffset; yin=yin+yoffset;
               2
               2          "Rotate the position"
               2          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c;
               2          yin = dist_phsp*sint_phsp + yin*cost_phsp;
               2
               2          "Rotate the direction"
               2          vtemp = vin;
               2          vin = -win*sint_phsp + vin*cost_phsp;
               2          win =  win*cost_phsp + vtemp*sint_phsp;
               2
               2          "write(6,*) 'Got ',iqin,ein,xin,yin,zin,uin,vin,win,weight;
               2          "Check if particle is within the geometry or will enter it"
               2          radp = xin*xin + yin*yin;
               2          IF( radp > CYRAD2(nr) | zin < zplane(1) | zin > zplane(nz+1) ) [
               3              " outside of geometry. check whether that particle will get in "
               3              check = .true.;
               3              IF( zin < zplane(1) & win > 0 ) [ tf = (zplane(1)-zin)/win; ]
               3              ELSE IF( zin > zplane(nz+1) & win < 0 ) [
               4                  tf = (zplane(nz+1) - zin)/win;
               4                  ]
               3              ELSE [ check = .false.; ]
               3              IF( check ) [
               4                  xtmp = xin + uin*tf; ytmp = yin + vin*tf;
               4                  radp = xtmp*xtmp + ytmp*ytmp;
               4                  IF( radp <= CYRAD2(nr) ) [
               5                      xin = xtmp; yin = ytmp;
               5                      IF( zin < zplane(1) ) [ zin = zplane(1); iz = 1; ]
               5                      ELSE                  [ zin = zplane(nz+1); iz = nz; ]
               5                      DO ix=1,nr [ IF( radp <= CYRAD2(ix) ) EXIT; ]
               5                      EXIT;
               5                      ]
               4                  radp = xin*xin + yin*yin;
               4                  ]
               3              IF( radp < CYRAD2(nr) ) NEXT;
               3              phbb = uin*uin + vin*vin;
               3              IF( phbb < 1e-15 ) NEXT;
               3              pha = (xin*uin + yin*vin)/phbb;
               3              IF( pha > 0 ) NEXT;
               3              phb = (radp - CYRAD2(nr))/phbb;
               3              phd = pha*pha - phb;
               3              IF( phd < 0 ) NEXT;
               3              tf = -pha-sqrt(phd);
               3              IF( tf < 0 ) NEXT;
               3              zin = zin + tf*win;
               3              IF( zin < zplane(1) | zin > zplane(nz+1) ) NEXT;
               3              ix = nr; xin = xin + uin*tf; yin = yin + vin*tf;
               3              DO iz=2,nplane [ IF( zin <= zplane(iz) ) EXIT; ]
               3              iz = iz-1;
               3              EXIT;
               3              ]
               2          ELSE [
               3              " already inside, find the region index "
               3              DO iz=2,nplane [ IF( zin <= zplane(iz) ) EXIT; ]
               3              iz = iz-1;
               3              DO ix=1,nr [ IF( radp <= CYRAD2(ix) ) EXIT; ]
               3              EXIT;
               3              ]
               2          ]
               1      irin = 1 + (ix-1)*nz + iz;
               1      "write(6,*) 'Got ',iqin,ein,xin,yin,zin,uin,vin,win,weight,ix,iz;
               1      ihstry = ihstry + nhstry - last_nhstry;
               1      last_nhstry = nhstry;
               1      ]
               0
               0  ELSEIF(ISOURC = 22)["full phase space for each particle: from side"
               1
               1      IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)["recycle this particle"
               2          CYCLNUM=CYCLNUM+1;
               2          XIN=XINOLD;
               2          YIN=YINOLD;
               2          ZIN=ZINOLD;
               2          UIN=UINOLD;
               2          VIN=VINOLD;
               2          WIN=WINOLD;
               2          IRIN=IRINOLD;
               2          NRCFLG=NRCFLGOLD;
               2          WEIGHT=WEIGHTOLD;
               2          "the rest of the parameters are global and unchanged"
               2          NNREAD=NNREAD+1;
               2          ]
               1      ELSE["get a new particle from the file"
               2          :READ-PARTICLE-SRC22:;
               2
               2          NPHSPN=NPHSPN+1;
               2
               2          IF(IPARALLEL>1 & PARNUM>0 & NPHSPN > INT(PARNUM*NCASE_PHSP/IPARALLEL))[
               3              NPHSPN=INT((PARNUM-1)*NCASE_PHSP/IPARALLEL)+1;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT;
               3              (' ***WARNING*** Used all particles from partition in source file.'/
               3              '               Restarting from first particle in partition.');
               3              WRITE(IOUT,
               3              '('' ***WARNING*** Used all particles from partition in source file.''/
            '  3              ''               Restarting from first particle in partition.'')');
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC/IPARALLEL;
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2          ELSEIF(n_parallel>0 & NPHSPN>NPHSPN_MAX)[
               3              "have reached the end of the phsp chunk in this parallel run"
               3              NPHSPN=NPHSPN_MIN;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT ;
               3              (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
               3              '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
               3              /1x,79('*')// );
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2          ELSEIF(NPHSPN>NCASE_PHSP)[
               3              NPHSPN=1;
               3              OUTCNT=OUTCNT+1;
               3              OUTPUT;
               3              (' ***WARNING*** Used all particles from source file.'/
               3              '               Restarting from first particle.');
               3              WRITE(IOUT,
               3              '('' ***WARNING*** Used all particles from source file.''/
            '  3              ''               Restarting from first particle.'')');
               3              IF(i_iaea_in=1)[NHSTRY=OUTCNT*NINCSRC;
               4                  $IAEA_SET_PHSP_RECORD(i_unit_in,NPHSPN);
               4                  ]
               3              ]
               2
               2          IF(OUTCNT>1000)["too many restart warnings"
               3              OUTPUT;(' ***ERROR*** >1000 restart warnings.');
               3              WRITE(IOUT,
               3              '('' ***ERROR*** >1000 restart warnings.'')');
               3              STOP;
               3              ]
               2
               2          IF(i_iaea_in=1)[
               3              $IAEA_READ_PHSP_RECORD(i_unit_in,NPASS,NHSTRY,LATCHI,IQIN,EIN,WEIGHT,
               3              XIN,YIN,ZIN,UIN,VIN,WIN,ZLAST,MUIDX);
               3              ]
               2          ELSE[
               3
               3              $READ_PHSP(IMODE,42,NPHSPN+1:NHSTRY,NPASS,IQIN,WIN,ZLAST,
               3              LATCHI,EIN,WEIGHT,XIN,YIN,UIN,VIN);
               3              ]
               2
               2          NNREAD=NNREAD+1; "counts total number of reads"
               2
               2          IF(DOSE_STAT=1 | NHSTRY=0) NHSTRY=NHSTRY+1;
               2
               2          "We only use the forward particles."
               2          IF( NPASS=1 ) GOTO :READ-PARTICLE-SRC22:;"...signals not 1st time crossing"
               2
               2          IF(IQIN=-1 & IQINC~=-1 & IQINC~=2 & IQINC ~=3)[GOTO :READ-PARTICLE-SRC22:;]
               2          IF(IQIN= 1 & IQINC~= 1 & IQINC~=2 & IQINC ~=3)[GOTO :READ-PARTICLE-SRC22:;]
               2          IF(IQIN= 0 & IQINC~= 0 & IQINC~=2)[GOTO :READ-PARTICLE-SRC22:;]
               2
               2          "IF(IQIN=-1 & IQINC~=-1 & IQINC~=2)[ GOTO :READ-PARTICLE-SRC22:;]"
               2          "ELSEIF(IQIN=1 & IQINC~=1 & IQINC~=2)[ GOTO :READ-PARTICLE-SRC22:;]"
               2          "ELSEIF(IQINC~=0 & IQINC~=2)[GOTO :READ-PARTICLE-SRC22:;]"
               2
               2          "apply the offset"
               2          xin=xin+xoffset;
               2          yin=yin+yoffset;
               2
               2          "Rotate the position"
               2          zin = -dist_phsp*cost_phsp + yin*sint_phsp + chamber_c;
               2          yin = dist_phsp*sint_phsp + yin*cost_phsp;
               2
               2          "Rotate the direction"
               2          vtemp = vin;
               2          vin = -win*sint_phsp + vin*cost_phsp;
               2          win =  win*cost_phsp + vtemp*sint_phsp;
               2
               2          "Check if particle is within the geometry or will enter it"
               2          radp = xin*xin + yin*yin;
               2          IF( radp > CYRAD2(nr) | zin < zplane(1) | zin > zplane(nz+1) ) [
               3              " outside of geometry. check whether that particle will get in "
               3              check = .true.;
               3              IF( zin < zplane(1) & win > 0 ) [ tf = (zplane(1)-zin)/win; ]
               3              ELSE IF( zin > zplane(nz+1) & win < 0 ) [
               4                  tf = (zplane(nz+1) - zin)/win;
               4                  ]
               3              ELSE [ check = .false.; ]
               3              IF( check ) [
               4                  xtmp = xin + uin*tf; ytmp = yin + vin*tf;
               4                  radp = xtmp*xtmp + ytmp*ytmp;
               4                  IF( radp <= CYRAD2(nr) ) [
               5                      xin = xtmp; yin = ytmp;
               5                      IF( zin < zplane(1) ) [ zin = zplane(1); iz = 1; ]
               5                      ELSE                  [ zin = zplane(nz+1); iz = nz; ]
               5                      DO ix=1,nr [ IF( radp <= CYRAD2(ix) ) EXIT; ]
               5                      goto :FOUND-ENTRY-22:;
               5                      ]
               4                  radp = xin*xin + yin*yin;
               4                  ]
               3              IF( radp < CYRAD2(nr) ) goto :READ-PARTICLE-SRC22:;
               3              phbb = uin*uin + vin*vin;
               3              IF( phbb < 1e-15 ) goto :READ-PARTICLE-SRC22:;
               3              pha = (xin*uin + yin*vin)/phbb;
               3              IF( pha > 0 ) goto :READ-PARTICLE-SRC22:;
               3              phb = (radp - CYRAD2(nr))/phbb;
               3              phd = pha*pha - phb;
               3              IF( phd < 0 ) goto :READ-PARTICLE-SRC22:;
               3              tf = -pha-sqrt(phd);
               3              IF( tf < 0 ) goto :READ-PARTICLE-SRC22:;
               3              zin = zin + tf*win;
               3              IF( zin < zplane(1) | zin > zplane(nz+1) ) goto :READ-PARTICLE-SRC22:;
               3              ix = nr; xin = xin + uin*tf; yin = yin + vin*tf;
               3              DO iz=2,nplane [ IF( zin <= zplane(iz) ) EXIT; ]
               3              iz = iz-1;
               3              goto :FOUND-ENTRY-22:;
               3              ]
               2          " already inside, find the region index "
               2          DO iz=2,nplane [ IF( zin <= zplane(iz) ) EXIT; ]
               2          iz = iz-1;
               2          DO ix=1,nr [ IF( radp <= CYRAD2(ix) ) EXIT; ]
               2
               2          :FOUND-ENTRY-22:
               2
               2          count_phsp = count_phsp + 1;
               2          irin = 1 + (ix-1)*nz + iz;
               2          NRCFLG = 20; "GEOMETRICAL FLAG, SOURCE INCIDENT FROM SIDE(?)"
               2          IF(NRCYCL>0)["store non-global parameters for recycling"
               3              CYCLNUM=1;
               3              XINOLD=XIN;
               3              YINOLD=YIN;
               3              ZINOLD=ZIN;
               3              UINOLD=UIN;
               3              VINOLD=VIN;
               3              WINOLD=WIN;
               3              IRINOLD=IRIN;
               3              NRCFLGOLD=NRCFLG;
               3              WEIGHTOLD=WEIGHT;
               3              ]
               2          ]
               1      ]
               0
               0  RETURN;
               0
               0  ENTRY SRCEND;
               0
               0  IF( ISOURC = 23 ) [
               1      call finish_beamsource;
               1      ]
               0
               0  return;
               0
               0  "FORMATS"
               0  %I0                                                                            ;
               0  100   FORMAT(' ',2(I2,' '),4(G14.7,' '))
               0  200   FORMAT(' ',I1)
               0  300   FORMAT(' ',I3)
               0  400   FORMAT(' ',2(G14.7,' '))
               0  500   FORMAT(/' ',79('*')//T30,'SOURCE PARAMETERS'//' ',79('*')/)
               0  510   FORMAT(T20,'Parallel beam on front face, radius=',
               0       1  F8.3,'cm'/
               0       2  T30,' X-axis direction cosine=',F10.4/
               0       3  T30,' Y-axis direction cosine=',F10.4/
               0       4  T30,' Z-axis direction cosine=',F10.4/
               0       5  T30,' Incident fluence=', 1PE13.3,'/cm**2')
               0  520   FORMAT(T5,'Point source on cyl axis',F8.1,
               0       1       ' cm away, collimated to R =',F8.3,' cm',/
               0       2       T5,'Incident fluence(at front face on axis) * ',
               0       3       'Solid angle=',1PE14.3)
               0  525   FORMAT(T5,'Point source on cyl axis',F8.1,
               0       1       ' cm away'/T10,'Collimated to radii =',F8.3,' cm to ',
               0       2       F8.3,' cm',/
               0       3       T5,'Incident fluence(at front face on axis) * ',
               0       4       'SOLID ANGLE=',1PE14.3)
               0  530   FORMAT(T20,'PARALLEL BEAM INCIDENT ON CYLINDRICAL WALL',
               0       1       /T21,'RADIAL DIMENSION=',F8.3,' cm, HALF-LENGTH='
               0       2       ,F8.3,' cm')
               0  535   FORMAT(T5,'Point source on cyl axis',F8.1,
               0       1       ' cm away'/T10,'Collimated to x =',F8.3,' cm, y = ',
               0       2       F8.3,' cm',/
               0       3       T5,'Incident fluence(at front face on axis) * ',
               0       4       'SOLID ANGLE=',1PE14.3)
               0  540   FORMAT(T20,'POINT SOURCE INCIDENT FROM SIDE',F8.1,' cm',
               0       1       ' FROM MID-POINT'/T25,'RADIAL DIMENSION=',F8.3,' cm'
               0       2       ,' HALF-LENGTH=',F8.3,' cm')
               0  550   FORMAT(/T30,'NOTE BEAM DOES NOT COVER THE DETECTOR'/
               0       1       T30,37('*') )
               0  560   FORMAT(' ',T20,'BROAD PARALLEL BEAM ON CYLINDRICAL AXIS')
               0  570   FORMAT(T10,'ISOTROPICALLY RADIATING, UNIFORM SOURCE LOCATED'/
               0       1      '      between radii',2F10.3,' and DEPTHS', 2F10.3)
               0  580   FORMAT(' ',T20,'POINT SOURCE OFF AXIS, RADIAL COORDINATE ',
               0       1       F8.3,' cm'/
               0       2' ',T20,'PERPENDICULAR DISTANCE OF SOURCE FROM FRONT FACE '
               0       3,F8.3,' cm')
               0  585   FORMAT(T20,'BROAD PARALLEL BEAM FROM ANY ANGLE'/
               0       1  T30,' X-AXIS DIRECTION COSINE=',F10.4/
               0       2  T30,' Y-AXIS DIRECTION COSINE=',F10.4/
               0       3  T30,' Z-AXIS DIRECTION COSINE=',F10.4/
               0       4  T30,' INCIDENT FLUENCE=', 1PE13.3,'/cm**2')
               0  590   FORMAT(' ',T23,'CENTRAL AXIS FLUENCE VS BEAM RADIUS'/
               0       1  T25,'CENTRAL AXIS RADIUS=',F9.4,' cm'//12X,
               0       2'  TREAT RADIAL BINS AS BEAM RADIUS, NOT SCORING REGION RADIUS'/)
               0  595   FORMAT(' ',T20,'RADIAL DISTRIBUTION, FRONTAL PARELLEL BEAM'/)
               0  605   FORMAT(80A1)
               0  600   FORMAT(27A1)
               0  610   FORMAT(' ',T20,'RADIAL DISTBN, # OF INCIDENT RADIAL BINS:',T60,I5/
               0       1' ',T20,'BIN    KINETIC RADIAL     PROBABILITY  CUMULATIVE PROB')
               0  620   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4)
               0  630   FORMAT(/' *******WARNING******'/T20,'SOME OF NORMALIZED BIN',
               0       1' PROBABILITIES SO SMALL BINS MAY BE MISSED'/)
               0  640   FORMAT(T20,'Full phase space input for each incident particle. '/
               0       1T5,' Source data file: ',256A1/
               0       2T25,' Source incident on front face, Z =',F14.4,' cm.'/
               0       3T25,' # of particles read from ph-sp file =', 1PE13.3,'.')
               0  642   FORMAT(T20,'Full phase space input for each incident particle. '/
               0       1T5,' Source data file: ',80A1/
               0       2T25,' Source incident on plane, Y =',F14.4,' cm.'/
               0       3T25,' Centre of source plane at Z =',F14.4,' cm.'/
               0       4T25,' # of particles read from ph-sp file =', 1PE13.3,'.')
               0  650   FORMAT(I1,1X,I7,1X,F5.0,1X,2(F4.0,1X),F1.0,1X,2(F10.8,1X),E10.4)
               0  660   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0/)
               0  670   FORMAT(40A1/22A1/80A1/I10,3X,3F6.0//)
               0  677   FORMAT(T20,'Full phase space input for each incident particle. '/
               0       &T5,' Source data file: ',256A1/
               0       &T25,' Source incident on plane ',F14.4,
               0       & ' cm from the point of rotation'/
               0       &T25,' Angle with respect to z-axis ',F14.4,' degrees.'/
               0       &T25,' z-position of point of rotation ',f14.4,/
               0       &T25,' X offset of phsp (before rotation)',F14.4,' cm'/
               0       &T25,' Y offset of phsp (before rotation)',F14.4,' cm'/
               0       &T25,' # of particles read from ph-sp file =', 1PE13.3,'.')
               0  679   FORMAT(T20,' Full treatment head simulation from an angle'/,
               0       &T10,'    Particle charge                               : ',i3,/
               0       &T10,'    Weight window                                 : ',
               0       &2g15.6,/
               0       &T10,'    BEAMnrc user code                             : ',a,/
               0       &T10,'    PEGS data file                                : ',a,/
               0       &T10,'    Input file                                    : ',a,/
               0       &T10,'    Rotation point to phsp-plane midpoint distance: ',f10.4,/
               0       &T10,'    Incident angle (degrees)                      : ',f10.4,/
               0       &T10,'    Rotation point (will be set to chamber center'/,
               0       &T10,'      if greater than 1e4 or less than -1e4):     : ',g14.4,
               0       &' cm'/
               0       &T10,'    X offset of phsp plane (before rotation)      : ',f10.4,
               0       &' cm'/
               0       &T10,'    Y offset of phsp plane (before rotation)      : ',f10.4,
               0       &' cm'/
               0       &T10,'    Max. kinetic energy of simulation             : ',f10.4,
               0       &' MeV')
               0  %I4                                                                            ;
               0  END;   "END OF SUBROUTINE SRCRZ"
               0
               0  subroutine src15;
               0
               0  implicit none;
               0
               0  ;COMIN/GEOM,IODAT2,RANDOM,SOURCE/;
               0
               0  $REAL       temp1,temp2,temp3,temp4; "from input file"
               0  $REAL       XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
               0  $INTEGER    NRCFLG,IRIN,iout,error_flag;
               0
               0  real*8      theta,cost,sint,d,d2,yo,zo,dz,R,R2,area,w0,pi,zc,ro2;
               0  real*8      fak,x1,y1,x2,y2,x3,y3,xmin,xmax,delx,ymin,ymax,dely;
               0  real*8      count,sumw,sumw2;
               0  logical     just_fb,just_side,enter_fb,enter_side;
               0  real*8      eta1,eta2,xx,yy,zz,dist2,dist,uli,vli,wli,
               0  xli,yli,zli,rad2,ts,tf,ur2,ux,ux2,rr2,del,error;
               0  integer*4   ix,iz;
               0
               0  save        cost,sint,d,d2,yo,zo,dz,R,R2,xmin,delx,ymin,dely,
               0  zc,area,w0,count,sumw,sumw2,just_fb,just_side,pi,ro2;
               0
               0  entry src15_ini(temp1,temp2,temp3,temp4,error_flag);
               0  "=================================================="
               0
               0  pi = 4*datan(1d0);
               0  theta = temp2; IF( theta > 180 ) [ theta = 360 - theta; ]
               0  theta = theta*pi/180;
               0  cost = cos(theta); sint = sin(theta);
               0  d = temp1; d2 = d*d;
               0  yo = d*sint; zo = -d*cost;
               0  "write(35,*) ' Source position: ',yo,zo;"
               0  R = RCYL(NR); R2 = R*R;
               0  dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1)); zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               0  IF( yo > -R & yo < R & zo > -dz & zo < dz ) [ "inside geometry"
               1      error_flag = 1;
               1      ]
               0  just_fb = .false.; just_side = .false.;
               0  IF( yo => -R & yo <= R ) [ just_fb = .true.; ]
               0  IF( zo >= -dz & zo <= dz ) [ just_side = .true.; ]
               0
               0  IF( just_fb ) [
               1      IF( zo < -dz ) [
               2          fak = 1./(1-(-R*sint + dz*cost)/d);
               2          x1 = R*fak; y1 = (-R*cost-dz*sint)*fak;
               2          fak = 1./(1-(R*sint + dz*cost)/d);
               2          x2 = R*fak; y2 = (R*cost-dz*sint)*fak;
               2          ]
               1      ELSE [
               2          fak = 1./(1-(-R*sint - dz*cost)/d);
               2          x1 = R*fak; y1 = (-R*cost+dz*sint)*fak;
               2          fak = 1./(1-(R*sint - dz*cost)/d);
               2          x2 = R*fak; y2 = (R*cost+dz*sint)*fak;
               2          ]
               1      ymin = MIN(y1,y2); ymax = MAX(y1,y2);
               1      xmax = MAX(x1,x2); xmin = -xmax;
               1      ]
               0  ELSE IF( just_side ) [
               1      fak = 1./(1-(R*sint + dz*cost)/d);
               1      x1 = R*fak; y1 = (R*cost-dz*sint)*fak;
               1      fak = 1./(1-(R*sint - dz*cost)/d);
               1      x2 = R*fak; y2 = (R*cost+dz*sint)*fak;
               1      ymin = MIN(y1,y2); ymax = MAX(y1,y2);
               1      xmax = MAX(x1,x2); xmin = -xmax;
               1      ]
               0  ELSE [
               1      IF( zo < -dz ) [
               2          fak = 1./(1-(-R*sint + dz*cost)/d);
               2          x1 = R*fak; y1 = (-R*cost-dz*sint)*fak;
               2          ]
               1      ELSE [
               2          fak = 1./(1-(-R*sint - dz*cost)/d);
               2          x1 = R*fak; y1 = (-R*cost+dz*sint)*fak;
               2          ]
               1      fak = 1./(1-(R*sint + dz*cost)/d);
               1      x2 = R*fak; y2 = (R*cost-dz*sint)*fak;
               1      fak = 1./(1-(R*sint - dz*cost)/d);
               1      x3 = R*fak; y3 = (R*cost+dz*sint)*fak;
               1      xmax = max(x1,x2,x3); xmin = -xmax;
               1      ymin = min(y1,y2,y3); ymax = max(y1,y2,y3);
               1      ]
               0  delx = xmax - xmin; dely = ymax - ymin; area = delx*dely;
               0  w0 = area/d2; ro2 = yo*yo;
               0  OUTPUT IQIN,d,temp2,xmin,xmax,ymin,ymax;
               0  (/' Electric charge of the source:',T60,I12/
               0  ' Point source off axis'/
               0  ' Distance of source from centre of chamber: ',T60,f10.4,/
               0  ' Angle to z-axis (degrees): ',T60,f10.4,/,
               0  ' Rectangle in the plane perpendicular to the source-chamber'/
               0  ' axis seen from the source: ',/,T40,4f10.4/);
               0
               0  return;
               0
               0  entry src15_oto(iout);
               0  ainflu = NCASET/d2;
               0  return;
               0
               0  entry src15_describe(iout);
               0  write(iout,580) d,theta,yo,zo;
               0  580 format(' ',t20,'POINT SOURCE OFF AXIS',/,' ',t20,
               0  'distance to chamber centre: ',f8.3,' cm',/,' ',t20,
               0  'angle: ',f8.3,' degrees ',/,' ',t20,
               0  'source position: y = ',f8.3,' z = ',f8.3);
               0  return;
               0
               0  entry src15_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               0
               0  count = count + 1;
               0  $RANDOMSET eta1; $RANDOMSET eta2;
               0  xx = xmin + delx*eta1; yy = ymin + dely*eta2;
               0  "write(35,*) ' xx = ',xx,' yy = ',yy;"
               0  dist2 = d2 + xx*xx + yy*yy; dist = sqrt(dist2);
               0  w0 = d/dist;
               0  zz = yy*sint; yy = yy*cost;
               0  uli = xx/dist; vli = (yy-yo)/dist; wli = (zz-zo)/dist;
               0  "write(35,*) ' direction ',uli,vli,wli;"
               0  tf = 1e15; ts = 1e15; enter_fb = .false.; enter_side = .false.;
               0  IF( ~just_side ) [
               1      IF( zo < -dz ) [ tf = (-dz-zo)/wli; ] ELSE [ tf = (dz - zo)/wli; ]
               1      xli = uli*tf; yli = vli*tf + yo;
               1      IF( xli*xli + yli*yli < R2 ) [ enter_fb = .true.; ]
               1      ELSE [ tf = 1e15; ]
               1      ]
               0  IF( ~just_fb ) [
               1      ur2 = uli*uli + vli*vli; ux = -yo*vli/ur2; ux2 = ux*ux; rr2 = ro2/ur2;
               1      del = ux2 - rr2 + R2/ur2;
               1      IF( del >= 0 ) [
               2          ts = ux - sqrt(del);
               2          IF( ts > 0 ) [
               3              zli = zo + wli*ts;
               3              IF( zli >= -dz & zli <= dz ) [ enter_side = .true.; ]
               3              ]
               2          IF( ~enter_side ) [ ts = 1e15; ]
               2          ]
               1      ]
               0  "write(35,*) ' distances: ',tf,ts;"
               0  IF( ~enter_fb & ~enter_side ) [
               1      weight = 0;
               1      xin = 0; yin = 0; zin = zplane(1);
               1      uin = 0; vin = 0; win = 1; irin = 2;
               1      return;
               1      ]
               0  uin = uli; vin = vli; win = wli; weight = w0*area/dist2;
               0  sumw = sumw + weight; sumw2 = sumw2 + weight*weight;
               0  IF( tf < ts ) [
               1      xin = xli; yin = yli;
               1      IF( zo < -dz ) [ zin = zplane(1); iz = 1; ]
               1      ELSE [ zin = zplane(nplane); iz = nplane-1; ]
               1      rad2 = xli*xli+yli*yli;
               1      DO ix=1,nr [ IF( rad2 <= CYRAD2(IX) ) EXIT; ]
               1      ]
               0  ELSE [
               1      zin = zli + zc;
               1      xin = ts*uli; yin = yo + vli*ts; ix = nr;
               1      DO iz=1,nz [ IF( zin >= zplane(iz) & zin < zplane(iz+1) ) EXIT; ]
               1      ]
               0  irin = 1 + (ix-1)*nz + iz;
               0  "write(35,*) ' entering at ',xin,yin,zin,irin;"
               0
               0  return;
               0
               0  entry src15_out(iout);
               0
               0  sumw = sumw/count; sumw2 = sumw2/count;
               0  error = (sumw2 - sumw*sumw)/(count-1);
               0  IF( error > 0 ) [ error = sqrt(error); ]
               0  write(iout,600) sumw,sumw2;
               0  600 format(//'  Source 15: solid angle for detector: ',g14.5,' +/- ',g14.5,//);
               0  return;
               0
               0  end;
               0
               0  "======================================================================"
               0  subroutine src16;
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  ;COMIN/GEOM,IODAT2,RANDOM,SOURCE/;
               0
               0  $REAL       temp1,temp2,temp3,temp4; "from input file"
               0  $REAL       XIN,YIN,ZIN,UIN,VIN,WIN,WEIGHT;
               0  $INTEGER    NRCFLG,IRIN,iout,error_flag;
               0
               0  real*8      pi,theta,cost,sint,d0,d02,R,R2,dz,dr,zc,u,aux,u2,
               0  xo,yo,zo,a_side,a_fb,atot,wfb,dist,dist2,rs,
               0  delxs,delys,rs2,rad2,eta,sumw,sumw2,count,zz;
               0  logical     point_source,do_fb,do_side,do_both,is_circle;
               0  integer*4   ix,iz;
               0
               0  save        pi,cost,sint,d0,d02,R,R2,dz,dr,zc,theta,
               0  xo,yo,zo,a_side,a_fb,atot,wfb,rs,delxs,delys,rs2,
               0  sumw,sumw2,count,point_source,do_fb,do_side,is_circle;
               0
               0  entry src16_ini(temp1,temp2,temp3,temp4,error_flag);
               0  "=================================================="
               0
               0  pi = 4*datan(1d0); count = 0;
               0  theta = temp2; theta = theta*pi/180;
               0  cost = cos(theta); sint = sin(theta);
               0  d0 = temp1; d02 = d0*d0;
               0  R = RCYL(NR); R2 = R*R;
               0  dz = 0.5*(ZPLANE(NPLANE)-ZPLANE(1)); zc = 0.5*(ZPLANE(NPLANE)+ZPLANE(1));
               0  IF( temp3 <= 0 & temp4 <= 0 ) [
               1      "We assume a point source (i.e. the same as source 12 and 15)"
               1      point_source = .true.; zo = -d0*cost; yo = d0*sint; xo = 0;
               1      do_fb = .false.; do_side = .false.; do_both = .false.;
               1      a_side = 0; a_fb = 0;
               1      IF( abs(yo) > R ) [
               2          u = R/yo; aux = sqrt(1-u*u); dr = R*aux; do_side = .true.;
               2          a_side = 4*dz*R*yo*(aux-u*atan(aux/u));
               2          ]
               1      IF( abs(zo) > dz ) [
               2          a_fb = pi*R2*(abs(zo)-dz); do_fb = .true.;
               2          ]
               1      atot = a_fb + a_side;  wfb = a_fb/atot;
               1      IF( do_side & do_fb ) [ do_both = .true.; ]
               1      ]
               0  ELSE [
               1      point_source = .false.; is_circle = .false.;
               1      IF( temp4 <= 0 | temp3 <= 0 ) [
               2          "We assume that the source is a circle with radius temp3"
               2          IF( temp4 <= 0 ) [ rs = temp3; ] ELSE [ rs = temp4; ]
               2          rs = temp3; rs2 = rs*rs; delxs = rs; delys = rs;
               2          is_circle = .true.;
               2          ]
               1      ELSE [
               2          "We assume that the source is a rectangle with half-widths"
               2          "temp3 and temp4 (x and y in the plane perpendicular to the
               2          "source center to chamber center axis)"
               2          delxs = temp3; delys = temp4; rs2 = 1.1*(delxs*delxs+delys*delys);
               2          ]
               1      ]
               0
               0  OUTPUT IQIN; (/' Electric charge of the source:',T60,I12);
               0  IF( point_source ) [
               1      OUTPUT d0,temp2,wfb,1-wfb;
               1      (' Point source off axis (source 16 implementation)'/
               1      ' Distance of source from centre of chamber: ',T60,f10.4,/
               1      ' Angle to z-axis (degrees): ',T60,f10.4,/,
               1      ' Estimated probability to strike front/back face: ',T60,f12.6,/
               1      ' Estimated probability to strike side face: ',T60,f12.6);
               1      ]
               0  ELSE [
               1      IF( is_circle ) [
               2          OUTPUT d0,temp2,rs;
               2          (' Disk irradiating the chamber (source 16 implementation)'/
               2          ' Distance of source centre to chamber centre: ',T60,f10.4,/
               2          ' Angle to z-axis (degrees): ',T60,f10.4,/,
               2          ' Radius of the source: ',T60,f10.4);
               2          ]
               1      ELSE [
               2          OUTPUT d0,temp2,delxs,delys;
               2          (' Rectangle irradiating the chamber (source 16 implementation)'/
               2          ' Distance of source centre to chamber centre: ',T60,f10.4,/
               2          ' Angle to z-axis (degrees): ',T60,f10.4,/,
               2          ' Rectangle half-sizes: ',T60,2f10.4);
               2          ]
               1      ]
               0  return;
               0
               0  entry src16_oto(iout);
               0  "===================="
               0  ainflu = NCASET/d02;
               0  return;
               0
               0  entry src16_describe(iout);
               0  "========================="
               0
               0  IF( point_source ) [
               1      write(iout,'(t20,a)') 'POINT SOURCE OFF AXIS (source 16)';
               1      ]
               0  ELSE [
               1      IF( is_circle ) [
               2          write(iout,'(t20,a)') 'Radiating circle off axis (source 16)';
               2          write(iout,'(t20,a,f10.4)') 'Source radius: ',rs;
               2          ]
               1      ELSE [
               2          write(iout,'(t20,a)') 'Radiating rectangle off axis (source 16)';
               2          write(iout,'(t20,a,2f10.4)') 'Source half-sizes: ',delxs,delys;
               2          ]
               1      ]
               0  write(iout,'(t20,a,f10.4)')
               0  'Distance between source and chamber centres: ',d0;
               0  write(iout,'(t20,a,f10.4,a)')
               0  'Angle to z-axis (degrees): ',theta*180/pi,' degrees';
               0  return;
               0
               0  entry src16_hst(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               0  "=========================================================="
               0
               0  count = count + 1;
               0  IF( ~point_source ) [
               1      LOOP [
               2          $RANDOMSET xo; xo = delxs*(2*xo-1);
               2          $RANDOMSET yo; yo = delys*(2*yo-1);
               2          ] UNTIL ( xo*xo + yo*yo < rs2 );
               1      zo = yo*sint - d0*cost; yo = d0*sint + yo*cost;
               1      yo = sqrt(yo*yo+xo*xo);
               1      do_fb = .false.; do_side = .false.; do_both = .false.;
               1      a_side = 0; a_fb = 0;
               1      IF( abs(yo) > R ) [
               2          u = R/yo; do_side = .true.;
               2          IF( u < 0.1 ) [
               3              u2 = u*u; aux = 1 - u2/2 - u2*u2/8;
               3              a_side = 4*dz*R*yo*(aux-pi*u/2+u2+u2*u2/6);
               3              ]
               2          ELSE [
               3              aux = sqrt(1-u*u);
               3              a_side = 4*dz*R*yo*(aux-u*atan(aux/u));
               3              ]
               2          dr = R*aux;
               2          ]
               1      IF( abs(zo) > dz ) [
               2          a_fb = pi*R2*(abs(zo)-dz); do_fb = .true.;
               2          ]
               1      atot = a_fb + a_side;
               1      IF( do_side & do_fb ) [ wfb = a_fb/atot; do_both = .true.; ]
               1      ]
               0  IF( do_both ) [
               1      $RANDOMSET eta;
               1      IF( eta < wfb ) [ do_fb = .true.; do_side = .false.; ]
               1      ELSE            [ do_fb = .false.; do_side = .true.; ]
               1      ]
               0  IF( do_fb ) [
               1      LOOP [
               2          $RANDOMSET xin; xin = R*(2*xin-1);
               2          $RANDOMSET yin; yin = R*(2*yin-1);
               2          rad2 = xin*xin + yin*yin;
               2          ] UNTIL (rad2 <= R2 );
               1      DO ix=1,nr [ IF( rad2 <= CYRAD2(ix) ) EXIT; ]
               1      IF ( zo < -dz ) [ zin = -dz; iz = 1; ]
               1      ELSE            [ zin =  dz; iz = nz; ]
               1      ]
               0  ELSE [
               1      $RANDOMSET zin; zin = dz*(2*zin-1);
               1      LOOP [
               2          $RANDOMSET xin;  $RANDOMSET eta;
               2          xin = dr*(2*xin-1);
               2          yin = sqrt(R2 - xin*xin);
               2          ] UNTIL ( eta < (yo-R2/yin)/(yo-R) );
               1      ix = nr;
               1      zz = zin + zc;
               1      DO iz=1,nz [ IF( zz >= zplane(iz) & zz < zplane(iz+1) ) EXIT; ]
               1      ]
               0  uin = xin; vin = yin - yo; win = zin - zo;
               0  dist2 = uin*uin + vin*vin + win*win;
               0  dist = sqrt(dist2); uin = uin/dist; vin = vin/dist; win = win/dist;
               0  weight = atot/dist2/dist;
               0  sumw = sumw + weight; sumw2 = sumw2 + weight*weight;
               0  irin = 1 + (ix-1)*nz + iz; zin = zin + zc;
               0  return;
               0
               0  end;
               0
               0  $HAVE_LOAD_DSO(#);
               0
               0  #ifndef HAVE_LOAD_DSO;
               0
               0  subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
               0  hen_house,egs_home,the_beam_code,
               0  the_pegs_file,the_input_file);
               0  $INTEGER i_parallel,n_parallel;
               0  character*(*) conf_name;
               0  character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_input_file;
               0  write(6,*) 'You need a working C compiler to use source 23!';
               0  $CALL_EXIT(1);
               0  end;
               0
               0  subroutine sample_beamsource(ein,xin,yin,zin,uin,vin,win,weight,iqin,latchi,
               0  nhstry,iphatin);
               0  return; end;
               0
               0  subroutine finish_beamsource;
               0  return; end;
               0
               0  #endif;
               0
               0  "Last line in srcrz.mortran "
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc input source spectrum subroutine                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2000                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This subroutine is used to do all the work associated with having an input "
               0  "  source spectrum for the NRC user codes.                                    "
               0  "                                                                             "
               0  "  This implementation of ENSRC uses the alias sampling technique to sample   "
               0  "  the source energy from a histogrammed input energy spectrum (and thus      "
               0  "  needs nrcaux.mortran). To avoid confusions with multiple definitions of    "
               0  "  the spectrum common block, this common block should not be used any longer "
               0  "  and all data needed stored in the static arrays ensrcd, srcpdf, srcpdf_at  "
               0  "  and srcbin_at. For now, to assure compatibility with current versions of   "
               0  "  NRC user codes, ensrcd and srcpdf are left in the common/source/.          "
               0  "                                                                             "
               0  "  Input is based on the input routine adapted by Aaron Merowitz from the     "
               0  "  original ENSRC implementation that uses get_input.                         "
               0  "                                                                             "
               0  "                                                                             "
               0  "  ENTRY POINTS                                                               "
               0  "  ------------                                                               "
               0  "                                                                             "
               0  "   NSRC                    call from anywhere in your user code (but before  "
               0  "                           the first SHOWER call) to get                     "
               0  "                           input data as defined below                       "
               0  "                                                                             "
               0  "   NSRC1:                  initialization routine. To be called after        "
               0  "                           ENSRC and before the first SHOWER call            "
               0  "                                                                             "
               0  "   NSRCO:                  produces a summary of the input data.             "
               0  "                                                                             "
               0  "   NSRCH(ENIN):            called from main for each history to sample the   "
               0  "                           spectrum (MONOEN=1) or return the source energy   "
               0  "                           if mono-energetic beam                            "
               0  "                           COMMON/SOURCE/ (EINSRC) (MONOEN=2).               "
               0  "                                                                             "
               0  "   NSRC_EMAX(EK_MAX):      Puts maximum spectrum energy (source energy       "
               0  "                           for mono-energetic beams) into EK_MAX             "
               0  "                                                                             "
               0  "   INPUTS                                                                    "
               0  "   ------                                                                    "
               0  "                                                                             "
               0  "   NENSRC                  number of energy bins used to define the          "
               0  "                           distribution                                      "
               0  "                                                                             "
               0  "   SRCPDF(I=1,NENSRC)      the source probability distribution not           "
               0  "                           necessarily normalized                            "
               0  "                           probability of particle in this bin or /MeV       "
               0  "                                                                             "
               0  "   ENSRCD(I=0,NENSRC)      ensrcd(i-1) is the bottom energy in bin i,        "
               0  "                           ensrcd(i) the top energy                          "
               0  "                           Note the definition as $REAL ensrcd(0:$NENSRC)    "
               0  "                                                                             "
               0  "   ENMIN                   equal ensrcd(0), still there for compatibility    "
               0  "                                                                             "
               0  "   IWATCH                  diagnostic printout if IWATCH is not 0            "
               0  "                                                                             "
               0  "   MONOEN                  passed in COMIN USER  = 0 if monoenergetic        "
               0  "                                            = 2 if ISOURC=21                 "
               0  "   EIN                     passed in IODAT2-K.E. of monoenergetic source     "
               0  "                                                                             "
               0  "                                                                             "
               0  "   OTHER ARRAYS                                                              "
               0  "   ------------                                                              "
               0  "                                                                             "
               0  "   srcpdf_at, srcbin_at    arrays necessary for the alias sampling           "
               0  "                           technique, they are initialized via a call to     "
               0  "                           prepare_alias_sampling and used in                "
               0  "                           the function alias_sample to do the actual        "
               0  "                           sampling                                          "
               0  "                                                                             "
               0  "                                                                             "
               0  "   NOTES                                                                     "
               0  "   -----                                                                     "
               0  "                                                                             "
               0  "   This routine DOES NOT need the COMIN SPECTR                               "
               0  "                                                                             "
               0  "   If ENFLAG=1 (variable in COMMON/SOURCE/) then the energy has been         "
               0  "   previously set and stored in EINSRC (variable in COMMON/SOURCE/)          "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0
               0
               0  SUBROUTINE ENSRC;
               0
               0  $IMPLICIT-NONE;
               0
               0  ;"LINE SKIP"
               0
               0  "***************************************************************************"
               0  "*               Variables passed to the subroutine GET_INPUTS             *"
               0  "***************************************************************************"
               0  COMIN/GetInput/;
               0
               0  "These variables point to the index of their values_sought"
               0  INTEGER NUM_EITYPE,
               0  NUM_KIEN,
               0  NUM_SPFIL,
               0  NUM_SPIOUSP;
               0
               0  "COMMIN BLOCK DEFINITIONS
               0  "************************
               0  ;COMIN/PRINTC,IODAT2,SCORE,SPECTR,USER,RANDOM,SOURCE/;
               0  "                           ^
               0  " We want to make the energy spectrum sampling self contained ->
               0  " no need to put required data in a common block that is defined in the
               0  " main user code. The only dependence on the user code should be $NENSRC which
               0  " is used to define array dimensions.
               0
               0  $INTEGER "nensrc,"
               0  srcbin_at($NENSRC),
               0  mode;
               0  $REAL    "ensrcd(0:$NENSRC),"
               0  "srcpdf($NENSRC),"
               0  srcpdf_at($NENSRC),
               0  enmin,enmax,sume1,sume,
               0  Ek_max,Emono;
               0  $LOGICAL is_mono;
               0  character*256 filnam,spec_title;
               0  integer*4 lnblnk1; "use our own in-house lnblnk routine because some"
               0  "compilers do not have lnblnk"
               0
               0  save enmin,enmax,"nensrc," srcbin_at,"ensrcd,srcpdf," srcpdf_at,Emono,
               0  is_mono,mode,filnam,spec_title;
               0
               0  $INTEGER ib;
               0  $REAL    enin,alias_sample;
               0
               0  "******************************************************************************
               0  "            NOT REQUIRED IF ISOURC=21 (FULL PHASE SPACE OF READ)
               0  "
               0  " ENSRC DELIMETERS:  :start source inputs:
               0  "                    :stop source inputs:
               0  "
               0  "
               0  "  INCIDENT ENERGY
               0  "        = monoenergetic  (0)  if monoenergetic beam
               0  "        = spectrum       (1)  if energy spectrum to be used
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Monoenergetic:
               0  "
               0  "     INCIDENT KINETIC ENERGY(MEV)   (I)
               0  "                                   kinetic energy of the incident beam in MeV
               0  "                                   (defaults to 1.25)
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Spectrum:
               0  "
               0  "                   SPEC FILENAME   (C)  filename (with ext)
               0  "                                   contains spectrum information
               0  "
               0  "                                   FILE FORMAT:
               0  "                                   TITLE      spectrum title  (80 char)
               0  "                                   NENSRC, ENMIN, MODE
               0  "                                   NENSRC     # energy bins in spec.  histogram
               0  "                                   ENMIN      lower energy of first bin
               0  "                                   MODE       =0, assumes cts/bin
               0  "                                              =1  assumes cts/MeV
               0  "                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
               0  "                                   top of energy bin and probability of
               0  "                                   initial particle being in this bin.
               0  "                                   probability does not need to be normalized
               0  "
               0  "                   SPEC IOUTSP
               0  "                        = none     (0)  no spectrum data in output summary
               0  "                        = include  (1)  include spectrum data in output summary
               0  ;
               0  "
               0  "*******************************************************************************
               0  ;"------------------------------------------------------------------------------
               0  DELIMETER='SOURCE INPUTS';
               0
               0  IF(ENFLAG.EQ.1)["FULL PHASE-SPACE INFORMATION READ PREVIOUSLY"
               1      MONOEN = 2;
               1      RETURN;
               1      ]
               0  OUTPUT;(' *** INPUT CARD TC1 ***');
               0  IVAL = IVAL +1;
               0  NUM_EITYPE = IVAL;
               0  VALUES_SOUGHT(IVAL)='INCIDENT ENERGY';
               0  TYPE(IVAL)=3;
               0  NVALUE(IVAL)=1;
               0  ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC';
               0  ALLOWED_INPUTS(IVAL,1)='SPECTRUM';
               0  $GET_INPUT(NUM_EITYPE);
               0  MONOEN=VALUE(NUM_EITYPE,1);
               0
               0  IF(MONOEN = 0)[
               1      OUTPUT ;(' MONOENERGETIC BEAM:');
               1      IVAL = IVAL +1;
               1      NUM_KIEN = IVAL;
               1      VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)';
               1      TYPE(IVAL)=1;
               1      NVALUE(IVAL)=1;
               1      VALUE_MIN(IVAL)=0.001;    "databases for EGSnrc stop at 1 keV"
               1      VALUE_MAX(IVAL)=200000;   "not sure what real upper limit is"
               1      DEFAULT(IVAL)=1.25;
               1      $GET_INPUT(NUM_KIEN);
               1      EIN=VALUE(NUM_KIEN,1);
               1      OUTPUT EIN;(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4);
               1      is_mono = .true.; Emono = EIN;
               1      ]
               0  ELSE[
               1      OUTPUT;(' ENERGY SPECTRUM:');
               1
               1      is_mono = .false.;
               1
               1      IVAL = IVAL +1;
               1      NUM_SPFIL = IVAL;
               1      VALUES_SOUGHT(IVAL)='SPEC FILENAME';
               1      TYPE(IVAL)=2;
               1      $GET_INPUT(NUM_SPFIL);
               1      READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam;
               1
               1      OUTPUT filnam;(/'   READ INPUT ENERGY SPECTRUM FROM: ',A);
               1      call replace_env(filnam);
               1      OPEN(9,file=filnam,STATUS='OLD');
               1      READ(9,'(A)') spec_title;
               1      READ(9,*) nensrc,ensrcd(0),mode;
               1      enmin = ensrcd(0);
               1      IF(NENSRC > $NENSRC) [
               2          OUTPUT NENSRC,$NENSRC;
               2          (//' ********** Asked for too many energy bins******'/
               2          ' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//);
               2          NENSRC = $NENSRC;
               2          ]
               1      READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
               1      CLOSE(UNIT=9);
               1      OUTPUT NENSRC; ('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE');
               1      IF(MODE=0)[OUTPUT;('      Counts/bin assumed');]
               1      ELSEIF(MODE = 1) [
               2          OUTPUT;('      Counts/MeV assumed');
               2          DO IB=1,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
               2          ] "end mode = 1 block"
               1      ELSE [OUTPUT MODE;(///'*****MODE not 0 or 1 in spectrum file? **'
               2          /80('*') //);]
               1
               1      EIN=ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
               1      OUTPUT ENMIN,EIN;('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV');
               1      enmax = ein;
               1
               1      IVAL = IVAL +1;
               1      NUM_SPIOUSP = IVAL;
               1      VALUES_SOUGHT(IVAL)='SPEC IOUTSP';
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=0;
               1      ALLOWED_INPUTS(IVAL,0)='NONE';
               1      ALLOWED_INPUTS(IVAL,1)='INCLUDE';
               1      $GET_INPUT(NUM_SPIOUSP);
               1      IOUTSP=VALUE(NUM_SPIOUSP,1);
               1      ]
               0  OUTPUT;(' ');
               0  RETURN;   "NORMAL RETURN"
               0
               0  ENTRY ENSRC1;
               0  "==========="
               0
               0  IF( is_mono ) return;
               0
               0  " Rewritten by IK: to guarantee that the input spectrum is exactly sampled,"
               0  "                  The alias sampling technique is employed
               0  "                  needs prepare_alias_sampling which is in nrcaux.mortran
               0
               0  " Check that enmin < ensrcd(1) "
               0  IF( enmin >= ensrcd(1) ) [
               1      write(6,*) ' Bad spectrum: minimum energy is > top of first bin! ';
               1      stop;
               1      ]
               0
               0  call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at);
               0
               0  RETURN;
               0
               0  ENTRY ENSRCO;
               0  "==========="
               0
               0  IF( is_mono ) [
               1      write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV';
               1      return;
               1      ]
               0  IF(enflag = 1) [ "this is a phase space input, print nothing here" return;]
               0  WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_TITLE));
               0  105 FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A);
               0  sume1 = 0; sume = 0;
               0  DO ib=1,nensrc[
               1      sume = sume + srcpdf(ib);
               1      sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2;
               1      ]
               0  WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/sume;
               0  IF(IOUTSP.EQ.1)[
               1      IF(MODE=0)[WRITE(IOUT,'(20x,'' Counts/bin assumed'')');]
               1      ELSE   [WRITE(IOUT,'(20x,'' Counts/MeV assumed'')');]
               1      WRITE(IOUT,110)NENSRC,enmin;
               1      DO IB=1,NENSRC[
               2          WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin_at(ib);
               2          ]
               1      ]
               0  RETURN;
               0
               0
               0  ENTRY ENSRCH(ENIN);
               0  "================"
               0
               0  IF( is_mono ) [ enin = Emono; return; ]
               0
               0  enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at);
               0  RETURN;
               0
               0  ENTRY ENSRC_EMAX(Ek_max);
               0
               0  IF( is_mono ) [ Ek_max = Emono; ]
               0  ELSE [ Ek_max = ensrcd(nensrc); ]
               0  return;
               0
               0
               0  100   FORMAT(' ',I1);
               0  102   FORMAT(' ',G14.7);
               0  110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3/
               0  T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/
               0  ' ',T20,'bin    kinetic energy     probability  at prob   at bin');
               0  120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4);
               0
               0  END; "end subroutine ensrc"
               0
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc cylindrical geometry input subroutine                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Aaron Merovitz, 1998                                      "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0
               0  ;"******************************************************************************
               0  "
               0  "                              ******************
               0  "                              *                *
               0  "                              * geomrz.mortran *
               0  "                              *                *
               0  "                              ******************
               0  "
               0  "
               0  "   This subroutine is used to do all the I/O associated with having
               0  "   a cylindrical geometry input.
               0  "
               0  "       VERSION 1       A. Merovitz         03/98 for DWOR
               0  "
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  ;
               0  "*******************************************************************************
               0  "                       CYLINDRICAL GEOMETRY INPUT
               0  "                       **************************
               0  "*******************************************************************************
               0  "
               0  " GEOMRZ DELIMETERS:    :start geometrical inputs:
               0  "                       :stop geometrical inputs:
               0  "
               0  "  METHOD OF INPUT
               0  "        = Groups         (0)   input groups of slabs of equal thickness
               0  "        = Individual     (1)   detailed input of the geometry and media.
               0  "                               [ITERSE]
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  " Information defining depth boundaries along z axis (all dimensions cm)
               0  "
               0  " Only if  METHOD OF INPUT=  Groups
               0  "
               0  "  Z OF FRONT FACE        (R)   start of first slab (real)
               0  "  NSLAB                  (M)   # planar slabs in a group (integers)
               0  "  SLAB THICKNESS         (M)   thickness of each slab in the group (reals)
               0  "
               0  "
               0  " Only if  METHOD OF INPUT=  Individual
               0  "
               0  "  Z OF FRONT FACE        (R)   start of first slab (real)
               0  "  DEPTH BOUNDARIES       (M)   geometrical z-plane coordinates (reals)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "  Information defining radial boundaries
               0  "
               0  "  RADII                  (M)   radii of cylinders defining the geometry (reals)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "  MATERIAL INPUT
               0  "  **************
               0  "
               0  "  MEDIA              (M)   material name which must match that in the
               0  "                           pegs4 data set EXACTLY, including case.
               0  "                           24 characters max per medium, ended by , or ;
               0  "
               0  "  Define which media in which regions, numbering in order given above.
               0  "
               0  "  DESCRIPTION BY= Regions            use the individual geometric region
               0  "                                     numbers
               0  "                = Planes             use the IX, IZ values
               0  "                = Regions + Density  same as Regions but specify medium
               0  "                                     density as well
               0  "                = Planes + Density   same as Planes but specify medium
               0  "                                     density as well
               0  "                               [DESCRIBE]
               0  "
               0  " If DESCRIPTION BY= Regions
               0  "
               0  "  MEDNUM                 (M)   the material number (integers)
               0  "                               (MEDNUM=0 => vacuum)
               0  "  RHOR (only if DESCRIPTION= Regions + Density)
               0  "                         (M)   material density if different from the default
               0  "                               (real) (if 0 then assumed to be default)
               0  "  START REGION           (M)   initial geometrical zone(irl) (integers) for
               0  "                               this medium [NREGLO]
               0  "  STOP REGION            (M)   final geometrical zone(irl) (integers) for
               0  "                               this medium.[NREGHI]
               0  "                               ( >NREGLO to input more than one zone)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "
               0  "                         These inputs should be thought of as triplets
               0  "                         (quadruplets if RHOR is also specified) of
               0  "                         MEDNUM, (RHOR,) START and STOP REGIONs which are used
               0  "                         to specify the medium numbers for all regions where
               0  "                         the medium is not the default (medium 1).
               0  "
               0  " If DESCRIPTION BY=  Planes
               0  "
               0  "  MEDNUM                 (M)   the material number (integers)
               0  "                               (MEDNUM=0 => vacuum)
               0  "  RHOR (only if DESCRIPTION= Planes + Density)
               0  "                         (M)   material density if different from the default
               0  "                               (real) (if 0 then assumed to be default)
               0  "  START ZSLAB            (M)   initial zslab(iz) (integers)
               0  "  STOP ZSLAB             (M)   final zslab(iz) (integers)
               0  "  START RING             (M)   initial radial ring (ix) (integers)
               0  "  STOP RING              (M)   final radial ring (ix) (integers)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "                         These inputs shpuld be thought of as quintuples
               0  "                         (sextuples if RHOR is specified) of numbers
               0  "                         which specify the medium numbers and density by
               0  "                         planar - radial regions
               0  "
               0  "  One must use one type of input or the other so you must decide
               0  "  which is more convenient for any given case.
               0  "
               0  "***************************************************************************"
               0  "
               0  ;
               0  SUBROUTINE GEOMRZ;
               0
               0
               0  $IMPLICIT-NONE;
               0
               0  "ERROR_FLAG is now in common block"
               0
               0  "DECLERATION OF COMIN BLOCKS
               0  "***************************
               0  ;COMIN/GEOM,IODAT2,MEDIA,MISC,SCORE,SOURCE,USER,RANDOM,GetInput/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0
               0  $INTEGER "NMED, "MEDNUM, NREGLO, NREGHI;               "material input"
               0  $INTEGER NZHI, NZLO, NRHI, NRLO;                     "material input"
               0  $INTEGER ITERSE,NSLAB($NVALUE), DESCRIBE;            "cylindrical geom. input"
               0  $REAL DELTAZ($NVALUE),RHORI;                         "cylindrical geom. input"
               0
               0  "***************************************************************************"
               0  "*                Variables used to point to the inputs                    *"
               0  "***************************************************************************"
               0  "Cylindrical geometry input"
               0  $INTEGER NUM_ITERSE,
               0  NUM_FTFACE,
               0  NUM_NSLAB,
               0  NUM_DELTAZ,
               0  NUM_ZPLANES,
               0  NUM_RCYL;
               0
               0  "Material Input"
               0  $INTEGER NUM_MEDIA,
               0  NUM_RHOR,
               0  NUM_DESCRIB,
               0  NUM_MEDNUM,
               0  NUM_NREGLO,
               0  NUM_NREGHI,
               0  NUM_NPLANLO,
               0  NUM_NPLANHI,
               0  NUM_NRADLO,
               0  NUM_NRADHI;
               0  "---------------------------------------------------------------------------"
               0  $INTEGER ERR;  "$inputfile.errors file"
               0  $INTEGER IOUT;  "unit number for .egslst file"
               0  $INTEGER lnblnk1; "our in-house lnblnk function"
               0  $INTEGER I,J,K,PLN,COUNT;
               0  $INTEGER IX, IZ, REGNUM, SLENGHT;
               0  $REAL ADDING;
               0
               0  save describe; "IK: Must be static because used in entry geomrz_isumry"
               0
               0  "---------------------------------------------------------------------------"
               0  I=0;  "initialize index number of the value_sought"
               0  ERR=15;  "output errors to unit # 15"
               0
               0  ERROR_FLAG=0;   "Initialization of bad input flag"
               0
               0  "                      CYLINDRICAL GEOMETRY INPUT"
               0  "                      **************************"
               0
               0  DELIMETER = 'GEOMETRICAL INPUTS';
               0
               0  NUM_ITERSE = IVAL;
               0  VALUES_SOUGHT(IVAL)='METHOD OF INPUT';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='GROUPS';
               0  ALLOWED_INPUTS(IVAL,1)='INDIVIDUAL';
               0  $GET_INPUT(IVAL);  "get the value for ITERSE"
               0  ITERSE=VALUE(IVAL,1);
               0
               0  IVAL = IVAL + 1;
               0  NUM_FTFACE = IVAL;
               0  VALUES_SOUGHT(IVAL)='Z OF FRONT FACE';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-999999;
               0  VALUE_MAX(IVAL)=999999;
               0  DEFAULT(IVAL)=0.0;
               0  $GET_INPUT(IVAL);
               0  ZPLANE(1)=VALUE(IVAL,1);
               0
               0  IF (ITERSE=0) [
               1      IVAL = IVAL + 1;
               1      NUM_NSLAB = IVAL;
               1      VALUES_SOUGHT(IVAL)='NSLAB';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=999999;
               1      DEFAULT(IVAL)=1;
               1      $GET_INPUT(IVAL);
               1
               1      IVAL = IVAL + 1;
               1      NUM_DELTAZ = IVAL;
               1      VALUES_SOUGHT(IVAL)='SLAB THICKNESS';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=999999;
               1      DEFAULT(IVAL)=1.0;
               1      $GET_INPUT(IVAL);
               1
               1      "Calculate the number of, and assign the Z planes"
               1      DO K=1,NVALUE(NUM_NSLAB) [NSLAB(K)=VALUE(NUM_NSLAB,K);]
               1      DO K=1,NVALUE(NUM_DELTAZ)[DELTAZ(K)=VALUE(NUM_DELTAZ,K);]
               1      COUNT=1;
               1      DO PLN=1, NVALUE(NUM_NSLAB) [
               2          IF (PLN=1) [ADDING=0;]
               2          ELSE [ADDING=ADDING+DELTAZ(PLN-1)*NSLAB(PLN-1);]
               2          DO K=1, NSLAB(PLN) [
               3              COUNT=COUNT+1;
               3              ZPLANE(COUNT)=ZPLANE(1)+ADDING+DELTAZ(PLN)*K;
               3              ]
               2          ]
               1      NZ=COUNT-1;
               1      IF( NZ-1 > $MAXZREG) [
               2          OUTPUT NZ-1, $MAXZREG;
               2          (///' Number of depth regions,',I3,' is greater than $MAXZREG=',I3/
               2          '  You must change the definition of $MAXZREG in the user code'/
               2          '      and recompile'///);
               2          STOP
               2          ]
               1      "Note radii are picked up below"
               1      ]
               0
               0  IF (ITERSE=1) [
               1      IVAL = IVAL + 1;
               1      NUM_ZPLANES = IVAL;
               1      VALUES_SOUGHT(IVAL)='DEPTH BOUNDARIES';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=-999999;
               1      VALUE_MAX(IVAL)=999999;
               1      DEFAULT(IVAL)=1.0;
               1      $GET_INPUT(IVAL);  "get the depth boundaries"
               1      NZ=NVALUE(IVAL);  "get the number of ZPLANES input"
               1      IF( NZ-1 > $MAXZREG) [
               2          OUTPUT NZ-1, $MAXZREG;
               2          (///' Number of depth regions,',I3,' is greater than $MAXZREG=',I3/
               2          '  You must change the definition of $MAXZREG in the user code'/
               2          '      and recompile'///);
               2          STOP
               2          ]
               1      ]
               0
               0  IVAL = IVAL + 1;
               0  NUM_RCYL = IVAL;
               0  VALUES_SOUGHT(IVAL)='RADII';
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.0000001;
               0  VALUE_MAX(IVAL)=999999.9;
               0  DEFAULT(IVAL)=1000.0;
               0  $GET_INPUT(NUM_RCYL);
               0  NR=NVALUE(NUM_RCYL);      "get the number of radial cylinders input"
               0  IF( NR > $MAXRADII ) [
               1      OUTPUT NR, $MAXRADII;
               1      (///' Number of radial regions,',I3,' is greater than $MAXRADII',I3,/
               1      '  You must change the definition of $MAXRADII in the user code'/
               1      '      and recompile'///);
               1      STOP
               1      ]
               0  NREG=NR*NZ+1;  "define the number of regions"
               0  IF( NREG > $MXREG ) [
               1      OUTPUT NREG, $MXREG;
               1      (///' Total number of regions,',I6,' is greater than $MXREG=',I6,/
               1      '  You must change the definition of $MXREG in the user code'/
               1      '      and recompile'///);
               1      STOP
               1      ]
               0
               0  "                               MATERIAL INPUT
               0  "                               **************
               0  IVAL = IVAL + 1;
               0  NUM_MEDIA = IVAL;
               0  VALUES_SOUGHT(IVAL)='MEDIA';
               0  TYPE(IVAL)=2;
               0  $GET_INPUT(IVAL); "get the number of media"
               0  NMED=NVALUE(IVAL);
               0
               0  IVAL = IVAL + 1;
               0  NUM_DESCRIB = IVAL;
               0  VALUES_SOUGHT(IVAL)='DESCRIPTION BY';
               0  TYPE(IVAL)=3;
               0  NVALUE(IVAL)=1;
               0  ALLOWED_INPUTS(IVAL,0)='REGIONS';
               0  ALLOWED_INPUTS(IVAL,1)='PLANES';
               0  ALLOWED_INPUTS(IVAL,2)='REGIONS + DENSITY';
               0  ALLOWED_INPUTS(IVAL,3)='PLANES + DENSITY';
               0  $GET_INPUT(NUM_DESCRIB);
               0  DESCRIBE=VALUE(NUM_DESCRIB,1);
               0
               0  IVAL = IVAL + 1;
               0  NUM_MEDNUM = IVAL;
               0  VALUES_SOUGHT(IVAL)='MEDNUM';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NMED;
               0  DEFAULT(IVAL)=1;
               0
               0  IF(DESCRIBE=2 | DESCRIBE=3)[
               1      IVAL = IVAL + 1;
               1      NUM_RHOR = IVAL;
               1      VALUES_SOUGHT(IVAL)='RHOR';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=0.0;
               1      VALUE_MAX(IVAL)=999999.0;
               1      DEFAULT(IVAL)=0.0;
               1      ]
               0
               0  IF (DESCRIBE=0 | DESCRIBE=2) [
               1      IVAL = IVAL + 1;
               1      NUM_NREGLO = IVAL;
               1      VALUES_SOUGHT(IVAL)='START REGION';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=NREG;
               1      DEFAULT(IVAL)=1;
               1
               1      IVAL = IVAL + 1;
               1      NUM_NREGHI = IVAL;
               1      VALUES_SOUGHT(IVAL)='STOP REGION';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=0;
               1      VALUE_MAX(IVAL)=NREG;
               1      DEFAULT(IVAL)=1;
               1
               1      "For error checking, get all geomrz inputs"
               1      $GET_INPUTS(NUM_ITERSE,NUM_NREGHI);
               1      ]
               0
               0  IF (DESCRIBE=1 | DESCRIBE=3) [
               1      IVAL = IVAL + 1;
               1      NUM_NPLANLO = IVAL;
               1      VALUES_SOUGHT(IVAL)='START ZSLAB';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=1;
               1      VALUE_MAX(IVAL)=NZ;
               1      DEFAULT(IVAL)=1;
               1
               1      IVAL = IVAL + 1;
               1      NUM_NPLANHI = IVAL;
               1      VALUES_SOUGHT(IVAL)='STOP ZSLAB';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=1;
               1      VALUE_MAX(IVAL)=NZ;
               1      DEFAULT(IVAL)=1;
               1
               1      IVAL = IVAL + 1;
               1      NUM_NRADLO = IVAL;
               1      VALUES_SOUGHT(IVAL)='START RING';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=1;
               1      VALUE_MAX(IVAL)=NR;
               1      DEFAULT(IVAL)=1;
               1
               1      IVAL = IVAL + 1;
               1      NUM_NRADHI = IVAL;
               1      VALUES_SOUGHT(IVAL)='STOP RING';
               1      TYPE(IVAL)=0;
               1      VALUE_MIN(IVAL)=1;
               1      VALUE_MAX(IVAL)=NR;
               1      DEFAULT(IVAL)=1;
               1
               1      "For error checking, get all geomrz inputs"
               1      $GET_INPUTS(NUM_ITERSE,NUM_NRADHI);
               1      ]
               0
               0
               0  "                     ECHO  CYLINDRICAL GEOMETRY INPUT
               0  "*************          **************************
               0  "* CARD CGM1 *
               0  "*************
               0  OUTPUT;(' *** INPUT CARD CGM1 ***');
               0  ITERSE=VALUE(NUM_ITERSE,1);
               0  OUTPUT ITERSE;(' TERSE(0), RAPID(1) OR DETAILED(2) INPUT:',T60,I12/);
               0
               0  "****************************"
               0  "* CARD CGM2A (IF ITERSE=0) *"
               0  "****************************"
               0  IF (ITERSE=0) [ "terse planar input"
               1      OUTPUT;(' *** CARD CGM2A *** (Input groups of slabs) ');
               1      OUTPUT NZ;(' Number of planar slabs: ',T60,I12);
               1      NPLANE=NZ+1;
               1      OUTPUT;(' Geometrical Z-plane coordinates:');
               1      OUTPUT (ZPLANE(I),I=1,NZ+1);(6F10.4);
               1      $SKIP-LINE;
               1      ]
               0
               0  "****************************"
               0  "* CARD CGM2B (IF ITERSE=1) *"
               0  "****************************"
               0  IF (ITERSE=1) [ "Verbose input"
               1      OUTPUT;(' *** INPUT CARD CGM2B *** (DETAILED INPUT)');
               1      DO I=1, NZ [ZPLANE(I+1)=VALUE(NUM_ZPLANES,I);]
               1      OUTPUT NZ;(' NUMBER OF PLANAR SLABS: ',T60,I12);
               1      NPLANE=NZ+1;
               1      OUTPUT;(' GEOMETRICAL Z-PLANE COORDINATES:');
               1      OUTPUT (ZPLANE(I),I=1,NPLANE);(6F10.4);
               1      $SKIP-LINE;
               1      ]
               0
               0  "*************"
               0  "* CARD CGM3 *"
               0  "*************"
               0  OUTPUT;(' *** INPUT CARD CG3 ***');
               0  OUTPUT NR;(' Number of concentric rings: ', T60, I12);
               0  RCYL(0)=0.0;
               0  DO I=1, NR [
               1      RCYL(I)=VALUE(NUM_RCYL,I);
               1      CYRAD2(I)=VALUE(NUM_RCYL,I)**2;
               1      ]
               0  DO I=1, NR [OUTPUT I,RCYL(I);(' Ring radius #',I2,':',T60,F10.4,' cm');]
               0
               0
               0  "                            ECHO MATERIAL INPUT"
               0  "***********                 *******************"
               0  "* CARD M1 *"
               0  "***********"
               0  OUTPUT;(/' *** INPUT CARD M1 ***');
               0  OUTPUT $MXMED, NMED;(' Number of media(<=',I3,'):',T60,I12/);
               0  IF (NMED > $MXMED ) [
               1      OUTPUT; (' ************************ERROR************************');
               1      OUTPUT; (' Number of media exceeds $MXMED - increase value and recompile');
               1      OUTPUT; (' ************************ERROR************************'//);
               1      WRITE(ERR,'('' Asked for'',I3,'' media and $MXMED is'',I3//)') NMED, $MXMED;
               1      ERROR_FLAG = 1;
               1      ]
               0
               0  "***********"
               0  "* CARD M2 *"
               0  "***********"
               0  OUTPUT;(' *** INPUT CARD M2 ***');
               0  DO I=1,NMED [
               1      SLENGHT=lnblnk1(CHAR_VALUE(NUM_MEDIA,I));
               1      READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLENGHT);
               1      IF (SLENGHT<24) [DO J=SLENGHT+1, 24 [MEDIA(J,I)=' ';]]
               1      OUTPUT I,(MEDIA(J,I),J=1,24);(' MEDIUM #',I1,':',T55,24A1);
               1      ]
               0  "***********"
               0  "* CARD M3 *"
               0  "***********"
               0  OUTPUT;(/' *** INPUT CARD M3 ***');
               0  MED(1)=0;
               0  DO I=2,NREG [MED(I)=1;]  "defaults"
               0  OUTPUT NREG;(/' # of geometrical zones = ',T60,I12);
               0  WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)';
               0
               0  IF (DESCRIBE=0 | DESCRIBE=2) [
               1      IF ((NVALUE(NUM_NREGLO)~=NVALUE(NUM_MEDNUM))|
               1      (NVALUE(NUM_NREGHI)~=NVALUE(NUM_MEDNUM))) [
               2          WRITE(ERR,*)'**************ERROR**************';
               2          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES';
               2          WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES';
               2          WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES';
               2          WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALUES';
               2          ERROR_FLAG=1;
               2          ]
               1      "The DEC compiled executable fails here bacause it tries to access"
               1      "NVALUE(NUM_RHOR) even if describe is not 2, but then NUM_RHOR is not set"
               1      "=>segmentation fault"
               1      "IF(DESCRIBE=2 & NVALUE(NUM_RHOR)~=NVALUE(NUM_MEDNUM))["
               1      IF( DESCRIBE = 2 ) [
               2          IF( NVALUE(NUM_RHOR)~=NVALUE(NUM_MEDNUM)) [
               3              WRITE(ERR,*)'**************ERROR**************';
               3              WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES';
               3              WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES';
               3              WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VALUES';
               3              ERROR_FLAG=1;
               3              ]
               2          ]
               1      "In the following, we allow for vacuum input"
               1      IF (VALUE(NUM_MEDNUM,1) >= 0) [
               2          DO I=1, NVALUE(NUM_MEDNUM) [
               3              RHORI=0.0;
               3              MEDNUM=VALUE(NUM_MEDNUM,I);
               3              IF(DESCRIBE=2) RHORI=VALUE(NUM_RHOR,I);
               3              NREGLO=VALUE(NUM_NREGLO,I);
               3              NREGHI=VALUE(NUM_NREGHI,I);
               3              IF (NREGHI<=NREGLO) [
               4                  IF( NREGLO > 0 & NREGLO <= $MXREG ) [
               5                      MED(NREGLO)=MEDNUM;
               5                      IF(RHORI>0.0) RHOR(NREGLO)=RHORI;
               5                      IF(DESCRIBE=2)[
               6                          IF(RHORI>0.0)[
               7                              OUTPUT NREGLO,MEDNUM,RHORI;
               7                              (' REGION(',I3,') = MATERIAL(',I2,'), RHOR =',F8.5);
               7                              ]
               6                          ELSE[
               7                              OUTPUT NREGLO,MEDNUM;
               7                              (' REGION(',I3,') = MATERIAL(',I2,'), RHOR = DEFAULT');
               7                              ]
               6                          ]
               5                      ELSE[
               6                          OUTPUT NREGLO,MEDNUM;
               6                          (' REGION(',I3,') = MATERIAL(',I2,')');
               6                          ]
               5                      ]
               4                  ]
               3              ELSE [
               4                  DO K=NREGLO,NREGHI [
               5                      IF( K > 0 & K <= $MXREG ) [
               6                          MED(K)=MEDNUM;
               6                          IF(RHORI>0.0) RHOR(K)=RHORI;
               6                          ]
               5                      ]
               4                  IF(DESCRIBE=2)[
               5                      IF(RHORI>0.0)[
               6                          OUTPUT NREGLO,NREGHI,MEDNUM,RHORI;
               6                          (' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I2,'), RHOR =',F8.5);
               6                          ]
               5                      ELSE[
               6                          OUTPUT NREGLO,NREGHI,MEDNUM;
               6                          (' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I2,'), RHOR = DEFAULT');
               6                          ]
               5                      ]
               4                  ELSE[
               5                      OUTPUT NREGLO,NREGHI,MEDNUM;
               5                      (' REGION(',I3,') TO REGION(',I3,') = MATERIAL(',I2,')');
               5                      ]
               4                  ]
               3              ] "end do I"
               2          ] "end IF ~=0"
               1      ] "end if describe=0,2"
               0
               0  IF (DESCRIBE=1 | DESCRIBE=3) [
               1      IF ((NVALUE(NUM_NPLANLO)~=NVALUE(NUM_MEDNUM))|
               1      (NVALUE(NUM_NPLANLO)~=NVALUE(NUM_MEDNUM))|
               1      (NVALUE(NUM_NRADLO)~=NVALUE(NUM_MEDNUM))|
               1      (NVALUE(NUM_NRADHI)~=NVALUE(NUM_MEDNUM))) [
               2          WRITE(ERR,*)'**************ERROR**************';
               2          WRITE(ERR,*)'MEDNUM has      ',NVALUE(NUM_MEDNUM),' values';
               2          WRITE(ERR,*)'START PLANE has ',NVALUE(NUM_NPLANLO),' values';
               2          WRITE(ERR,*)'STOP PLANE has  ',NVALUE(NUM_NPLANHI),' values';
               2          WRITE(ERR,*)'START RING has  ',NVALUE(NUM_NRADLO),' values';
               2          WRITE(ERR,*)'STOP RING has   ',NVALUE(NUM_NRADHI),' values';
               2          WRITE(ERR,*)'>>>> They must all have the same number of values';
               2          ERROR_FLAG=1;
               2          ]
               1      IF(DESCRIBE=3 & NVALUE(NUM_RHOR)~=NVALUE(NUM_MEDNUM))[
               2          WRITE(ERR,*)'**************ERROR**************';
               2          WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES';
               2          WRITE(ERR,*)'RHOR HAS        ',NVALUE(NUM_RHOR),' VALUES';
               2          WRITE(ERR,*)'>>>> THEY MUST BOTH HAVE THE SAME NUMBER OF VALUES';
               2          ERROR_FLAG=1;
               2          ]
               1      IF (VALUE(NUM_MEDNUM,1) >= 0) [
               2          DO I=1, NVALUE(NUM_MEDNUM) [
               3              RHORI=0.0;
               3              MEDNUM=VALUE(NUM_MEDNUM,I);
               3              IF(DESCRIBE=3) RHORI=VALUE(NUM_RHOR,I);
               3              NZLO=VALUE(NUM_NPLANLO,I);
               3              NZHI=VALUE(NUM_NPLANHI,I);
               3              NRLO=VALUE(NUM_NRADLO,I);
               3              NRHI=VALUE(NUM_NRADHI,I);
               3              IF (NZLO>NZHI) [NZHI=NZLO;]
               3              IF (NRLO>NRHI) [NRHI=NRLO;]
               3              DO IZ= NZLO, NZHI [
               4                  DO IX= NRLO, NRHI [
               5                      REGNUM=IZ+NZ*(IX-1)+1;
               5                      IF( regnum > 0 & regnum <= $MXREG ) [
               6                          MED(REGNUM)=MEDNUM;
               6                          IF(RHORI>0.0) RHOR(REGNUM)=RHORI;
               6                          IF(DESCRIBE=3)[
               7                              IF(RHORI>0.0)[
               8                                  OUTPUT IZ,IX,MEDNUM,RHORI;
               8                                  (' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(',I2,') RHOR =',F8.5);
               8                                  ]
               7                              ELSE[
               8                                  OUTPUT IZ,IX,MEDNUM;
               8                                  (' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(',I2,') RHOR = DEFAULT');
               8                                  ]
               7                              ]
               6                          ELSE[
               7                              OUTPUT IZ,IX,MEDNUM;
               7                              (' ZPLANE(',I3,'),RADIUS(',I3,') = MATERIAL(',I2,')');
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              ] "end do I"
               2          ] "end IF ~=0"
               1      ] "end if describe=1,3"
               0
               0  $SKIP-LINE;
               0
               0  RETURN; "end of input portion of subroutine"
               0
               0  ENTRY GEOMRZ_ISUMRY(IOUT); "output regions where density is not default to"
               0  "the .egslst file"
               0  IF(DESCRIBE=2|DESCRIBE=3)[
               1
               1      WRITE(IOUT,100);
               1      RHORI=0.0;
               1      DO I=2,NREG[ "loop through the geometrical regions"
               2          IF(RHORI>0.0 & (RHOR(I)~=RHORI | MED(I)~=MED(I-1)))[
               3              NREGHI=I-1;
               3              WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI;
               3              RHORI=0.0;
               3              ]
               2          IF(RHOR(I)>0.0 & RHOR(I)~=RHO(MED(I)) & RHORI=0.0)[
               3              NREGLO=I;
               3              RHORI=RHOR(I);
               3              ]
               2          IF(I=NREG & RHORI>0.0)["needed if ir=NREG has non-default density"
               3              NREGHI=I;
               3              WRITE(IOUT,200)NREGLO,NREGHI,MED(NREGLO),RHORI;
               3              ]
               2          ]
               1      ]
               0
               0  100 FORMAT(/' ',T25,'NON-DEFAULT DENSITIES'//
               0  ' ',T10,'    Region #         Medium             Rhor  '/
               0  ' ',T10,'from        to          #             (g/cm**3)'/);
               0  200 FORMAT(' ',T10,I3,2I11,F20.5);
               0
               0  RETURN;
               0
               0  END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parameter input functions                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Aaron Merovitz, 1998                                      "
               0  "                   Dave Rogers, 1998                                         "
               0  "                   Iwan Kawrakow, 1998                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
               0  "                                                                             "
               0  "  - Input values taken only if between specified delimiters (prior this      "
               0  "    change, the first VALUES_SOUGHT found was taken, even if it was not      "
               0  "    between the specified delimiters).                                       "
               0  "                                                                             "
               0  "  - Changed argument list to a common block GetInput defined in egs4.macros  "
               0  "    to avoid memory use explosion.                                           "
               0  "                                                                             "
               0  "  - Eliminated initial loop checking for presence of values sought as it is  "
               0  "    not necessary.                                                           "
               0  "                                                                             "
               0  "  - Introduced macros for handling strings (skipping blanks and comments,    "
               0  "    changing to upper case, etc.)                                            "
               0  "                                                                             "
               0  "  - Eliminated string input bug: strings were always converted to upper case "
               0  "                                                                             "
               0  "  - Changed definition of strings to character*$MACRO where $MACRO has a     "
               0  "    certain value that can be be defined in the user code if longer strings  "
               0  "    are required.                                                            "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
               0  "                                                                             "
               0  "  - Missing or misspelled end delimiter together with a missing value sought  "
               0  "    caused the routine to terminate. It now prints an error message and      "
               0  "    continues to look for additional input.                                  "
               0  "                                                                             "
               0  "  - Introduced an array ERROR_FLAGS where the input status of each of the    "
               0  "    attempted inputs is stored.                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT;
               0  "                                                                           "
               0  "                                                                           "
               0  " FUNCTION: Extracts the requested values_sought from input file and        "
               0  "           returns it to the caller.                                       "
               0  "                                                                           "
               0  " USAGE   :      Inputs must have the general form:                         "
               0  "              ***************************************                      "
               0  "              * Value_sought=  Value(s)             *                      "
               0  "              ***************************************                      "
               0  "         e.g.:        MEDNUM= 0, 1, 2                                      "
               0  "                      MEDIA= AIR700ICRU                                    "
               0  "                      RAYLEIGH SCATTERING= on                              "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "
               0  "   Inputs are all in the format: name of value_sought= value
               0  "   where the name of value_sought must match that expected by the
               0  "   program and the = sign must have no blanks between it and value_sought.
               0  "
               0  "   The value_sought must be the first thing on a line but blanks are
               0  "     allowed before it.
               0  "
               0  "   Various inputs are only sought between certain delimeter strings
               0  "     which are defined below (eg :start I/O control: :stop I/O control:)
               0  "     If not specified, the whole file is searched for a requested value_sought.
               0  "     Delimeter strings are enclosed by colons.
               0  "     Note that within delimeter strings, order of inputs does not matter.
               0  "
               0  "   If a requested quantity is not found, this is noted in $input.errors
               0  "     and this file is printed at the end of the log file.
               0  "
               0  "   A semi-colon implies the end of input for this quantity but is
               0  "     not mandatory.  However, this means they cannot be used in titles.
               0  "   A # sign indicated everything else on the line is a comment (and
               0  "     cannot be used in titles.
               0  "   Case is not important in the names of the quantites.
               0  "
               0  "   Commas separate multiple values for a given quantity and a comma
               0  "     at the end of a line implies there is more input on the next line.
               0  "   Values can extend over as many lines as needed. Use commas to imply
               0  "     there are more values on the next line.
               0  "
               0  "   Blank lines and blanks in general are ignored.
               0  "
               0  "   The maximum record length is 256 characters.
               0  "
               0  "
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  "                                                                           "
               0  "                                                                           "
               0  " FEATURES: If the amount of values needed for a particular values_sought   "
               0  "           is known and passed throught NVALUE(I), the subroutine will     "
               0  "           check that the number of inputs correspond.  Otherwise,         "
               0  "           NVALUE(I) will return the # of inputs found.                    "
               0  "                                                                           "
               0  "           For any integer or real (TYPE=0 or 1), get_inputs will check    "
               0  "           that the numerical value input is between VALUE_MIN and         "
               0  "           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
               0  "                                                                           "
               0  "           Writing in the input file can be upper case or lower case.      "
               0  "           However, all FORTRAN >MUST< be programmed in upper case.        "
               0  "              Changed the above: Can now be upper or lower case            "
               0  "                                 IK, Dec. 1998                             "
               0  "                                                                           "
               0  "           For clarity, inputs can be terminated with a semicolon(;).      "
               0  "           This is by no means necessary.                                  "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "                                                                           "
               0  "                   **** DECLARE YOUR INPUTS ****                           "
               0  "                                                                           "
               0  "    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
               0  "                                                                           "
               0  "  I=I+1;                              <--index counter                     "
               0  "  NUM_DRMIN=I;                        <--named pointer to the index num.   "
               0  "  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
               0  "  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
               0  "  TYPE(I)=0;                          <--Type (0-3)                        "
               0  "  VALUE_MIN(I)=0;                     <--Minimum value                     "
               0  "  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
               0  "  DEFAULT(I)=0;                       <--Default value                     "
               0  "                                                                           "
               0  "    CHARACTER INPUTS (TYPE 2)                                              "
               0  "                                                                           "
               0  "  I=I+1;
               0  "  NUM_TITLE=I;
               0  "  VALUES_SOUGHT(I)='TITLE';
               0  "  TYPE(I)=2;
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "
               0  "    ALLOWED INPTUS (TYPE 3)
               0  "
               0  "  I=I+1;
               0  "  NUM_IWATCH=I;
               0  "  VALUES_SOUGHT(I)='IWATCH';
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "  TYPE(I)=3;
               0  "  ALLOWED_INPUTS(I,0)='OFF';
               0  "  ALLOWED_INPUTS(I,1)='INTERACTIONS';
               0  "  ALLOWED_INPUTS(I,2)='STEPS';
               0  "  ALLOWED_INPUTS(I,3)='DEPOSITED';
               0  "  ALLOWED_INPUTS(I,4)='GRAPH';
               0  "                                                                           "
               0  "                      **** STATE THE DELIMETER ****                        "
               0  "                                                                           "
               0  "            DELIMETER='TRANSPORT CONTROL'                                  "
               0  "     OR     DELIMETER='NONE';                                              "
               0  "                                                                           "
               0  "  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
               0  "                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
               0  "                                                                           "
               0  "   The inputs are returned through CHAR_VALUE for character inputs         "
               0  "   or VALUE for integers, reals and allowed inputs                         "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0
               0
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING256 TEXTPIECE;  "Used to read a piece of TEXT                 "
               0  CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  UNITNUM=i_input; "inputfile.egs4inp"
               0  DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);   "Rewind the input file"
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIMETER = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIMETER~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A256)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  "the following is no longer used so comment it out"
               0  ":GI1002:
               0  "      WRITE (ERR,*) '***************ERROR***************';
               0  "      IF (CHECK=100) [
               0  "         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               0  "         WRITE (ERR,*) 'WAS NOT FOUND';
               0  "      ]
               0  "      ELSE [
               0  "         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               0  "                       '<<',' NOT FOUND';
               0  "      ]
               0  "      WRITE (ERR,*) 'END OF FILE REACHED';
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0
               0
1              0  %E   "get_inputs.mortran"
               0  "*****************************************************************************
               0  "
               0  subroutine get_transport_parameter(ounit);
               0  "
               0  " is provided for use with the EGSnrc system. It reads all physics
               0  " related parameters from the input file using the get_input routine.
               0  " For a description for the format/conventions used in get_input,
               0  " see the description at the beginning of this file.
               0  " In order to use this routine, include transportp.macros BEFORE
               0  " get_inputs.mortran via the configuration file.
               0  " If the routine is called with ounit > 0, the transport parameter
               0  " settings will be printid on unit ounit.
               0  "
               0  " Version 0.1           Iwan Kawrakow, January 1999
               0  "
               0  "******************************************************************************
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  You can change this by including the statement
               0  "
               0  "  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
               0  "
               0  "  in your input file.
               0  "
               0  "  Currently, the following options are available (case does not matter and
               0  "             the internal variables are shown in [ ] brackets):
               0  "
               0  "       Global ECUT=     Global (in all regions) electron transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Global (in all regions) photon transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions
               0  "                        will be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%).
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        difference even in `well conditioned' situations
               0  "                        (e.g. depth dose curves for RTP energy range
               0  "                        electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If KM, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, NRC default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but significant in the keV energy range. If NRC is
               0  "                        selected, the NRC brems cross-section data base will
               0  "                        be used, which is a version of the NIST data base
               0  "                        with corrected electron-electron brems contributions
               0  "                        (corrections to the NIST data is typically only
               0  "                        significant for low values of the atomic number Z
               0  "                        and for k/T < 0.005).
               0  "       Triplet production= On or Off (default).  Turns on/off simulation
               0  "                        of triplet production.  If On, then Borsellino's
               0  "                        first Born approximation is used to sample triplet
               0  "                        events based on the triplet cross-section data.
               0  "                        [ itriplet ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej (default)
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impulse approximation.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to use for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Radiative Compton corrections= On or Off (default). If on, then
               0  "                        include radiative corrections for Compton scattering.
               0  "                        Equations are based on original Brown & Feynman
               0  "                        equations (Phys. Rev. 85, p 231--1952).  Requires
               0  "                        a change to the user codes Makefile to include
               0  "                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
               0  "                        SOURCES (just before
               0  "                        $(EGS_SOURCEDIR)get_inputs.mortran).
               0  "                        [ radc_flag ]
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski, penelope.  If set to On or ik, then use
               0  "                        Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then
               0  "                        use the cross-sections of Casnati (contained in the
               0  "                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
               0  "                        kolbenstvedt, gryzinski and penelope. This is only of
               0  "                        interest in kV X-ray calculations.
               0  "                        Case-sensitive except for Off, On or ik options.
               0  "                        [ eii_flag ]
               0  "       Pair angular sampling= Off, Simple, KM.
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.  Uniform
               0  "                        Default is Simple, make sure you always use
               0  "                        Simple or KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel), epdl (Evaluated Photon Data
               0  "                        Library), xcom (the default), pegs4, mcdf-xcom and
               0  "                        mcdf-epdl:
               0  "                        Allows the use of photon cross-sections other than
               0  "                        from the PEGS4 file (unless the pegs4 option is
               0  "                        specified).  Options mcdf-xcom and mcdf-epdl use
               0  "                        Sabbatucci and Salvat's renormalized photoelectric
               0  "                        cross sections with either xcom or epdl for all other
               0  "                        cross sections.  These are more accurate but can
               0  "                        increase CPU time by up to 6 %.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turn on coherent (Rayleigh) scattering.
               0  "                        Default is On. Should be turned on for low energy
               0  "                        applications.
               0  "                        If custom, user must provide media names and form
               0  "                        factor files for each desired medium. For the rest
               0  "                        of the media, default atomic FF are used.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "Ali:photonuc, 2 blocks of comments"
               0  "       Photonuclear attenuation= Off (default) or On
               0  "                        If On, models the photonuclear effect. Current
               0  "                        implementation is crude. Available on a
               0  "                        region-by-region basis (see below)
               0  "                        [ IPHOTONUCR ]
               0  "       Photonuclear cross sections= Total photonuclear cross sections. User-
               0  "                        supplied total photonuclear cross-sections in
               0  "                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
               0  "                        where photonuc_xsections is the name supplied for
               0  "                        this input (case sensitive). In the absence of
               0  "                        any user-supplied data, or if photonuc_xsections
               0  "                        is set to 'default', the default file is
               0  "                        iaea_photonuc.data.
               0  "                        [ photonuc_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is On
               0  "                        [ IPHTER ]
               0  "       Atomic relaxations= Off, On, eadl, simple
               0  "                        Default is eadl.  On defaults to eadl.
               0  "                        When simulating atomic relaxations:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross sections
               0  "                        - Shell vacancies created in photoelectric,
               0  "                          compton and electron impact ionization events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         The eadl option features a more accurate treatment
               0  "                         of relaxation events and uses binding energies
               0  "                         consistent with those in of the photon cross sections
               0  "                         used in the simulation.  If using mcdf-xcom or
               0  "                         mcdf-epdl photon cross sections, you cannot use
               0  "                         the simple option and this will automatically get
               0  "                         reset to eadl.
               0  "                         Make sure to use eadl or simple for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "       and photonuclear effect(Ali:photonuc)
               0  "       can also be turned On/Off on a region-by-region
               0  "       basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "                or                  Ali:photonuc
               0  "       Photonuclear start region=
               0  "       Photonuclear stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0
               0  implicit none;  "Hard coded to catch possible user replacements of the "
               0  "following common blocks"
               0
               0  character*80 line;
               0  character*512 toUpper;
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0
               0  $INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
               0  num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
               0  num_ffmed,num_ffiles,
               0  num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
               0  num_pxsec,num_pxsec_out, num_cxsec,
               0  num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
               0  num_efield, num_bfield, num_emlmt,"EMH: EM fields"
               0  num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
               0  egs_open_file,lnblnk1;
               0
               0  $LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"
               0
               0  character*15 output_strings(14);"Ali:photonuc, increased by 1"
               0  save         output_strings,line;
               0  save         ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions,
               0  num_photonuc;"Ali:photonuc"
               0
               0
               0  DO k=1,80 [ line(k:k) = '='; ]
               0  delimeter = $THE_DELIMETER;
               0  ival = 0;
               0
               0  ;
               0  /ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,
               0  "Ali:photonuc, 1 line"
               0  photonuc_inregions/ = .false.;
               0
               0  "open a .errors file exclusively for output from this subroutine"
               0  i_errors=15;
               0  i_errors=egs_open_file(i_errors,0,1,'.errors');
               0
               0  write(i_errors,*)
               0  ' If you are not trying to reset transport parameters, ';
               0  write(i_errors,*)
               0  ' ignore all the output until the message ';
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  " ECUT "
               0  ival                = ival + 1;
               0  num_ecut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-ECUT;
               0
               0  " PCUT "
               0  ival                = ival + 1;
               0  num_pcut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-PCUT;
               0
               0  " SMAX "
               0  ival                = ival + 1;
               0  num_smax            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_SMAX;             "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $MAX-SMAX;
               0
               0  " Incoherent (Compton) scattering "
               0  ival                = ival + 1;
               0  num_incoh           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'Simple';
               0  allowed_inputs(ival,5) = 'norej';
               0
               0  " Radiative corrections for Compton scattering "
               0  ival                = ival + 1;
               0  num_radc            = ival;
               0  values_sought(ival) = $RADC_COMPTON;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Coherent (Rayleigh) scattering "
               0  ival                = ival + 1;
               0  num_coh             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'custom';
               0
               0  " Atomic Relaxations "
               0  ival                = ival + 1;
               0  num_relax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'eadl';
               0  allowed_inputs(ival,5) = 'simple';
               0
               0  " Photoelectron angular sampling "
               0  ival                = ival + 1;
               0  num_pe_ang          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Bremsstrahlung angular sampling "
               0  ival                = ival + 1;
               0  num_brems_ang       = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Simple';
               0  allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0
               0  " Bremsstrahlung cross sections "
               0  ival                = ival + 1;
               0  num_brems_cs        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
               0  allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"
               0
               0
               0  " Pair angular sampling "
               0  ival                = ival + 1;
               0  num_pair_ang        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
               0  allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0  allowed_inputs(ival,3) = 'Uniform';
               0  allowed_inputs(ival,4) = 'Blend';
               0
               0  " Pair cross sections "
               0  ival                = ival + 1;
               0  num_pair_cs         = ival;
               0  values_sought(ival) = $PAIR_CROSS_SECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NRC';
               0
               0  " Triplet production "
               0  ival                = ival + 1;
               0  num_triplet         = ival;
               0  values_sought(ival) = $TRIPLET_PRODUCTION;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Spin effects          "
               0  ival                = ival + 1;
               0  num_spin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SPIN_EFFECTS;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';                 "Only global on/off available"
               0
               0  " Electron impact ionization "
               0  ival                = ival + 1;
               0  num_eii             = ival;
               0  values_sought(ival) = $ELECTRON_IMPACT_IONI;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0  "type(ival)          = 3;"
               0  "allowed_inputs(ival,0) = 'Off';"
               0  "allowed_inputs(ival,1) = 'On';"
               0  "allowed_inputs(ival,2) = 'casnati';"
               0  "allowed_inputs(ival,3) = 'kolbenstvedt';"
               0  "allowed_inputs(ival,4) = 'gryzinski';"
               0
               0  " L-shell EII xsection scaling"
               0  ival                = ival + 1;
               0  num_eii_L= ival;                                "Set the variable pointer"
               0  values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0e+9;
               0  default(ival)       = 1.0;
               0
               0  " ESTEPE "
               0  ival                = ival + 1;
               0  num_estepe          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 1e-5;                     "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $MAX-ELOSS;
               0
               0  " XIMAX "
               0  ival                = ival + 1;
               0  num_ximax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $EXACT-BCA-XIMAX;
               0
               0  " BCA "
               0  ival                = ival + 1;
               0  num_bca             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Exact';
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Skindepth "
               0  ival                = ival + 1;
               0  num_skin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1;                       "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $SKIN-DEPTH-FOR-BCA;
               0
               0  " Electron-step algorithm "
               0  ival                = ival + 1;
               0  num_alg             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Photon cross sections "
               0  ival                = ival + 1;
               0  num_pxsec           = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " Photon cross sections output "
               0  ival                = ival + 1;
               0  num_pxsec_out       = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS_OUT;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Compton cross sections "
               0  ival                = ival + 1;
               0  num_cxsec           = ival;
               0  values_sought(ival) = $COMPTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " E-Field "
               0  ival                = ival + 1;
               0  num_efield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $E_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e15;                    "Define the allowed range"
               0  value_max(ival)     =  1e15;
               0  default(ival)       =  0;
               0
               0  " B-Field "
               0  ival                = ival + 1;
               0  num_bfield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $B_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e10;                    "Define the allowed range"
               0  value_max(ival)     =  1e10;
               0  default(ival)       =  0;
               0
               0  " EM-field step and eloss restriction "
               0  ival                = ival + 1;
               0  num_emlmt           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $EM_LMT;                 "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0;
               0  default(ival)       = 0.02;
               0
               0  "Ali:photonuc, 2 blocks"
               0  " Photonuclear "
               0  ival                = ival + 1;
               0  num_photonuc        = ival;           "set the variable pointer"
               0  values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
               0  nvalue(ival)        = 1;              "1 input"
               0  type(ival)          = 3;              "an `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Photonuclear cross sections "
               0  ival                = ival + 1;
               0  num_photonuc_xsec   = ival;
               0  values_sought(ival) = $PHOTONUC_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  "Ali:photonuc, 1 line"
               0  Nmin = num_ecut; Nmax = num_photonuc_xsec;
               0  "Nmin = num_ecut; Nmax = num_cxsec;"
               0
               0  CALL GET_INPUT;
               0
               0  IF( error_flags(num_ecut) = 0 ) [
               1      DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
               1      ]
               0  IF( error_flags(num_pcut) = 0 ) [
               1      DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
               1      ]
               0  IF( error_flags(num_smax) = 0 ) [
               1      DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
               1      ]
               0  IF( error_flags(num_brems_ang) = 0 ) [
               1      ibrdst = value(num_brems_ang,1);
               1      ]
               0  IF( error_flags(num_brems_cs) = 0 ) [
               1      ibr_nist = value(num_brems_cs,1);
               1      ]
               0  IF( error_flags(num_radc) = 0 ) [
               1      radc_flag = value(num_radc,1);
               1      ]
               0  IF( error_flags(num_pair_ang) = 0 ) [
               1      iprdst = value(num_pair_ang,1);
               1      ]
               0  IF( error_flags(num_pair_cs) = 0 ) [
               1      pair_nrc = value(num_pair_cs,1);
               1      ]
               0  IF( error_flags(num_triplet) = 0 ) [
               1      itriplet = value(num_triplet,1);
               1      ]
               0  IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
               0  IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
               0  IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
               0  IF( error_flags(num_bca) = 0 ) [
               1      bca_algorithm = value(num_bca,1);
               1      IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               1      ]
               0  IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
               0  IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
               0  IF( error_flags(num_spin) = 0 ) [
               1      itmp = value(num_spin,1);
               1      IF( itmp = 1 ) [ spin_effects = .true.; ]
               1      ELSE           [ spin_effects = .false.; ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_eii) = 0 ) [
               1      eii_xfile = char_value(num_eii,1);eii_flag=1;
               1      IF (toUpper($cstring(eii_xfile)).eq.'ON' |
               1      toUpper($cstring(eii_xfile)).eq.'IK' )[
               2          eii_xfile = 'ik';
               2          $egs_info(*,'==> Using default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
               2          eii_xfile='Off';eii_flag=0;
               2          ]
               1      ELSE["Using non-default EII data compilation"
               2          $egs_warning(*,'==> Using non-default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_pxsec) = 0 ) [
               1      photon_xsections = char_value(num_pxsec,1);
               1      IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
               2          ]
               1      ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
               2          ]
               1      ELSE[
               2          mcdf_pe_xsections = .false.;
               2          ]
               1      ]
               0
               0  IF( error_flags(num_pxsec_out) = 0 ) [
               1      xsec_out = value(num_pxsec_out,1);
               1      ]
               0  IF( error_flags(num_cxsec) = 0 ) [
               1      comp_xsections = char_value(num_cxsec,1);
               1      ]
               0  "Ali:photonuc, 3 lines"
               0  IF( error_flags(num_photonuc_xsec) = 0 ) [
               1      photonuc_xsections = char_value(num_photonuc_xsec,1);
               1      ]
               0
               0  IF( error_flags(num_efield) = 0 ) [
               1      ExIN = value(num_efield,1);
               1      EyIN = value(num_efield,2);
               1      EzIN = value(num_efield,3);
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented only for the C++ applications     "
               0  IF( error_flags(num_bfield) = 0 ) [
               1      BxIN = value(num_bfield,1);
               1      ByIN = value(num_bfield,2);
               1      BzIN = value(num_bfield,3);
               1      Bx=BxIN;By=ByIN;Bz=BzIN;
               1      Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_coh) = 0 ) [
               1      IF(value(num_coh,1) = 4)[
               2          write(*,'(/a/)') ' ===> custom ff requested!';
               2          ival                = ival + 1;
               2          num_ffmed           = ival;
               2          values_sought(ival) = 'ff media names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          ival                = ival + 1;
               2          num_ffiles          = ival;
               2          values_sought(ival) = 'ff file names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          Nmin = num_ffmed; Nmax = num_ffiles;
               2          CALL GET_INPUT;
               2          IF( error_flags(num_ffmed) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffmed));
               3              ]
               2          IF( error_flags(num_ffiles) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffiles));
               3              ]
               2          IF (nvalue(num_ffmed)>$MXMED)[
               3              $egs_fatal('(a,a,i3,a)',
               3              '***** Number of media with custom ff larger ',
               3              'than maximum number of media $MXMED = ',$MXMED,
               3              ' increase $MXMED and try again!!!');
               3              ]
               2          DO i=1,nvalue(num_ffmed) [
               3              iray_ff_media(i) = char_value(num_ffmed,i);
               3              iray_ff_file(i)  = char_value(num_ffiles,i);
               3              ]
               2          value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
               2          ]
               1      write(*,'(/)');
               1      ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $TURN-ON/OFF-IN-REGIONS(num_incoh,
               0  'Bound Compton start region',
               0  'Bound Compton stop region',
               0  ibcmp); incoh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_coh,
               0  'Rayleigh start region',
               0  'Rayleigh stop region',
               0  iraylr); coh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_relax,
               0  'Relaxations start region',
               0  'Relaxations stop region',
               0  iedgfl); relax_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_pe_ang,
               0  'PE sampling start region',
               0  'PE sampling stop region',
               0  iphter); pe_inregions = aux_inregions;
               0  "Ali:photonuc, 1 block"
               0  $TURN-ON/OFF-IN-REGIONS(num_photonuc,
               0  'Photonuclear start region',
               0  'Photonuclear stop region',
               0  iphotonucr); photonuc_inregions = aux_inregions;
               0  $SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
               0  'Set ECUT stop region');
               0  ecut_inregions = aux_inregions;
               0
               0  $SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
               0  'Set PCUT stop region');
               0  pcut_inregions = aux_inregions;
               0
               0  $SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
               0  'Set SMAX stop region');
               0  smax_inregions = aux_inregions;
               0
               0  write(i_errors,*);
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  "Check if EADL relaxation requested. Note that original relaxation"
               0  "algorithm using <M> and <N> is only turned ON for all regions."
               0  "Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
               0  "default case."
               0  IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
               1      eadl_relax = .true.;
               1      "Default relaxation is EADL"
               1      IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
               1      ]
               0  ELSE [
               1      IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
               2          eadl_relax = .true.; value(num_relax,1)=4;
               2          $egs_warning('(a/,a/,a/)',
               2          '    Simplified atomic relaxation not allowed',
               2          '    with shellwise PE cross sections. Resetting',
               2          '    to detailed EADL atomic relaxation!!!');
               2          ]
               1      ELSE [
               2          eadl_relax = .false.;
               2          ]
               1      ]
               0
               0  " we put the information stored in allowed_inputs into "
               0  " output_strings just in case the user over-rides it "
               0  " before printing out the settings "
               0
               0  output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
               0  itmp = value(num_incoh,1);
               0  output_strings(2) = allowed_inputs(num_incoh,itmp);
               0  $RADC_WARNING;
               0  output_strings(12) = allowed_inputs(num_radc,radc_flag);
               0  itmp = value(num_coh,1);
               0  output_strings(3) = allowed_inputs(num_coh,itmp);
               0  itmp = value(num_relax,1);
               0  output_strings(4) = allowed_inputs(num_relax,itmp);
               0  itmp = value(num_pe_ang,1);
               0  output_strings(5) = allowed_inputs(num_pe_ang,itmp);
               0  output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
               0  output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
               0  output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
               0  output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
               0  output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
               0  output_strings(11) = allowed_inputs(num_triplet,itriplet);
               0  "output_strings(13) = allowed_inputs(num_eii,eii_flag);"
               0  "Ali:photonuc, 2 lines"
               0  itmp = value(num_photonuc,1);
               0  output_strings(14) = allowed_inputs(num_photonuc,itmp);
               0
               0  entry show_transport_parameter(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0  write(ounit,'(a,/)')
               0  '                   Electron/Photon transport parameter';
               0  write(ounit,'(a,/)') line;
               0
               0
               0  IF (mcdf_pe_xsections)[
               1      write(ounit,'(a,38x,a,a)') ' Photon cross sections',
               1      'mcdf-',$cstring(photon_xsections);
               1      ]
               0  ELSE[
               1      write(ounit,'(a,38x,a)') ' Photon cross sections',
               1      $cstring(photon_xsections);
               1      ]
               0  write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);
               0
               0  write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
               0  IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
               1      ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
               1      ]
               0  write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
               0  write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
               0  write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
               0  write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
               0  write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
               0  write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
               0  write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
               0  write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
               0  "Ali:photonuc, 3 lines. EMH added IF statement"
               0  IF ( value(num_photonuc,1) > 0 )[
               1      write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
               1      write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
               1      $cstring(photonuc_xsections);
               1      ]
               0
               0  write(ounit,*);
               0
               0  write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
               0  IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
               1      ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
               1      ]
               0  write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
               0  write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
               0  IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
               0  ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
               0  write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
               0  IF (eii_L_factor ~= 1.0) [
               1      write(ounit,'(a,25x,f6.4)')
               1      ' L-shell EII xsections scaling factor',eii_L_factor;
               1      ]
               0  write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
               0  IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
               1      ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
               1      ]
               0  write(ounit,'(a,16x,f6.4)')
               0  ' Maximum fractional energy loss/step (ESTEPE)',estepe;
               0  write(ounit,'(a,21x,f6.4)')
               0  ' Maximum 1st elastic moment/step (XIMAX)',ximax;
               0  write(ounit,'(a,33x,a10)')
               0  ' Boundary crossing algorithm',output_strings(7);
               0  write(ounit,'(a,22x,g9.4)')
               0  ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
               0  write(ounit,'(a,37x,a10)')
               0  ' Electron-step algorithm',output_strings(8);
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
               1      write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
               1      ExIN,EyIN,EzIN;
               1      ]
               0  IF( Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
               1      Bx,By,Bz;
               1      ]
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
               0  Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
               1      ]
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0
               0  return;
               0  end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine set_elastic_parameter;
               0
               0  implicit none;
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0  ;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
               0  $INTEGER imed,ival,lnblnk1,nchanged;
               0  character*24 medname;
               0
               0  ounit = i_log;
               0  ounit = i_log;
               0  delimeter = $THE_DELIMETER;
               0  call get_input_set_error_level(0);
               0  ival = 0;
               0  DO imed=1,nmed [
               1      call egs_get_medium_name(imed,medname);
               1      ival                = ival + 1;
               1      values_sought(ival) = 'scale elastic scattering in '//
               1      medname(:lnblnk1(medname));
               1      nvalue(ival)        = 1;
               1      type(ival)          = 1;
               1      value_min(ival)     = 1e-3;
               1      value_max(ival)     = 1e3;
               1      default(ival)       = 1;
               1      ]
               0  Nmin = 1; Nmax = nmed;
               0  CALL GET_INPUT;
               0  nchanged = 0;
               0  DO imed=1,nmed [
               1      IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
               1      ]
               0  IF( nchanged > 0 ) [
               1      write(ounit,'(//a)')
               1      '================ Elastic scattering scaled as follows ==================';
               1      DO imed=1,nmed [
               2          IF( error_flags(imed) = 0 ) [
               3              call egs_get_medium_name(imed,medname);
               3              xcc(imed)  = xcc(imed)*value(imed,1);
               3              blcc(imed) = blcc(imed)*value(imed,1);
               3              write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
               3              value(imed,1);
               3              ]
               2          ]
               1      write(ounit,'(a//)')
               1      '========================================================================';
               1      ]
               0  return; end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc media input functions                                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END);
               0  "                                                                           "
               0  " A version of GET_INPUT that allows the user to specify a UNITNUM          "
               0  " other than the .egsinp file and different start and end delimiters.       "
               0  " Note that delimiters are interpreted literally.                           "
               0  " If NONE is supplied as DELIM_END, then EOF is taken as the stop           "
               0  " delimiter.                                                                "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING256 TEXTPIECE; "Used to read a piece of TEXT                  "
               0  CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING80  ENDSTRING;  "string at which to terminate search          "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG,end_string;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  DELIM_START=DELIM_START(:lnblnk1(DELIM_START));
               0  DELIM_END=DELIM_END(:lnblnk1(DELIM_END));
               0  $SKIP LEADING BLANKS IN DELIM_START;
               0  $SKIP LEADING BLANKS IN DELIM_END;
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0  $SKIP LEADING BLANKS IN ENDSTRING;
               0  IF(ENDSTRING=blank)[
               1      end_string=.false.;
               1      ]
               0  ELSE[
               1      $CONVERT ENDSTRING TO UPPER CASE;
               1      end_string=.false.;
               1      ]
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIM_START = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIM_END~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END;
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A256)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_plus_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0  "*****************************************************************************
               0  "
               0  subroutine get_media_inputs(ounit);
               0  "subroutine to take the media names in the input file and get the material
               0  "data, either from a user-specified material data file, from material data
               0  "specified explicitly in the input file, or from a user-specified density
               0  "correction file.  This subroutine is called in HATCH.  It assumes that
               0  "the subroutine get_transport_parameter has already been called and that
               0  "the media names in the simulation have already been read in.
               0
               0  implicit none;
               0
               0  REPLACE{$MAXPOINTS}WITH{300};
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0  COMIN/MEDINP,ELECIN,THRESH,ELEMTB,USEFUL/;
               0
               0  $INTEGER  ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_ap,ival_up,
               0  ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iaprim,ival_gasp,
               0  ival_pz,ival_sterncid,
               0  ival_densityfile,medfile_error,ival_outfile,
               0  egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_mederr,mindex,eindex,
               0  i_density,i01,length,i_outfile;
               0  $REAL ecut_min, pcut_min;
               0
               0  $LOGICAL  medfile_specified,densityfile_specified,elements_specified,
               0  outfile_specified($MXMED);
               0  $LOGICAL  iunrst_specified,stern_specified,iaprim_specified,
               0  gasp_specified,rho_specified,start_delim_found,end_delim_found,
               0  spec_by_pz,spec_by_rhoz,df_if_elem_mismatch($MXMED),
               0  df_if_rho_mismatch($MXMED);
               0  $LOGICAL  ex;
               0
               0  $INTEGER CURSOR,Kconvert;
               0
               0  "maybe we do not need to keep ZTBL REAL4, since it is only used here"
               0  $REAL4 ZTBL;
               0
               0  "variables for output of cross-section data to file for plotting"
               0  "some names end with O to avoid conflict with global variables"
               0  "in common blocks above"
               0  $REAL EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETAB(16),
               0  EIE,PLOTE($MAXPOINTS),PLOTEM($MAXPOINTS),PLOTEEN($MAXPOINTS),
               0  PLOTEMP($MAXPOINTS), PLOTEMS($MAXPOINTS);
               0  $INTEGER IPLOTE,IFLAG1,IFLAG2,LELKE;
               0  CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp,
               0  SUBTITLE,SERIES;
               0  DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9./;
               0
               0
               0  character*24 medium_name,med_tmp,sterncid_tmp;
               0  character*256 density_file,material_file,tmp_string,
               0  spoutput_file($MXMED);
               0  character*80 text_string, text_save, title;
               0  character*80 delim_start,delim_end;
               0  character*1 blank;
               0  character*512 toUpper;
               0
               0  "temporary variables for storing values before committing them"
               0  "to the media library"
               0  $INTEGER nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp;
               0  $REAL rho_tmp,rhoz_tmp($MXEL),z_tmp($MXEL),pz_tmp($MXEL),ae_tmp,ap_tmp,
               0  ue_tmp,up_tmp,gasp_tmp;
               0  $TYPE asym_tmp($MXEL);
               0
               0  "for stuff read from the density correction file"
               0  $INTEGER nepst_df,nne_df;
               0  $REAL iev_df,rho_df,z_df($MXEL),rhoz_df($MXEL),rhoz_tot;
               0  $TYPE asym_df($MXEL);
               0
               0  data blank/' '/;
               0
               0  save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho_mismatch,
               0  spoutput_file,outfile_specified;
               0
               0  REPLACE {$WRITE_MEDERR(#)} WITH {
            {  0  ;
            {  0  IF(n_parallel=0 | i_parallel=first_parallel)[
            {  0  write(i_mederr,*){P1};
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  call get_input_set_error_level(0);
               0  call get_input_plus_set_error_level(0);
               0
               0  "open a file for output from this routine"
               0  IF(n_parallel=0 | i_parallel=first_parallel)[
               1      i_mederr=17;
               1      i_mederr=egs_open_file(i_mederr,0,1,'.mederr');
               1      ]
               0
               0  "find min. ecut and pcut"
               0  ecut_min=999.;
               0  pcut_min=999.;
               0  DO i=1,$MXREG[
               1      IF(ecut(i)<ecut_min)ecut_min=ecut(i);
               1      IF(pcut(i)<pcut_min)pcut_min=pcut(i);
               1      ]
               0
               0  delimeter = 'MEDIA DEFINITION';
               0  ival = 0;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "full name of media data file"
               0  ival                = ival + 1;
               0  ival_medfile         = ival;
               0  values_sought(ival) = 'material data file';    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 2;
               0  Nmin = ival_medfile; Nmax = ival_medfile;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_medfile)=0)[
               1      material_file=char_value(ival_medfile,1);
               1      medfile_specified=.true.;
               1      "try opening it"
               1      i_medfile=17;
               1      i_medfile=egs_get_unit(i_medfile);
               1      IF(i_medfile < 1)[
               2          $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               2          ' medium data file.');
               2          ]
               1      open(i_medfile,file=material_file,status='old',err=:no_media_file:);
               1      medfile_specified=.true.;
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: material data file not supplied.');
               1      $WRITE_MEDERR(' Thus, you must define media explicitly in input file');
               1      $WRITE_MEDERR(' or via density correction file.');
               1      medfile_specified=.false.;
               1      ]
               0
               0  "get AE, UE, AP, UP, if specified"
               0  ival                = ival + 1;
               0  ival_ae = ival;
               0  values_sought(ival) = 'ae';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = ecut_min;
               0
               0  ival                = ival + 1;
               0  ival_ap = ival;
               0  values_sought(ival) = 'ap';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = pcut_min;
               0
               0  ival                = ival + 1;
               0  ival_ue = ival;
               0  values_sought(ival) = 'ue';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50 + prm;
               0
               0  ival                = ival + 1;
               0  ival_up = ival;
               0  values_sought(ival) = 'up';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50.0;
               0
               0  Nmin=ival_ae;Nmax=ival_up;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_ae)=0)[
               1      ae_tmp=value(ival_ae,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AE for media not supplied.  Will use min. ECUT.');
               1      ae_tmp=ecut_min;
               1      ]
               0  IF(error_flags(ival_ap)=0)[
               1      ap_tmp=value(ival_ap,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AP for media not supplied.  Will use min. PCUT.');
               1      ap_tmp=pcut_min;
               1      ]
               0  IF(error_flags(ival_ue)=0)[
               1      ue_tmp=value(ival_ue,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UE for media not supplied.  Will use
            '  1      50.5109989461 MeV');
               1      ue_tmp=50 + prm;
               1      ]
               0  IF(error_flags(ival_up)=0)[
               1      up_tmp=value(ival_up,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UP for media not supplied.  Will use 50.0 MeV');
               1      up_tmp=50.;
               1      ]
               0
               0  IF(ue_tmp<=ae_tmp)[
               1      $WRITE_MEDERR(' Error: UE <= AE.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UE <= AE.  Adjust value(s) and try again.');
               1      ]
               0  IF(up_tmp<=ap_tmp)[
               1      $WRITE_MEDERR(' Error: UP <= AP.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UP <= AP.  Adjust value(s) and try again.');
               1      ]
               0
               0  "now check for individual media inputs in file"
               0  "if not there, get data from material data file"
               0
               0  DO i=1,NMED[
               1
               1      "convert medium name to string for ease of"
               1      "implementation"
               1      DO j=1,24[medium_name(j:j)=media(j,i);]
               1
               1      "set up defaults"
               1      elements_specified=.false.;
               1      rho_specified=.false.;
               1      densityfile_specified=.false.;
               1      stern_specified=.false.;
               1      iunrst_specified=.false.;
               1      iaprim_specified=.false.;
               1      gasp_specified=.false.;
               1      spec_by_rhoz=.false.;
               1      spec_by_pz=.false.;
               1      df_if_elem_mismatch(i)=.false.;
               1      df_if_rho_mismatch(i)=.false.;
               1
               1      sterncid_tmp=medium_name;
               1      gasp_tmp=0.0;
               1      iunrst_tmp=0;
               1      iaprim_tmp=0;
               1      epstfl_tmp=0;
               1      density_file=' ';
               1
               1      $WRITE_MEDERR(' ');
               1
               1      $WRITE_MEDERR(' For medium: ',medium_name);
               1
               1      delimeter=$cstring(medium_name);
               1
               1      ival=0;
               1
               1      "see if composition is specified explicitly"
               1      ival=ival+1;
               1      ival_elements=ival;
               1      values_sought(ival) = 'elements';
               1      type(ival)          = 2;  "i.e.  character input"
               1      nvalue(ival)        = 0;
               1      nmin=ival_elements;nmax=ival_elements;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_elements)=0)[
               2          DO j=1,nvalue(ival_elements)[
               3              $CONVERT char_value(ival_elements,j) TO UPPER CASE;
               3              ]
               2          "now get fraction of each element"
               2          ival=ival+1;
               2          ival_pz=ival;
               2          nne_tmp=nvalue(ival_elements);
               2          values_sought(ival)='number of atoms';
               2          type(ival)=0;
               2          nvalue(ival)=nne_tmp;
               2          nmin=ival_pz;nmax=ival_pz;
               2          CALL GET_INPUT;
               2          IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               3              "got em.  Use em.  But not if this is an element"
               3              DO j=1,nne_tmp[
               4                  asym_tmp(j)=char_value(ival_elements,j);
               4                  pz_tmp(j)=value(ival_pz,j);
               4                  ]
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          ELSE[
               3              "check to see if fractional wts specified"
               3              ival=ival+1;
               3              ival_rhoz=ival;
               3              values_sought(ival)='mass fractions';
               3              type(ival)=1;
               3              nvalue(ival)=nne_tmp;
               3              nmin=ival_rhoz;nmax=ival_rhoz;
               3              IF(nne_tmp=1)[
               4                  "set max, min and default values"
               4                  value_min(ival)=0.0;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=1.;
               4                  ]
               3              CALL GET_INPUT;
               3              IF(error_flags(ival_rhoz)=0)[
               4                  "got em.  Use em."
               4                  DO j=1,nne_tmp[
               5                      asym_tmp(j)=char_value(ival_elements,j);
               5                      rhoz_tmp(j)=value(ival_rhoz,j);
               5                      ]
               4                  elements_specified=.true.;
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          IF(nne_tmp=1 & ~elements_specified)[
               3              "an element: set pz to 1 and use default atomic weight"
               3              asym_tmp(1)=char_value(ival_elements,1);
               3              pz_tmp(1)=1;
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          IF(elements_specified)[
               3              $WRITE_MEDERR(' Composition specified in .egsinp file.');
               3              ]
               2          ]
               1
               1      "see what else is there"
               1      ival=ival+1;
               1      ival_rho=ival;
               1      values_sought(ival) = 'rho';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=1.0;
               1      nmin=ival_rho;nmax=ival_rho;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_rho)=0)[
               2          rho_tmp=value(ival_rho,1);
               2          rho_specified=.true.;
               2          $WRITE_MEDERR(' Rho specified in .egsinp file.');
               2          ]
               1
               1      "now see what else is specified in the .egsinp file"
               1      ival=ival+1;
               1      ival_sterncid=ival;
               1      values_sought(ival)='sterncid';
               1      type(ival)=2;
               1      nvalue(ival)=1;
               1      nmin=ival_sterncid;nmax=ival_sterncid;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_sterncid)=0)[
               2          sterncid_tmp=char_value(ival_sterncid,1);
               2          stern_specified=.true.;
               2          $WRITE_MEDERR(' STERNCID specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iunrst=ival;
               1      values_sought(ival)='stopping powers';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='restricted total';
               1      allowed_inputs(ival,1)='unrestricted collision';
               1      allowed_inputs(ival,2)='unrestricted collision and radiative';
               1      allowed_inputs(ival,3)='unrestricted collision and restricted radiative';
               1      allowed_inputs(ival,4)='restricted collision and unrestricted radiative';
               1      allowed_inputs(ival,5)='unrestricted radiative';
               1      nmin=ival_iunrst;nmax=ival_iunrst;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iunrst)=0)[
               2          iunrst_tmp=value(ival_iunrst,1);
               2          iunrst_specified=.true.;
               2          $WRITE_MEDERR(' IUNRST specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iaprim=ival;
               1      values_sought(ival)='bremsstrahlung correction';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='KM';
               1      allowed_inputs(ival,1)='NRC';
               1      allowed_inputs(ival,2)='none';
               1      nmin=ival_iaprim;nmax=ival_iaprim;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iaprim)=0)[
               2          iaprim_tmp=value(ival_iaprim,1);
               2          iaprim_specified=.true.;
               2          $WRITE_MEDERR(' IAPRIM specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_gasp=ival;
               1      values_sought(ival)='gas pressure';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=0.0;
               1      nmin=ival_gasp;nmax=ival_gasp;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_gasp)=0)[
               2          gasp_tmp=value(ival_gasp,1);
               2          gasp_specified=.true.;
               2          $WRITE_MEDERR(' GASP specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_densityfile=ival;
               1      values_sought(ival)='density correction file';
               1      type(ival)          = 2;
               1      nvalue(ival)=1;
               1      nmin=ival_densityfile;nmax=ival_densityfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_densityfile)=0)[
               2          density_file=char_value(ival_densityfile,1);
               2          densityfile_specified=.true.;
               2          "may get changed to false later if it cannot be opened"
               2          $WRITE_MEDERR(' Density correction file specified in .egsinp file.');
               2          ]
               1
               1      "check if the user has specified an output file for plotting"
               1      "e- data."
               1      ival = ival+1;
               1      ival_outfile = ival;
               1      values_sought(ival) = 'e- stopping power output file';
               1      type(ival) = 2;
               1      nvalue(ival) =1;
               1      nmin=ival_outfile;nmax=ival_outfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_outfile)=0)[
               2          spoutput_file(i)=char_value(ival_outfile,1);
               2          outfile_specified(i)=.true.;
               2          $WRITE_MEDERR(' e- stopping powers will be output to ',
               2          spoutput_file(i));
               2          ]
               1      ELSE [
               2          outfile_specified(i)=.false.;
               2          ]
               1
               1      "done reading the .egsinp file for this medium"
               1      "see if we need anything from the material data file"
               1      IF(medfile_specified & (~elements_specified | ~rho_specified |
               1      ~iunrst_specified | ~iaprim_specified | ~gasp_specified |
               1      ~stern_specified | ~densityfile_specified))[
               2          "we assume at this point that the media file has been opened"
               2          "let us find the delimeters for this medium"
               2          rewind(i_medfile);
               2          start_delim_found=.false.;
               2          end_delim_found=.false.;
               2          WHILE(~start_delim_found | ~end_delim_found)[
               3              read(i_medfile,'(a)',end=:stop_medfile_read:)text_string;
               3              text_save=text_string;
               3              text_string=toUpper($cstring(text_string));
               3              mindex=index(text_string,'MEDIUM');
               3              eindex=index(text_string,'=');
               3              IF(mindex>0 & eindex>mindex)[
               4                  "remove everything up to ="
               4                  text_string=text_save(eindex+1:);
               4                  text_string=$cstring(text_string);
               4                  $SKIP LEADING BLANKS IN text_string;
               4                  IF(text_string=medium_name)[
               5                      delim_start=text_save;
               5                      start_delim_found=.true.;
               5                      ]
               4                  ELSEIF(start_delim_found)[
               5                      delim_end=text_save;
               5                      end_delim_found=.true.;
               5                      ]
               4
               4                  ]
               3              ]
               2          :stop_medfile_read:
               2          IF(~start_delim_found)[
               3              $WRITE_MEDERR(' Warning: Data for ',medium_name,' not found');
               3              $WRITE_MEDERR(' in material data file.');
               3              ]
               2          ELSE[
               3              IF(~end_delim_found)[
               4                  "eof is end delimiter"
               4                  delim_end='NONE';
               4                  ]
               3
               3              ival=0;
               3              "now go through and get what is required"
               3              IF(~elements_specified)[
               4                  ival=ival+1;
               4                  ival_elements=ival;
               4                  values_sought(ival) = 'elements';
               4                  type(ival)          = 2;  "i.e.  character input"
               4                  nvalue(ival)        = 0;
               4                  nmin=ival_elements;nmax=ival_elements;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_elements)=0)[
               5                      "now get fraction of each element"
               5                      ival=ival+1;
               5                      ival_pz=ival;
               5                      nne_tmp=nvalue(ival_elements);
               5                      values_sought(ival)='number of atoms';
               5                      type(ival)=0;
               5                      nvalue(ival)=nne_tmp;
               5                      nmin=ival_pz;nmax=ival_pz;
               5                      CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               5                      IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               6                          "got em.  Use em.  If its not an element"
               6                          DO j=1,nne_tmp[
               7                              asym_tmp(j)=char_value(ival_elements,j);
               7                              pz_tmp(j)=value(ival_pz,j);
               7                              ]
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      ELSE[
               6                          "check to see if fractional wts specified"
               6                          ival=ival+1;
               6                          ival_rhoz=ival;
               6                          values_sought(ival)='mass fractions';
               6                          type(ival)=1;
               6                          nvalue(ival)=nne_tmp;
               6                          nmin=ival_rhoz;nmax=ival_rhoz;
               6                          IF(nne_tmp=1)[
               7                              "set max, min and default values"
               7                              value_min(ival)=0.0;
               7                              value_max(ival)=1.e15;
               7                              default(ival)=1.;
               7                              ]
               6                          CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               6                          IF(error_flags(ival_rhoz)=0)[
               7                              "got em.  Use em."
               7                              DO j=1,nne_tmp[
               8                                  asym_tmp(j)=char_value(ival_elements,j);
               8                                  rhoz_tmp(j)=value(ival_rhoz,j);
               8                                  ]
               7                              elements_specified=.true.;
               7                              spec_by_rhoz=.true.;
               7                              ]
               6                          ]
               5                      IF(nne_tmp=1 & ~elements_specified)[
               6                          asym_tmp(1)=char_value(ival_elements,1);
               6                          pz_tmp(1)=1;
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      IF(elements_specified)[
               6                          $WRITE_MEDERR(' Composition specified in material data file');
               6                          ]
               5                      ]
               4                  ]
               3
               3              IF(~rho_specified)[
               4                  ival=ival+1;
               4                  ival_rho=ival;
               4                  values_sought(ival) = 'rho';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1e15;
               4                  default(ival)=1.0;
               4                  nmin=ival_rho;nmax=ival_rho;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_rho)=0)[
               5                      rho_tmp=value(ival_rho,1);
               5                      rho_specified=.true.;
               5                      $WRITE_MEDERR(' Rho specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~stern_specified)[
               4                  ival=ival+1;
               4                  ival_sterncid=ival;
               4                  values_sought(ival)='sterncid';
               4                  type(ival)=2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_sterncid;nmax=ival_sterncid;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_sterncid)=0)[
               5                      sterncid_tmp=char_value(ival_sterncid,1);
               5                      stern_specified=.true.;
               5                      $WRITE_MEDERR(' STERNCID specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iunrst_specified)[
               4                  ival=ival+1;
               4                  ival_iunrst=ival;
               4                  values_sought(ival)='stopping powers';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='restricted total';
               4                  allowed_inputs(ival,1)='unrestricted collision';
               4                  allowed_inputs(ival,2)='unrestricted collision and radiative';
               4                  allowed_inputs(ival,3)=
               4                  'unrestricted collision and restricted radiative';
               4                  allowed_inputs(ival,4)=
               4                  'restricted collision and unrestricted radiative';
               4                  allowed_inputs(ival,5)='unrestricted radiative';
               4                  nmin=ival_iunrst;nmax=ival_iunrst;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iunrst)=0)[
               5                      iunrst_tmp=value(ival_iunrst,1);
               5                      iunrst_specified=.true.;
               5                      $WRITE_MEDERR(' IUNRST specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iaprim_specified)[
               4                  ival=ival+1;
               4                  ival_iaprim=ival;
               4                  values_sought(ival)='bremsstrahlung correction';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='KM';
               4                  allowed_inputs(ival,1)='NRC';
               4                  allowed_inputs(ival,2)='none';
               4                  nmin=ival_iaprim;nmax=ival_iaprim;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iaprim)=0)[
               5                      iaprim_tmp=value(ival_iaprim,1);
               5                      iaprim_specified=.true.;
               5                      $WRITE_MEDERR(' IAPRIM specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~gasp_specified)[
               4                  ival=ival+1;
               4                  ival_gasp=ival;
               4                  values_sought(ival)='gas pressure';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=0.;
               4                  nmin=ival_gasp;nmax=ival_gasp;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_gasp)=0)[
               5                      gasp_tmp=value(ival_gasp,1);
               5                      gasp_specified=.true.;
               5                      $WRITE_MEDERR(' GASP specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~densityfile_specified)[
               4                  ival=ival+1;
               4                  ival_densityfile=ival;
               4                  values_sought(ival)='density correction file';
               4                  type(ival)          = 2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_densityfile;nmax=ival_densityfile;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_densityfile)=0)[
               5                      density_file=char_value(ival_densityfile,1);
               5                      densityfile_specified=.true.;
               5                      "may get changed to false later if it cannot be opened"
               5                      $WRITE_MEDERR(
               5                      ' Density correction file specified in material data file.');
               5                      ]
               4                  ]
               3              ]
               2
               2          ]
               1
               1      "now, try to open the density correction file, if specified"
               1      IF(densityfile_specified)[
               2          "if a file separator is specified in the name, assume the full path + name"
               2          "of the file is specified"
               2          write(*,*)' density_file ',density_file;
               2          IF(index(density_file,$file_sep)>0) [
               3              tmp_string=$cstring(density_file);
               3              inquire(file=tmp_string,exist=ex);
               3              IF(~ex)[
               4                  $WRITE_MEDERR(' Error: Density correction file ',tmp_string);
               4                  $WRITE_MEDERR(' cannot be found.');
               4                  ]
               3              ]
               2          ELSE [
               3              density_file=$cstring(density_file)//'.density';
               3              "first look in $EGS_HOME/pegs4/density_corrections"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look in $EGS_HOME/pegs4/density in case directory still there"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look through $HEN_HOUSE/pegs4/density_corrections"
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              $WRITE_MEDERR(' Error: Density correction file',
               3              density_file);
               3              $WRITE_MEDERR(' does not exist in');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/elements, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/compounds, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density, ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/elements or ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/compounds.');
               3              :density_file_found:
               3              ]
               2          ]
               1
               1      IF(densityfile_specified)[
               2          "now try to open it"
               2          i_density=19;
               2          i_density=egs_get_unit(i_density);
               2          IF(i_density < 1)[
               3              $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               3              ' density correction file.');
               3              ]
               2          open(i_density,file=tmp_string,status='old',err=:no_density_file:);
               2          density_file=tmp_string;
               2          densityfile_specified=.true.;
               2          epstfl_tmp=1;
               2
               2          "the density file is open at this point so just read the data"
               2
               2          read(i_density,'(a)')title;
               2          read(i_density,*)nepst_df,iev_df,rho_df,nne_df;
               2          read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df);
               2
               2          "get atomic symbols and pz based on df header"
               2          DO j=1,nne_df[
               3              i01=z_df(j);
               3              asym_df(j)=ASYMT(i01);
               3              ]
               2
               2          "check to see if data read from density file matches"
               2          "composition and rho already input"
               2          IF(elements_specified)[
               3              IF(nne_tmp~=nne_df)[
               4                  df_if_elem_mismatch(i)=.true.;
               4                  ]
               3              ELSE[
               4                  rhoz_tot=0.;
               4                  DO j=1,nne_tmp["normalize rhoz as it is in dcf"
               5                      IF(spec_by_pz)[
               6                          i01=ZTBL(asym_tmp(j));
               6                          rhoz_tmp(j)=pz_tmp(j)*WATBL(i01);
               6                          ]
               5                      rhoz_tot=rhoz_tot+rhoz_tmp(j);
               5                      ]
               4                  DO j=1,nne_df[
               5                      DO k=1,nne_tmp[ "at this point nne_df=nne_tmp"
               6                          IF(asym_df(j)=asym_tmp(k))[
               7                              IF(rhoz_df(j)>(1+0.01)*rhoz_tmp(k)/rhoz_tot |
               7                              rhoz_df(j)<(1-0.01)*rhoz_tmp(k)/rhoz_tot)[
               8                                  df_if_elem_mismatch(i)=.true.;
               8                                  ]
               7                              exit;
               7                              ]
               6                          ]
               5                      IF(k>nne_tmp) df_if_elem_mismatch(i)=.true.;
               5                      "never found the element"
               5                      IF(df_if_elem_mismatch(i)) [exit;];
               5                      ]
               4                  ]
               3              IF(df_if_elem_mismatch(i))[
               4                  $WRITE_MEDERR(' Warning: composition specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use the composition specified in the density correction file.');
               4                  nne_tmp=nne_df;
               4                  DO j=1,nne_tmp[
               5                      z_tmp(j)=z_df(j);
               5                      rhoz_tmp(j)=rhoz_df(j);
               5                      asym_tmp(j)=asym_df(j);
               5                      ]
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              $WRITE_MEDERR(' Composition specified in density correction file');
               3              nne_tmp=nne_df;
               3              DO j=1,nne_tmp[
               4                  z_tmp(j)=z_df(j);
               4                  rhoz_tmp(j)=rhoz_df(j);
               4                  asym_tmp(j)=asym_df(j);
               4                  ]
               3              spec_by_rhoz=.true.;
               3              elements_specified=.true.;
               3              ]
               2
               2          IF(rho_specified)[
               3              "check to see if rho read from density correction file matches"
               3              "that already input"
               3              IF(rho_df>(1+0.01)*rho_tmp | rho_df<(1-0.01)*rho_tmp)[
               4                  $WRITE_MEDERR(' Warning: rho specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use rho as specified in the density correction file.');
               4                  rho_tmp=rho_df;
               4                  df_if_rho_mismatch(i)=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              rho_tmp=rho_df;
               3              rho_specified=.true.;
               3              $WRITE_MEDERR(' Rho specified in density correction file');
               3              ]
               2
               2          IF(gasp_specified)[
               3              "any value of gasp other than 1 atm is incompatible with"
               3              "use of dcf and, since gasp is only used to scale rho when"
               3              "dcf is used, this input is now unecessary at best"
               3              $WRITE_MEDERR(' Warning: gas pressure input not required',
               3              ' when using density correction file.  Will set GASP=0.');
               3              gasp_specified=.false.;
               3              gasp_tmp=0.;
               3              ]
               2
               2          "close the density file"
               2          close(i_density);
               2          ]
               1
               1      "okay, now commit this to the media library"
               1      IF(elements_specified & rho_specified)[
               2
               2          ae(i)=ae_tmp;
               2          ue(i)=ue_tmp;
               2          ap(i)=ap_tmp;
               2          up(i)=up_tmp;
               2
               2          DO j=1,24[
               3              inpstrn(j,i) = sterncid_tmp(j:j);
               3              ]
               2
               2          nne(i)=nne_tmp;
               2          rho(i)=rho_tmp;
               2
               2          DO j=1,nne_tmp[
               3              inpasym(i,j)=asym_tmp(j);
               3              "assume we are getting z from asym"
               3              "redundant in the case where medium defined using"
               3              "density correction file"
               3              "ZTBL is a function defined in pegs4_routines.mortran"
               3              zelem(i,j)=ZTBL(asym_tmp(j));
               3              i01=zelem(i,j);
               3              "WATBL defined in pegs4_macros.mortran"
               3              wa(i,j)=WATBL(i01);
               3              wa4(i,j)=WATBL(i01);
               3              "also do $REAL4 math so we can check against cross-sections"
               3              "calculated by pegs4.mortran"
               3              IF(spec_by_rhoz)[
               4                  rhoz(i,j)=rhoz_tmp(j);
               4                  rhoz4(i,j)=rhoz_tmp(j);
               4                  pz(i,j)=rhoz(i,j)/wa(i,j);
               4                  pz4(i,j)=rhoz4(i,j)/wa4(i,j);
               4
               4                  ]
               3              ELSEIF(spec_by_pz)[
               4                  pz(i,j)=pz_tmp(j);
               4                  pz4(i,j)=pz_tmp(j);
               4                  rhoz(i,j)=pz(i,j)*wa(i,j);
               4                  rhoz4(i,j)=pz4(i,j)*wa4(i,j);
               4                  ]
               3              ]
               2
               2          iunrst(i)=iunrst_tmp;
               2          iaprim(i)=iaprim_tmp;
               2          epstfl(i)=epstfl_tmp;
               2          inpgasp(i)=gasp_tmp;
               2          inpdensity_file(i)=density_file;
               2
               2          ]
               1      ELSE[
               2          $WRITE_MEDERR(' Error: Medium ',medium_name,' not correctly defined.');
               2          ]
               1      ]
               0
               0  IF(medfile_specified) close(i_medfile);
               0
               0  IF(n_parallel=0 | i_parallel=first_parallel) close(i_mederr);
               0
               0
               0  entry show_media_parameters(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  IF(is_pegsless)[
               1
               1      "show common data"
               1
               1      write(ounit,*);
               1      write(ounit,*)' Medium data: ';
               1      write(ounit,*);
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE = ',ue(1),' MeV';
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP = ',up(1),' MeV';
               1      write(ounit,*);
               1      IF(medfile_specified)[
               2          write(ounit,*)' Material data file: ',material_file;
               2          ]
               1      ELSE[
               2          write(ounit,*)' No material data file supplied.  Material data obtained from';
               2          write(ounit,*)' .egsinp file or density correction file.';
               2          ]
               1      write(ounit,*);
               1
               1      "now list data for individual media that were successfully read in"
               1
               1      DO i=1,nmed[
               2
               2          write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24);
               2          write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24);
               2          write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3';
               2          write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i));
               2          write(ounit,'(a,i5)')'  iunrst: ',iunrst(i);
               2          write(ounit,'(a,i5)')'  iaprim: ',iaprim(i);
               2          write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.';
               2          IF(epstfl(i)=1)[
               3              write(ounit,*)' density correction file: ',
               3              $cstring(inpdensity_file(i));
               3              IF(df_if_elem_mismatch(i))[
               4                  write(ounit,*)' ****Warning: composition specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use the composition specified in the density correction file.';
               4                  ]
               3              IF(df_if_rho_mismatch(i))[
               4                  write(ounit,*)' ****Warning: rho specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use rho as specified in the density correction file.';
               4                  ]
               3              ]
               2          write(ounit,*);
               2
               2          "output stopping powers to file for plotting if requested"
               2          IF(outfile_specified(i) & (n_parallel=0 | i_parallel=first_parallel)) [
               3              inquire(file=spoutput_file(i),exist=ex);
               3              IF(ex) [
               4                  $egs_warning('(a)','Warning: stopping power output file ',
               4                  spoutput_file(i),'already exists.  Will overwrite.');
               4                  ]
               3              i_outfile=20;
               3              i_outfile=egs_get_unit(i_outfile);
               3              IF(i_outfile < 1)[
               4                  $egs_warning('(a)','Warning: Failed to get available fortran unit for',
               4                  ' stopping power output file.');
               4                  ]
               3              open(i_outfile,file=spoutput_file(i),status='unknown',err=:no_output_file:);
               3              goto :got_outfile:;
               3              :no_output_file:
               3              $egs_warning('(a)','Warning: Failed to open stopping power output file ',
               3              spoutput_file(i));
               3              goto :end_outfile:;
               3              :got_outfile:
               3              IFLAG1=0;IFLAG2=0;IPLOTE=0;MEDIUM=i;
               3              XAXIS = 'kinetic energy / MeV';
               3              YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N';
               3              YAXISEmfp = 'mean free path / cm';
               3              YAXISPmfp = 'mean free path / cm';
               3              write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24);
               3              SUBTITLE = 'Electron data';
               3              DO j=1,8[
               4                  DO k=1,16[
               5                      EKE=ETAB(k)*10.**(j-4);
               5                      IF(EKE <= AE(1)-PRM) [
               6                          IF(IFLAG1 = 0) [
               7                              IFLAG1=1; EKE=AE(1)-PRM;
               7                              ] ELSE [ EKE=0.0; ]
               6                          ]
               5
               5                      IF(EKE > UE(1)-PRM) [
               6                          IF(IFLAG2 = 0) [
               7                              IFLAG2=1; EKE=UE(1)-PRM;
               7                              ] ELSE [ EKE=1.E30; ]
               6                          ]
               5                      EIE=EKE+PRM;       TMXSO=0.0;        DEDXE=0.0;
               5                      DEDXP=0.0;           EFRACT=0.0;
               5                      IF(EIE >= AE(1)-0.0001 & EIE <= UE(1)+0.001) [
               6                          ELKE=LOG(EKE);
               6                          $SET INTERVAL ELKE,EKE;
               6                          $EVALUATE DEDXE USING EDEDX(ELKE);"RESTRICTED STOPPING POWERS"
               6
               6                          "enable below to plot other quantities"
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6                          IPLOTE=IPLOTE+1;   "keep track of how many entries"
               6                          PLOTEEN(IPLOTE)=EKE;
               6                          PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM);
               6                          "enable below to plot other quantities
               6
               6
               6
               6
               6
               6
               6
               6
               6                          ]
               5                      ]
               4                  ]
               3              IF(IPLOTE>0)[
               4                  "currently only plots stopping powers"
               4                  IF(iunrst(i)=0) [
               5                      SERIES='restricted total stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=1) [
               5                      SERIES='unrestricted collision stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=2) [
               5                      SERIES='unrestricted collision + radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=3) [
               5                      SERIES='unrestricted collision + restricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=4) [
               5                      SERIES='restricted collision + unrestricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=5) [
               5                      SERIES='unrestricted radiative stopping power';
               5                      ]
               4                  CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES,
               4                  XAXIS,YAXISE,GRAPHTITLE,SUBTITLE,i_outfile,2);
               4                  ]
               3              close(i_outfile);
               3              :end_outfile:
               3              ]
               2          ]
               1      ]
               0
               0  return;
               0  :no_media_file:
               0  $egs_fatal('(a)','Error: Cannot open material data file',material_file);
               0  return;
               0  :no_density_file:
               0  $egs_fatal('(a)','Error: Cannot open density correction file: ',
               0  $cstring(density_file));
               0  return;
               0  end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0
               0  SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, AXISTYPE);
               0  "a version of XVGRPLOT specifically for plotting stopping powers and"
               0  "associated data.  Note that this is required because xvgrplot.mortran"
               0  "is not included at compile time for all user codes."
               0  IMPLICIT NONE;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER MAX;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY;
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  $LOGICAL TESTFILE, ALLPOS;
               0
               0  FUDGE = 1.e-10;
               0
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0
               0  "---Initialize LOGX, LOGY, to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;
               0
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          ]
               1      ]
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Data set is of type XY---"
               0  WRITE(UNITNUM,:200:);
               0  :200: FORMAT ('@TYPE xy');
               0  IF (CURVENUM < 10) [
               1      WRITE(UNITNUM,:151:) CURVENUM;
               1      IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               1      ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,:152:) CURVENUM;
               1      WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               1      ]
               0  :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               0  :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               0  :197: FORMAT ('@    s',I1,' symbol color ',I2);
               0  :198: FORMAT ('@    s',I1,' symbol color ',I1);
               0  :199: FORMAT ('@    s',I2,' symbol color ',I2);
               0
               0  "---Then write the data to the file.---"
               0  DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               0  :250: FORMAT (1PE15.4,1PE15.4);
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END;
               0  ;
               0  "---End of subroutine.---"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc generalized grid output of values                                   "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Aaron Merovitz, 1998                                      "
               0  "                   Dave Rogers, 1998                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE ZONEGRID(NRADIAL, NDEPTH, NRMIN, NZMIN, NZ, RESULTS, UNCRT,
               0  NCOMP, RADIAL_BINS, DEPTH_BINS, LABELS, EXPLANATIONS);
               0  "
               0  "      DESCRIPTION : Routine provides a generalized grid output of
               0  "          OF      : values.  The grid will be rotated if radnum>3
               0  "         THE      : and deepnum<=3. Also, if 10% of all the uncertainties
               0  "      SUBROUTINE  : are less than 0.3% (this is the value of the
               0  "                    parameter 'CUTOFF') an extra significant figure will
               0  "                    appear in the grid output.
               0  "
               0  "                      Ensure that the macro $MAXRZ has been declared.
               0  "                  \   One must add the macro '$MAXCMPTS'(usually=$MAXIT)
               0  "   FOR INSTALLING  \  to the program in which this subroutine is called.
               0  "       THIS         > Be careful that all arrays passed to the subroutine
               0  "    SUBROUTINE     /  (especially 'RESULTS()' and 'UNCRT()') have exactly
               0  "                  /   the same dimensions as used here.
               0  "
               0  "      Description of the arguments:
               0  "      NRADIAL     : number of radial results to display
               0  "      NDEPTH      : number of depth results to display
               0  "      NRMIN       : index of min radius of results zone
               0  "      NZMIN       : index of min Z plane of results zone
               0  "      NZ          : total number of slabs in the geometry
               0  "      RESULTS     : array of results
               0  "      UNCRT       : corresponding array of uncertainties(max at 99.9%)
               0  "      NCOMP       : number of components of the results
               0  "      RADIAL_BINS : array of outer boundaries of each radial bin(1st
               0  "                                                              radius=0)
               0  "      DEPTH_BINS  : array of depth boundaries (1st plane not always 0)
               0  "      LABELS      : array of length ncomp, the label for each component
               0  "      EXPLANATIONS: explanations for the labels
               0  "
               0  "***************************************************************************
               0  ;IMPLICIT NONE;
               0
               0  "This MACRO outputs a grid of values."
               0  "There is room for three sets of values(blocks or boxes) in"
               0  "80 columns(standard window size), so the grids each"
               0  "contain sets of three values, e.g. radii(if non-rotated)."
               0  REPLACE {$MKGRID;} WITH {
            {  0  ;
            {  0  "Set up the formatting indicator FMT"
            {  0  IF (RADNUM-HSET>1) [FMT=3;]
            {  0  ELSE [IF (MOD(RADNUM,3) = 1) [FMT=1;]
            {  0  IF (MOD(RADNUM,3) = 2) [FMT=2;]]
            {  0  "Horizontal axis indicators"
            {  0  WRITE (IOUT, 91) (RADIAL_BINS(IX), IX=HSET,HSET+FMT);
            {  0  PGTHROW=PGTHROW+1;
            {  0  DO IZ=1, DEEPNUM [
            {  0  "This is for IRL, IZ and IX"
            {  0  IF (ROT) [REGNUM= (IZ+NRMIN-1)*NZ + HSET+NZMIN;]
            {  0  ELSE [REGNUM= (HSET+NRMIN-1)*NZ + IZ+NZMIN;]
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(IZ);
            {  0  IF (SFIG) [IF (ROT)[
            {  0  WRITE (IOUT, 15) REGNUM,HSET+NZMIN-1,IZ+NRMIN;]
            {  0  ELSE [WRITE (IOUT, 15) REGNUM,IZ+NZMIN-1,HSET+NRMIN;]
            {  0  ]
            {  0  ELSE [IF (ROT) [WRITE (IOUT, 18) REGNUM,HSET+NZMIN-1,IZ+NRMIN;]
            {  0  ELSE [WRITE (IOUT, 18) REGNUM,IZ+NZMIN-1,HSET+NRMIN;]
            {  0  ]
            {  0  ]
            {  0  IF (FMT=2) [
            {  0  WRITE (IOUT, 11) DEPTH_BINS(IZ);
            {  0  IF (SFIG)[
            {  0  IF (ROT) [WRITE(IOUT,14) REGNUM,HSET+NZMIN-1,IZ+NRMIN,
            {  0  REGNUM+1,HSET+NZMIN,IZ+NRMIN; ]
            {  0  ELSE [WRITE(IOUT,14) REGNUM,IZ+NZMIN-1,HSET+NRMIN,
            {  0  REGNUM+NZ,IZ+NZMIN-1,HSET+NRMIN+1;]
            {  0  ]
            {  0  ELSE [
            {  0  IF (ROT) [WRITE(IOUT,17) REGNUM,HSET+NZMIN-1,IZ+NRMIN,
            {  0  REGNUM+1,HSET+NZMIN, IZ+NRMIN;]
            {  0  ELSE [WRITE(IOUT,17) REGNUM,IZ+NZMIN-1,HSET+NRMIN,
            {  0  REGNUM+NZ,IZ+NZMIN-1,HSET+NRMIN+1;]
            {  0  ]
            {  0  ]
            {  0  IF (FMT=3) [
            {  0  WRITE (IOUT, 12) DEPTH_BINS(IZ);
            {  0  IF (SFIG) [
            {  0  IF (ROT) [
            {  0  WRITE (IOUT,13)REGNUM,HSET+NZMIN-1,IZ+NRMIN,
            {  0  REGNUM+1,HSET+NZMIN,IZ+NRMIN,
            {  0  REGNUM+2,HSET+NZMIN+1,IZ+NRMIN;
            {  0  ]
            {  0  ELSE [
            {  0  WRITE (IOUT, 13) REGNUM,IZ+NZMIN-1,HSET+NRMIN,
            {  0  REGNUM+NZ,IZ+NZMIN-1,HSET+NRMIN+1,
            {  0  REGNUM+NZ*2,IZ+NZMIN-1,HSET+NRMIN+2;
            {  0  ]
            {  0  ]"end SFIG true block"
            {  0  ELSE ["not SFIG"
            {  0  IF (ROT) [
            {  0  WRITE (IOUT,16)REGNUM,HSET+NZMIN-1,IZ+NRMIN,
            {  0  REGNUM+1,HSET+NZMIN,IZ+NRMIN,
            {  0  REGNUM+2,HSET+NZMIN+1,IZ+NRMIN;
            {  0  ]
            {  0  ELSE [
            {  0  WRITE (IOUT, 16)REGNUM,IZ+NZMIN-1,HSET+NRMIN,
            {  0  REGNUM+NZ,IZ+NZMIN-1,HSET+NRMIN+1,
            {  0  REGNUM+NZ*2,IZ+NZMIN-1,HSET+NRMIN+2;
            {  0
            {  0  ]
            {  0  ]
            {  0  ]"end FMT=3 block"
            {  0  PGTHROW=PGTHROW+2;
            {  0  "Main part of the grid"
            {  0  DO ICOMP=1, NCOMP [
            {  0  IF (SFIG) [
            {  0  IF (FMT=3) [
            {  0  WRITE(IOUT, 3) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP),
            {  0  RESULTS(IZ,HSET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP),
            {  0  LABELS(ICOMP),RESULTS(IZ,HSET+2,ICOMP),
            {  0  UNCRT(IZ,HSET+2,ICOMP);
            {  0  ]
            {  0  IF (FMT=2) [
            {  0  WRITE(IOUT, 2) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP),
            {  0  RESULTS(IZ,HSET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP);
            {  0  ]
            {  0  IF (FMT=1) [
            {  0  WRITE(IOUT, 1) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP);
            {  0  ]
            {  0  ] "end IF (SFIG)"
            {  0  ELSE [
            {  0  IF (FMT=3) [
            {  0  WRITE(IOUT, 6) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP),
            {  0  RESULTS(IZ,HSET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP),
            {  0  LABELS(ICOMP),RESULTS(IZ,HSET+2,ICOMP),
            {  0  UNCRT(IZ,HSET+2,ICOMP);
            {  0  ]
            {  0  IF (FMT=2) [
            {  0  WRITE(IOUT, 5) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP),LABELS(ICOMP),
            {  0  RESULTS(IZ,HSET+1,ICOMP),UNCRT(IZ,HSET+1,ICOMP);
            {  0  ]
            {  0  IF (FMT=1) [
            {  0  WRITE(IOUT, 4) LABELS(ICOMP),RESULTS(IZ,HSET,ICOMP),
            {  0  UNCRT(IZ,HSET,ICOMP);
            {  0  ]
            {  0  ] "end ELSE (SFIG)"
            {  0  PGTHROW=PGTHROW+1;
            {  0  ] "end DO ICOMP"
            {  0  "This piece of code surveys PGTHROW, and throws the page when"
            {  0  "PGTHROW is near 65 lines."
            {  0  IF (MOD(PGTHROW,65)>(61-NCOMP)) [
            {  0  "This is for the last vertical bin"
            {  0  IF (IZ~=DEEPNUM) [ "only for grid cut by PGTHROW"
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(IZ+1);]
            {  0  IF (FMT=2) [WRITE (IOUT, 11) DEPTH_BINS(IZ+1);]
            {  0  IF (FMT=3) [WRITE (IOUT, 12) DEPTH_BINS(IZ+1);]
            {  0  "Start a new page"
            {  0  WRITE (IOUT, *) '\f'; "page break"
            {  0  PGTHROW=10;
            {  0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
            {  0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
            {  0  ELSE [WRITE(IOUT, 94) TITLE;]
            {  0  WRITE (IOUT, 91) (RADIAL_BINS(IX), IX=HSET,HSET+FMT);]
            {  0  "The following statement delays the page throw until the "
            {  0  "last line of the grid can be printed"
            {  0  ELSE [ DLYPT = HSET;]
            {  0  ] "end IF mod(pgthrow)"
            {  0  ] "end DO IZ"
            {  0  "This is for the last vertical bin"
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1);]
            {  0  IF (FMT=2) [WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1);]
            {  0  IF (FMT=3) [WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1);]
            {  0
            {  0  "For the delayed page throw"
            {  0  IF ((DLYPT=HSET)&(RADNUM-HSET>2)) [
            {  0  "Start a new page"
            {  0  WRITE (IOUT, *) '\f'; "page break"
            {  0  PGTHROW=10;
            {  0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
            {  0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
            {  0  ELSE [WRITE(IOUT, 94) TITLE;]
            {  0  ]
            {  0  PGTHROW=PGTHROW+1;
            {  0  }
               0
               0  ;COMIN/IODAT1/; "COMMON BLOCK is for TITLE, TIMEN and DATEN"
               0  $INTEGER RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TMP1;
               0  $LOGICAL SFIG; "controls significant figures on UNCRT()"
               0  "true => use 1 significant figure"
               0  "false => use 2 significant figures"
               0  $LOGICAL ROT;  "for rotation of the grid"
               0  PARAMETER CUTOFF=0.3; "changes SFIG if 10% of uncertainties are less"
               0  "than 0.2%"
               0  $REAL RESULTS($MAXZREG,$MAXRADII,$MAXCMPTS),
               0  UNCRT($MAXZREG,$MAXRADII,$MAXCMPTS),
               0  RADIAL_BINS($MAXRADII),DEPTH_BINS($MAXZPLANE),
               0  TMP2,TMP3;
               0  CHARACTER*60 EXPLANATIONS($MAXCMPTS);
               0  CHARACTER*4 LABELS($MAXCMPTS);
               0  $INTEGER IOUT, ICOMP, IX, IZ, HSET, PGTHROW, DLYPT, COUNT,NZMIN,NRMIN,NZ;
               0  ROT=.FALSE.; "For a rotated grid (.FALSE. = off)"
               0  SFIG=.TRUE.;   "Default sig. fig. option off"
               0  IF(NCOMP>4)[PGTHROW=20;]
               0  ELSE[PGTHROW=17;]
               0  "For printing: throw page at 66 lines(16 1st for title)"
               0  IOUT=1; "Designates output to file fort.1, the *.egs4lst file"
               0  "Change variable names so any changes are not passed back to MAIN prog"
               0  RADNUM=NRADIAL;DEEPNUM=NDEPTH;
               0  COUNT = 0;
               0  DO IX=1, RADNUM [   "Check for needed precision of uncertainties"
               1      DO IZ=1, DEEPNUM [
               2          DO ICOMP=1,NCOMP [
               3              IF (UNCRT(IZ, IX, ICOMP) < CUTOFF) [COUNT = COUNT + 1;]
               3              ]
               2          ]
               1      ]
               0  "IF better precision in UNCRT() is needed, change the grid format."
               0  IF (COUNT/(RADNUM*DEEPNUM*NCOMP) > 0.1) [SFIG=.FALSE.;]
               0  "Check for rotation of the grid"
               0  IF ((DEEPNUM<=3)&(RADNUM>3))[
               1      ROT=.TRUE.;
               1      DO IX=1, RADNUM [
               2          IF(IX <= DEEPNUM+1) [
               3              TMP3=RADIAL_BINS(IX);
               3              RADIAL_BINS(IX)=DEPTH_BINS(IX);
               3              DEPTH_BINS(IX)=TMP3;
               3              ]
               2          ELSE[
               3              DEPTH_BINS(IX)=RADIAL_BINS(IX);
               3              ]
               2          IF(IX <= DEEPNUM)[
               3              DO IZ=IX+1,DEEPNUM[
               4                  DO ICOMP=1,NCOMP[
               5                      TMP2=RESULTS(IZ,IX,ICOMP);
               5                      RESULTS(IZ,IX,ICOMP)=RESULTS(IX,IZ,ICOMP);
               5                      RESULTS(IX,IZ,ICOMP)=TMP2;
               5                      TMP2=UNCRT(IZ,IX,ICOMP);
               5                      UNCRT(IZ,IX,ICOMP)=UNCRT(IX,IZ,ICOMP);
               5                      UNCRT(IX,IZ,ICOMP)=TMP2;
               5                      ]
               4                  ]
               3              ]
               2          ELSE[
               3              DO IZ=1,DEEPNUM[
               4                  DO ICOMP=1,NCOMP[
               5                      RESULTS(IX,IZ,ICOMP)=RESULTS(IZ,IX,ICOMP);
               5                      UNCRT(IX,IZ,ICOMP)=UNCRT(IZ,IX,ICOMP);
               5                      ]
               4                  ]
               3              ]
               2          ] "end DO IX"
               1      DEPTH_BINS(RADNUM+1)=RADIAL_BINS(RADNUM+1);
               1      TMP1=RADNUM;RADNUM=DEEPNUM;DEEPNUM=TMP1;
               1      ] "end check for rotation"
               0  WRITE (IOUT, *) '\f'; "Page break"
               0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
               0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
               0  ELSE [WRITE(IOUT, 94) TITLE;]
               0  DO ICOMP=1, NCOMP [WRITE(IOUT, 95) LABELS(ICOMP), EXPLANATIONS(ICOMP);]
               0  "Make the grids"
               0  DO HSET=1,RADNUM,3 [$MKGRID;] "Feed in horiz. sets of three"
               0  "FORMATS"
               0  1        FORMAT (T11, '|',
               0  A4, 1PE10.3, '+-', 0PF4.1, '%',  '|');
               0  2        FORMAT (T11, '|',
               0  1 (A4, 1PE10.3, '+-', 0PF4.1, '%',  ' |'),
               0  A4, 1PE10.3, '+-', 0PF4.1, '%',  '|');
               0  3        FORMAT (T11, '|',
               0  2 (A4, 1PE10.3, '+-', 0PF4.1, '%',  ' |'),
               0  A4, 1PE10.3, '+-', 0PF4.1, '%',  '|');
               0  4        FORMAT (T11, '|',
               0  A4, 1PE10.3, '+-', 0PF5.2, '%',  '|');
               0  5        FORMAT (T11, '|',
               0  1 (A4, 1PE10.3, '+-', 0PF5.2, '%',  ' |'),
               0  A4, 1PE10.3, '+-', 0PF5.2, '%',  '|');
               0  6        FORMAT (T10, '|',
               0  2 (A4, 1PE10.3, '+-', 0PF5.2, '%',  '|'),
               0  A4, 1PE10.3, '+-', 0PF5.2, '%',  '|');
               0  10       FORMAT (1X, F9.4, T11, 1 (23 ('-')));
               0  11       FORMAT (1X, F9.4, T11, 2 (23 ('-')));
               0  12       FORMAT (1X, F9.4, T11, 3 (23 ('-')));
               0  13       FORMAT (T11, '|',
               0  2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'),
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|');
               0  14       FORMAT (T11, '|',
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |',
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|');
               0  15       FORMAT (T11, '|',
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'|');
               0  16       FORMAT (T10, '|',
               0  2 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |'),
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |');
               0  17       FORMAT (T11, '|',
               0  1 ('IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,'  |'),
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |');
               0  18       FORMAT (T11, '|',
               0  'IRL',I3,1X,'IZ ',I3,1X,'IX ',I3,1X,' |');
               0  91       FORMAT (/ T7,F9.4,T30,F9.4,T53,F9.4,T70,F9.4);
               0  93       FORMAT (' ',79A1 //
               0  T19, 27H ZONAL OUTPUT GRID: ROTATED /
               0  T20, '**************************');
               0  94       FORMAT (' ',79A1 //
               0  T19, 31H ZONAL OUTPUT GRID: NON-ROTATED /
               0  T20, '******************************');
               0  95       FORMAT (T14, A4, T19, A60);
               0  400      FORMAT (T54,a1,$);
               0
               0  RETURN;
               0  END;
               0
               0  "***************************************************************************
               0  "
               0  "       VERSION 1          MATERIALGRID.MORTRAN           VERSION 1
               0  "             \             ==================                 /
               0  "              \                                              /
               0  "               By Aaron Merovitz and D.W.O. Rogers, Feb 1998
               0  "
               0  SUBROUTINE MATERIALGRID(NRADIAL, NDEPTH, MASSVOL, MORV, ECUTS, PCUTS,
               0  RCYL, ZPLANE, MED, MEDIA, CDSTBL, CTRTBL, CABSRB);
               0  "
               0  "      DESCRIPTION : routine provides a material grid output.
               0  "          OF      : the grid will be rotated if nradial>3
               0  "         THE      : and ndepth<=3.  the grid contains the IRL, the type
               0  "      SUBROUTINE  : of the region and material aswell as it's mass.
               0  "
               0  "                  \   one must add the macro '$maxcmpts'(usually=$maxit)
               0  "   FOR INSTALLING  \  to the program in which this subroutine is called.
               0  "       THIS         > be careful that all arrays passed to the subroutine
               0  "    SUBROUTINE     /  (especially 'MASSVOL()' and 'MEDIA()') have
               0  "                  /   exactly the same dimensions.
               0
               0  "      DESCRIPTION OF THE ARGUMENTS:
               0  "      NRADIAL     : number of radial results to display
               0  "      NDEPTH      : number of depth results to display
               0  "      MASSVOL     : array of the masses, or volumes for each region
               0  "      MORV        : 1 for mass, 2 for volume.
               0  "      ECUTS, PCUTS: the 'ECUT' and 'PCUT' arrays.
               0  "      RCYL        : array of outer boundaries of each radial bin(1st
               0  "                                                              radius=0)
               0  "      ZPLANE      : array of depth boundaries (1st plane not always=0)
               0  "      MED         : array of the medium numbers for each IRL.
               0  "      MEDIA       : 2-d array of the masse for each medium number.
               0  "      CDSTBL      : array that contains a 'D' for each dose scoring
               0  "                    region(for each IRL). default is 0.
               0  "      CTRTBL      : contains a 'T' for each tracking region. default 0
               0  "      CABSRB      : contains an 'A' for each tatally absorbing region.
               0  "                    0 default means these values are not calculated.
               0  "***************************************************************************
               0  ;IMPLICIT NONE;
               0
               0  "This MACRO outputs a grid of values."
               0  "There is room for three sets of values(blocks or boxes) in"
               0  "80 columns(standard window size), so the grids each"
               0  "contain sets of three values, e.g. radii(if non-rotated)."
               0  REPLACE {$MKGRID;} WITH {
            {  0  ;
            {  0  "Set up the formatting indicator FMT"
            {  0  IF (RADNUM-HSET>1) [FMT=3;]
            {  0  ELSE [IF (MOD(RADNUM,3) = 1) [FMT=1;]
            {  0  IF (MOD(RADNUM,3) = 2) [FMT=2;]
            {  0  ]
            {  0  "Horizontal axis indicators"
            {  0  WRITE (IOUT, 91) (RADIAL_BINS(IX), IX=HSET,HSET+FMT);
            {  0  PGTHROW=PGTHROW+1;
            {  0  DO IZ=1, DEEPNUM [
            {  0  "This is for IRL, IZ and IX"
            {  0  IF (ROT) [REGNUM=2+(IZ-1)*FMT+(HSET-1)*RADNUM;]
            {  0  ELSE [REGNUM=( IZ+1+((HSET-1)*DEEPNUM) );]
            {  0  "Setting up medium name in each region"
            {  0  IF (ROT) [
            {  0  MNUM1=MED(REGNUM);MNUM2=MED(REGNUM+1);MNUM3=MED(REGNUM+2);
            {  0  ]
            {  0  ELSE [
            {  0  MNUM1=MED(REGNUM);MNUM2=MED(REGNUM+DEEPNUM);MNUM3=MED(REGNUM+DEEPNUM*2);
            {  0  ]
            {  0  IF (MNUM1=0) [MED_NAME1(1)='V';MED_NAME1(2)='A';MED_NAME1(3)='C';
            {  0  MED_NAME1(4)='U';MED_NAME1(5)='U';MED_NAME1(6)='M';
            {  0  DO J=7, 11 [MED_NAME1(J)=' ';]
            {  0  ]
            {  0  ELSE [DO COUNT=1, 11 [MED_NAME1(COUNT) = MEDIA(COUNT, MNUM1);]]
            {  0  IF (MNUM2=0) [MED_NAME2(1)='V';MED_NAME2(2)='A';MED_NAME2(3)='C';
            {  0  MED_NAME2(4)='U';MED_NAME2(5)='U';MED_NAME2(6)='M';
            {  0  DO J=7, 11 [MED_NAME2(J)=' ';]
            {  0  ]
            {  0  ELSE [DO COUNT=1, 11 [MED_NAME2(COUNT) = MEDIA(COUNT,MNUM2);]]
            {  0  IF (MNUM3=0) [MED_NAME3(1)='V';MED_NAME3(2)='A';MED_NAME3(3)='C';
            {  0  MED_NAME3(4)='U';MED_NAME3(5)='U';MED_NAME3(6)='M';
            {  0  DO J=7, 11 [MED_NAME3(J)=' ';]
            {  0  ]
            {  0  ELSE [DO COUNT=1, 11 [MED_NAME3(COUNT) = MEDIA(COUNT,MNUM3);]]
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(IZ);
            {  0  IF (ROT) [WRITE (IOUT, 15) REGNUM,HSET,IZ;]
            {  0  ELSE [WRITE (IOUT, 15) REGNUM,IZ,HSET;]
            {  0  WRITE (IOUT, 4) CDSTBL(REGNUM),CTRTBL(REGNUM),
            {  0  CABSRB(REGNUM), (MED_NAME1(J),J=1,11);
            {  0  ]
            {  0  IF (FMT=2) [WRITE (IOUT, 11) DEPTH_BINS(IZ);
            {  0  IF (ROT) [WRITE(IOUT,14) REGNUM,HSET,IZ,
            {  0  REGNUM+1,HSET+1,IZ;
            {  0  WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM),
            {  0  CABSRB(REGNUM), (MED_NAME1(J),J=1,11),
            {  0  CDSTBL(REGNUM+1),CTRTBL(REGNUM+1),
            {  0  CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11);
            {  0  ]
            {  0  ELSE [WRITE(IOUT,14) REGNUM,IZ,HSET,
            {  0  REGNUM+DEEPNUM,IZ,HSET+1;
            {  0  WRITE(IOUT, 5) CDSTBL(REGNUM),CTRTBL(REGNUM),
            {  0  CABSRB(REGNUM), (MED_NAME1(J),J=1,11),
            {  0  CDSTBL(REGNUM+DEEPNUM),CTRTBL(REGNUM+DEEPNUM),
            {  0  CABSRB(REGNUM+DEEPNUM),(MED_NAME2(J),J=1,11);
            {  0  ]
            {  0  ]
            {  0  IF (FMT=3) [WRITE (IOUT, 12) DEPTH_BINS(IZ);
            {  0  IF (ROT) [WRITE (IOUT, 13)
            {  0  REGNUM,HSET,IZ,REGNUM+1,
            {  0  HSET+1,IZ,REGNUM+2,HSET+2,IZ;
            {  0  WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM),
            {  0  CABSRB(REGNUM), (MED_NAME1(J),J=1,11),
            {  0  CDSTBL(REGNUM+1),CTRTBL(REGNUM+1),
            {  0  CABSRB(REGNUM+1), (MED_NAME2(J),J=1,11),
            {  0  CDSTBL(REGNUM+2),CTRTBL(REGNUM+2),
            {  0  CABSRB(REGNUM+2), (MED_NAME3(J),J=1,11);
            {  0  ]
            {  0  ELSE [WRITE (IOUT, 13)
            {  0  REGNUM,IZ,HSET,REGNUM+DEEPNUM,
            {  0  IZ,HSET+1,REGNUM+DEEPNUM*2,IZ,HSET+2;
            {  0  WRITE (IOUT, 6) CDSTBL(REGNUM),CTRTBL(REGNUM),
            {  0  CABSRB(REGNUM), (MED_NAME1(J),J=1,11),
            {  0  CDSTBL(REGNUM+DEEPNUM),CTRTBL(REGNUM+DEEPNUM),
            {  0  CABSRB(REGNUM+DEEPNUM), (MED_NAME2(J),J=1,11),
            {  0  CDSTBL(REGNUM+DEEPNUM*2),CTRTBL(REGNUM+DEEPNUM*2),
            {  0  CABSRB(REGNUM+DEEPNUM*2), (MED_NAME3(J),J=1,11);
            {  0  ]
            {  0  ]
            {  0  PGTHROW=PGTHROW+3;
            {  0  "Main part of the grid"
            {  0  DO ICOMP=1, NCOMP [
            {  0  IF (FMT=3) [
            {  0  WRITE(IOUT, 3) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP),
            {  0  LABELS(ICOMP),VALUES(IZ,HSET+1,ICOMP),
            {  0  LABELS(ICOMP),VALUES(IZ,HSET+2,ICOMP);
            {  0  ]
            {  0  IF (FMT=2) [
            {  0  WRITE(IOUT, 2) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP),
            {  0  LABELS(ICOMP),VALUES(IZ,HSET+1,ICOMP);
            {  0  ]
            {  0  IF (FMT=1) [WRITE(IOUT, 1) LABELS(ICOMP),VALUES(IZ,HSET,ICOMP);]
            {  0  PGTHROW=PGTHROW+1;
            {  0  ] "end DO ICOMP"
            {  0  "This piece of code surveys PGTHROW, and throws the page when"
            {  0  "PGTHROW is near 65 lines."
            {  0  IF (MOD(PGTHROW,65)>(60-NCOMP)) [
            {  0  "This is for the last vertical bin"
            {  0  IF (IZ~=DEEPNUM) [ "only for grid cut by PGTHROW"
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(IZ+1);]
            {  0  IF (FMT=2) [WRITE (IOUT, 11) DEPTH_BINS(IZ+1);]
            {  0  IF (FMT=3) [WRITE (IOUT, 12) DEPTH_BINS(IZ+1);]
            {  0  "Start a new page"
            {  0  WRITE (IOUT, *) '\f'; "page break"
            {  0  PGTHROW=15;
            {  0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
            {  0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
            {  0  ELSE [WRITE(IOUT, 94) TITLE;]
            {  0  WRITE (IOUT, 91) (RADIAL_BINS(IX), IX=HSET,HSET+FMT);
            {  0  ]
            {  0  "The following statement delays the page throw until the "
            {  0  "last line of the grid can be printed"
            {  0  ELSE [ DLYPT = HSET;]]
            {  0  ] "end DO IZ"
            {  0  "This is for the last vertical bin"
            {  0  IF (FMT=1) [WRITE (IOUT, 10) DEPTH_BINS(DEEPNUM+1);]
            {  0  IF (FMT=2) [WRITE (IOUT, 11) DEPTH_BINS(DEEPNUM+1);]
            {  0  IF (FMT=3) [WRITE (IOUT, 12) DEPTH_BINS(DEEPNUM+1);]
            {  0  "For the delayed page throw"
            {  0  IF ((DLYPT=HSET)&(RADNUM-HSET>2)) [
            {  0  "Start a new page"
            {  0  WRITE (IOUT, *) '\f'; "page break"
            {  0  PGTHROW=17;
            {  0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
            {  0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
            {  0  ELSE [WRITE(IOUT, 94) TITLE;]
            {  0  ]
            {  0  PGTHROW=PGTHROW+1;
            {  0  }
               0
               0  ;COMIN/IODAT1/; "COMMON BLOCK is for TITLE, TIMEN and DATEN"
               0  $INTEGER RADNUM, DEEPNUM, NRADIAL, NDEPTH, NCOMP, REGNUM, FMT, TMP1;
               0  $LOGICAL ESTEPSON, ECUTON, PCUTON, ROT;
               0  $REAL VALUES($MAXZREG,$MAXRADII,$MAXCMPTS),
               0  RCYL($MAXRADII),ZPLANE($MAXZREG),
               0  RADIAL_BINS($MAXRZ),DEPTH_BINS($MAXRZ),
               0  MASSVOL($MAXZREG,$MAXRADII),
               0  ECUTS($MXREG), PCUTS($MXREG),
               0  TMP2($MAXZREG,$MAXRADII,$MAXCMPTS),TMP3($MAXRZ),CHINDEX($MAXRZ);
               0  CHARACTER*60 EXPLANATIONS($MAXCMPTS);
               0  CHARACTER*4 LABELS($MAXCMPTS);
               0  CHARACTER*4 MED_NAME1(11),MED_NAME2(11),MED_NAME3(11);
               0  CHARACTER*4 MEDIA(24, $MXMED);
               0  CHARACTER*4 CDSTBL($MXREG), CTRTBL($MXREG),CABSRB($MXREG);
               0  $SHORT_INT MED($MXREG);
               0  $INTEGER MNUM1, MNUM2, MNUM3, MORV;
               0  $INTEGER IOUT, ICOMP, IZ, IX, IRL, HSET, PGTHROW, DLYPT, J, COUNT;
               0  ROT=.FALSE.; "For a rotated grid (.FALSE. = off)"
               0  ESTEPSON=.FALSE.;ECUTON=.FALSE.;PCUTON=.FALSE.; "default these options off"
               0
               0  NCOMP=1; "start the grid with one component(minimum)"
               0  PGTHROW=14+NCOMP; "For printing: throw page at 66 lines(15 1st for title)"
               0
               0  IOUT=1; "Designates output to file fort.1, the *.egs4lst file"
               0  "Set up the bin number indicators"
               0  DEEPNUM=NDEPTH;RADNUM=NRADIAL;
               0  "Set up the bin indicators"
               0  IF (RCYL(1)=0.) [DO IX=1,RADNUM+1 [RADIAL_BINS(IX)=RCYL(IX);]]
               0  ELSE [DO IX=1,RADNUM+1 [RADIAL_BINS(IX+1)=RCYL(IX);]]
               0  DO IZ=1,DEEPNUM+1 [DEPTH_BINS(IZ)=ZPLANE(IZ);]
               0  "Load the array of VALUES to be output"
               0  IF (MORV=1) [
               1      LABELS(NCOMP)='MASS';
               1      EXPLANATIONS(NCOMP)='MASS OF EACH REGION IN GRAMS';
               1      ]
               0  IF (MORV=2) [
               1      LABELS(NCOMP)='VOL ';
               1      EXPLANATIONS(NCOMP)='VOLUME OF EACH REGION IN cm^3';
               1      ]
               0  DO IX=1, RADNUM [
               1      DO IZ=1, DEEPNUM [
               2          VALUES(IZ, IX, NCOMP)=MASSVOL(IZ, IX);
               2          IRL=IZ+DEEPNUM*(IX-1)+1;
               2          IF (CDSTBL(1)='0') [CDSTBL(IRL)=' ';]
               2          IF (CTRTBL(1)='0') [CTRTBL(IRL)=' ';]
               2          IF (CABSRB(1)='0') [CABSRB(IRL)=' ';]
               2          IF (ECUTS(IRL)~=ECUTS(2)) [ECUTON=.TRUE.;]
               2          IF (PCUTS(IRL)~=PCUTS(2)) [PCUTON=.TRUE.;]
               2          ]
               1      ]
               0  IF (ECUTON) [
               1      NCOMP=NCOMP+1;
               1      LABELS(NCOMP)='ECUT';
               1      EXPLANATIONS(NCOMP)='ECUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL)';
               1      DO IX=1, RADNUM [
               2          DO IZ=1, DEEPNUM [
               3              IRL=IZ+DEEPNUM*(IX-1)+1;
               3              VALUES(IZ, IX, NCOMP)=ECUTS(IRL);
               3              ]
               2          ]
               1      ]
               0  IF (PCUTON) [
               1      NCOMP=NCOMP+1;
               1      LABELS(NCOMP)='PCUT';
               1      EXPLANATIONS(NCOMP)='PCUT (PRINTED BECAUSE DIFFERENT FROM GLOBAL)';
               1      DO IX=1, RADNUM [
               2          DO IZ=1, DEEPNUM [
               3              IRL=IZ+DEEPNUM*(IX-1)+1;
               3              VALUES(IZ, IX, NCOMP)=PCUTS(IRL);
               3              ]
               2          ]
               1      ]
               0  PGTHROW=14+NCOMP; "For printing: throw page at 66 lines(for title)"
               0  "Check for rotation of the grid"
               0  IF ((DEEPNUM<=3)&(RADNUM>3))[
               1      ROT=.TRUE.;
               1      CHINDEX(RADNUM+1)=RADIAL_BINS(RADNUM+1);
               1      DO IX=1, RADNUM [
               2          TMP3(IX)=DEPTH_BINS(IX);
               2          CHINDEX(IX)=RADIAL_BINS(IX);
               2          DEPTH_BINS(IX)=CHINDEX(IX);
               2          RADIAL_BINS(IX)=TMP3(IX);
               2          DO IZ=1, DEEPNUM [
               3              DO ICOMP=1, NCOMP [
               4                  TMP2(IZ, IX, ICOMP)=VALUES(IZ, IX, ICOMP);
               4                  ] "end do ICOMP"
               3              ] " end DO IZ"
               2          ] "end DO IX"
               1      DO IX=1, RADNUM [
               2          DO IZ=1, DEEPNUM [
               3              DO ICOMP=1, NCOMP [
               4                  VALUES(IX, IZ, ICOMP)=TMP2(IZ, IX, ICOMP);
               4                  ]
               3              ]
               2          ]
               1      DEPTH_BINS(RADNUM+1)=CHINDEX(RADNUM+1);
               1      TMP1=RADNUM;RADNUM=DEEPNUM;DEEPNUM=TMP1;
               1      ] "end check for rotation"
               0  WRITE (IOUT, *) '\f'; "Page break"
               0  WRITE(IOUT, 400) ' '; call egs_fdate(iout); write(iout,'(//)');
               0  IF (ROT) [WRITE(IOUT, 93) TITLE;]
               0  ELSE [WRITE(IOUT, 94) TITLE;]
               0  WRITE(IOUT, 95) (LABELS(ICOMP), EXPLANATIONS(ICOMP), ICOMP=1, NCOMP);
               0  "Make the grids"
               0  DO HSET=1,RADNUM,3 [$MKGRID;] "Feed in horiz. sets of three"
               0  "FORMATS"
               0  1        FORMAT (T11, '|', 2X, A4, 2X, 1PE10.3, 2X, ' |');
               0  2        FORMAT (T11, '|', 2 (2X, A4, 2X, 1PE10.3, 2X, ' |'));
               0  3        FORMAT (T11, '|', 3 (2X, A4, 2X, 1PE10.3, 2X, ' |'));
               0  4        FORMAT (T11, '|', 1X, '/', 3 (A1, '/'), 11A1, '  |');
               0  5        FORMAT (T11, '|', 2 (1X, '/', 3 (A1, '/'), 11A1, '  |'));
               0  6        FORMAT (T11, '|', 3 (1X, '/', 3 (A1, '/'), 11A1, '  |'));
               0  10       FORMAT (1X, F9.4, T11, 23 ('-'));
               0  11       FORMAT (1X, F9.4, T11, 45 ('-'));
               0  12       FORMAT (1X, F9.4, T11, 67 ('-'));
               0  13       FORMAT (T11, '|',
               0  3 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|'));
               0  14       FORMAT (T11, '|',
               0  2 ('IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|'));
               0  15       FORMAT (T11, '|',
               0  'IRL', I3, 1X, 'IZ ', I3, 1X, 'IX ', I3, 1X, '|');
               0  91       FORMAT (/ T7, F9.4, T30, F9.4, T53, F9.4, T70, F9.4);
               0  93       FORMAT (' ',79A1 //
               0  T19, 29H ZONAL MATERIAL GRID: ROTATED /
               0  T21, '**************************'/,
               0  /T4 , '/X/Y/Z/MED :  X = " " IS DEFAULT: OPTION NOT USED'/,
               0  T18, '  = "D" IF DOSE SCORING REGION'/,
               0  T18, 'X = "C" IF CAVITY REGION'/,
               0  T18, 'X = "S" IF SPR SCORING REGION'/,
               0  T18, 'Y = "T" IF TRACKING REGION'/,
               0  T18, 'Z = "A" IF TOTALLY ABSORBING REGION'/,
               0  T16, 'MED = MEDIUM NAME, 11 CHARACTER ABREVIATION');
               0  94       FORMAT (' ',79A1 //
               0  T19, 33H ZONAL MATERIAL GRID: NON-ROTATED /
               0  T21, '******************************'/
               0  /T4 , '/X/Y/Z/MED :  X = " " IS DEFAULT: OPTION NOT USED'/,
               0  T18, '  = "D" IF DOSE SCORING REGION'/,
               0  T18, '  = "C" IF CAVITY REGION'/,
               0  T18, '  = "S" IF SPR SCORING REGION'/,
               0  T18, 'Y = "T" IF TRACKING REGION'/,
               0  T18, 'Z = "A" IF TOTALLY ABSORBING REGION'/,
               0  T16, 'MED = MEDIUM NAME, 11 CHARACTER ABREVIATION');
               0  95       FORMAT (T10, A4, ' = ', A60);
               0  400      FORMAT (/T54,a1,$);
               0
               0  RETURN;
               0  END;
               0  "    end of grids.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc auxiliary routines for NRC user codes                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These are auxiliary routines used in many NRC user codes.                  "
               0  "                                                                             "
               0  "  If you include them via your configuration file, your user code will need  "
               0  "  to define $MXDATA and $STAT. For example, if you are not using the         "
               0  "  statistical analysis package:                                              "
               0  "                                                                             "
               0  "  REPLACE {$MXDATA} WITH {1}; REPLACE{$STAT} WITH {1};                       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80                                                                           ;
               0  "*****************************************************************************"
               0  "                                                                             "
               0  "                        WATCH                                                "
               0  "                                                                             "
               0  SUBROUTINE WATCH(IARG,IWATCH);
               0
               0  "============================================================================="
               0  "                                                                             "
               0  "     A general purpose auxiliary routine for use with the EGSnrc system
               0  "
               0  "     It prints out information about the particle transport                  "
               0  "                                                                             "
               0  "       For IWATCH = 1 it prints information about each discrete interaction  "
               0  "       For IWATCH = 2 or 3 it prints information about each step as well     "
               0  "       For IWATCH = 4 it prints graphing data for use with EGS_Windows       "
               0  "                                                                             "
               0  "                                                                             "
               0  "    Routine is used via two mandatory and 1 optional call from the user's    "
               0  "          code                                                               "
               0  "                                                                             "
               0  "   1)The routine must be initialized by a call with IARG=-99 before the first"
               0  "          call to SHOWER. It should be after all inputs are in place.        "
               0  "   2)The routine must be called near the beginning of the AUSGAB subroutine  "
               0  "          IF (IWATCH > 0 ) CALL WATCH(IARG,IWATCH);                          "
               0  "   3)The routine may be called at the end of each history with IARG = - 1 so "
               0  "          a message will get printed stated history is complete              "
               0  "                                                                             "
               0  "    Since WATCH cannot output values related to the initial values in a      "
               0  "    shower call, it is useful to also put something like the following       "
               0  "    immediately prior to the CALL SHOWER stmt                                "
               0  "           IF((IWATCH ~= 0) & (IWATCH ~= 4))[                                "
               0  "              OUTPUT 1,EIN,IQI,IRI,XI,YI,ZI,UI,VI,WI,LATCHI,WTI;              "
               0  "               (/' INITIAL SHOWER VALUES',T36,':',                           "
               0  "               I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);                         "
               0  "           ]                                                                 "
               0  "    Note EIN is the kinetic energy of the incident particle                  "
               0  "                                                                             "
               0  "                                                                             "
               0  "   The routine uses up to 132 columns for output.                            "
               0  "                                                                             "
               0  "     JAN 1984  GENERALIZED VERSION WITH INITIALIZATION                       "
               0  "                              DAVE ROGERS NRCC                               "
               0  "     JUN 1987  PUT IN IWATCH = 4 OPTION     AFB                              "
               0  "     JUL 1988  COMPATIBLE WITH X-RAY FLUORESCENCE  DWOR                      "
               0  "     SEP 1990  ADDED ENERGY OUTPUT TO IWATCH = 4 OPTION     AFB              "
               0  "     OCT 1990  UNIX compatible carriage control   DWOR                       "
               0  "     JAN 2000  Rewritten to output relaxation particles and also             "
               0  "               so some of the output makes more sense BW                     "
               0  "                                                                             "
               0  "*****************************************************************************"
               0
               0  "define a local macro"
               0  REPLACE {$CNTOUT(#);(#);} WITH {
            {  0  ICOUNT=ICOUNT+1;
            {  0  OUTPUT {P1},KE,IQ({P1}),IR({P1}),X({P1}),Y({P1}),Z({P1}),U({P1}),V({P1}),
            {  0  W({P1}),LATCH({P1}),WT({P1});  ({P2},I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            {  0  }
               0
               0  $IMPLICIT-NONE;
               0  $INTEGER iarg,iwatch,IP,ICOUNT,JHSTRY,J,N;
               0  $REAL KE;
               0  $INTEGER graph_unit;
               0  integer  egs_open_file;
               0  $INTEGER ku,kr,ka;
               0
               0  ;COMIN/BOUNDS, STACK,EPCONT,EGS-VARIANCE-REDUCTION,USEFUL,EGS-IO/;
               0
               0  DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/;
               0  save     ICOUNT,JHSTRY,graph_unit;
               0
               0  ku = 13; kr = 0; ka = 1;
               0  IF(IARG = -99) [ "Initialize flags so we will get calls thru AUSGAB"
               1      DO J=1,29[IAUSFL(J)=1;];
               1      /IAUSFL(22),IAUSFL(23),IAUSFL(24)/=0;
               1      ]
               0
               0  IF(IARG = -1) ["main is assumed to call AUSGAB with IARG=-1 at end of history"
               1      IF(IWATCH = 4) [
               2          IF( graph_unit < 0 ) [
               3              graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               3              ]
               2          WRITE(graph_unit,:GRAPHICS_FORMAT:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
               2          JHSTRY=JHSTRY+1;
               2          ]
               1      ELSE[
               2          OUTPUT JHSTRY;(' END OF HISTORY',I8,3X,40('*')/);
               2          JHSTRY=JHSTRY+1;ICOUNT=ICOUNT+2;RETURN;
               2          ]
               1      ]
               0
               0  IF( (IWATCH ~= 4) & ((ICOUNT >= 50) | (ICOUNT = 0) | (IARG = -99)) )[
               1      "PRINT HEADER"
               1      ICOUNT=1;
               1      OUTPUT;(//T39,' NP',3X,'ENERGY  Q REGION    X',7X,
               1      'Y',7X,'Z',6X,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/);
               1      ]
               0
               0  IF((IWATCH = 4) & (IARG >= 0) & (IARG ~= 5)) [ "GRAPHICS OUTPUT"
               1      IF( graph_unit < 0 ) graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               1      WRITE(graph_unit,:GRAPHICS_FORMAT:) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP);
               1      :GRAPHICS_FORMAT:FORMAT(2I4,1X,I6,4G15.8,I12);
               1      ]
               0
               0  IF(IARG = 5  |  IARG < 0) RETURN;
               0  IF(IWATCH = 4) RETURN; "NONE OF THE REST NEEDED FOR GRAPHICS OUTPUT"
               0
               0  KE=E(NP);IF(IQ(NP).NE.0)[KE=E(NP)-PRM;]
               0
               0  IF(IARG = 0 & IWATCH = 2)[
               1      $CNTOUT(NP);(T11,'STEP ABOUT TO OCCUR', T36,':');
               1      ]
               0  ELSEIF(IARG = 0)[RETURN;]
               0  IF(    IARG = 1)[
               1      $CNTOUT(NP);(' Discard  AE,AP<E<ECUT',T36,':');]
               0  ELSEIF(IARG = 2)[
               1      $CNTOUT(NP);(' Discard  E<AE,AP',T36,':');]
               0  ELSEIF(IARG = 3)[
               1      $CNTOUT(NP);(' Discard -user request',T36,':');]
               0  ELSEIF(IARG = 4)[OUTPUT EDEP,IR(NP);
               1      (T10,'Local energy deposition',T36,':',F12.5,' MeV in region ',I6);]
               0
               0  ELSEIF(IARG = 6)[
               1      $CNTOUT(NP);(' bremsstrahlung  about to occur',T36,':');]
               0  ELSEIF(IARG = 7)[
               1      IF(nbr_split =1) ["no splitting or SBS is on in BEAMnrc"
               2          DO IP=NPold,NP[
               3              IF(IQ(IP)=-1)[
               4                  KE = E(IP) - RM;
               4                  $CNTOUT(IP);(T10,'Resulting electron',T36,':');
               4                  ]
               3              ELSE[
               4                  KE = E(IP);
               4                  $CNTOUT(IP);(T10,'Resulting photon',T36,':');
               4                  ]
               3              ]
               2          ]
               1      ELSE ["splitting case--e- is always at NPold"
               2          KE = E(NPold) - RM;
               2          $CNTOUT(NPold);(T10,'Resulting electron',T36,':');
               2          DO IP=NPold+1,NP[
               3              KE= E(IP);
               3              IF(IP = NPold+1)["print info for first one only"
               4                  $CNTOUT(IP);(T10,'Split photons',T36,':');
               4                  ]
               3              ELSE[ $CNTOUT(IP);(T36,':'); ]
               3              ]
               2          ]" end of splitting block"
               1      ]
               0
               0  ELSEIF(IARG = 8)[$CNTOUT(NP);(' Moller   about to occur',T36,':');]
               0  ELSEIF(IARG = 9)[
               1      "surely this logic not needed?"
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(NP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting electrons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 10)[
               1      $CNTOUT(NP);(' Bhabba   about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 11)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[ $CNTOUT(IP);(T11,'Resulting e- or e+',T36,':'); ]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 12)[
               1      $CNTOUT(NP);(' Positron about to decay in flight',T36,':');
               1      ]
               0  ELSEIF(IARG = 13)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting photons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 28)[
               1      $CNTOUT(NP);(' Positron will annihilate at rest',T36,':');
               1      ]
               0  ELSEIF(IARG = 14)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(' Positron annihilates at rest',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 15)[
               1      $CNTOUT(NP);(' Pair production about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 16)["after pair production"
               1      IF(NP=NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP=NPold & i_survived_rr > 0)["we have cleared the stack"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting pair',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          IF(i_survived_rr > 0)[
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I2,'
            '  3              particle(s) with probability ',F8.5);
               3              $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 17)[$CNTOUT(NP);(' Compton  about to occur',T36,':');]
               0  ELSEIF(IARG = 18)["after call to COMPT"
               1      IF(NP = NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP > NPold)["have not cleared the stack with rus rou"
               2          DO IP=NPold,NPold+1[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IQ(IP).NE.0)[$CNTOUT(IP);(T11,'compton electron created',T36,':');]
               3              ELSE[$CNTOUT(IP);(T11,'compton scattered photon',T36,':');]
               3              ]
               2          ]
               1      IF(i_survived_rr > 0)["whether the stack has been cleared or not"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 19)[
               1      $CNTOUT(NP);(' Photoelectric about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 20)[
               1      IF(NPold=NP & IQ(NP)=0 & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Photon energy below N-shell',/,
               2          T11,'Photon discarded',T36,':');
               2          ]
               1      ELSEIF(IQ(NPold) = -1 & i_survived_rr = 0)[
               2          KE= E(NPold)-RM;
               2          $CNTOUT(NPold);(T10,'Resulting photoelectron',T36,':');
               2          ]
               1      ELSEIF(i_survived_rr > 0)["done some russian roulette"
               2          IF(NP=NPold-1 | IQ(NPold) ~= -1)[
               3              IF(i_survived_rr > 1)["eliminated more than the photoelectron"
               4                  OUTPUT i_survived_rr-1,prob_rr;
               4                  (T10,'Russian Roulette eliminated ',I4,
               4                  ' particle(s) with probability ',F8.5,' plus');
               4                  ]
               3              OUTPUT prob_rr;
               3              (T10,'Russian Roulette eliminated resulting photoelectron',
               3              ' with probability ',F8.5);
               3              ]
               2          ELSE["NPold could hold the photoelectron"
               3              KE = E(NPold) - RM;
               3              $CNTOUT(NPold);(T10,'Resulting photoelectron?',T36,':');
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I4,
               3              ' particle(s) with probability ',F8.5);
               3              ]
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 24)[$CNTOUT(NP);(' Rayleigh scattering occured',T36,':');]
               0
               0  ELSEIF(IARG = 25)[$CNTOUT(NP);(T10,'Fluorescent X-ray created',T36,':');]
               0
               0  ELSEIF(IARG = 26)[$CNTOUT(NP);(T10,'Coster-Kronig e- created',T36,':');]
               0
               0  ELSEIF(IARG = 27)[$CNTOUT(NP);(T10,'Auger electron created',T36,':');]
               0
               0  IF(IARG = 0  &  IWATCH = 2)[OUTPUT  USTEP,TUSTEP,VSTEP,TVSTEP,EDEP;
               1      (T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4));ICOUNT=ICOUNT+1;]
               0
               0  IF(NP = 1  |  IARG = 0) RETURN;
               0  IF( IARG <= 3)[
               1      N=NP-1;
               1      KE = E(N) - ABS(IQ(N))*RM;
               1      $CNTOUT(N);(T10,'Now on top of stack',T36,':');
               1      ]
               0  RETURN;END;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E
               0  "*******************************************************************************
               0  "
               0  "
               0  "                       *****************
               0  "                       *               *
               0  "                       * SIGMA.MORTRAN *
               0  "                       *               *
               0  "                       *****************
               0  "
               0  "
               0  "       SIGMA IS A STATISTICAL ANALYSIS ROUTINE DESIGNED TO BE USED BY EGS
               0  "       USER PROGRAMS TO GIVE THE TOTALS OR AVERAGES AND THEIR UNCERTAINTIES
               0  "       OF THE DATA CALCULATED BY THE MONTE CARLO CODE.
               0  "       THE UNCERTAINTIES ARE RETURNED AS PERCENTS.
               0  "
               0  "       VARIABLES
               0  "       =========
               0  "
               0  "       DATA(NDATA,ISTAT)       THE TWO DIMENSIONAL ARRAY OF DATA TO BE
               0  "                               ANALYZED. ISTAT IS THE NUMBER OF STATISTICAL
               0  "                               BATCHES AND NDATA IS THE NUMBER OF ERRORS TO
               0  "                               BE CALCULATED. AFTER THE END OF THE CALCULATION,
               0  "                               DATA(N,1) CONTAINS THE TOTAL OR AVERAGE AND
               0  "                               DATA(N,2) CONTAINS THE ERROR. NDATA SHOULD
               0  "                               BE < OR = $MAXDATA AND ISTAT SHOULD BE < OR =
               0  "                               $STAT WHCH MUST BE DEFINED IN THE MAIN ROUTINE.
               0  "                               Note $STAT must be 2 or greater, even if istat=1
               0  "
               0  "       MODE    =  0 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS
               0  "                               IGNORED. (eg. STOPPING POWER RATIO)
               0  "               =  1 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS NOT
               0  "                               IGNORED. (e.g. DOSE)
               0  "               =  2 =>         ANALYSIS ON TOTAL VALUES (eg. TOTAL EDEP)
               0  "
               0  "       IERR    =  0 =>         NORMAL COMPLETION.
               0  "               =  1 =>         WARNING: MODE OUT OF RANGE, DEFAULTED TO 0
               0  "               = 10 =>         ERROR: ONLY ONE BATCH INPUT, QUICK CALCULATION
               0  "                                      DONE. ERROR=99.9%
               0  "               = 11 =>         ERROR: NO NON-ZERO DATA FOUND IN A GIVEN SET,
               0  "                                       ERROR=99.9%
               0  "               = -1 =>         FATAL ERROR: NDATA OR ISTAT OUT OF RANGE, NO
               0  "                                            CALCULATION DONE.
               0  "
               0  "
               0  "               VERSION  1      A.F.B.  83/7/22
               0  "               Version  2      IK      Jan 6 6000 implemented implicit none
               0  "
               0  "*******************************************************************************
1              0  %E
               0  SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR);
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER NDATA,ISTAT,MODE,IERR;
               0
               0  REPLACE {;COMIN/ERROR/;} WITH {
            {  0  ;COMMON/ERROR/DATA($MXDATA,$STAT);
            {  0  $REAL data;
            {  0  }
               0  ;COMIN/ERROR,EGS-IO/;
               0
               0  $INTEGER n,non0,i;
               0  $REAL    stat,sdenom;
               0  real*8   emax,avg,error,datum,argmnt;
               0  "It is a good idea to use double precision"
               0  "in cases with very low stat. uncertainties"
               0
               0  DATA EMAX/99.9/;
               0
               0  IERR=0; "ASSUME NORMAL COMPLETION"
               0
               0  "TEST INPUTS AND SET ERROR CODES AND RETURN IF NEEDED."
               0
               0  IF((MODE < 0) | (MODE > 2)) [MODE=2;IERR=1;]
               0
               0  IF((NDATA.LE.0).OR.(NDATA.GT.$MXDATA).OR.(ISTAT.LE.0).OR.(ISTAT.GT.$STAT)) [
               1      IERR=-1;RETURN;"FATAL INPUT ERROR, RETURN IMMEDIATELY"
               1      ]
               0  IF(ISTAT = 1)[
               1      IERR=10;"ONLY ONE STATISTICAL BATCH, QUICK CALCULATION"
               1      DO N=1,NDATA[DATA(N,2)=EMAX;]
               1      RETURN;
               1      ]
               0
               0  "MOST ANOMALIES HAVE BEEN HANDLED. NOW DO THE ANALYSIS"
               0
               0  IF(MODE.NE.0)[STAT=FLOAT(ISTAT);SDENOM=STAT*(STAT-1.);]
               0  DO N=1,NDATA[
               1      NON0=0;             "NON-ZERO COUNTER"
               1      AVG=0.0;ERROR=0.0;
               1      DO I=1,ISTAT[
               2          DATUM=DATA(N,I);
               2          IF(DATUM.NE.0.0)[NON0=NON0+1;AVG=AVG+DATUM;ERROR=ERROR+DATUM**2;]
               2          ]
               1      IF(NON0 = 0)[IERR=11;ERROR=EMAX;GOTO :TRANSFER:;"NO NON-ZERO DATA "]
               1
               1      ELSEIF((NON0 = 1) & (MODE = 0))[ERROR=EMAX;GOTO:TRANSFER:;"ONLY ONE DATUM"]
               1
               1      ELSE[
               2          IF(MODE = 0)[STAT=FLOAT(NON0);SDENOM=STAT*(STAT-1.);]
               2          ]
               1
               1      AVG=AVG/STAT;ARGMNT=ERROR-STAT*AVG**2;
               1      "FLAG -VE SQUARE ROOTS THAT CAN ONLY OCCUR DUE TO ROUND-OFF ERRORS"
               1      IF(ARGMNT.LT.0.0)[
               2          OUTPUT ARGMNT,ERROR,STAT,AVG,SDENOM;
               2          (' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM='/' ',5E12.4);
               2          ARGMNT=0.0;
               2          ]
               1      ERROR=SQRT(ARGMNT/SDENOM);
               1
               1      IF(AVG = 0.)[ERROR=EMAX;]ELSE[ERROR=100.*ERROR/ABS(AVG);]
               1
               1      IF(MODE =  2)AVG=AVG*STAT;
               1
               1      :TRANSFER:;
               1      DATA(N,1)=AVG;DATA(N,2)=MIN(EMAX,ERROR);
               1      ] "END OF NDATA LOOP"
               0  RETURN;
               0  END; "END OF SIGMA"
               0  ;
               0
               0  "*****************************************************************************
               0  " The following are routines that implement
               0  " the alias sampling technique for sampling from a histogram
               0  " distribution coded for use with EGSnrc
               0  "
               0  " subroutine prepare_alias_sampling
               0  " function   alias_sample
               0  "
               0  " I. Kawrakow, January 2000
               0  "
               0  "*****************************************************************************
               0
               0  subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_array);
               0  "====================================================================
               0  "
               0  " inputs:  nsbin:    number of bins in the histogram
               0  "          fs_array: bin probabilities
               0  "
               0  " Note that we don't need the bin limits at this point, they
               0  " are needed for the actual sampling (in alias_sample)
               0  "
               0  " outputs: ws_array, ibin_array: alias table ready for sampling
               0  "
               0  "====================================================================
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     fs_array(nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      IF( fs_array(i) < 1e-30 ) fs_array(i) = 1e-30;
               1      ws_array(i) = -fs_array(i); ibin_array(i) = 1;
               1      sum = sum + fs_array(i);
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return;
               0  end;
               0
               0
               0  $REAL function alias_sample(nsbin,xs_array,ws_array,ibin_array);
               0  "===============================================================
               0  "
               0  " samples from an alias table which must have been prepared
               0  " using prepare_alias_table
               0  "
               0  "===============================================================
               0
               0  implicit none;
               0
               0  $INTEGER nsbin,ibin_array(nsbin);
               0  $REAL    xs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    v1,v2,aj;
               0  $INTEGER j;
               0
               0  $RANDOMSET v1; $RANDOMSET v2;
               0  aj = 1 + v1*nsbin; j = aj;
               0  IF( j > nsbin ) j = nsbin; " this happens only if $RANDOMSET produces
               0  " numbers in (0,1]
               0  aj = aj - j;
               0  IF( aj > ws_array(j) ) [ j = ibin_array(j); ]
               0  alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j);
               0  return;
               0  end;
               0  ;
1              0  %E
               0  ;
               0  "==========================end of nrcaux.mortran======================"
               0
               0
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc xvgr plotting subroutines                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Andrew Booth, 1995                                        "
               0  "                                                                             "
               0  "  Contributors:    Charlie Ma                                                "
               0  "                   Aaron Merovitz                                            "
               0  "                   Dave Rogers                                               "
               0  "                   Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  !INDENT F2;
               0  %I4                                                                            ;
               0  %Q1                                                                            ;
               0  "************************************************************************"
               0
               0  SUBROUTINE XVGRPLOT (X, Y, ERRY, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, TYPE, HISTXMIN, AXISTYPE);
               0
               0  "************************************************************************"
               0  "                                                                        "
               0  "  This subroutine is used to create an xvgr plot file that will plot    "
               0  "  Y as a function of X and include all of the pertinent information for "
               0  "  the graph.  Each time the subroutine is called it writes one series   "
               0  "  worth of data points to the unit specified.  For graphs that use      "
               0  "  several series, multiple subroutine calls are required.               "
               0  "                                                                        "
               0  "  Written  by:  Andrew Booth, August 1995                               "
               0  "  Modified by:  C-M Ma, Sept. 1995                                      "
               0  "  Modified by:  Andrew Booth, July 1996                                 "
               0  "                - introduced AXISTYPE argument to handle lin and log    "
               0  "                  axis combinations.                                    "
               0  "   Jan 98 A Merovitz/DR added xview xmin value so y axis label displayed"
               0  "   Feb 98 A Merovitz/DR if non-negative, makes zeros fudge*smalest      "
               0  "   Jun 99 BW/DWOR in Y>0 and ERRY crosses/touches 0, adjusted>0.0       "
               0  "   Jul 99 DWOR made grace/xmgr compatible and added timestamp           "
               0  "                                                                        "
               0  "  The arguments of the subroutine are described in detail below:        "
               0  "                                                                        "
               0  "     1) X - array of x values to be plotted.  Top of bin if histogram.  "
               0  "     2) Y - corresponding array of y values to be plotted.              "
               0  "     3) ERRY - array containing uncertainties in Y for the plot.        "
               0  "            If the first entry of this array is 0, it is                "
               0  "            assumed that the graph is of type XY.  If it is             "
               0  "            not 0, the graph is of type XY-DY.                          "
               0  "     4) NPTS - the number (integer) of points to be plotted. This       "
               0  "            should be the number of data points that exist in the       "
               0  "            X, Y, and ERRY arrays.                                      "
               0  "     5) CURVENUM - the number (integer) of the curve that is to be      "
               0  "            plotted. The first curve number should be 0.  If this       "
               0  "            number is not 0, then it is assumed that the plot file      "
               0  "            already exists and the subroutine call is to add an         "
               0  "            additional series to the existing graph.                    "
               0  "     6) SERIESTITLE - string (max of 60 characters) giving the          "
               0  "            series title (legend) for the data in the X and Y arrays.   "
               0  "     7) XTITLE - string (max of 60 characters) giving the x axis        "
               0  "            title.                                                      "
               0  "     8) YTITLE - string (max of 60 characters) giving the y axis        "
               0  "            title.                                                      "
               0  "     9) GRAPHTITLE - string (max of 60 characters) giving the           "
               0  "            graph title.                                                "
               0  "    10) SUBTITLE - string (max of 60 characters) giving the subtitle    "
               0  "            for the graph.                                              "
               0  "    11) UNITNUM - number (integer) specifying where the data is to      "
               0  "            be written.                                                 "
               0  "            this unit must be opened by the calling routine             "
               0  "    12) TYPE - 0 if data is to be written as normal point plot.         "
               0  "               1 if data is to be written as a histogram plot.          "
               0  "    13) HISTXMIN - used for histogram plots only.  This is a real       "
               0  "                   number with the value of lower xbin for the plot.    "
               0  "    14) AXISTYPE - 0 if linear-linear plot                              "
               0  "                   1 if log-linear plot (y = log; x = lin)              "
               0  "                   2 if linear-log plot (y = lin; x = log)              "
               0  "                   3 if log-log plot                                    "
               0  "                                                                        "
               0  "                                                                        "
               0  "************************************************************************"
               0  REPLACE{$SMALLFACTOR} WITH {1.E-5}
               0  REPLACE{$LARGEFACTOR} WITH {1.E5}
               0
               0  IMPLICIT NONE;
               0
               0  $INTEGER MAX, IDEBUG;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,HISTXMIN,ERRYOLD,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY, LOGDY,ZEROYCOUNT;
               0
               0  "CHARACTER*80 SUBTITLE;"
               0  "CHARACTER*60 GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;"
               0  " IK changed the above to avoid complains from the compiler about"
               0  " inconsistent argument lists"
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  CHARACTER*10 INDEX;
               0  CHARACTER*3  INDEXNUM;
               0
               0  $LOGICAL TESTFILE, ALLPOS;
               0  $REAL    one;
               0  parameter (one = 1);
               0
               0  FUDGE = 1.e-10;              "If a number in the gaph is zero, it is replaced"
               0  "by the (smallest number in the gaph)*(FUDGE)"
               0  IDEBUG = 0;  "set to 1 to get debug stmts active"
               0  IF (IDEBUG = 1) [
               1      write(6,'(//'' Entering xvgrplot ''/)');
               1      write(6,'('' Curve'',I3,'' to go to unit'',I3)')CURVENUM,UNITNUM;
               1      write(6,'(''SERIESTITLE: '',a60)') SERIESTITLE;
               1      write(6,'(''XTITLE:      '',a60)') XTITLE;
               1      write(6,'(''YTITLE       '',a60)') YTITLE;
               1      write(6,'(''GRAPHTILE:   '',a60)') graphtitle;
               1      write(6,'(''SUBTITLE:    '',a80)') subtitle;
               1      ]
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  "---Check to make sure that speicified unit is open for---"
               0  "---writing to.---"
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0  "---Set defaults if arguments are left blank.---"
               0  IF (GRAPHTITLE = ' ') [
               1      GRAPHTITLE = 'Untitled Graph - No title specified in subroutine';
               1      ]
               0  IF (XTITLE = ' ') [ XTITLE = 'X-axis not titled in subroutine';  ]
               0
               0  IF (YTITLE = ' ') [ YTITLE = 'Y-axis not titled in subroutine'; ]
               0
               0  IF (SERIESTITLE = ' ') [
               1      SERIESTITLE = 'series # ';
               1      INDEX = '0123456789';
               1      INDEXNUM = INDEX(CURVENUM+1:CURVENUM+1);
               1      SERIESTITLE(9:9) = INDEXNUM;
               1      ]
               0
               0  "---Find lengths of stings for formatting purposes---"
               0  "---Initialize variable lengths---"
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0  IF( IDEBUG = 1) [
               1      OUTPUT SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH;
               1      (' SERIESLENGTH,YAXISLENGTH,XAXISLENGTH,SUBLENGTH,TITLELENGTH'/
               1      5I10)
               1      ]
               0
               0  "---Small bit of error checking here done for the purpose of warning the---"
               0  "---user if there is a problem when using a 'log' type graph.           ---"
               0  "---Possible problems are:                                              ---"
               0  "---    1.)  value on log scale < or = 0.                               ---"
               0  "---    2.)  value of error bar for xydy plot extends into the region   ---"
               0  "---                    where y < or = 0.                               ---"
               0  "---                                                                    ---"
               0  "---To keep track of these problems the flags LOGX, LOGY, and LOGDY will---"
               0  "---be set if there is the respective error.                            ---"
               0  "---(ie.  if LOGX set (=1) then there exist an X value that is <= 0 AND ---"
               0  "--- the xaxis is set to be a log scale.)                               ---"
               0  "--------------------------------------------------------------------------"
               0
               0  "---Initialize LOGX, LOGY, and LOGDY to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;          LOGDY = 0;
               0
               0  "---Initialize ZEROYCOUNT to 0---"
               0  ZEROYCOUNT=0;
               0
               0  "In all cases where no negatives are concerned, fix points that are"
               0  "equal to 0.0"
               0  "Aaron Merovitz, Jan 1998"
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0  "---Loop through data points (if any log scales set) to see if there are---"
               0  "---any  <= 0 problems that might not have been fixed---"
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          IF ((Y(COUNT)-ERRY(COUNT)) <= 0.) [ LOGDY = 1; ]
               2          ]
               1      ]
               0  ELSE[ "--fix error bars that just hit Y axis in case user wants"
               1      "to switch to linlog plot while in xmgr--"
               1      DO COUNT = 1, NPTS1 [
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT) & Y(COUNT)>0.)[
               3              ZEROYCOUNT=ZEROYCOUNT+1;
               3              IF(ZEROYCOUNT=1)[
               4                  WRITE(6,:105:);
               4                  :105: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               4                  ,/'  Some errors give 0 value and so are adjusted so       '
               4                  ,/'  that you can switch to a log Y scale while in xmgr.   '
               4                  ,/' -------------------------------------------------------'/);
               4                  ]
               3              ERRYOLD=ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              "WRITE(6,:106:) COUNT,ERRYOLD,ERRY(COUNT);"
               3              ":106: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'"
               3              "       /'        ',1PE11.4,'.');"
               3              ]
               2          ]
               1      ]
               0
               0  "---Use this info later when writing to file---"
               0
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  "--XVGR has the characteristic that if the same input command is issued more---"
               0  "--than once, the last one to be read is the one that is executed.  For this---"
               0  "--situation, this is perfect.  Say the first series written to a file is of---"
               0  "--a log scale, and the second is also of log scale, but has a data point   ---"
               0  "--on the log scale that is < or = 0, then we can write the '@g0 type xy'   ---"
               0  "--to the file AFTER the previous '@g0 type logxy' and the xy type will     ---"
               0  "--prevail.  This will prevent errors when executing XVGR.  Of course the   ---"
               0  "--alteration will also be written to the display.                          ---"
               0
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  "---now make a fix for those error bars that 'dip' beneath the x-axis on---"
               0  "---log plots.                                                          ---"
               0
               0  IF (LOGDY = 1 & LOGY ~= 1 & (AXISTYPE = 3 | AXISTYPE = 1)) [
               1      "--if LOGDY problem and log scale not been already reset to linear--"
               1      "--do fudge to correct the problem--"
               1
               1      WRITE(6,:101:);
               1      :101: FORMAT (/' ------------WARNING from Subroutine XVGRPLOT-----------'
               1      ,/'  Log scale requested for Y axis, and Y value less      '
               1      ,/'  error gives 0 or negative value.                      '
               1      ,//'  Error adjusted to aviod negavite values on log scale. '
               1      ,/' -------------------------------------------------------'/);
               1
               1      DO COUNT = 1,NPTS1[
               2          IF(Y(COUNT)-ERRY(COUNT) < Y(COUNT)-0.9999*Y(COUNT)) [
               3              ERRYOLD = ERRY(COUNT);
               3              ERRY(COUNT) = 0.9999*Y(COUNT);
               3              WRITE(6,:103:) COUNT,ERRYOLD,ERRY(COUNT);
               3              :103: FORMAT (/'  Error adjusted on point #',I2,' from',1PE11.4, ' to'
               3              /'        ',1PE11.4,'.');
               3              ]
               2          ]
               1
               1      WRITE(6,:104:);
               1      :104: FORMAT (/' -------------------------------------------------------'/);
               1
               1      ]
               0
               0  "---Include data about series for legend purposes.---"
               0  "first line needed to make it work with grace"
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Do normal plot.  ie. NOT histogram plot.---"
               0  IF (TYPE = 0) [ "---Normal point plot.---"
               1
               1      "---Check all ERRYs.  If even one is nonzero, then series is type xydy---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY1:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      WRITE(UNITNUM,:200:);
               1      :200: FORMAT ('@TYPE xy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               1      :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               1      :197: FORMAT ('@    s',I1,' symbol color ',I2);
               1      :198: FORMAT ('@    s',I1,' symbol color ',I1);
               1      :199: FORMAT ('@    s',I2,' symbol color ',I2);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               1      :250: FORMAT (1PE15.4,1PE15.4);
               1      GOTO  :END-X-Y-DY1:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY1:;
               1      WRITE(UNITNUM,:300:);
               1      :300: FORMAT ('@TYPE xydy');
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [WRITE(UNITNUM,:350:) X(COUNT),Y(COUNT),ERRY(COUNT);]
               1      :350: FORMAT (1PE15.4,1PE15.4,1PE15.4);
               1      :END-X-Y-DY1:;
               1
               1      ]  "--end of point plot block--"
               0  ELSE [ "---Histogram plot---"
               1
               1      "---Must find minimum y value in the y array to    ---"
               1      "---use as scale factor for establishing y-min on  ---"
               1      "---histogram plot.  We don't use 0 here as with 0 ---"
               1      "---plot can not be made into log plot in xvgr.    ---"
               1
               1      YMIN = ABS($LARGEFACTOR * Y(1));
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ABS(Y(COUNT)) < YMIN) [ YMIN = ABS(Y(COUNT)); ]
               2          ]  "---End loop to find smalled Y---"
               1
               1      "---Now smallest value of Y has been found.  Want to make sure that the---"
               1      "---first point used is even smaller than this and that it is of the same---"
               1      "---sign as the first Y data point in the plot.---"
               1
               1      "---Now set YMIN to even smaller value for plot and set sign.---"
               1      YMIN = SIGN(one,Y(1)) * $SMALLFACTOR * YMIN ;
               1
               1      "---Set this value in y-array as element after the---"
               1      "---element in index npts.---"
               1      Y(NPTS1+1) = YMIN;
               1
               1      IF ((AXISTYPE = 2 | AXISTYPE = 3) & HISTXMIN = 0) [
               2          IF (X(1) = (X(2)-X(1))) [ HISTXMIN = X(1)-0.5*(X(2)-X(1)); ]
               2          ELSE                    [ HISTXMIN = X(1)-(X(2)-X(1)); ]
               2
               2          WRITE(6,:306:) HISTXMIN;
               2          :306: FORMAT (/' ---------WARNING from Subroutine XVGRPLOT--------'
               2          ,/'  Minimum bin for X specified as 0 with log scale  '
               2          ,/'  on X axis.  Minimum X bin set to ',1PE10.3,'.'
               2          ,/' -------------------------------------------------'/);
               2          ]
               1
               1      DO COUNT = 1, NPTS1 [
               2          IF (ERRY(COUNT) ~= 0.) [ "---Data set is not of type XY---"
               3              GOTO :X-Y-DY:;
               3              ]
               2          ]
               1
               1      "---Data set is of type XY---"
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:200:);
               1
               1      "---Plot the first histogram points.---"
               1      WRITE(UNITNUM,:250:) HISTXMIN,YMIN;
               1      WRITE(UNITNUM,:250:) HISTXMIN,Y(1);
               1
               1      "--Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT);
               2          WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT+1);
               2          ]
               1      GOTO :END-X-Y-DY:;
               1
               1      "---Data set is of type XY-DY---"
               1      :X-Y-DY:;
               1      "---Put error of 0 on last *made-up* point in error array.---"
               1      ERRY(NPTS1+1) = 0.0;
               1
               1      IF (CURVENUM < 10) [
               2          WRITE(UNITNUM,:151:) CURVENUM;
               2          IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               2          ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               2          ]
               1      ELSE [
               2          WRITE(UNITNUM,:152:) CURVENUM;
               2          WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               2          ]
               1      WRITE(UNITNUM,:300:);
               1
               1      "---Plot the first histogram points.---"
               1      IF (HISTXMIN = 0.0) [ "Aaron Meroivtz, Feb. 1998"
               2          HISTXMIN = SMALLESTX*FUDGE;
               2          ]
               1      WRITE(UNITNUM,:350:) HISTXMIN, YMIN, 0.;
               1      WRITE(UNITNUM,:350:) HISTXMIN, Y(1), 0.;
               1      WRITE(UNITNUM,:350:) (X(1)+HISTXMIN)/2., Y(1), ERRY(1);
               1
               1      "---Then write the data to the file.---"
               1      DO COUNT = 1, NPTS1 [
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT),0.;
               2          WRITE (UNITNUM,:350:) X(COUNT),Y(COUNT+1),0.;
               2          IF(COUNT < NPTS1)[
               3              WRITE (UNITNUM,:350:) (X(COUNT)+X(COUNT+1))/2.,Y(COUNT+1),ERRY(COUNT+1);
               3              ]
               2          ]
               1      :END-X-Y-DY:;
               1      ] "---End HIST=0 loop---"
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END; "---End of subroutine.---"
               0  ;
               0
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc I/O functions                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " Iwan Kawrakow, 2004:                                                        "
               0  "                                                                             "
               0  " re-factored egs_init so that it is easy to program a corresponding egs_init "
               0  " when one loads a EGSnrc user code as a library and therefore no command     "
               0  " line arguments are available. (see beam library).                           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  REPLACE {$max_unit} WITH {99}
               0
               0  REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "
               0
               0  REPLACE {;COMIN/my_times/;} WITH {;
            {  0  common/my_times/ t_elapsed, t_cpu, t_first;
            {  0  $REAL            t_elapsed, t_cpu;
            {  0  integer          t_first(8);
            {  0  real             egs_tot_time,egs_etime;
            {  0  };
               0
               0  "******************************************************************************
               0  " subroutine egs_init;
               0  "******************************************************************************
               0  " A call to this subroutine becomes Step 0 in every EGSnrc user code.
               0  " Its purpose is to:
               0  "   - initialize arrays and default values for various transport options
               0  "     (this was previously done in block data, but due to the GNU Fortran
               0  "     compiler complaints and extremely slow compilation when the number of
               0  "     regions is large, we decided to remove block data from the source)
               0  "   - Process command line arguments specifying input file, pegs4 data file,etc.
               0  "     In the current version the following command line options are supported:
               0  "
               0  "       -i or --input ifile          Input file is ifile.egsinp
               0  "
               0  "       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
               0  "                                    The system will look for it in the
               0  "                                    HEN_HOUSE and the user's pegs4 data areas
               0  "
               0  "       -o or --output ofile         Output data will be writtent to
               0  "                                    ofile.egslog, ofile.egslst, etc., instead
               0  "                                    of ifile.egslog, etc.
               0  "
               0  "       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
               0  "                                    of the directory specified in the
               0  "                                    machine.macros file.
               0  "
               0  "       -e or --egs-home dir         Change EGS_HOME to be dir instead of
               0  "                                    the directory specified by the EGS_HOME
               0  "                                    environment variable
               0  "
               0  "       -h or --help                 Print a help message and exit
               0  "                                    ignoring all other arguments
               0  "
               0  "       -b or --batch                Specify a 'batch' run. The difference
               0  "                                    between a 'batch' run and an interactive
               0  "                                    run is that in 'batch' mode unit 6 is
               0  "                                    connected to a file, whereas in interactive
               0  "                                    mode unit 6 goes to the standard output.
               0  "                                    The file name in batch run is determined
               0  "                                    as follows:
               0  "                                     - ofile.egslog, if ofile was specified
               0  "                                       with the -o option
               0  "                                     - ifile.egslog, if there was no -o option
               0  "                                       used but an input file was specified
               0  "                                       with -i
               0  "                                     - test.egslog, if neither -i nor -o was
               0  "                                       used.
               0  "
               0  "       -P or --parallel n           Tell the system that this run is part of
               0  "                                    a parallel run and that this is job number
               0  "                                    n (so that the random number sequence
               0  "                                    can be initialized differently)
               0  "
               0  "       -c or --chunk N              Tell the system to use N histories per
               0  "                                    calculation 'chunk' in parallel runs.
               0  "
               0  "   - open default EGSnrc data file units thus avoiding the necessity for
               0  "     symbolik links
               0  "   - open user code specific I/O units if a .io file is found in
               0  "     the user code area. The format of this file is an integer
               0  "     followed by a string on every line.
               0  "     The string specifies the file extension
               0  "     and the integer the unit number this file should connect to, e.g.
               0  "       4   .egsdat
               0  "       15  .egserr
               0  "       1   .egslst
               0  "     will result in connecting unit 4 to the file ifile.egsdat
               0  "     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
               0  "  -  Outputs a summary to standard output about configuration etc
               0  "  -  Creates a temporary working directory in the user code area
               0  "
               0  "  The files always opened (appart from the ones specified in the .io file)
               0  "  are the following:
               0  "
               0  "  1. The PEGS data file (and so, for now, the -p pegs_file command line
               0  "     option must be always given)
               0  "     The algorithm for looking for a PEGS data file is:
               0  "       - The file name passed with -p. In this way, PEGS files can be located
               0  "         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
               0  "         and $EGS_HOME/pegs4/data) if the absolute path name is given after
               0  "         the -p option.
               0  "       - $EGS_HOME/pegs4/data/pegs_file or
               0  "         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
               0  "       - $HEN_HOUSE/pegs4/data/pegs_file or
               0  "         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
               0  "     See note below on how $HEN_HOUSE and $EGS_HOME are determined
               0  "
               0  "  2. If a -i ifile option was given as argument, ifile.egsinp is
               0  "     opened as fortran unit 5.
               0  "     The input file MUST be in the user code directory on $EGS_HOME
               0  "
               0  "  3. If the run is a batch run (the -b option was present on the command
               0  "     line), fortran unit 6 is connected to an output file with a .egslog
               0  "     extension instead of going to standard output.
               0  "     The algorithm for determining the .egslog file name is the following:
               0  "       - If the -o ofile option was present, the output to unit 6 will go
               0  "         to ofile.egslog
               0  "       - If there was no -o option, but there is an inpuit file specified
               0  "         with -i ifile, output to unit 6 will go to ifile.egslog
               0  "       - If neither of the above is true, the output will go to
               0  "         test.egslog.
               0  "
               0  "  Note on determining EGS_HOME:
               0  "  EGS_HOME is normally taken from the environment variable EGS_HOME.
               0  "  However, one can overwrite the environment by giving the
               0  "    -e | --egs-home  new_egs_home_location
               0  "  option on the command line.
               0  "  EGS_HOME must be set, either via the environment or via the command line,
               0  "  otherwise the job will abort.
               0  "
               0  "  Note on determining HEN_HOUSE:
               0  "  HEN_HOUSE is set to the value defined in machine.macros, which is
               0  "  created by the configure script or the configuration wizard in the GUI
               0  "  This value can be overwritten by giving the
               0  "    -H | --hen-house new_hen_house_location
               0  "  option on the command line.
               0  "  HEN_HOUSE is NOT taken from the environment.
               0  "
               0  "  The name of the temporary working directory is created using
               0  "    egsrun_getpid_ifile_hostname, if there was an input file, or
               0  "    egsrun_getpid_noinput_hostname, if there was no input file specified.
               0  "  In the above, getpid is the process id returned bt the getpid() intrinsic
               0  "  and hostname is the host name as determined by egs_get_hostnm().
               0  "  During run time, all output from the program (the .egslog file and
               0  "  all other files specified in the .io file) is kept in the
               0  "  temporary working directory. After succesful completion, egs_finish
               0  "  moves all output back to the user code area and removes the
               0  "  temporary working directory. This implies that if for whatever reason
               0  "  the job terminates prematurely, the temporary working directory
               0  "  with all output will be left behind.
               0  "
               0  "
               0  "
               0  "******************************************************************************
               0  subroutine egs_init;
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/my_times/;
               0  $REAL dum;
               0
               0
               0
               0
               0
               0  call egs_set_defaults;
               0  call egs_check_arguments;
               0  call egs_init1;
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_init1;
               0  "******************************************************************************
               0
               0  implicit none;
               0  ;COMIN/EGS-IO,MISC,my_times/;
               0  integer   l, lnblnk1, l1, l2;
               0  integer   i;
               0  character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
               0  line*80,
               0  line1*80,dattim*24;
               0  $LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home,is_opened;
               0  $INTEGER  mypid;
               0  integer   getpid;
               0  integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
               0  $REAL     dum;
               0  $declare_write_buffer;
               0
               0  t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
               0  call egs_date_and_time(t_first);
               0
               0  $set_string(line,'=');
               0  $set_string(line1,'.');
               0
               0  " Handy macros for checking command line arguments "
               0  REPLACE {$check_get_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg-1 [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; call getarg(i+1,{P3}); EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$check_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  IF(~is_pegsless)[
               1      " Get the pegs4 data file "
               1      on_egs_home = .false.;
               1      inquire(file=pegs_file,exist=ex);
               1      IF( ex ) [
               2          kmpi=egs_get_unit(kmpi);
               2          IF(kmpi<0)[
               3              $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               3              ]
               2          open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               2          $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               2          goto :found_pegs_file:;
               2          ]
               1      arg = $cstring(pegs_file);
               1      ex = egs_strip_extension(arg,'.pegs4dat');
               1      l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
               1      l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              on_egs_home = .true.;
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1      l = lnblnk1(hen_house);
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1
               1      $egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));
               1
               1      ]
               0
               0  :found_pegs_file:
               0  ;
               0  " Open egsnrc data files "
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  "set proposed unit numbers"
               0  i_nist_data=76;
               0  i_incoh=78;
               0  i_photo_relax=77;
               0  i_photo_cs=79;
               0  i_mscat=11;
               0
               0  REPLACE {$open_data_file(#,#,#,#);} WITH {;
            {  0  $set_string({P2},' ');
            {  0  {P2} = $cstring({P1}) // {P3};
            {  0  inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
            {  0  IF( ~ex ) [
            {  0  $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
            {  0  ]
            {  0  IF( ~is_opened ) [
            {  0  {P4}=egs_get_unit({P4});
            {  0  IF({P4}<0)[
            {  0  $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
            {  0  $cstring({P2}));
            {  0  ]
            {  0  open({P4},file={P2},status='old',err=:data_file_error:);
            {  0  ]
            {  0  ELSE [ {P4} = itmp; ]
            {  0  $egs_debug('(a,a)','opened data file ',$cstring({P2}));
            {  0  };
               0  $open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
               0  $open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);
               0
               0  $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0
               0  have_input = .false.;
               0  i_input=5;
               0  IF( lnblnk1(input_file) > 0 ) [
               1      have_input = .true.;
               1      l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
               1      l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
               1      IF( l + l1 + l2 > 1024 ) [
               2          $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
               2          ]
               1      ex = egs_strip_extension(input_file,'.egsinp');
               1      tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ~ex ) [
               2          $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
               2          ]
               1      $AVAILABLE_UNIT(i_input,tmp_string);
               1      open(i_input,file=tmp_string,status='old',err=:open_input_error:);
               1      ]
               0
               0  " Construct a temporary directory name to run from "
               0  $set_string(work_dir,' ');
               0  work_dir = 'egsrun_'; mypid = getpid();
               0  call egs_itostring(work_dir,mypid,.false.);
               0  call egs_get_hostnm(host_name);
               0  IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
               0  IF( have_input ) [
               1      work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               1      '_' // $cstring(host_name) // $file_sep;
               1      ]
               0  ELSE [
               1      work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               1      $file_sep;
               1      ]
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               0  DO i=1,lnblnk1(tmp_string) [
               1      IF( tmp_string(i:i) = '/' ) [
               2          tmp_string(i:i) = $file_sep;
               2          ]
               1      ]
               0  ex = egs_isdir(tmp_string);
               0  IF( ex ) [
               1      $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
               1      ]
               0  tmp1_string = 'mkdir ' // $cstring(tmp_string);
               0  l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
               0  " some systems need the command string to be 0 terminated"
               0  istat = egs_system(tmp1_string);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
               1      ]
               0
               0  call egs_open_units(.true.);
               0
               0  " Now print a summary of what happened "
               0  $egs_info('(a)',line);
               0  $egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
               0  call egs_get_fdate(dattim);
               0  $egs_info('(a,/,a)',dattim,line);
               0
               0  REPLACE {$write_description(#);} WITH {;
            {  0  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
            {  0  $egs_info('(a,$)',line1(:l));
            {  0  };
               0  pos1 = lnblnk1('output file(s)');
               0  pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
               0  pos2 = min(pos2,80-lnblnk1(user_code));
               0  $set_string(tmp_string,' '); tmp_string = pegs_file;
               0  call egs_strip_path(tmp_string);
               0  ex = egs_strip_extension(tmp_string,'.pegs4dat');
               0  IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
               0  ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
               0  IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
               1      $set_string(tmp_string,' '); tmp_string = pegs_file;
               1      ]
               0  pos2 = min(pos2,80-lnblnk1(tmp_string));
               0  pos2 = min(pos2,80-lnblnk1(host_name));
               0  pos2 = min(pos2,80-lnblnk1($CONFIG_TIME));
               0  IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
               0  pos2 = min(pos2,80-lnblnk1(output_file));
               0  IF( pos2 < pos1+2 ) pos2 = pos1 + 2;
               0
               0  $write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
               0  $write_description('configuration time'); $egs_info('(a)',$CONFIG_TIME);
               0  $write_description('app compile time'); $egs_info('(a)',COMPILE_TIME);
               0  $write_description('git commit hash'); $egs_info('(a)',GIT_HASH);
               0  $write_description('application'); $egs_info('(a)',$cstring(user_code));
               0  $write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
               0  $write_description('using host'); $egs_info('(a)',$cstring(host_name));
               0  IF( have_input ) [
               1      $write_description('input file'); $egs_info('(a)',$cstring(input_file));
               1      ]
               0  $write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
               0  IF( n_parallel > 0 ) [
               1      $write_description('number of parallel jobs');
               1      $egs_info('(i2)',n_parallel);
               1      $write_description('job number'); $egs_info('(i2)',i_parallel);
               1      ]
               0  $egs_info('(a)',line);
               0
               0  IF (is_uniform_run)[
               1      $egs_info('(//a,i0,a,i0,a//)',
               1      '-> User requests uniform run control. I am job # ',
               1      i_parallel,' of ',n_parallel,' jobs');
               1      ]
               0
               0  return;
               0
               0  " Errors "
               0  :open_input_error:
               0  $egs_fatal(*,'failed to open input file ',$cstring(tmp_string));
               0
               0  :open_pegs_error:
               0  $egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));
               0
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_check_arguments;
               0  "*****************************************************************************
               0  implicit none;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character arg*256,tmp_string*512, line1*80;
               0  $LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home;
               0  integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
               0  $declare_write_buffer;
               0
               0  narg = iargc();
               0  IF( narg < 1 ) return;
               0
               0  " Check for hen_house "
               0  $check_get_argument('-H','--hen-house',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(hen_house,' ');
               1      IF( l > 0 ) [
               2          IF( l > 254 ) [
               3              $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
               3              ]
               2          hen_house(:l) = $cstring(arg);
               2          IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
               2          ]
               1      ELSE [
               2          $egs_fatal('(a)',' empty argument after -H');
               2          ]
               1      DO i=1,lnblnk1(hen_house) [
               2          IF( hen_house(i:i) = '/' ) [
               3              hen_house(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(hen_house) ) [
               1      $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
               1      $warning('(a)','does not exist. Hope you know what you are doing.');
               1      ]
               0
               0  " Check if the user requested help "
               0  $check_argument('-h','--help',arg);
               0  IF( have_arg ) [
               1      call getarg(0,arg); call egs_strip_path(arg);
               1      $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
               1      tmp_string = $cstring(hen_house) // 'pieces/help_message';
               1      i_help=98;
               1      i_help=egs_get_unit(i_help);
               1      IF(i_help<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
               2          ]
               1      open(i_help,file=tmp_string,status='old',err=:no_help_file:);
               1      LOOP [
               2          read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
               2          $egs_info('(a)',line1);
               2          ]
               1      :end_of_help:;
               1      $CALL_EXIT(0);
               1      :no_help_file:;
               1      $egs_fatal(*,'Did not find the help_message file!');
               1      ]
               0
               0  " Check for batch option "
               0  $check_argument('-b','--batch',arg);
               0  IF( have_arg ) is_batch = .true.;
               0
               0  " Check for parallel run option"
               0  $check_get_argument('-P','--parallel',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_parallel_arg:) n_parallel;
               1      IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
               1      goto :ok_parallel_arg:;
               1      :wrong_parallel_arg:;
               1      $egs_warning(*,
               1      ' Wrong/missing parallel job number argument, -P option ignored');
               1      n_parallel = 0;
               1      :ok_parallel_arg:;
               1      ]
               0
               0  $check_get_argument('-j','--job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_job_arg:) i_parallel;
               1      IF( i_parallel < 0 ) goto :wrong_job_arg:;
               1      goto :ok_job_arg:;
               1      :wrong_job_arg:;
               1      $egs_warning(*,' Wrong/missing job argument, -j option ognored');
               1      i_parallel = 0;
               1      :ok_job_arg:;
               1      ]
               0
               0  $check_get_argument('-f','--first-job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_first_job_arg:) first_parallel;
               1      IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
               1      goto :ok_first_job_arg:;
               1      :wrong_first_job_arg:;
               1      $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
               1      first_parallel = 1;
               1      :ok_first_job_arg:;
               1      ]
               0
               0  IF( n_parallel > 0 | i_parallel > 0 ) [
               1      IF( n_parallel*i_parallel = 0 ) [
               2          $egs_warning(*,'You need to specify number of jobs AND job number ',
               2          '=> will not use parallel run ');
               2          n_parallel = 0; i_parallel = 0;
               2          ]
               1      IF( first_parallel > i_parallel ) [
               2          $egs_warning(*,'i_parallel (',i_parallel,
               2          ') can not be smaller than first_parallel (',first_parallel,')');
               2          first_parallel = i_parallel;
               2          ]
               1      ]
               0
               0  " Check for run control option "
               0  $check_argument('-u','--urc',arg);
               0  IF( have_arg ) is_uniform_run = .true.;
               0
               0  $egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));
               0
               0  " Check for egs_home "
               0  $check_get_argument('-e','--egs-home',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(egs_home,' ');
               1      IF( l = 0 ) [
               2          $egs_fatal('(a)',' empty argument after -e');
               2          ]
               1      IF( l > 254 ) [
               2          $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
               2          ]
               1      egs_home(:l) = $cstring(arg);
               1      IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
               1      DO i=1,lnblnk1(egs_home) [
               2          IF( egs_home(i:i) = '/' ) [
               3              egs_home(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(egs_home) ) [
               1      $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
               1      ]
               0  $egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));
               0
               0  " Get the pegs4 data file "
               0  on_egs_home = .false.;
               0  is_pegsless=.false.;
               0  $check_get_argument('-p','--pegs-file',arg);
               0  IF( ~have_arg ) [
               1      $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
            '  1      in pegs-less mode with media details specified in input file.');
               1      is_pegsless=.true.;
               1      ]
               0  ELSE[
               1      pegs_file = $cstring(arg);
               1      ]
               0
               0  " Deduct the user code name from the executable name "
               0  call egs_get_usercode(user_code);
               0
               0  " Check for an input file "
               0  $check_get_argument('-i','--input',arg);
               0  IF( have_arg ) [
               1      ex = egs_strip_extension(arg,'.egsinp');
               1      l2 = lnblnk1(arg) + lnblnk1('.egsinp');
               1      IF( l2 > 256 ) [
               2          $egs_fatal(*,'input file name is too long ',l2);
               2          ]
               1      input_file = $cstring(arg);
               1      ]
               0
               0  " Check for an output file option "
               0  $check_get_argument('-o','--output',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg);
               1      IF( l > 256 ) [
               2          $egs_fatal(*,'output file name is too long ',l);
               2          ]
               1      output_file(:l) = $cstring(arg);
               1      ]
               0  ELSE [
               1      IF( lnblnk1(input_file) > 0 ) [
               2          output_file(:lnblnk1(input_file)) = $cstring(input_file);
               2          ]
               1      ELSE [
               2          output_file = 'test';
               2          ]
               1      ]
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_open_units(flag);
               0  "******************************************************************************
               0  " Open output files.
               0  " Looks for output file definition in user_code.io.
               0  " In addition, if it is a batch run connects a .egslog file to unit 6.
               0  " If flag is .true., open the files in the temporary working directory,
               0  " else open them in the user code directory.
               0  "******************************************************************************
               0  implicit none;
               0  $LOGICAL flag;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
               0  input_line*100, arg*20;
               0  integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
               0  $LOGICAL  ex,is_open;
               0  $declare_write_buffer;
               0
               0  $set_string(tmp_string,' '); $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  IF( flag ) [
               1      tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               1      ]
               0  ELSE [
               1      tmp_string = $cstring(ucode_dir);
               1      ]
               0
               0  tmp_string = $cstring(tmp_string) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  $set_string(tmp1_string,' ');
               0  i_log=6;
               0  IF( is_batch ) [
               1      tmp1_string = $cstring(tmp_string) // '.egslog';
               1      $AVAILABLE_UNIT(i_log,tmp1_string);
               1      open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
               1      ]
               0  $set_string(tmp2_string,' ');
               0  tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
               0  inquire(file=tmp2_string,exist=ex);
               0  n_files = 0;
               0  IF( ex ) [
               1      i_iofile=99;
               1      i_iofile=egs_get_unit(i_iofile);
               1      IF (i_iofile<1)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
               2          ]
               1      open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
               1      LOOP [
               2          read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
               2          IF( input_line(1:1) = '#' ) NEXT;
               2          "The DEC and SGI compilers fail at the following statement!"
               2          "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
               2          read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
               2          istart = 1;
               2          DO i=lnblnk1(input_line),1,-1 [
               3              IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
               3              ]
               2          DO i=1,len(arg) [ arg(i:i) = ' '; ]
               2          DO i=istart,lnblnk1(input_line) [
               3              arg(i+1-istart:i+1-istart) = input_line(i:i);
               3              ]
               2          inquire(unit=u,opened=is_open);
               2          IF( is_open ) [
               3              $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
               3              'Unit ',u,' which you want to connect to a ',
               3              $cstring(arg),' file ',
               3              'is already in use. Will assume this code is being used as',
               3              'a shared library source and this file will be opened explicitly.');
               3              ]
               2          ELSE[
               3              n_files = n_files + 1;
               3              IF( n_files > $mx_units ) [
               4                  $egs_fatal(*,'Too many units requested in .io.',
               4                  ' Increas $mx_units and retry');
               4                  ]
               3              file_units(n_files) = u;
               3              $set_string(file_extensions(n_files),' ');
               3              l = lnblnk1(arg);
               3              IF( l > $max_extension_length ) [
               4                  $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
               4                  $max_extension_length,' chars. ',
               4                  'Increase $max_extension_length and retry ');
               4                  ]
               3              file_extensions(n_files) = $cstring(arg);
               3              tmp1_string = $cstring(tmp_string) // $cstring(arg);
               3              open(u,file=tmp1_string,status='unknown');
               3              $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
               3              ' to unit ',u);
               3              ]
               2          :end_of_ioline:
               2          ]
               1      :end_of_iofile:
               1      close(i_iofile);
               1      ]
               0  return;
               0
               0  :output_file_error:
               0  $egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));
               0
               0  :io_file_error:
               0  $egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
               0  return; end;
               0
               0
               0  "******************************************************************************
               0  subroutine egs_finish;
               0  "******************************************************************************
               0  " This subroutine becomes the last step in every EGSnrc user code.
               0  " It's purpose is to move the all output files from the temporary working
               0  " directory to the user code directory and to remove the working dir.
               0  " This was previously done by the egs_run script.
               0  " This routine also prints a summary to standard output.
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/EGS-IO,my_times/;
               0  character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
               0  character dattim*24;
               0  integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
               0  $LOGICAL is_open,egs_isdir;
               0  $REAL    t1,t2,tt_cpu;
               0  $declare_write_buffer;
               0
               0  $set_string(line,'=');
               0  IF( n_parallel = 0 | i_parallel > 0 ) [
               1      "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
               1      "or if it is parallel but it is not the final egs_finish (after combining"
               1      "results from parallel runs)"
               1      t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
               1      t1 = t_elapsed; t2 = t1/3600;
               1      $egs_info('(//a,/,a,/)',line,'Finished simulation');
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
               1      t1 = tt_cpu; t2 = t1/3600;
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
               1      $egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
               1      ]
               0  call egs_get_fdate(dattim);
               0  $egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);
               0
               0  " Close all I/O units "
               0  n_open=0;
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code);
               0  DO i=1,$max_unit [
               1      IF( is_batch | i ~= i_log ) [
               2          inquire(i,opened=is_open);
               2          IF( is_open ) [
               3              inquire(i,name=fname);
               3              IF(index($cstring(fname),$cstring(base))>0)[
               4                  close(i); n_open = n_open+1; ]
               3              ]
               2          ]
               1      ]
               0
               0  "If work_dir is empty, this is a second call to egs_finish for the last"
               0  "job in a parallel run. This implies that the temporary working "
               0  "directory has been already removed => just return"
               0
               0  IF( lnblnk1(work_dir) = 0 ) [ return; ]
               0
               0  " Now generate a junk file in the working directory so that the move "
               0  " command does not fail in case there are no files "
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir);
               0  DO i=1,lnblnk1(base) [
               1      IF( base(i:i) = '/' ) [
               2          base(i:i) = $file_sep;
               2          ]
               1      ]
               0  IF( egs_isdir(base) ) [
               1      $set_string(tmp_string,' '); $set_string(junk_file,' ');
               1      junk_file = $cstring(work_dir);
               1      l = lnblnk1(junk_file); junk_file(l:l) = ' ';
               1      junk_file = $cstring(junk_file) // '_junk';
               1      tmp_string = $cstring(base) // $cstring(junk_file);
               1      i_junk=99;
               1      i_junk=egs_get_unit(i_junk);
               1      IF(i_junk<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
               2          ]
               1      open(i_junk,file=tmp_string,status='unknown');
               1      write(i_junk,*) 'junk';
               1      close(i_junk);
               1
               1      " Move all files from the working directory to the user code directory "
               1      $set_string(base1,' ');
               1      base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               1      $cstring(work_dir);
               1      base1 = $cstring(egs_home) // $cstring(user_code);
               1      $set_string(tmp_string,' ');
               1      tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
               1      l = lnblnk1(tmp_string)+1;
               1      tmp_string(l:l) = char(0);
               1      istat = egs_system(tmp_string);
               1      IF( istat ~= 0 ) [
               2          $egs_warning(*,'Moving files from working directory failed ?');
               2          $warning(*,'=> will not remove working directory');
               2          ]
               1      ELSE [
               2          " Remove the working directory "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $remove_directory // $cstring(base);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = egs_system(tmp_string);
               2          IF( istat ~= 0 ) [
               3              $egs_warning(*,'Failed to remove working directory ',
               3              $cstring(work_dir));
               3              ]
               2          " Remove the junk file "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = unlink(tmp_string);
               2          ]
               1      ]
               0
               0  " Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
               0  " in the user code directory "
               0  $set_string(work_dir,' ');
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_set_defaults;
               0  "******************************************************************************
               0  " Replaces BLOCK DATA "
               0  implicit none;
               0  $COMIN-SET-DEFAULTS;
               0
               0  integer  i,j,lnblnk1;
               0  $TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
               0  character fool_dec;
               0  data MEDIA1/$S'NAI                     '/;
               0  data fool_dec/'/'/;
               0  data fool_intel_optimizer/.false./;
               0
               0  vacdst = 1e8;
               0  $set-region-by-region-defaults;
               0
               0  eii_flag = 0; "No EII by default. "
               0  eii_xfile = 'Off';
               0  eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
               0  "========================================="
               0  "See egsnrc.macros for defaults used below"
               0  "========================================="
               0  xsec_out = $XSEC-DEFAULT;
               0  photon_xsections = $XDATA-DEFAULT;"default photon xsection"
               0  comp_xsections = $COMP-XDATA-DEFAULT;
               0  eadl_relax = $EADL-RELAX-DEFAULT;
               0  mcdf_pe_xsections = $MCDF-PE-DEFAULT;
               0  "Ali:photonuc, 2 lines"
               0  photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
               0  "EMH:emf"
               0  ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented ONLY for the C++ applications     "
               0  BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
               0  Bx=BxIN;    By=ByIN;    Bz=BzIN;
               0  Bx_new=Bx;  By_new=By;  Bz_new=Bz;
               0  emfield_on=.false.;
               0  IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               1      emfield_on=.true.
               1      ]
               0
               0  DO i=1,$MXMED [
               1      iraylm(i) = 0; "Rayleigh data available?"
               1      DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
               1      DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
               1      " set all thresholds to zero "
               1      /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
               1      ]
               0  DO i=1,$MXSHXSEC [
               1      DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
               1      ]
               0  ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
               0  ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
               0  pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
               0  itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
               0  iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
               0  rhof = 1;
               0  DO i=1,5 [ iausfl(i) = 1; ]
               0  "Ali:photonuc, line below already includes iarg=29,30"
               0  DO i=6,$MXAUS [ iausfl(i) = 0; ]
               0  ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
               0  skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
               0  transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
               0  bca_algorithm = $BCA-ALGORITHM-DEFAULT;
               0  exact_bca = $EXACT-BCA-DEFAULT;
               0  spin_effects = $SPIN-EFFECTS-DEFAULT;
               0  count_pII_steps = 0; count_all_steps = 0;
               0  radc_flag = 0;
               0  nmed = $default_nmed;
               0  kmpi = 12; kmpo = 8; dunit = 1;
               0  rng_seed = 999999;
               0  latchi = 0;
               0
               0  rmt2 = 2*rm; rmsq = rm*rm;
               0
               0  pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
               0  nbr_split = 1;
               0  i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;
               0
               0  $set_string(hen_house,' ');
               0  i = lnblnk1($HEN_HOUSE);
               0  hen_house(:i) = $HEN_HOUSE;
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;
               0
               0  n_files = 0;
               0  $set_egs_home;
               0  i = lnblnk1(egs_home);
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
               0  $set_string(input_file,' ');
               0  $set_string(output_file,' ');
               0  $set_string(work_dir,' ');
               0  $set_string(pegs_file,' ');
               0  $set_string(host_name,' ');
               0  n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
               0  first_parallel = 1;
               0  is_uniform_run = $URC-DEFAULT;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_combine_runs(combine_routine,extension);
               0  "*****************************************************************************
               0  " This subroutine loops over job number i from 1 to $max_unit,
               0  " checks if the file output_file_wi.extension exists, and if yes,
               0  " calls the external subroutine combine_routine with that file name.
               0  "*****************************************************************************
               0  implicit none;
               0  external combine_routine;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  character*1024 tmp_string,base,command,outfile,parfile_name,base1,
               0  text_string;
               0  integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
               0  $INTEGER i,k,j,numparfiles,textindex;
               0  integer urcSleep, urcCheckIntervals;
               0  $LOGICAL ex,iwin;
               0
               0  iwin=.false.; "start off assuming a non-Windows system"
               0
               0  urcSleep          = $URC-SLEEP;    "Set to 1 s in egsnrc.macros"
               0  urcCheckIntervals = $URC-INTERVALS;"Set to 1 in egsnrc.macros"
               0
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w';
               0
               0  "the following is to count the number of output files from"
               0  "a parallel run"
               0  $set_string(base1,' ');
               0  base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w*' // $cstring(extension);
               0  $set_string(outfile,' ');
               0  outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  'parfiles_tmp';
               0
               0  :check-output-files:;
               0  "try Unix/Linux first"
               0  $set_string(command,' ');
               0  command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)["now assume a Windows system"
               1      command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
               1      $cstring(outfile);
               1      istat = egs_system($cstring(command));
               1      IF(istat~=0)[
               2          $egs_fatal(*,
               2          ' Failed to write number of output files from parallel runs.');
               2          ]
               1      ELSE [
               2          iwin=.true.;
               2          ]
               1      ]
               0
               0  "now open parfiles_tmp and read the number of files"
               0  ipar=1;
               0  ipar=egs_open_file(ipar,0,1,$cstring(outfile));
               0  IF(iwin)[
               1      "need to do a bit of manipulation of a text string to get the number of files
               1      read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
               1      text_string = $cstring(text_string);
               1      textindex = index(text_string,'File(s)');
               1      text_string = text_string(:textindex-1);
               1      read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
               1      ]
               0  ELSE[
               1      read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
               1      ]
               0  close(ipar);
               0
               0  #ifdef HAVE_C_COMPILER;
               0  IF ( is_uniform_run & numparfiles < n_parallel & urcCheckIntervals > 0 ) [
               1      call egs_sleep(urcSleep);"sleep for urcSleep seconds"
               1      urcCheckIntervals -= 1;
               1      goto :check-output-files:;
               1      ]
               0  #endif;
               0
               0  "now remove parfiles_tmp"
               0  $set_string(command,' ');
               0
               0  IF(iwin)[
               1      command = 'del /Q ' // $cstring(outfile);
               1      ]
               0  ELSE[
               1      command = 'rm -f ' // $cstring(outfile);
               1      ]
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)[
               1      $egs_warning(*,' Failed to delete list of output files from parallel runs.');
               1      ]
               0
               0  k=1;
               0  j=1;
               0  WHILE(j<=numparfiles) [
               1      $set_string(tmp_string,' ');
               1      tmp_string = $cstring(base);
               1      call egs_itostring(tmp_string,k,.false.);
               1      tmp_string = $cstring(tmp_string) // $cstring(extension);
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ex ) [
               2          call combine_routine(tmp_string);
               2          j=j+1;
               2          ]
               1      k=k+1;
               1      ]
               0  return;
               0
               0  :end_of_parfile:
               0  $egs_fatal(*,' Failed to read number of output files from parallel runs.');
               0  end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_strip_extension(filen,fext);
               0  "******************************************************************************
               0  " Check if the string pointed to by filen ends with the string pointed to by
               0  " fext and if yes, replace with blanks and return .true., otherwise return
               0  " false.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) filen,fext;
               0  integer  l1,l2,lnblnk1,i;
               0
               0  l1 = lnblnk1(filen); l2 = lnblnk1(fext);
               0  IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
               1      egs_strip_extension = .true.;
               1      DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
               1      ]
               0  ELSE [ egs_strip_extension = .false.; ]
               0  return; end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_is_absolute_path(fn);
               0  "******************************************************************************
               0  " Returns .true., if the string pointed to by fn is an absolute file name,
               0  " .fale. otherwise.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) fn;
               0  integer  i,lnblnk1;
               0  DO i=1,lnblnk1(fn) [
               1      IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
               1      ]
               0  egs_is_absolute_path = .false.; return; end;
               0
               0  "******************************************************************************
               0  integer  function egs_get_unit(iunit);
               0  "******************************************************************************
               0  " Returns iunit, if the Fortran I/O unit iunit is not currently in use.
               0  " Otherwise return the first free I/O unit found or -1 if none is available.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, i;
               0  $LOGICAL is_open;
               0
               0  IF( iunit > 0 ) [
               1      inquire(iunit,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = iunit; return; ]
               1      ]
               0  DO i=1,$max_unit [
               1      inquire(i,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = i; return; ]
               1      ]
               0  egs_get_unit = -1; return; end;
               0
               0  "******************************************************************************
               0  integer function egs_open_file(iunit,rl,action,extension);
               0  "******************************************************************************
               0  " Open a file trying to connect to Fortran I/O unit iunit.
               0  " If iunit is already in use, connect to the first free I/O unit found.
               0  " If no free I/O unit is found, then
               0  "   - if action = 0, return -1.
               0  "   - if action ~= 0, call the $egs_fatal macro.
               0  " If extension is an absolute file name (including path), use extension
               0  " as a file name, otherwise use output_file.extension in the temporary
               0  " working directory as name. In both cases use status='unknown' to open the
               0  " file. If rl = -1, open the file with stream access to write C-style binary
               0  " files. If rl = 0, open the file for formatted sequential access, otherwise
               0  " open for unformatted direct access with record length = rl.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, rl, action;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  $LOGICAL egs_is_absolute_path,is_open;
               0  integer  egs_get_unit;
               0  integer  i,lnblnk1;
               0  character*1024 tmp_string,error_string;
               0  $INTEGER the_unit;
               0  $declare_write_buffer;
               0
               0  egs_open_file = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_file = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      inquire(file=extension,opened=is_open);
               1      IF(is_open)[
               2          inquire(file=extension,number=the_unit);
               2          $egs_warning('(a,a,/,a,i3,/,a,/,a)',
               2          'File ',$cstring(extension),
               2          ' is already opened and connected to unit ',the_unit,
               2          ' Will not try to re-open this file, assuming it has been opened',
               2          ' by the .io file.');
               2          ]
               1      ELSE IF ( rl = -1 ) [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='stream');
               2          ]
               1      ELSE IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='unknown');
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='direct', recl=rl);
               2          ]
               1      egs_open_file = the_unit; return;
               1      ]
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  tmp_string = $cstring(tmp_string) // $cstring(extension);
               0
               0  inquire(file=tmp_string,opened=is_open);
               0  IF(is_open)[
               1      inquire(file=tmp_string,number=the_unit);
               1      $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
               1      'File ',$cstring(tmp_string),
               1      ' is already opened and connected to unit ',the_unit,
               1      ' Will not try to re-open this file, assuming it has been opened',
               1      ' by specifying it in the .io file.');
               1      ]
               0  ELSE IF ( rl = -1 ) [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='stream');
               1      ]
               0  ELSE IF( rl = 0 ) [
               1      open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='direct', recl=rl,err=:open_error:);
               1      ]
               0  egs_open_file = the_unit; return;
               0
               0  :open_error:
               0  error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
               0  // char(10) // 'iunit = ';
               0  call egs_itostring(error_string,iunit,.false.);
               0  error_string = $cstring(error_string) // ' the_unit = ';
               0  call egs_itostring(error_string,the_unit,.false.);
               0  $egs_fatal('(a)',$cstring(error_string));
               0  end;
               0
               0
               0  "******************************************************************************
               0  integer  function egs_open_datfile(iunit,rl,action,extension);
               0  "******************************************************************************
               0  "
               0  " Open an existing 'data' file.
               0  " First try to connect the file to Fortran unit iunit, but if iunit is
               0  " already in use, use the first free unit instead.
               0  " extension is the datafile extension (e.g. '.egsdat') .
               0  " The algorithm for searching for the file is as follows:
               0  "  1. If extension is an absolute file name (including path),
               0  "     try opening this file, else
               0  "  2. Try output_file.extension in the user code directory.
               0  "  3. Try input_file.extension in the user code directory (if input_file is
               0  "     different from output_file).
               0  " If the file is found, open it using status='old' for
               0  "   a) formatted sequential access, if rl=0
               0  "   b) unformatted direct access with record length = rl, if rl > 0.
               0  "
               0  " Return value:
               0  "   - if all is OK, return the opened unit number
               0  "   - if something fails, then
               0  "       * if action = 0, return error code less than 0.
               0  "       * if action != 0, call the $egs_fatal macro with an error message.
               0  "
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit,rl,action;
               0  character*(*) extension;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  integer  i,the_unit,lnblnk1,egs_get_unit;
               0  $LOGICAL egs_is_absolute_path;
               0  character base*1024, fn*1024;
               0  $declare_write_buffer;
               0
               0  egs_open_datfile = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_datfile = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='old',err=:no_datfile_0:);
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='old',form='unformatted',
               2          access='direct',recl=rl,err=:no_datfile_0:);
               2          ]
               1      egs_open_datfile = the_unit; return;
               1
               1      :no_datfile_0:;
               1      IF( action = 0 ) [ egs_open_datfile = -2; return; ]
               1      $egs_fatal(*,'Failed to open file ',$cstring(extension));
               1      ]
               0
               0  $set_string(base,' '); $set_string(fn,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  "fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(output_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_1:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_1:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_1:;
               0  $egs_warning('(a,a)','Failed to open ',$cstring(fn));
               0  $set_string(fn,' ');
               0  "fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(input_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_2:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_2:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_2:;
               0  $egs_fatal(*,'Failed to open data file');
               0  end;
               0
               0  "******************************************************************************
               0  integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
               0  "******************************************************************************
               0  " Open the file filen for sequential formatted I/O and return the unit
               0  " number it was connected to.
               0  " If iunit ~= 0, try to connect to unit |iuniti|, otherwise
               0  " use the first unconnected unit found.
               0  " If iunit > 0
               0  "    open the unit even if it was already open, if do_it_anyway is .true.,
               0  "    otherwise return -4.
               0  " If iunit < 0
               0  "    if the unit |iunit| is already in use and do_it_anyway is .true.,
               0  "    search for the first available unit, otherwise return -4.
               0  " Return values:
               0  "   unit number, if the file was succesfully opened.
               0  "   -1, if there was no free unit numer to connect to.
               0  "   -2, if the file does not exist.
               0  "   -3, if the file exist, but could not be opened.
               0  "   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit;
               0  $LOGICAL do_it_anyway;
               0  character*(*) filen;
               0
               0  $LOGICAL aux;
               0  $INTEGER the_unit,i;
               0
               0  inquire(file=filen,exist=aux);
               0  IF( ~aux ) [ egs_open_file_junk = -2; return; ]
               0  IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
               0  IF( the_unit ~= 0 ) [
               1      inquire(unit=the_unit,opened=aux);
               1      IF( aux ) [
               2          IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
               2          IF( iunit < 0 ) the_unit = 0;
               2          ]
               1      ]
               0  IF( the_unit = 0 ) [
               1      DO i=1,$max_unit [
               2          inquire(unit=i,opened=aux);
               2          IF( ~aux ) [ the_unit = i; EXIT; ]
               2          ]
               1      IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
               1      ]
               0  open(the_unit,file=filen,status='old',err=:failed_to_open:);
               0  egs_open_file_junk = the_unit; return;
               0  :failed_to_open:
               0  egs_open_file_junk = -3; return; end;
               0
               0  "==============================================================================
               0  subroutine egs_strip_path(fname);
               0  "==============================================================================
               0  " Strip the path name from fname (if any)
               0  implicit none;
               0  character*(*) fname;
               0  integer  i,l,l1,lnblnk1,j;
               0  character slash;
               0  slash = '/';
               0  l = lnblnk1(fname);
               0  DO i=1,l [
               1      IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
               1      ]
               0  DO i=l,1,-1 [
               1      IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
               2          l1 = l-i;
               2          fname(:l1) = fname(i+1:l);
               2          DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
               2          return;
               2          ]
               1      ]
               0  return; end;
               0
               0  "==============================================================================
               0  subroutine replace_env(fname);
               0  "==============================================================================
               0  "subroutine to replace environment variables (beginning with $) with their"
               0  "full names or ~ with the full name of $HOME"
               0  "Assumes environment variable or ~ appears only at the beginning of the"
               0  "file name"
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character*(*) fname;
               0  character*256 dirname;
               0  integer indsep,ind1,ind2;
               0
               0  indsep = index(fname,$file_sep);
               0  IF(indsep <= 0) return;
               0  "hope that the user has just supplied the file name"
               0  "and it is in the current directory"
               0
               0  ind1=index(fname,'$');
               0  ind2=index(fname,'~');
               0
               0  "examine first character of name"
               0  IF(ind1=1)[
               1      "get the environment variable"
               1      call getenv(fname(2:indsep-1),dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' First element in name does not specify a defined environment variable.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  ELSEIF(ind2=1)[
               1      call getenv('HOME',dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' HOME is undefined.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  return;
               0  end;
               0
               0  "=============================================================================
               0  subroutine egs_get_usercode(ucode);
               0  "=============================================================================
               0  " Deduct the user code name from the executable name
               0  " The algorithm assumes that the executable is called
               0  "   xxx[_debug|noopt][.exe]
               0  " and it will fail if this is not the case.
               0  "=============================================================================
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  character*(*) ucode;
               0  character*512 arg;
               0  integer  l,l1,lnblnk1,i;
               0  $declare_write_buffer;
               0
               0  call getarg(0,arg); call egs_strip_path(arg);
               0  l = lnblnk1(arg);
               0  IF( arg(l-3:l) = '.exe' ) [
               1      arg(l-3:l) = ' '; l = l - 4;
               1      ]
               0  IF( arg(l-5:l) = '_debug' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  IF( arg(l-5:l) = '_noopt' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  l1 = len(ucode);
               0  IF( l > l1 ) [
               1      $egs_fatal(*,' user code name is too long (',l,' chars)');
               1      ]
               0  $set_string(ucode,' '); ucode(:l) = arg(:l);
               0  return; end;
               0
               0  subroutine egs_itostring(string,i,leave_space);
               0  implicit none;
               0  character*(*) string;
               0  $INTEGER i;
               0  integer  l,lnblnk1,idiv,itmp,iaux;
               0  $LOGICAL first,leave_space;
               0  l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
               0  idiv = 1000000000; itmp = i; first = .false.;
               0  do while(idiv.gt.0) ;
               0  iaux = itmp/idiv;
               0  IF( (iaux > 0 | first ) & l <= len(string) ) [
               1      string(l:l) = char(iaux+48); first = .true.; l = l+1;
               1      ]
               0  itmp = itmp - iaux*idiv; idiv = idiv/10;
               0  end do;
               0  return; end;
               0
               0  "=============================================================================
               0  $REAL function egs_rndm();
               0  "=============================================================================
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET egs_rndm;
               0  return; end;
               0
               0  "=============================================================================
               0  integer  function egs_add_medium(medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed,medname_len;
               0  character c;
               0  $LOGICAL  same;
               0  $declare_write_buffer;
               0
               0  l = min(len(medname),24); medname_len = l;
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
               1      ]
               0  DO imed=1,nmed [
               1      l = 24;
               1      DO i=1,24 [
               2          IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
               2          ]
               1      IF( l = medname_len ) [
               2          same = .true.;
               2          DO i=1,l [
               3              c = medname(i:i);
               3              IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
               3              ]
               2          IF( same ) [
               3              egs_add_medium = imed; return;
               3              ]
               2          ]
               1      ]
               0  nmed = nmed + 1;
               0  IF( nmed > $MXMED ) [
               1      $egs_fatal('(a,/,a,i3,a)',
               1      'In egs_add_medium: maximum number of media exceeded ',
               1      'Increase the macro $MXMED (currently ',$MXMED,') and retry');
               1      ]
               0  l = min(len(medname),24);
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
               1      media(i,nmed) = ' ';
               1      media(i,nmed)(1:1) = c;
               1      ]
               0  IF( l < 24 ) [
               1      DO i=l+1,24 [ media(i,nmed) = ' '; ]
               1      ]
               0  egs_add_medium = nmed;
               0  return; end;
               0
               0  subroutine egs_get_medium_name(imed,medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed;
               0  DO i=1,len(medname) [ medname(i:i) = ' '; ]
               0  IF( imed < 1 | imed > nmed ) [ return; ]
               0  l = 24;
               0  DO l=24,1,-1 [
               1      IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
               1      ]
               0  l = min(l,len(medname));
               0  DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
               0  return; end;
               0  ;
               0
               0  "============================================================================"
               0  "  Pass pointers to the cross section interpolation coefficients to          "
               0  "  an external subroutine                                                    "
               0  "============================================================================"
               0  subroutine egs_get_electron_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - eke0(imed))/eke1(imed);
               0  lemax = (meke(imed) - eke0(imed))/eke1(imed);
               0  IF( which = 1 ) [
               1      call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
               1      ] ELSE IF( which = 6 ) [
               1      call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
               1      ] ELSE IF( which = 7 ) [
               1      call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
               1      ] ELSE IF( which = 8 ) [
               1      call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
               1      ] ELSE IF( which = 9 ) [
               1      call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown electron data type ',which);
               1      ]
               0  return; end;
               0
               0  subroutine egs_get_photon_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/PHOTIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - ge0(imed))/ge1(imed);
               0  lemax = (mge(imed) - ge0(imed))/ge1(imed);
               0  IF( which = 1 ) [
               1      call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown photon data type ',which);
               1      ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine egs_print_binding_energies;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EDGE,MEDIA,EGS-IO/;
               0  $INTEGER    i,j;
               0  integer*4   lnblnk1;
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0  ' M1',' M2',' M3',' M4',' M5',
               0  ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0  $egs_info('(a,a,a)',
               0  'Binding energies from ',$cstring(photon_xsections),
               0  ' photon cross section library');
               0  DO j = 1,$MXELEMENT [
               1      DO i = 1,$MXPESHELL [
               2          IF ( binding_energies(i,j) > 0 ) [
               3              $egs_info('(a,i3,a,a,a,1pe12.4,a)',
               3              ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
               3              ]
               2          ]
               1      ]
               0
               0  return;end;
               0
               0
               0  "============================================================================="
               0  "  scale elastic scattering strength by a given factor                        "
               0  "============================================================================="
               0  subroutine egs_scale_xcc(imed,factor);
               0  implicit none;
               0  $INTEGER imed;
               0  $REAL    factor;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA/;
               0  IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_write_string(ounit,string);
               0  implicit none;
               0  $INTEGER ounit;
               0  character*(*) string;
               0  write(ounit,'(a,$)') string;
               0  $FLUSH_UNIT(ounit);
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_swap_2(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(2),tmp;
               0  tmp=c(2); c(2)=c(1); c(1)=tmp;
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_swap_4(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(4),tmp;
               0  tmp=c(4); c(4)=c(1); c(1)=tmp;
               0  tmp=c(3); c(3)=c(2); c(2)=tmp;
               0  return; end;
               0
               0
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0  " Utility subroutines and functions previously in egsnrc.mortran
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0
1              0  %E
               0  subroutine set_spline(x,f,a,b,c,d,n);
               0  "======================================================================"
               0  "
               0  " Sets cubic spline interpolation coefficients for the data contained  "
               0  " in the array f(n) at the abscissas x(n)                              "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    x(n),f(n),a(n),b(n),c(n),d(n);
               0
               0  $INTEGER m1,m2,m,mr;
               0  $REAL    s,r;
               0
               0  m1 = 2; m2 = n-1; s = 0;
               0  DO m=1,m2 [
               1      d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
               1      c(m) = r - s; s = r;
               1      ]
               0  /s,r,c(1),c(n)/=0;
               0  DO m=m1,m2 [
               1      c(m) = c(m) + r*c(m-1);
               1      b(m) = 2*(x(m-1) - x(m+1)) - r*s;
               1      s = d(m); r = s/b(m);
               1      ]
               0  mr = m2;
               0  DO m=m1,m2 [
               1      c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
               1      mr = mr - 1;
               1      ]
               0  DO m=1,m2 [
               1      s = d(m); r = c(m+1) - c(m); d(m) = r/s;
               1      c(m) = 3*c(m);
               1      b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
               1      a(m) = f(m);
               1      ]
               0  return; end;
               0  ;
               0
               0  $REAL function spline(s,x,a,b,c,d,n);
               0  "======================================================================"
               0  "                                                                      "
               0  " Returns the value of the function at s using the spline coefficients "
               0  " a,b,c,d, which must have been set using set_spline                   "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    s,x(n),a(n),b(n),c(n),d(n);
               0
               0  integer  m_lower,m_upper,direction,m,ml,mu,mav;
               0  $REAL    q;
               0
               0  IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
               0  ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
               0  IF ( s >= x(m_upper + direction) ) [
               1      m = m_upper + 2*direction - 1;
               1      ]
               0  ELSE IF( s <= x(m_lower+1-direction) ) [
               1      m = m_lower - 2*direction + 1;
               1      ]
               0  ELSE [   " Perform a binary search to find the interval s is in "
               1      ml = m_lower; mu = m_upper;
               1      WHILE ( iabs(mu-ml) > 1 ) [
               2          mav = (ml+mu)/2;
               2          IF( s < x(mav) ) [ mu = mav; ]
               2          ELSE             [ ml = mav; ]
               2          ]
               1      m = mu + direction - 1;
               1      ]
               0  q = s - x(m);
               0  spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
               0  return; end;
               0  ;
               0
1              0  %E "start of prepare_alias_table subroutine"
               0  "****************************************************************************
               0
               0  subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Prepare an alias sampling table, given the histogram probabilities
               0  " xs_array,fs_array.
               0  "*****************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
               1      IF( aux < 1e-30 ) aux = 1e-30;
               1      ws_array(i) = -aux; ibin_array(i) = 1;
               1      sum = sum + aux;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT_1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT_2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return; end;
               0  ;
               0
1              0  %E   " start of alias_sample1 function "
               0  "******************************************************************************
               0
               0  $REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Sample a random variable from the alias table
               0  "    xs_array,fs_array,ws_array,ibin_array
               0  " which must have been prepared with prepare_alias_table
               0  "
               0  "******************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $INTEGER j;
               0  $REAL    r1,r2,aj,x,dx,a,rnno1;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  aj = 1 + r1*nsbin; j = aj; aj = aj - j;
               0  IF( aj > ws_array(j) ) j = ibin_array(j);
               0  x = xs_array(j-1); dx = xs_array(j)-x;
               0  IF( fs_array(j-1) > 0 ) [
               1      a = fs_array(j)/fs_array(j-1)-1;
               1      IF( abs(a) < 0.2 ) [
               2          rnno1 = 0.5*(1-r2)*a;
               2          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
               2          ]
               1      ELSE [
               2          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
               2          ]
               1      ]
               0  ELSE [
               1      alias_sample1 = x + dx*sqrt(r2);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of prepare_alias_histogram routine "
               0  subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
               0  "*************************************************************
               0  "                                                                           "
               0  " Prepares an alias histogram for the probability array ws_array of         "
               0  " dimension nsbin.                                                          "
               0  " On return, the ws_array is modified and contains the alias weights,       "
               0  " ibin_array holds the alias indices.                                       "
               0  " To be used with the integer function sample_alias_histogram, which        "
               0  " returns a bin index j with probability ws_array(j)                        "
               0  "                                                                           "
               0  " Iwan Kawrakow, November 2001
               0  "***************************************************************************"
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      sum = sum + ws_array(i); ibin_array(i) = -1;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
               2          ]
               1
               1      DO j_l = 1,nsbin [
               2          IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
               2          ]
               1
               1      aux = sum - ws_array(j_l);
               1      ws_array(j_h) = ws_array(j_h) - aux;
               1      ws_array(j_l) = ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1
               1      ]
               0
               0  DO i=1,nsbin [
               1      IF( ibin_array(i) < 0 ) [
               2          ibin_array(i) = i; ws_array(i) = 1;
               2          ]
               1      ]
               0
               0  return;
               0  end;
               0
1              0  %E   " start of sample_alias_histogram function "
               0  $INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
               0  "***********************************************************************
               0  "
               0  " This function samples a bin index using the alias sampling technique.
               0  " The arrays ws_array and ibin_array of dimension nsbin must have been
               0  " prepared with the subroutine prepare_alias_histogram.
               0  "
               0  " Iwan Kawrakow, November 2001.
               0  "***********************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(*);
               0  $REAL     ws_array(*);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    r1,r2;
               0  $INTEGER ibin;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  ibin = 1 + nsbin*r1;
               0  IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
               0  sample_alias_histogram = ibin;
               0  return;
               0  end;
               0
1              0  %E   " start of gauss_legendre subroutine "
               0  "******************************************************************************
               0
               0  subroutine gauss_legendre(x1,x2,x,w,n);
               0
               0  "     Given the lower and upper limit of integration, x1 and x2,
               0  "     and given n, this routine returns arrays x and w,
               0  "     containing the abscissas and weights of the Gauss-Legendre
               0  "     n - point quadrature formula
               0  "
               0  "******************************************************************************
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER n;
               0  real*8   x1,x2,x(n),w(n);
               0
               0  real*8     eps,Pi;
               0  parameter (eps = 3.D-14, Pi = 3.141592654D0);
               0
               0  $INTEGER i,m,j;
               0  real*8   xm,xl,z,z1,p1,p2,p3,pp;
               0
               0  m = (n + 1)/2;
               0  xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
               0  DO i=1,m [
               1      z=cos(Pi*(i-.25d0)/(n+.5d0));
               1      LOOP [
               2          p1=1.d0; p2=0.d0;
               2          DO j=1,n [
               3              p3 = p2; p2 = p1;
               3              p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
               3              ]
               2          pp=n*(z*p1-p2)/(z*z-1.d0);
               2          z1=z; z=z1-p1/pp;
               2          ] UNTIL (abs(z-z1) < eps);
               1      x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
               1      w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of lnblnk1 function"
               0  "******************************************************************************
               0
               0  integer  function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  integer i;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
1              0  %E   " start of erf1 function "
               0  "************************************************************************
               0  "       an error function routine which is needed since some of
               0  "       the compiler don't have it as an intrinsic
               0  "
               0  "       Originally came from some library somewhere (Harwell I think)
               0  "       recoded in mortran
               0  "************************************************************************
               0
               0  $REAL FUNCTION ERF1(X);
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL x;
               0
               0  double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
               0  " (K=1) and for erfc(x) x>3 (K=2)
               0  double precision
               0  CONST,                   " 2/sqrt(pi)
               0  BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
               0  Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
               0  $INTEGER N,                     " recursion index n
               0  K,                     " K=1,2 for x <= 3 or x > 3
               0  NLIM(2);               " Maximum value of n in sum for K=1,2
               0
               0  DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
               0  -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
               0  0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
               0  -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
               0  0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
               0  -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
               0  0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
               0  -0.0000000000000005 ,  0.0000000000000001 ,
               0  0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
               0  -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
               0  0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
               0  0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
               0  -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;
               0
               0  DATA NLIM/ 22,16 /;
               0  DATA CONST/ 1.128379167095513 /;
               0
               0  IF( x > 3 ) [ y = 3/x; k = 2; ]
               0  ELSE        [ y = x/3; k = 1; ]
               0
               0  " Calculate sum of Chebyshev polynomials by backwards recursion
               0  "
               0  "       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
               0  "       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
               0  "                                      = ( B(0) - B(2) + A(0) ) / 2
               0  "
               0  "       where B(N+2) = B(N+1) = 0
               0  "       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
               0  "
               0  FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
               0  BN1 = 0.0;                       " Initialise B(N+2) = 0
               0  BN  = 0.0;                       " Initialise B(N+1) = 0
               0
               0  DO n = NLIM(K),0,-1 [
               1      BN2 = BN1; BN1 = BN;
               1      BN = FAC * BN1 - BN2 + A(N,K)
               1      ]
               0
               0  IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
               0  ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]
               0
               0  RETURN;
               0  end;
               0
1              0  %E   " start of zero function "
               0  "********************************************************"
               0  "   Finds minimum non-zero value which can be used for   "
               0  "   evaluating logarithms without getting a NAN.         "
               0  "                                                        "
               0  " Starting with 10^-20 and decreasing it by 5 orders of  "
               0  " magnitud at a time, a check is made until the compiler "
               0  " recognizes the number as zero and the previous number  "
               0  " used. The same procedure is applied to this number but "
               0  " decreasing it by one order of magnitud. Finally it is  "
               0  " divided by 2..10 until the zero-check is successful.   "
               0  "********************************************************"
               0  $REAL FUNCTION ZERO();
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER i;
               0  $REAL    x, xtemp;
               0
               0  x = 1.E-20;
               0  "jump over 5 orders of magnitude"
               0  DO i=1,100[
               1      IF (x = 0.0) [EXIT;]
               1      ELSE[xtemp = x;]
               1      x = x/1.E5;
               1      ]
               0  x = xtemp;
               0  "jump over 1 order of magnitude"
               0  DO i=1,5[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/10;
               1      ]
               0  x = xtemp;
               0  "divide it up by 2...10"
               0  DO i=2,10[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/i;
               1      ]
               0  zero = xtemp;
               0  return;end;
               0  ;
               0
1              0  %E   " start of toUpper function "
               0  "**************************************"
               0  "
               0  "   Converts a string to upper case.   "
               0  "                                      "
               0  "**************************************"
               0  character*512 function toUpper(a_string);
               0  character*(*) a_string;
               0  character*512 the_string;
               0  $INTEGER cursor, i, lnblnk1;
               0  toUpper = a_string; the_string = a_string;
               0  DO i=1, lnblnk1(the_string) [
               1      cursor=ICHAR(the_string(i:i));
               1      IF ((cursor.GE.97).AND.(cursor.LE.122)) [
               2          cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
               2          ]
               1      ]
               0  return; end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0  "================================================================="
               0  integer*1 function egs_read_byte(iunit, jrec);
               0  "================================================================="
               0  " Reads one byte from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*1 i_1;
               0  character c_1;
               0  equivalence (i_1,c_1);
               0  ;COMIN/EGS-IO/;
               0  read(iunit,rec=jrec,IOSTAT=ierr) c_1;
               0  IF (ierr.ne.0) [
               1      $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
               1      $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               1      egs_read_byte = -1; return;
               1      ]
               0  jrec = jrec + 1; egs_read_byte = i_1;
               0  return; end;
               0
               0  "================================================================="
               0  integer*2 function egs_read_short(iunit, jrec);
               0  "================================================================="
               0  " Reads short int from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*2 i_2;
               0  character c_2(2);
               0  equivalence (i_2,c_2);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+1[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_2(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_short = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 2; egs_read_short = i_2;
               0  return; end;
               0
               0  "================================================================="
               0  integer*4 function egs_read_int(iunit, jrec);
               0  "================================================================="
               0  " Reads integer from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*4 i_4;
               0  character c_4(4);
               0  equivalence (i_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_int = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_int = i_4;
               0  return; end;
               0
               0
               0  "================================================================="
               0  real*4 function egs_read_real(iunit, jrec);
               0  "================================================================="
               0  " Reads float from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  real*4 r_4;
               0  character c_4(4);
               0  equivalence (r_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_real = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_real = r_4;
               0  return; end;
               0
               0  "****************************************************************
               0  "*                                                              *
               0  "*                 Function ibsearch(a, nsh, b)                 *
               0  "*                                                              *
               0  "*       binary search for an element l of array b such that    *
               0  "*   b[l] =< a < b[l+1], array must be monotonically increasing *
               0  "*                                                              *
               0  "****************************************************************
               0  $INTEGER function ibsearch(a, nsh, b);
               0  implicit none;
               0  $REAL a, b(*);
               0  $INTEGER min,max,help,nsh;
               0  $REAL x;
               0  min = 1; max = nsh; x = a;
               0  WHILE ( min < max-1 )[
               1      help = (max+min)/2;
               1      IF ( b(help).le.x)[min = help;]
               1      ELSE[max = help;]
               1      ]
               0  ibsearch = min;
               0  return;end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parallel processing functions                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " The following set of functions only gets included if we found a working     "
               0  " C compiler that can compile egs_c_utils.c                                   "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  #ifdef HAVE_C_COMPILER;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_create_lockfile(flag);
               0  "*****************************************************************************
               0  " Create a lock file in the user code directory to store parallel processing
               0  " information. To be called from job #1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_create_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to create a lock file named ',$cstring(fname));
               1      ]
               0  egs_create_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_open_lockfile(flag);
               0  "*****************************************************************************
               0  " Open a lock file in the user code directory to read/write parallel
               0  " processing info. To be called from all jobs except 1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_open_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to open the lock file named ',$cstring(fname));
               1      ]
               0  egs_open_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_remove_lockfile(istat);
               0  "*****************************************************************************
               0  $INTEGER istat;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_remove_file(fname,istat);
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,dres);
               0  "*****************************************************************************
               0  "
               0  " This subroutine controls a parallel run. It only works if the EGS_HOME
               0  " directory is the same for all machines participating in the parallel
               0  " processing (e.g. EGS_HOME is on a NFS for *nix or on a network share on
               0  " Windows).
               0  " n_case: number of histories to be run (all jobs, not just the current
               0  "         job)  (input)
               0  " n_run:  number of histories the user code should run (output). If n_run = 0,
               0  "         then finish simulation, clean up, call egs_finish and
               0  "         egs_pjob_finish (in that order) and exit.
               0  " n_left  no. of histories left to run after current job has been submitted
               0  " n_tot:  should be set to number of histories from previous runs (if any)
               0  "         for first call from job number 1. For all other jobs and for all
               0  "         other calls from job 1, it is set by egs_pjob_control to the
               0  "         number of histories run so far (including previous runs and other
               0  "         parallel jobs).
               0  "         Note: n_case, n_run and n_tot are $LONG_INT
               0  " sum,    input. for first call and job 1, score and score squared for quantity
               0  " sum2:   of interest, should be zero for first call from jobs other than 1.
               0  "         score for quantity of interest since last call to this subroutine
               0  "         for all other calls.
               0  " res:    combined result for the quantity of interest from previous runs
               0  "         and other parallel jobs, output
               0  " dres:   relative uncertainty of res in %
               0  "
               0  " The shower loop of a user code that wants to use the new parallel processing
               0  " implementation should look something like this:
               0  "
               0  " /sum,sum2/=0; (or result from a previous run, if i_parallel=1)
               0  " /last_sum,last_sum2/=0;
               0  " :start_simulation:
               0  " x=sum-last_sum; x2=sum2-last_sum2; last_sum=sum; last_sum2=sum2;
               0  " call egs_pjob_control(ncase,n_run,n_tot,x,x2,res,dres);
               0  " IF( n_run = 0 ) goto :end_simulation:
               0  " write(6,*) ' running ',n_run,' histories,' n_tot so far: ',n_tot;
               0  " write(6,*) ' result so far: ',res,' +/- ',dres,' %';
               0  " DO icase=1,n_run [
               0  "    get source particle, call shower. sum and sum2 are updated
               0  " ]
               0  " goto :start_simulation:;
               0  " :end_simulation:
               0  " analyze and output results for this job.
               0  " call egs_finish;
               0  "   (after egs_finish all output files are closed and moved to the user code
               0  "    directory from the temporary working directory).
               0  " call egs_pjob_finish(combine_results,'.egsdat');
               0  " output combined results.
               0  " end;
               0  "
               0  " In the above, combine_results is a user supplied subroutine that
               0  " combines parallel runs and takes a file name as an argument.
               0  " egs_pjob_finish  decreases the number of running job, n_job, in the
               0  " job control file by one. If n_job > 0, it simply returns.
               0  " If n_job = 0 (i.e. this job is the last job), it checks for
               0  " data files output_file_wj.egsdat, j=1,99. For each file found, it calls
               0  " combine_results with that file name.
               0  "
               0
               0  implicit none;
               0  $LONG_INT ncase,n_run,n_tot;
               0  $REAL    sum,sum2,res,dres;
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $LONG_INT n_last,n_left,nn_tot;
               0  integer   t_dum(8);
               0  $INTEGER  i,lnblnk1,n_write,n_read,istat,n_job;
               0  $INTEGER  egs_create_lockfile, egs_open_lockfile;
               0  $REAL     tmp,tmp2;
               0  $LOGICAL first_time;
               0  character control_string*256;
               0  data first_time/.true./;
               0  save first_time,n_last;
               0
               0
               0
               0
               0  IF( is_uniform_run ) [
               1      IF (first_time)[
               2          n_run = ncase/n_parallel;
               2          first_time = .false.;
               2          ]
               1      ELSE[
               2          n_run = 0;
               2          ]
               1      n_left = 0;
               1      return;
               1      ]
               0
               0  IF( n_parallel <= 0 ) [
               1      n_run = ncase; return;
               1      ]
               0
               0  IF( first_time ) n_last = 0;
               0
               0  $set_string(control_string,' ');
               0  n_run = ncase/n_parallel/$N_CHUNKS;
               0  n_left = ncase;
               0
               0  REPLACE {$control_format} WITH {
            {  0  '(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)'};
               0
               0  IF( first_time ) [
               1      IF( n_run > n_left ) n_run = n_left;
               1      n_left = ncase - n_run;
               1
               1      IF( i_parallel = first_parallel ) [ "I'm first job => "
               2          "create the job control file"
               2          istat = egs_create_lockfile(1); "The 1 tells egs_create_lockfile to "
               2          "print an error message and exit if"
               2          "it fails."
               2          IF( n_tot > 1 ) [ "=> a continuation from a previous run "
               3              res = sum/n_tot; dres = sum2/n_tot - res*res;
               3              IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               3              ELSE [ dres = 99.9 ]
               3              ] ELSE [ res = 0; dres = 99.9; ]
               2
               2
               2
               2
               2
               2          write(control_string,$control_format)
               2          n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8);
               2          n_write = lnblnk1(control_string) + 1;
               2          call egs_write_control_file(control_string,n_write,istat);
               2          IF( istat ~= n_write ) [
               3              $egs_fatal(*,'job 1: failed to write to lock file ',n_write,istat);
               3              ]
               2          call egs_unlock_control_file(istat);
               2          IF( istat ~= 0 ) [
               3              $egs_fatal(*,'job 1: failed to unlock the file ',istat);
               3              ]
               2          first_time = .false.;
               2          n_max_parallel = 1; n_last = n_run;
               2          return;
               2          ]
               1      istat = egs_open_lockfile(1);
               1      ]
               0
               0  " Here for all calls except first call from job 1. "
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,err=:error_lockfile_read:) n_left,nn_tot,n_job,tmp,tmp2,
               0  res,dres,(t_dum(i),i=1,8);
               0
               0  " Update the number of histories finished so far "
               0  nn_tot = nn_tot + n_last;
               0
               0  " Update the score for the quantity of interest "
               0  tmp = tmp + sum; tmp2 = tmp2 + sum2;
               0
               0  " First call => increase number of running jobs "
               0  IF( first_time ) [
               1      first_time = .false.; n_job = n_job + 1;
               1      nn_tot = nn_tot + n_tot;
               1      ]
               0  n_tot = nn_tot;
               0
               0  " If n_tot > 1, do stat. analysis and put result is res, dres "
               0  IF( n_tot > 1 ) [
               1      res = tmp/n_tot; dres = tmp2/n_tot - res*res;
               1      IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               1      ELSE [ dres = 99.9 ]
               1      ] ELSE [ res = 0; dres = 99.9; ]
               0
               0  " Take another chunk of histories to run "
               0  IF( n_run > n_left ) [
               1      n_run = n_left; n_left = 0;
               1      ] ELSE [ n_left = n_left - n_run; ]
               0
               0  n_last = n_run;
               0
               0  " Write new job control info into job control string "
               0  $set_string(control_string,' ');
               0  write(control_string,$control_format)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8);
               0
               0  " Rewind again the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1
               1      ]
               0
               0  " Write the new job control string "
               0  n_write = lnblnk1(control_string) + 1;
               0  call egs_write_control_file(control_string,n_write,istat);
               0  IF( istat ~= n_write ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               1      n_write,istat);
               1      ]
               0
               0  " Finally unlock the job control file so that other jobs can access it. "
               0  call egs_unlock_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to unlock the file ',istat);
               1      ]
               0  IF( n_job > n_max_parallel ) n_max_parallel = n_job;
               0  return;
               0
               0  :error_lockfile_read:
               0  $egs_fatal('(a,/a)','Failed to read from job control file: got ',
               0  $cstring(control_string));
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_pjob_finish(n_job);
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER n_job;
               0
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $INTEGER  istat,i,lnblnk1,n_read,n_write;
               0  $LONG_INT n_left,n_tot;
               0  integer   t_start(8),t_end(8);
               0  $REAL     tmp,tmp2,res,dres,t_run;
               0  real      egs_time_diff;
               0  character control_string*256;
               0
               0
               0
               0
               0  IF( is_uniform_run )[
               1      IF( i_parallel = n_parallel )[
               2          n_job = 0;"I am the last job!!!"
               2          goto :complete_calculation:;
               2          ]
               1      ELSE ["nothing to do here"
               2          n_job = 1;"Only last job allowed to finish!"
               2          return;
               2          ]
               1      ]
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,end=:error2_lockfile_read:,err=:error2_lockfile_read:)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               0
               0  n_job = n_job - 1;
               0  IF( n_job > 0 ) [  " Other jobs still running "
               1      $set_string(control_string,' ');
               1      write(control_string,$control_format)
               1      n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               1      call egs_rewind_control_file(istat);
               1      IF( istat ~= 0 ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the ',
               2          'control file, error was:', istat);
               2          ]
               1      n_write = lnblnk1(control_string) + 1;
               1      call egs_write_control_file(control_string,n_write,istat);
               1      IF( istat ~= n_write ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               2          n_write,istat);
               2          ]
               1      call egs_unlock_control_file(istat);
               1      call egs_close_control_file(istat);
               1      return;
               1      ]
               0
               0  " If here, I'm the last job => remove job control file
               0
               0  call egs_close_control_file(istat);
               0  call egs_remove_lockfile(istat);
               0
               0  :complete_calculation:;
               0  i_parallel = 0; call egs_open_units(.false.);
               0  IF ( is_uniform_run )[
               1      $egs_info('(/a/,a,t55,i3/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      '***************************************************************');
               1      ]
               0  ELSE[
               1      call egs_date_and_time(t_end);
               1      t_run = egs_time_diff(t_start,t_end);
               1      $egs_info('(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      ' max. number of jobs executing simultaneously: ',n_max_parallel,
               1      ' elapsed time since first job started: ',t_run,' s (',t_run/3600,' h)',
               1      '***************************************************************');
               1      ]
               0  return;
               0
               0  :error2_lockfile_read:;
               0  $egs_fatal('(a,/a)',
               0  'In egs_pjob_finish: failed to read from control string ',
               0  $cstring(control_string));
               0
               0  return; end;
               0
               0
               0  #endif;
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 routines                                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but NOTE, this doesn't happen inside a REPLACE macro
               0  "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE EFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  $REAL4 E,V(8);
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM;
               0
               0  "*****SUBROUTINE TO COMPUTE ELECTRON FUNCTIONS TO BE FIT           "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  COMIN/THRESHP,DERCON,EGS-IO/;
               0  THBREM=RMP+APP;"threshold for bremsstrahlung"
               0  IF(IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)[
               1  "  REGULAR DATA SET OR"
               1  "   UNRESTRICTED COLLISIONAL(1) OR RADIATIVE(5) STOPPING POWERS"
               1  "write(58,*)' here e ',e;"
               1  BREM=BREMTM(E);
               1  AMOLL=AMOLTM(E);
               1  BHAB=BHABTM(E);
               1  ANNIH=ANIHTM(E);
               1  ESIG=BREM+AMOLL; "TOTAL ELECTRON CROSS-SECTION"
               1  V(1)=ESIG;
               1  PSIG=BREM+BHAB+ANNIH;"TOTAL POSITRON CROSS SECTION"
               1  V(2)=PSIG;
               1  V(3)=SPTOTE(E,AEP,APP); "TOTAL ELECTRON STOPPING POWER"
               1  V(4)=SPTOTP(E,AEP,APP);"TOTAL POSITRON STOPPING POWER"
               1  "EBR1=BREM/(BREM+AMOLL)"
               1  IF (ESIG.GT.0.0)[V(5)=BREM/ESIG;]
               1  ELSE["BELOW THRESHOLD FOR BOTH BREMS AND MOLLER. USE THE BRANCHING"
               2  "RATIO THAT EXISTED WHEN CROSS SECTION APPROACHED ZERO"
               2  IF (THBREM.LE.THMOLLP)[V(5)=1.0;]ELSE[V(5)=0.0;]
               2  ]
               1  V(6)=BREM/PSIG;"PBR1=BREM/(BREM+BHABA+ANNIH)"
               1  V(7)=(BREM+BHAB)/PSIG;"PBR2=(BREM+BHABA)/(PSIG)"
               1  "MAXIMUM ALLOWED TRANSPORT STEP, FROM MULTIPLE SCATTERING"
               1  V(8)=TMXS(E);
               1  "write(*,*)'v1,v2,v3,v4,v5,v6,v7,v8 ',v(1),v(2),v(3),v(4),v(5),v(6),v(7),v(8);"
               1  ]
               0  "  THE FOLLOWING ARE UNDOCUMENTED ADDITIONS"
               0  ELSEIF(IUNRSTP.EQ.2)[ "FULL CSDA DATA SET WITH NO DISCRETE INTERACTIONS"
               1  /V(1),V(2),V(5),V(6),V(7)/=0.0;
               1  "ZERO TOTAL CROSS SECTION FOR EL & POS, AND ZERO BRANCHING RATIOS"
               1  V(3) = SPTOTE(E,E,E);"  TOTAL UNRESTRICTED STOPPING POWER"
               1  V(4) = SPTOTP(E,E,E);
               1  V(8) = TMXS(E);]
               0  ELSEIF(IUNRSTP.EQ.3)["CONSIDER BREM AND ANNIHILATION IN FLIGHT AS"
               1  "     DISCRETE EVENTS BUT TREAT DELTAS IN CSDA"
               1  BREM=BREMTM(E);  ANNIH=ANIHTM(E);
               1  V(1)=BREM; "TOTAL X-SECTION IS JUST BREM"
               1  V(2)=BREM + ANNIH;"POSITRONS ALSO HAVE ANNIHILATION IN FLIGHT"
               1  V(3)=SPTOTE(E,E,APP);"UNRESTRICTED COLLISIONAL+RESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,E,APP);"    ''                             ''    "
               1  V(5)=1.0;"ALL ELECTRON EVENTS ARE BREM EVENTS"
               1  V(6)=BREM/V(2);"FRACTION FOR POSITRONS WHICH IS BREM"
               1  V(7)=V(6);"FRACTION WHICH IS BREM + COLLISION(=0)"
               1  V(8)=TMXS(E);]
               0
               0  ELSEIF(IUNRSTP.EQ.4)["CREATE SECONDARIES BUT HAVE NO DISCRETE BREM OR"
               1  "ANNIHILATION IN FLIGHT"
               1
               1  V(1)=AMOLTM(E);"ONLY MOLLERS FOR ELECTRONS"
               1  V(2)=BHABTM(E);"ONLY BHABHA FOR POSITRONS"
               1  V(3)=SPTOTE(E,AEP,E);"RESTRICTED COLLISIONAL + UNRESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,AEP,E);"         ''                         ''       "
               1  V(5)=0.0;"I.E. NEVER BREMS"
               1  V(6)=0.0;"I.E. NEVER BREMS"
               1  V(7)=1.0;"ALL BHABHA - NO ANNIHILATION"
               1  V(8)=TMXS(E);]
               0
               0  ELSE ["IUNRST=6 OR 7 NOT ALLOWED HERE"
               1  OUTPUT IUNRSTP; (//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/
               1  ' IUNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//);
               1  $CALL_EXIT(20);]
               0  RETURN;
               0  END; "END OF SUBROUTINE EFUNS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,BREMRM;
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.APP+RMP) [BREMTM=0.; ]
               0  ELSE [BREMTM=BREMRM(E0,APP,E0-RMP);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2;
               0  $INTEGER I;
               0  $REAL4    BREMRZ;
               0  COMIN/MIXDAT/;
               0  BREMRM=0.;
               0  DO I=1,NEP [BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BREMFZ;
               0  $REAL4  DUMMY,BREMDZ,QD,BREMFZ;
               0  "     INITIALIZE BREMFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BREMDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BREMDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)'2 e ',e;"
               0  DUMMY=BREMDZ(Z,E,K1);
               0  BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ');
               0  "write(58,*)'bremrz ',BREMRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BREMRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMDZ(Z,E,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4    Z,E,K,BRMSDZ;
               0  "***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
               0  "   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
               0  "   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
               0  "   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
               0  "   BREMDZ.. D-SIGMA/D-K FOR BREMS IN Z                              "
               0  "   BRMSDZ.. K*(D-SIGMA/D-K) FOR SOFT ENERGY LOSS FROM BREMS IN Z    "
               0
               0  "EVALUATES EQUATION 2.7.108 IN SLAC-265"
               0
               0  BREMDZ=BRMSDZ(Z,E,K)/K;
               0  "write(58,*)'bremdz,z,e,k ',BREMDZ,z,e,k;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMDZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 K,BRMSFZ;
               0  BREMFZ=BRMSFZ(K)/K;
               0  "write(58,*)'bremfz ',BREMFZ;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 K;
               0  $REAL4 EMKLOC,DELTA,SB1,SB2,EE;
               0  COMIN/LBREMZ/;
               0  EMKLOC=EBREMZ-K;
               0  IF(EMKLOC.EQ.0.0) [EMKLOC=1.E-25;]
               0  DELTA=DELC*K/EMKLOC;
               0  IF (DELTA.GE.DELTAM) [BRMSFZ=0.0;]
               0  ELSE [IF (DELTA.LE.1.)[
               2  SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
               2  SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
               1  ELSE [SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ;
               2  SB2=SB1;]
               1  EE=EMKLOC/EBREMZ;
               1  BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2);]
               0  "write(58,*)' const,ee,sb1,sb2,brmsfz ',const,ee,sb1,sb2,brmsfz;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    T0,AMOLRM;
               0  "***TOTAL CROSS SECTION FOR MOLLER SCATTERING WITH INCIDENT ELECTRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.THMOLLP) [AMOLTM=0.; ]
               0  ELSE [T0=E0-RMP;
               1  AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP);] "EQ.2.10.6"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    EN0,EN1,EN2;
               0  $REAL4    T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2;
               0  "***MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  C1=(TM/EM)**2;
               0  C2=(2.*TM+1.)/EM**2;
               0  BETASQ=1.-1./EM**2;
               0  CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM); "CONSTANT FACTOR IN EQ.2.10.3"
               0  EPS1=T1/T0;
               0  EPSP1=1.-EPS1;
               0  EPS2=T2/T0;
               0  EPSP2=1.-EPS2;
               0  AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1
               0    -C2*LOG(EPS2*EPSP1/(EPS1*EPSP2))); "EQ.2.10.3"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR BHABHA SCATTERING WITH INCIDENT POSITRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4 E0,BHABRM;
               0  COMIN/THRESHP/;
               0  IF (E0.LE.AEP) [BHABTM=0.;]
               0  ELSE [BHABTM=BHABRM(E0,AEP,E0);]  "EQ.2.11.4"
               0  RETURN;
               0  END; "END OF FUNCTION BHABTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  ;
               0  implicit none;
               0  $REAL4 EN0,EN1,EN2;
               0  $REAL4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  Y=1./(TM+2.);
               0  BETASI=1./(1.-1./EM**2);
               0  CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM; "CONSTANT FACTOR IN EQ.2.11.2"
               0  B1=2.-Y**2;
               0  B2=3.-Y*(6.-Y*(1.-Y*2.));
               0  B3=2.-Y*(10.-Y*(16.-Y*8.));
               0  B4=1.-Y*(6.-Y*(12.-Y*8.));
               0  EPS1=T1/T0;
               0  EPS2=T2/T0;
               0  BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1)
               0    +B2*(EPS2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3)
               0    - EPS1*EPS1*(EPS1*B4/3.-0.5*B3));  "EQ.2.11.2"
               0  RETURN;
               0  END; "END OF FUNCTION BHABRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ANIHTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR TWO-PHOTON POSITRON-ELECTRON ANNIHILATION"
               0  "   WITH INCIDENT POSITRON ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    GAM,P0P2,P0P,CANIH;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  GAM=E0/RMP;   "EQ.2.12.3"
               0  P0P2=GAM*GAM-1.0;
               0  P0P=SQRT(P0P2);  "EQ.2.12.6"
               0  CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.); "CONSTANT FACTOR IN EQ.2.12.14"
               0  ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P)
               0     -(GAM+3.)/P0P);   "EQ.2.12.14"
               0  RETURN;
               0  END;  "END OF FUNCTION ANIHTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTP(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "MODIFIED JAN 1989 DWOR AS SPTOTE                                  "
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONP,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG);
               1  "write(*,*)' eo,ee,eg,spionp,brmstm ',e0,ee,eg,SPIONP(E0,EE),BRMSTM(E0,EG);"]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTP=SPIONP(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTP=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTP=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTP=SPIONP(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTE(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  " patched DWOR, Jan 1988 to correct IURST=2,3,4 and add 6 and 7    "
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONE,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTE=SPIONE(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTE=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTE=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTE=SPIONE(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONE(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONE=SPIONB(E0,EE,.FALSE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONB(E0,EE,POSITR);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***STOPPING POWER FOR AN ELECTRON.  THIS FUNCTION ALSO HAS OTHER    "
               0  "   ENTRY POINTS. . .                                                "
               0  "   SPIONP(E0,EE) - STOPPING POWER FOR A POSITRON                    "
               0  "   SPINIT(MEDIUM) - DOES INITIALIZATION FOR THE OTHER ENTRY POINTS  "
               0  "   WHENEVER THE MEDIUM CHANGES.                                     "
               0  "   THIS FUNCTION IS FOR STOPPING POWER DUE TO COLLISIONS WITH LESS  "
               0  "   THAN EE-RM ENERGY TRANSFER AND DOES NOT INCLUDE SOFT BREMS LOSS. "
               0  "   WE USE BERGER AND SELTZER'S FORMULATION.                         "
               0  "   STOPPING POWER IS RETURNED IN UNITS OF MEV/R.L.                  "
               0  ;
               0  implicit none;
               0  $REAL4   E0,EE;
               0  LOGICAL POSITR;
               0  $REAL4   G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA;
               0  $INTEGER I;
               0  COMIN/DERCON,LSPION,EPSTAR/; "MOD NOV 24,1988"
               0  "     COMMON POINT FOR E- AND E+ ENTRIES.                              "
               0  G=E0/RMP;
               0  EEM=EE/RMP-1.;
               0  "     T IS BERGER'S TAU                                                "
               0  T=G-1;
               0  ETA2=T*(G+1.);
               0  BETA2=ETA2/G**2;
               0  ALETA2=LOG(ETA2);
               0  X=0.21715*ALETA2;
               0  "     0.21715=ALOG10(E)/2.   THIS FACTOR IS BECAUSE THE DEFINITION OF  "
               0  "     X IS ALOG10(P/(MC)) AND ETA2=ETA**2=(P/MC)**2                    "
               0  IF (.NOT.POSITR)["THIS IS ELECTRON CASE"
               1  "     COMPUTE F-TERM FOR ELECTRON.  MAXIMUM TRANSFER IS T/2            "
               1  "     D IS BERGER'S CAPITOL DELTA.                                     "
               1  D=AMIN1(EEM,0.5*T);
               1  "     EEM IS DEFINED AS EE/RM-1 IS ENERGY TRANSFER THRESHOLD FOR       "
               1  "     DISCRETE MOLLER AND BHABHA SCATTERING(IN UNITS OF RM.)           "
               1  FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D)
               1    +(D*D/2.+(2.*T+1.)*LOG(1.-D/T))/(G*G);]
               0  "     COMPUTE F-TERM FOR POSITRON.  MAXIMUM TRANSFER IS T.             "
               0  ELSE ["THIS IS POSITRON CASE"
               1  D=AMIN1(EEM,T);
               1  TP2=T+2.;
               1  D2=D*D;
               1  D3=D*D2;
               1  D4=D*D3;
               1  FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2
               1   -(D-D3/3.)/(TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3);]
               0
               0  "     NOW COMPUTE THE DENSITY CORRECTION TERM.                         "
               0
               0  IF(EPSTFLP = 0) ["USE STANDARD PEGS4 METHOD"
               1  IF (X.LE.X0) [DELTA=0.0;]
               1  ELSEIF (X.LT.X1) [DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK;]
               1  ELSE [DELTA=TOLN10*X - CBAR;]]
               0
               0  ELSE ["USE LINEAR INTERPOLATION OF USER SUPPLIED INPUT TABLE"
               1
               1  "IEPST IS A POINTER SUCH THAT                              "
               1  "       EPSTEN(IEPST) <= E0 < EPSTEN(IEPST+1)              "
               1  "                                                          "
               1  "IEPST IS INITIALIZED IN BLOCK DATA TO 1. WE START FROM    "
               1  "THE PREVIOUS VALUE OF THE POINTER SINCE WE ASSUME THAT    "
               1  "THE CODE IS WORKING UP OR DOWN A GRID.                    "
               1  "  THIS CODING IS FAR FROM OPTIMAL                         "
               1
               1  IF(E0 >= EPSTEN(IEPST))["AT OR ABOVE PREVIOUS ENTRY"
               2  IF(E0 = EPSTEN(IEPST))["FOUND ENTRY, INCLUDING THE POSSIBILITY"
               3  "THAT WE ARE AT THE TOP OF THE TABLE"     GO TO :END-SEARCH:;]
               2
               2  DO I= IEPST,NEPST-1 [
               3       IF(E0<EPSTEN(I+1))["WE FOUND IT" IEPST = I; GO TO :END-SEARCH:]
               3       ]
               2  "IF WE FALL THRU TO HERE, WE MUST BE AT UPPER ENERGY"
               2  IEPST = NEPST; GO TO :END-SEARCH:;
               2  ]"END OF BLOCK E0>EPSTEN(IEPST)"
               1
               1  ELSE [ "E0<EPSTEN(IEPST)"
               2
               2  DO I = IEPST,2,-1 [
               3      IF(E0 >= EPSTEN(I-1)) [IEPST = I-1; GO TO :END-SEARCH:;]
               3      ]
               2  "   IF WE GET HERE WE MUST BE IN THE FIRST REGION"
               2      IEPST = 1;]
               1
               1  :END-SEARCH:
               1
               1  "NOW JUST INTERPOLATE LINEARLY IN THE ENERGY"
               1  IF(IEPST < NEPST) [
               2     DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/
               2     (EPSTEN(IEPST+1) - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST));]
               1  ELSE [DELTA = EPSTD(NEPST);]
               1
               1  ]"END OF EPSTFL NON-ZERO BLOCK"
               0
               0  "     NOW PUT IT ALL TOGETHER                                          "
               0  SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONP(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONP=SPIONB(E0,EE,.TRUE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSTM(E0,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EG,BRMSRM,AU,zero;
               0  parameter (zero=0);
               0  COMIN/DERCON/;
               0  IF (E0.LE.RMP) [BRMSTM=0.; ]
               0  ELSE [AU=AMIN1(EG,E0-RMP);
               1  BRMSTM=BRMSRM(E0,zero,AU);
               1  "write(*,*)'au,e0,brmsrm ',au,e0,BRMSRM(E0,zero,AU);"
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2,BRMSRZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  BRMSRM=0.;
               0  DO I=1,NEP[BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2);
               1  "write(*,*)'i,e,k1,k2,pz,brmsrz ',i,e,k1,k2,PZ(i_med,I),"
               1  "BRMSRZ(ZELEM(i_med,I),E,K1,K2);"]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BRMSFZ;
               0  $REAL4 DUMMY,BRMSDZ,QD,BRMSFZ;
               0  "     INITIALIZE BRMSFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BRMSDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BRMSDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)' e ',e;"
               0  DUMMY=BRMSDZ(Z,E,K1);
               0  BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ');
               0  "write(58,*)'brmsrz ',BRMSRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSDZ(Z,EA,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,EA,K;
               0  $REAL4 APRIM,XSIFP,FCOULCP,BRMSFZ;
               0  COMIN/PMCONS,DERCON,MOLVAR,LBREMZ/;
               0  EBREMZ=EA;
               0  DELC=136.*Z**(-1./3.)*RMP/EBREMZ;
               0  CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP;
               0  "write(58,*)' z,ebremz,an,rho,wm,r0,fsc,xsif,rlc,aprim ',z,ebremz,an,rhop,"
               0  "wm,r0,fsc,xsifp(z),RLCP,APRIM(Z,Ebremz);"
               0  XLNZ=4./3.*LOG(Z);
               0  IF (EBREMZ.GE.50)XLNZ=XLNZ+4.*FCOULCP(Z);
               0  ".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
               0  DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
               0  BRMSDZ=BRMSFZ(K);
               0  RETURN;
               0  END;  "END OF FUNCTION BRMSDZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION APRIM(Z,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     EMPIRICAL CORRECTION FACTOR TO BREMS CROSS SECTION               "
               0
               0  " This version can be switched to use different values:                "
               0  "   IAPRIM = 0  equivalent to old PEGS4 (default)                      "
               0  "            1  reads in values from unit 22                           "
               0  "            2  sets APRIM to 1.0                                      "
               0  " Future changes can be accommodated by reading in                     "
               0  " different data on unit 22 and if necessary changing the array sizes: "
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,E;
               0  $INTEGER  napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1;
               0  $REAL4     EM,AINTP;
               0  character  aprim_file*256;
               0  REPLACE {$NAPRE} WITH {115} " Maximum number of energies ( > 18 )      "
               0  REPLACE {$NAPRZ} WITH {14}  " Maximum number of elements ( > 5 )       "
               0
               0  REPLACE {$NAPR1} WITH {{COMPUTE $NAPRE - 18}}
               0  REPLACE {$NAPR2} WITH {{COMPUTE $NAPRZ - 5}}
               0  REPLACE {$NAPR3} WITH {{COMPUTE $NAPRE * $NAPR2}}
               0  ;COMIN/DERCON,EPSTAR,EGS-IO/; "NRC CHANGE NOV 88"
               0  $REAL4 APRIMD($NAPRE,$NAPRZ),EPRIM($NAPRE),ZPRIM($NAPRZ),APRIMZ($NAPRE);
               0  DATA APRIMD/
               0  1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*1.0,$NAPR1*0.0,
               0  1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*1.0,$NAPR1*0.0,
               0  1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.994,
               0   2*0.991,0.990,2*0.989,2*0.988,$NAPR1*0.0,
               0  1.46,1.34,1.23,1.15,1.11,1.08, 1.06,1.05,1.03,1.02,0.989,
               0   0.973,0.971,0.969,0.967,0.965,2*0.963,$NAPR1*0.0,
               0  1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,0.955,0.935,
               0   0.930,0.925,0.920,0.915,2*0.911,$NAPR1*0.0,
               0  $NAPR3*0.0/,
               0  EPRIM /
               0  2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81.,91.,
               0  $NAPR1*0.0/,
               0  ZPRIM /6.,13.,29.,50.,79.,$NAPR2*0.0/;
               0  save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz;
               0
               0  IF (IAPRIMP.EQ.0) [ " PEGS4 default APRIM"
               1      IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2
               2      ]
               1      IF (E.GE.50) [ APRIM=1.; ]
               1      ELSE [ " INTERPOLATE APRIM OVER Z "
               2          EM=E/RMP;
               2          DO IE=1,18[
               3             APRIMZ(IE)=
               3             AINTP(Z,ZPRIM,5,APRIMD(IE,1),$NAPRE,.FALSE.,.FALSE.);
               3             ] " Z INTERPOLATION IS NOW COMPLETE. NOW DO ENERGY "
               2          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.);
               2      ]
               1  ]
               0  ELSEIF (IAPRIMP.EQ.1) [
               1      IF (IAPRFL.EQ.0) [ " read in data from APRIME.DATA"
               2
               2
               2
               2
               2          aprim_file = $cstring(hen_house) // 'pegs4' // $file_sep //
               2                       'aprime.data';
               2          aprim_unit=22;" want unit 22"
               2          aprim_unit=egs_get_unit(aprim_unit);
               2          IF( aprim_unit < 1 ) [
               3               $egs_fatal(*,'APRIM: failed to get a free fortran unit');
               3          ]
               2          open(aprim_unit,file=aprim_file,status='old',err=:no_aprim_file:);
               2
               2          READ(aprim_unit,*) NAPRZ, NAPRE;
               2          IF (NAPRZ.GT.$NAPRZ) [
               3              OUTPUT; (//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRZ AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          IF (NAPRE.GT.$NAPRE) [
               3              OUTPUT; (//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRE AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE);
               2          DO IE=1,NAPRE [ EPRIM(IE)=1.+EPRIM(IE)/RMP; ]
               2          DO IZ=1,NAPRZ [READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE);]
               2          IAPRFL=1;
               2          close(aprim_unit);
               2          ]
               1      EM=E/RMP;
               1      DO IE=1,NAPRE [ " INTERPOLATE APRIM OVER LOG(Z)  "
               2          APRIMZ(IE)=
               2          AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),$NAPRE,.TRUE.,.FALSE.);
               2          ]           " NOW DO ENERGY INTERPOLATION     "
               1      APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.);
               1      ]
               0  ELSEIF (IAPRIMP.EQ.2) [
               1          IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2          ]
               1          APRIM=1.0]
               0  ELSE [ OUTPUT IAPRIMP; (//,' ILLEGAL VALUE FOR IAPRIM: ',I4);
               1         $CALL_EXIT(24); ]
               0  RETURN;
               0  :no_aprim_file:
               0  $egs_fatal(*,'Cannot open file $HEN_HOUSE/pegs4/aprime.data');
               0  RETURN;
               0  END; "END OF FUNCTION APRIM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0
               0  "     LINEAR OR LOG INTERPOLATION FUNCTION.                          "
               0
               0  "CHANGED"
               0  "REAL XA(1),YA(ISK,1);"
               0  "TO"
               0  "REAL XA(NX),YA(ISK,NX);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $INTEGER NX,ISK;
               0  $REAL4    X;
               0  $REAL4    XA(NX),YA(ISK,NX);
               0  LOGICAL XLOG,YLOG,XLOGL;
               0
               0  $INTEGER I,J;
               0  $REAL4    XI,XJ,XV,YI,YJ;
               0  XLOGL=XLOG;  "SET LOCAL VARIABLE"
               0  "     FIND INTERVAL FOR X INTERPOLATION.                             "
               0  DO J=2,NX[
               1  IF (X.LT.XA(J))GO TO :NSTEP:;]
               0  J=NX;
               0  :NSTEP:    I=J-1;
               0  IF (XA(I).LE.0.0) [XLOGL=.FALSE.;]
               0  IF (.NOT.XLOGL)[ XI=XA(I); XJ=XA(J); XV=X;]
               0  ELSE [XI=LOG(XA(I)); XJ=LOG(XA(J)); XV=LOG(X);]
               0  IF (YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))
               0     [AINTP=0.0;]
               0  ELSE[
               1      IF(YLOG)[YI=LOG(YA(1,I));YJ=LOG(YA(1,J));
               2      IF(XJ.EQ.XI) [AINTP=YI;]
               2      ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]
               2      AINTP=EXP(AINTP);]
               1      ELSE[YI=YA(1,I); YJ=YA(1,J);
               2           IF(XJ.EQ.XI) [AINTP=YI;]
               2           ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]]
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION AINTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXS(E);"MAXIMUM STEP SIZE VALID FOR MULTIPLE SCATTERING"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E,TMXB;
               0  $REAL4 SAFETY,TABSMX;
               0  DATA SAFETY/0.8/,TABSMX/10.0/;
               0  save SAFETY,TABSMX;
               0  TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX);
               0  "THE FACTORE 'SAFETY' IS TO KEEP SOMEWHAT BELOW BETHE'S LIMIT"
               0  "TABSMX IS AN ABSOLUTE LIMIT TO SIZE OF ELECTRON TRANSPORT,"
               0  "  INDEPENDENT OF THE MULTIPLE SCATTERING LIMIT"
               0  RETURN;
               0  END;  "END OF FUNCTION TMXS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXB(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E;
               0  "THIS FUNCTION FINDS THE TRANSPORT DISTANCE WHICH AT THIS ENERGY"
               0  "IS THE LARGEST CONSISTENT WITH BETHE'S CRITERION, NAMELY"
               0  "  XC**2*B.LE.1;   SINCE XC ANB B ARE INCREASING FUNCTIONS OF T"
               0  " THE TRANSPORT DISTANCE, THE CRITERION FOR TMXB IS THEN"
               0  "  XC**2*B=1;      OTHER RELATIONS USED IN THE DERIVATION ARE"
               0  "EXPLAINED IN SUBROUTINES MIX AND MOLIER.  THEY ARE:"
               0  "  XC=XCC*SQRT(T)/(E*BETA**2); "
               0  "  EXP(B)/B = BLCC*T/BETA**2;  "
               0  "FROM THESE IS DERIVED THE EQUATION THIS FUNCTION IS BASED ON:"
               0  "TMXB=(E**2*BETA**2/XCC**2)*BETA**2/LOG(BLCC*(E**2*BETA**2/XCC**2));"
               0  ;
               0  $REAL4 ESQ,BETA2,PX2;
               0  COMIN/DERCON,MOLVAR/;
               0  ESQ=E**2;
               0  BETA2=1.0-RMPSQ/ESQ;
               0  PX2=ESQ*BETA2/XCCP**2;
               0  TMXB=PX2*BETA2/LOG(BLCCP*PX2);
               0  RETURN;
               0  END;   "END OF FUNCTION TMXB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKE(E);"LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E;
               0  COMIN/DERCON/;
               0  ALKE=LOG(E-RMP);
               0  "write(58,*)' alke,e,rm,e-rm ',alke,e,rmp,e-rmp;"
               0  RETURN;
               0  END;  "END OF FUNCTION ALKE"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKEI(X);"INVERSE OF LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 x;
               0  COMIN/DERCON/;
               0  ALKEI=EXP(X) + RMP;
               0  RETURN;
               0  END;  "END OF FUNCTION ALKEI"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI,
               0                   AX,BX,NALM,NFUN,AF,BF,VFUNS);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***PWLF1 IS A ROUTINE WHICH WILL FIT UP TO 10(CURRENTLY) FUNCTIONS  "
               0  "   SIMULTANEOUSLY ON AN INTERVAL (XL,XU) OF THE INDEPENDENT VARIABLE"
               0  "   X OF THE FUNCTIONS. THE FIT IS A PIECEWISE LINEAR FUNCTION OF    "
               0  "   XFUN(X).  XFI IS THE INVERSE FUNCTION OF XFUN.  THE SUBINTERVALS "
               0  "   ARE CHOSEN OF UNIFORM WIDTH IN XFUN(X) AND SUFFICIENT OF THEM    "
               0  "   ARE CHOSEN SO THAT THE FIT GIVES A RELATIVE ERROR[EP FOR ALL     "
               0  "   THE FUNCTIONS OVER ALL THE SUBINTERVALS.                         "
               0  "   QFIT IS AN AUXILIARY FUNCTION.       "
               0  "   EXPLANATION OF THE ARGUMENTS:                                    "
               0  "   NI   ON RETURN IS NUMBER OF SUBINTERVALS USED FOR THE FIT.       "
               0  "   XL   LOWER LIMIT OF INTERVAL ON WHICH TO FIT THE FUNCTIONS.      "
               0  "   XU   UPPER LIMIT                                                 "
               0  "   XR   VALUE OF X WHICH WILL BE FORCED TO BE A SUBINTERVAL BOUNDARY"
               0  "        THE SIGNIFICANCE OF THIS IS THAT THE STRAIGHT LINES ON THE  "
               0  "        SUBINTERVALS ARE CHOSEN TO FIT EXACTLY AT THE SUBINTERVAL   "
               0  "        BOUNDARIES, THUS IF ONE WANTS AN EXACT FIT OF THE FUNCTIONS "
               0  "        AT A PARTICULAR POINT, XR SHOULD BE SET TO THAT VALUE.      "
               0  "        OTHERWISE XR SHOULD BE SET TO XH.  ANOTHER REQUIREMENT      "
               0  "        IS THAT XU SHOULD BE LARGER THAN XL.                        "
               0  "   EP   THE MAXIMUM RELATIVE ERROR ALLOWED THE FIT.                 "
               0  "   NIP  THE MINUIMUM NUMBER OF POINTS INTERIOR TO (XL,XU) AT WHICH  "
               0  "        THE FIT IS TO BE TESTED FOR RELATIVE ERROR VS. EP.          "
               0  "   XFUN A FUNCTION OF X OVER WHICH IT IS HOPED THE FUNCTIONS TO BE  "
               0  "        FIT ARE MORE LINEAR THAN OVER X.  XFUN IS EXPECTED TO BE    "
               0  "        MONOTONICALLY INCREASING IN X.                              "
               0  "   XFI  THE INVERSE OF XFUN. THAT IS XFI(XFUN(X))=X.                "
               0  "   AX,BX ARE COEFFICIENTS USED AS SHOWN BELOW TO DETERMINE WHICH    "
               0  "        SUBINTERVAL A VALUE OF X IS IN.                             "
               0  "   AF,BF ARE ARRAYS OF COEFFICIENTS USED TO GET VALUES OF THE FUNCS."
               0  "   THE PROCEDURE FOR FINDING THE FIT VALUE OF FUNCTION IFUN IS:     "
               0  "   INTERV=AX*XFUN(X)+BX                                             "
               0  "   VALUE=AF(INTERV,IFUN)*XFUN(X)+BF(INTERV,IFUN)                    "
               0  "   NALM  IS THE MAXIMUM NUMBER OF SUBINTERVALS FOR WHICH ARRAY SPACE"
               0  "         HAS BEEN ALLOCATED.                                        "
               0  "   NFUN  IS THE NUMBER OF FUNCTIONS TO BE FITTED(SIMULTANEOUSLY,I.E."
               0  "         ALL FUNCTIONS HAVE THE SAME XFUN AND SUBINTERVALS, AND ALL "
               0  "         ARE REQUIRED TO BE FIT WITH MAX REL ERR[EP)                "
               0  "   VFUNS IS A SUBROUTINE TO FILL AN ARRAY WITH THE VALUES OF THE    "
               0  "   FUNCTIONS TO BE FITTED.                                          "
               0  ;
               0  implicit none;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER NI,NIMX,NIP,NALM,NFUN;
               0  $REAL4    XL,XU,XR,EP,AX,BX,XFUN,XFI;
               0  EXTERNAL XFI,VFUNS,XFUN;
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "   QFIT IS A LOGICAL FUNCTION WHICH IS TRUE IF THE STATED NUMBER    "
               0  "   OF INTERVALS GIVES A SUFFICIENTLY CLOSE FIT.                     "
               0  LOGICAL QFIT;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER NL,NU,IPRN,NJ,NK;
               0  $REAL4    REM;
               0  "   FIND # OF INTERVALS REQUIRED.                                    "
               0  NL=0;
               0  NU=1;
               0  IPRN=0;
               0  LOOP [NJ=MIN0(NU,NIMX);
               1  "write(58,*)' 1 nj ',nj;"
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1   AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) EXIT;
               1  IF (NU.GE.NIMX) [
               2
               2
               2
               2
               2
               2  "write(58,*)' nj ',nj;"
               2  NI=NJ;RETURN;]
               1  NL=NU;
               1  NU=NU*2;]
               0  "   WE NOW HAVE AN UPPER AND LOWER LIMIT ON NI, REFINE IT.           "
               0  NU=NJ ; "SAVE SUCCESSFUL INDEX"
               0  WHILE(NU.GT.NL+1)["LOOP UNTIL CONVERGENCE"
               1  NJ=(NL+NU)/2;
               1  NK=NJ; "THIS IS NECESSARY BECAUSE QFIT MAY LOWER NJ,BUT NEED ORIGINAL"
               1  " FOR SETTING NL OR MAY GET INTO INFINITE LOOP."
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1  AX,BX,NALM,NFUN,AF,BF,VFUNS,0))[NU=NJ;]ELSE[NL=NK;]
               1  ]
               0  "     NU IS NOW THE SMALLEST NI WHICH FITS OK.                       "
               0  NI=NU;
               0  IF (NI.EQ.NJ)RETURN;"LAST TEST WAS SUCCESS"
               0  "     CALL IT ONCE MORE TO GET THE FITS.                             "
               0  IF (.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) OUTPUT NI;
               0  (' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5);
               0  RETURN;
               0  END;  "END OF SUBROUTINE PWLF1"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI,
               0   AX,BX,NALM,NFUN,AF,BF,VFUNS,IPRN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  "EXTERNAL XFUN,XFI,VFUNS;"
               0  EXTERNAL VFUNS;
               0  $REAL4    XFUN,XFI;
               0  $INTEGER NJ,NALM,NFUN,NJP,IPRN;
               0  $REAL4    XL,XH,XR,AX,BX,REM,EP;
               0  $REAL4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10);
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "     CONSTRUCT THE INTERVAL COEFFICIENTS.                             "
               0  "     XR SHOULD BE IN THE INTERVAL (XL,XH).  IF NOT IT WILL BE SE TO TH"
               0  "     NEAREST LIMIT.  SUBINTERVALS WILL BE ARRANGED SO                 "
               0  "     THAT XR IS ALWAYS ON A SUBINTERVAL BOUNDARY.   THE PURPOSE OF THI"
               0  "     FEATURE IS TO MORE EASILY FIT FUNCTIONS WHICH HAVE AN INTERIOR   "
               0  "     DISCONTINUITY IN SLOPE.  EXAMPLES ARE THE MOLLER AND PAIR        "
               0  "     CROSS SECTIONS WHICH CONTRIBUTE DISCONTINUITIES IN SLOPE         "
               0  "     TO THE ELECTRON AND PHOTON INTERACTION PROBABILITIES IN          "
               0  "     THE INTERIOR OF THE ENERGY RANGES FOR THESE PARTICLES.           "
               0  "     IN ABLE TO GIVE SOME VALUE FOR X'S WHICH MAY LIE SLIGHTLY OUTSIDE"
               0  "     THE INTERVAL (XL,XH) AN EXTRA SUBINTERVAL ON EACH SIDE OF (XL,XH)"
               0  "     IS PROVIDED, WHICH USED THE SAME STRAIGHT LINES AS THE ADJACENT  "
               0  "     INCLUDED SUBINTERVAL.  NJ IS THE TOTAL NUMBER OF SUBINTERVALS    "
               0  "     AND NI IS DEFINED TO BE THE NUMBER OF INTERNAL SUBINTERVALS=NJ-2."
               0  "     NJP IS THE MINUMUM NUMBER OF POINTS INTERIOR TO THE INTERVAL     "
               0  "     (XL,XH) AT WHICH THE FIT IS TO BE TESTED.  A NUMBER NIP WILL BE  "
               0  "     CHOSEN AS THE NUMBER OF INTERIOR POINTS WITHIN EACH SUBINTERVAL  "
               0  "     AT WHICH TO TEST SO THAT NIP*NI]=NJP.                        "
               0  $REAL4    XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP,
               0           SXFIP,XIP;
               0  $INTEGER NI,NIP,ISUB,IFUN,JSUB,IP;
               0  $INTEGER nkp;
               0  DATA NKP/3/;
               0  save nkp;
               0  IF (XH.LE.XL)[
               1  OUTPUT XL,XH;(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6);
               1  QFIT=.FALSE.; RETURN;]
               0  XS=AMAX1(XL,AMIN1(XH,XR));
               0  "     GET NUMBER OF INTERNAL SUBINTERVALS ARE ALLOWED AND CHECK        "
               0  NI=NJ-2;
               0  "     AT LEAST 2 SUBINTERVALS ARE NEEDED IF XR(XS) IS NOT AN END POINT."
               0  IF (((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2) [XFL=XFUN(XL);]
               0  ELSE [QFIT=.FALSE.; RETURN;]
               0  XFH=XFUN(XH);
               0  XFS=XFUN(XS);
               0  "write(58,*)'xfh,xfs,xh,xs ',xfh,xfs,xh,xs;"
               0  "     SET SUBINTERVAL WIDTH.                                           "
               0  XM=AMAX1(XFH-XFS,XFS-XFL);
               0  DX=XFH-XFL;
               0  W=XM/AMAX1(1.,AINT(NI*XM/DX));
               0  "write(58,*)' w,xm,ni,dx ',w,xm,ni,dx;"
               0  "     RESET NI TO HOW MANY WE'RE ACTUALLY GOING TO USE.                "
               0  NI=NI-AINT(NI-DX/W);
               0  "     COMPUTE HOW MANY INTERIOR POINTS TO SAMPLE IN EACH SUBINTERVAL.  "
               0  NIP=MAX0(NKP,(NJP+NI-1)/NI);
               0  "     MAKE NIP ODD                                                     "
               0  NIP=(NIP/2)*2+1;
               0  "     SET ACTUAL LOWER LIMIT OF INTERVAL.                              "
               0  IF (XFH-XFS.LE.XFS-XFL) [XLL=XFL;]
               0  ELSE [XLL=XFH-NI*W;]
               0  "     COEFICIENTS FOR USER TO COMPUTE WHICH SUBINTERVAL TO USE.        "
               0  "     ISUBINT=AX*XFUN(X)+BX                                            "
               0  AX=1./W;
               0  BX=2.-XLL*AX;
               0  "     THE RIGHT BOUNDARY OF SUBINTERVAL I IS XFI(XLL+W*(I-1))          "
               0  "     NOW COMPUTE THE FIT COEFFICIENTS FOR THE SUBINTERVALS            "
               0  "     AND FIND MAXIMUM RELATIVE ERROR(REM).                            "
               0  REM=0.0;
               0  QFIT=.TRUE.;
               0  "     LOOP OVER SUBINTERVALS                                           "
               0  "     INITIALIZE LOWER BOUNDARY AND VALUE.                             "
               0  SXFL=AMAX1(XLL,XFL);
               0  ISUB=0;
               0  XSXF=XFI(SXFL);
               0  "write(58,*)' 1 xsxf ',XSXF;"
               0  CALL VFUNS(XSXF,FSXL);
               0  IF (IPRN.NE.0) WRITE(6,:FMT:) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFUN);
               0  :FMT: FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4));
               0  DO ISUB=1,NI[
               1  "     ALLOW FOR EXTRA SUBINTERVAL OUTSIDE THE MAIN INTERVAL            "
               1  JSUB=ISUB+1;
               1  SXFH=AMIN1(XLL+W*ISUB,XH);
               1  XSXF=XFI(SXFH);
               1  "write(58,*)' 2 xsxf ',XSXF;"
               1  CALL VFUNS(XSXF,FSXH);
               1  IF (IPRN.NE.0)WRITE(6,:FMT:)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NFUN);
               1  DSXF=SXFH-SXFL;
               1  "write(58,*)' xll,w,isub,xh ',xll,w,isub,xh;"
               1  "write(58,*)' dsxf,sxfh,sxfl ',dsxf,sxfh,sxfl;"
               1  DO IFUN=1,NFUN[
               2  AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF;
               2  BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF;] "END OF IFUN"
               1  "     LOOP OVER INTERIOR POINTS TO LOOK FOR MAX. REL.ERROR             "
               1  "     COMPUTE INTERIOR POINT SPACING.                                  "
               1  WIP=DSXF/(NIP+1);
               1  "write(58,*)' dsxf,nip ',dsxf,nip;"
               1  DO IP=1,NIP[
               2  "     VALUE OF XFUN AT THE INTERIOR POINT OF THIS SUBINTERVAL.         "
               2  SXFIP=SXFL+IP*WIP;
               2  XIP=XFI(SXFIP);
               2  "write(58,*)' sxfl,ip,wip ',sxfl,ip,wip;"
               2  "     COMPUTE FUNCTION AT INTERIOR POINT                               "
               2  "write(58,*)' xip ',XIP;"
               2  CALL VFUNS(XIP,FIP);
               2  "     COMPUTE FITTED VALUES.                                           "
               2  DO IFUN=1,NFUN[
               3  FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN);
               3  AFIP(IFUN)=ABS(FIP(IFUN));
               3  AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN));
               3  RE(IFUN)=0.0;
               3  IF (FIP(IFUN).NE.0.0) [RE(IFUN)=AER(IFUN)/AFIP(IFUN);]
               3  IF (AFIP(IFUN).GE.ZTHR(IFUN)) [REM=AMAX1(REM,RE(IFUN));]
               3  ELSEIF (AER(IFUN).GT.ZEP(IFUN)) [QFIT=.FALSE.;]
               3  ] "END OF IFUN"
               2  "*****WRITE OUT SO WE CAN SEE HOW WE ARE DOING.                        "
               2  IF (IPRN.NE.0) [
               3  OUTPUT ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFUN),
               3   RE(IFUN),AER(IFUN),IFUN=1,NFUN);
               3  (1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G11.4/
               3   (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)));]
               2  ] "END OF IP"
               1  "     SAVE RIGHT BOUNDARY AND VALUE FOR NEXT SUBINTERVAL.              "
               1  SXFL=SXFH;
               1  DO IFUN=1,NFUN [FSXL(IFUN)=FSXH(IFUN);]
               1  ] "END OF ISUB"
               0  "     SET UP SKIRTING SUBINTERVALS(VIA EXTRAPOLATION)                  "
               0  DO IFUN=1,NFUN[
               1  AF(1,IFUN)=AF(2,IFUN);
               1  BF(1,IFUN)=BF(2,IFUN);
               1  AF(NI+2,IFUN)=AF(NI+1,IFUN);
               1  BF(NI+2,IFUN)=BF(NI+1,IFUN);] "END OF IFUN"
               0  QFIT=QFIT.AND.REM.LE.EP;
               0  NJ=NI+2; "TELL ACTUAL NO. OF SUBINTERVALS USED."
               0  "write(58,*)'ni ',ni;"
               0  RETURN;
               0  END; "END OF LOGICAL FUNCTION QFIT
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION QD(F,A,B,MSG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL4    A,B,F;
               0  EXTERNAL F;
               0  CHARACTER*6 MSG;
               0  logical first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0  "    CHANGED"
               0
               0  "    REAL*8 DCADRE,ADUM,BDUM,ERRDUM,MSG;"
               0
               0  "    TO"
               0
               0  "    DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  "    CHARACTER*6 MSG;"
               0
               0  "    FOR SUN COMPATIBILITY AFB 89/12/27"
               0
               0  "DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  $REAL4 DCADRE,ADUM,BDUM,ERRDUM;
               0  $INTEGER IER;
               0
               0  ADUM=A; BDUM=B;
               0  QD=DCADRE(F,ADUM,BDUM,$AERR,$RERR,ERRDUM,IER);
               0  "write(58,*)' qd ',QD;"
               0  IF (IER.GT.66)[
               1      OUTPUT IER,MSG,A,B,QD,ERRDUM;
               1      (' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,' TO ',G14.6,
               1      ',QD=',G14.6,'+-',G14.6);
               1  ]
               0  RETURN;
               0  END;  "END OF FUNCTION QD"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  "DOUBLE PRECISION FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);"
               0  $REAL4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);
               0  implicit none;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "                                                                  "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "-DCADRE--------D-------LIBRARY 1----------------------------------"
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  "FUNCTION:          - INTEGRATE F(X) FROM A TO B, USING CAUTIOUS   "
               0  "                     ADAPTIVE ROMBERG EXTRAPOLATION.              "
               0  "                                                                  "
               0  "USAGE:             - FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)   "
               0  "                                                                  "
               0  "PARAMETERS: DCADRE - ESTIMATE OF THE INTEGRAL OF F(X) FROM A TO B."
               0  "                                                                  "
               0  "            F      - A SINGLE-ARGUMENT REAL FUNCTION SUBPROGRAM   "
               0  "                     SUPPLIED BY THE USER.  F MUST BE DECLARED    "
               0  "                     EXTERNAL IN THE CALLING PROGRAM.             "
               0  "                                                                  "
               0  "            A,B    - THE TWO ENDPOINTS OF THE INTERVAL OF         "
               0  "                     INTEGRATION (INPUT).                         "
               0  "                                                                  "
               0  "            AERR   - DESIRED ABSOLUTE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            RERR   - DESIRED RELATIVE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            ERROR  - ESTIMATED BOUND ON THE ABSOLUTE ERROR OF     "
               0  "                     THE OUTPUT NUMBER, DCADRE.                   "
               0  "                                                                  "
               0  "            IER    - ERROR PARAMETER                              "
               0  "                                                                  "
               0  "                     WARNING ERROR(WITH FIX) = 64 + N             "
               0  "                                                                  "
               0  "                       N = 1 IMPLIES THAT ONE OR MORE SINGULAR-   "
               0  "                             ITIES WERE SUCCESSFULLY HANDLED.     "
               0  "                                                                  "
               0  "                       N = 2 IMPLIES THAT, IN SOME SUBINTERVAL(S),"
               0  "                             THE ESTIMATE OF THE INTEGRAL WAS     "
               0  "                             ACCEPTED MERELY BECAUSE THE ESTIMATED"
               0  "                             ERROR WAS SMALL, EVEN THOUGH NO REG- "
               0  "                             ULAR BEHAVIOR WAS RECOGNIZED.        "
               0  "                                                                  "
               0  "                     TERMINAL ERROR = 128 + N                     "
               0  "                                                                  "
               0  "                       N = 3 FAILURE DUE TO INSUFFICIENT INTERNAL "
               0  "                             WORKING STORAGE.                     "
               0  "                                                                  "
               0  "                       N = 4 FAILURE.  THIS MAY BE DUE TO TOO MUCH"
               0  "                             NOISE IN THE FUNCTION (RELATIVE TO   "
               0  "                             THE GIVEN ERROR REQUIREMENTS) OR DUE "
               0  "                             TO AN ILL-BEHAVED INTEGRAND.         "
               0  "                                                                  "
               0  "                       N = 5 INDICATES THAT RERR IS GREATER THAN  "
               0  "                             0.1, OR RERR IS LESS THAN 0.0, OR    "
               0  "                             RERR IS TOO SMALL FOR THE PRECISION  "
               0  "                             OF THE MACHINE.                      "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "VERSION DATE:      - 8 OCTOBER 1974                               "
               0  "                                                                  "
               0  "MORTRAN VERSION    - 4 OCTOBER 1984/1545 (W. R. NELSON)           "
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  ; "NOTE: SEMI-COLON TO CLEAR MORTRAN BUFFER                        "
               0  "                                                                  "
               0  "ADDED"
               0  "EXTERNAL F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  "EXTERNAL F;"
               0
               0  DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049);
               0  DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30);
               0  DIMENSION REGLSV(30);
               0  LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $REAL4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
               0  $REAL4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;
               0  $REAL4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;
               0  $REAL4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
               0  $REAL4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
               0  $REAL4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
               0  $REAL4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
               0  $REAL4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
               0  $REAL4 ERRET,H2TFEX,FI;
               0  "ADDED"
               0  "REAL RVAL,F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $REAL4 RVAL,F;
               0
               0  $INTEGER IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,ISTEP2,IT,NNLEFT;
               0  $INTEGER MAXTS,MAXTBL,MXSTGE;
               0  DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0,
               0       .1D0,.01D0,2049,10,30/;
               0  DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0,
               0       .1263305D0/;
               0  DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0,
               0       1.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/;
               0  save MAXTS,MAXTBL,MXSTGE;
               0  ALG4O2=LOG10(TWO);
               0  /CADRE,ERROR,CUREST,VINT/=ZERO;
               0  IER=0;
               0  LENGTH=ABS(B-A);
               0  IF(LENGTH.EQ.ZERO) GO TO 215;
               0  IF(RERR.GT.P1.OR.RERR.LT.ZERO) GO TO 210;
               0  IF(AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN) GO TO 210;
               0  ERRR=RERR;
               0  ERRA=ABS(AERR);
               0  STEPMN=(LENGTH/FLOAT(2**MXSTGE));
               0  STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN;
               0  STAGE=HALF;
               0  ISTAGE=1;
               0  FNSIZE=ZERO;
               0  PREVER=ZERO;
               0  REGLAR=.FALSE.;
               0  "                              THE GIVEN INTERVAL OF INTEGRATION   "
               0  "                                IS THE FIRST INTERVAL CONSIDERED. "
               0  BEG=A;
               0
               0  "CHANGED"
               0  "FBEG=F(BEG)*HALF;"
               0  "TO"
               0  "RVAL=BEG;FBEG=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG;FBEG=F(RVAL)*HALF;
               0  "write(*,*)' rval, f, half ',rval,F(RVAL),half;"
               0
               0  TS(1)=FBEG;
               0  IBEG=1;
               0  END=B;
               0
               0  "CHANGED"
               0  "FEND=F(END)*HALF;"
               0  "TO"
               0  "RVAL=END;FEND=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=END;FEND=F(RVAL)*HALF;
               0
               0  TS(2)=FEND;
               0  IEND=2;
               0  5 RIGHT=.FALSE.;
               0  "                              INVESTIGATION OF A PARTICULAR       "
               0  "                                SUBINTERVAL BEGINS AT THIS POINT. "
               0  10 STEP=END - BEG;
               0  ASTEP=ABS(STEP);
               0  IF(ASTEP.LT.STEPMN) GO TO 205;
               0  IF(STEPNM+ASTEP.EQ.STEPNM) GO TO 205;
               0  T(1,1)=FBEG + FEND;
               0  TABS=ABS(FBEG) + ABS(FEND);
               0  L=1;
               0  N=1;
               0  H2CONV=.FALSE.;
               0  AITKEN=.FALSE.;
               0  15 LM1=L;
               0  L=L + 1;
               0  "                              CALCULATE THE NEXT TRAPEZOID SUM,   "
               0  "                                T(L,1), WHICH IS BASED ON *N2* + 1"
               0  "                                EQUISPACED POINTS. HERE,          "
               0  "                                N2 = N*2 = 2**(L-1).              "
               0  N2=N + N;
               0  FN=N2;
               0  ISTEP=(IEND - IBEG)/N;
               0  IF(ISTEP.GT.1) GO TO 25;
               0  II=IEND;
               0  IEND=IEND + N;
               0  IF(IEND.GT.MAXTS) GO TO 200;
               0  HOVN=STEP/FN;
               0  III=IEND;
               0  FI=ONE;
               0  DO I=1,N2,2[
               1  TS(III)=TS(II);
               1
               1  "CHANGED"
               1  "TS(III-1)=F(END - FI * HOVN);"
               1  "TO"
               1  "RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);"
               1  "FOR SUN AFB 89/12/27"
               1
               1  RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);
               1
               1  FI=FI+TWO;
               1  III=III-2;
               1  II=II-1;]
               0  ISTEP=2;
               0  25 ISTEP2=IBEG + ISTEP/2;
               0  SUM=ZERO;
               0  SUMABS=ZERO;
               0  DO I=ISTEP2,IEND,ISTEP[
               1  SUM=SUM + TS(I);
               1  SUMABS=SUMABS + ABS(TS(I));]
               0  T(L,1)=T(L-1,1)*HALF+SUM/FN;
               0  TABS=TABS*HALF+SUMABS/FN;
               0  ABSI=ASTEP*TABS;
               0  N=N2;
               0  "                              GET PRELIMINARY VALUE FOR *VINT*    "
               0  "                                FROM LAST TRAPEZOID SUM AND UPDATE"
               0  "                                THE ERROR REQUIREMENT *ERGOAL*    "
               0  "                                FOR THIS SUBINTERVAL.             "
               0  IT=1;
               0  VINT=STEP*T(L,1);
               0  TABTLM=TABS*TEN;
               0  FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)));
               0  ERGL=ASTEP*FNSIZE*TEN;
               0  ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT));
               0  "                              COMPLETE ROW L AND COLUMN L OF *T*  "
               0  "                                ARRAY.                            "
               0  FEXTRP=ONE;
               0  DO I=1,LM1[
               1  FEXTRP=FEXTRP*FOUR;
               1  T(I,L)=T(L,I) - T(L-1,I);
               1  T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE);]
               0  ERRER=ASTEP*ABS(T(1,L));
               0  "                              PRELIMINARY DECISION PROCEDURE      "
               0  "                                IF L = 2 AND T(2,1) = T(1,1),     "
               0  "                                GO TO 135 TO FOLLOW UP THE        "
               0  "                                IMPRESSION THAT INTERGRAND IS     "
               0  "                                STRAIGHT LINE.                    "
               0  IF(L.GT.2) GO TO 40;
               0  IF(TABS+P1*ABS(T(1,2)).EQ.TABS) GO TO 135;
               0  GO TO 15;
               0  "                              CACULATE NEXT RATIOS FOR            "
               0  "                                COLUMNS 1,...,L-2 OF T-TABLE      "
               0  "                                RATIO IS SET TO ZERO IF DIFFERENCE"
               0  "                                IN LAST TWO ENTRIES OF COLUMN IS  "
               0  "                                ABOUT ZERO                        "
               0  40 DO 45 I=2,LM1;
               0  DIFF=ZERO;
               0  IF(TABTLM+ABS(T(I-1,L)).NE.TABTLM) DIFF=T(I-1,LM1)/T(I-1,L);
               0  T(I-1,LM1)=DIFF;
               0  45 CONTINUE;
               0  IF(ABS(FOUR-T(1,LM1)).LE.H2TOL) GO TO 60;
               0  IF(T(1,LM1).EQ.ZERO) GO TO 55;
               0  IF(ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL) GO TO 130;
               0  IF(L.EQ.3) GO TO 15;
               0  H2CONV=.FALSE.;
               0  IF(ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL) GO TO 75;
               0  50 IF(REGLAR) GO TO 55;
               0  IF(L.EQ.4) GO TO 15;
               0  55 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  GO TO 145;
               0  "                              CAUTIOUS ROMBERG EXTRAPOLATION      "
               0  60 IF(H2CONV) GO TO 65;
               0  AITKEN=.FALSE.;
               0  H2CONV=.TRUE.;
               0  65 FEXTRP=FOUR;
               0  70 IT=IT + 1;
               0  VINT=STEP*T(L,IT);
               0  ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L));
               0  IF(ERRER.LE.ERGOAL) GO TO 160;
               0  IF(ERGL+ERRER.EQ.ERGL) GO TO 160;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(T(IT,LM1).EQ.ZERO) GO TO 70;
               0  IF(T(IT,LM1).LE.FEXTRP) GO TO 125;
               0  IF(ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL)
               0  FEXTRP=FEXTRP*FOUR;
               0  GO TO 70;
               0  "                              INTEGRAND MAY HAVE X**ALPHA TYPE    "
               0  "                                SINGULARITY                       "
               0  "                                RESULTING IN A RATIO OF *SING*  = "
               0  "                                2**(ALPHA + 1)                    "
               0  75 IF(T(1,LM1).LT.AITLOW) GO TO 175;
               0  IF(AITKEN) GO TO 80;
               0  H2CONV=.FALSE.;
               0  AITKEN=.TRUE.;
               0  80 FEXTRP=T(L-2,LM1);
               0  IF(FEXTRP.GT.FOURP5) GO TO 65;
               0  IF(FEXTRP.LT.AITLOW) GO TO 175;
               0  IF(ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL) GO TO 175;
               0  SING=FEXTRP;
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  AIT(1)=ZERO;
               0  DO 85 I=2,L;
               0  AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1;
               0  R(I)=T(1,I-1);
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  85 CONTINUE;
               0  IT=2;
               0  90 VINT=STEP*AIT(L);
               0  ERRER=ERRER*FEXTM1;
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 95;
               0  ALPHA=LOG10(SING)/ALG4O2 - ONE;
               0  IER=MAX0(IER,65);
               0  GO TO 160;
               0  95 IT=IT + 1;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(IT.GT.3) GO TO 100;
               0  H2NXT=FOUR;
               0  SINGNX=SING+SING;
               0  100 IF(H2NXT.LT.SINGNX) GO TO 105;
               0  FEXTRP=SINGNX;
               0  SINGNX=SINGNX+SINGNX;
               0  GO TO 110;
               0  105 FEXTRP=H2NXT;
               0  H2NXT=FOUR*H2NXT;
               0  110 DO 115 I=IT,LM1;
               0  R(I+1)=ZERO;
               0  IF(TABTLM+ABS(DIF(I+1)).NE.TABTLM) R(I+1)=DIF(I)/DIF(I+1);
               0  115 CONTINUE;
               0  H2TFEX=-H2TOL*FEXTRP;
               0  IF(R(L)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  IF(R(L-1)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  ERRER=ASTEP*ABS(DIF(L));
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  DO 120 I=IT,L;
               0  AIT(I)=AIT(I) + DIF(I)*FEXTM1;
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  120 CONTINUE;
               0  GO TO 90;
               0  "                              CURRENT TRAPEZOID SUM AND RESULTING "
               0  "                                EXTRAPOLATED VALUES DID NOT GIVE  "
               0  "                                A SMALL ENOUGH *ERRER*.           "
               0  "                                NOTE -- HAVING PREVER .LT. ERRER  "
               0  "                                IS AN ALMOST CERTAIN SIGN OF      "
               0  "                                BEGINNING TROUBLE WITH IN THE FUNC"
               0  "                                TION VALUES. HENCE, A WATCH FOR,  "
               0  "                                AND CONTROL OF, NOISE SHOULD      "
               0  "                                BEGIN HERE.                       "
               0  125 FEXTRP=DMAX1(PREVER/ERRER,AITLOW);
               0  PREVER=ERRER;
               0  IF(L.LT.5) GO TO 15;
               0  IF(L-IT.GT.2.AND.ISTAGE.LT.MXSTGE) GO TO 170;
               0  ERRET=ERRER/(FEXTRP**(MAXTBL-L));
               0  IF(ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL) GO TO 170;
               0  GO TO 15;
               0  "                              INTEGRAND HAS JUMP (SEE NOTES)      "
               0  130 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170;
               0  "                                NOTE THAT  2*FN=2**L              "
               0  DIFF=ABS(T(1,L))*(FN+FN);
               0  GO TO 160;
               0  "                              INTEGRAND IS STRAIGHT LINE          "
               0  "                                TEST THIS ASSUMPTION BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO END POINTS OF THE SUB-INTERVAL"
               0  "                                IF TEST IS PASSED, ACCEPT *VINT*  "
               0  135 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  DO 140 I=1,4;
               0
               0  "CHANGED"
               0  "DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  IF(TABTLM+DIFF.NE.TABTLM) GO TO 155;
               0  140 CONTINUE;
               0  GO TO 160;
               0  "                              NOISE MAY BE DOMINANT FEATURE       "
               0  "                                ESTIMATE NOISE LEVEL BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO ENDPOINTS. IF SMALL ENOUGH,   "
               0  "                                ACCEPT *VINT*                     "
               0  145 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  I=1;
               0
               0  "CHANGED"
               0  "150 DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  155 ERRER=DMAX1(ERRER,ASTEP*DIFF);
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  I=I+1;
               0  IF(I.LE.4) GO TO 150;
               0  IER=66;
               0  "                              INTERGRATION OVER CURRENT SUB-      "
               0  "                                INTERVAL SUCCESSFUL               "
               0  "                                ADD *VINT* TO *DCADRE* AND *ERRER*"
               0  "                                TO *ERROR*, THEN SET UP NEXT SUB- "
               0  "                                INTERVAL, IF ANY.                 "
               0  160 CADRE=CADRE + VINT;
               0  ERROR=ERROR + ERRER;
               0  IF(RIGHT) GO TO 165;
               0  ISTAGE=ISTAGE - 1;
               0  IF(ISTAGE.EQ.0) GO TO 220;
               0  REGLAR=REGLSV(ISTAGE);
               0  BEG=BEGIN(ISTAGE);
               0  END=FINIS(ISTAGE);
               0  CUREST=CUREST - EST(ISTAGE+1) + VINT;
               0  IEND=IBEG - 1;
               0  FEND=TS(IEND);
               0  IBEG=IBEGS(ISTAGE);
               0  GO TO 180;
               0  165 CUREST=CUREST + VINT;
               0  STAGE=STAGE+STAGE;
               0  IEND=IBEG;
               0  IBEG=IBEGS(ISTAGE);
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  GO TO 5;
               0  "                              INTEGRATION OVER CURRENT SUBINTERVAL"
               0  "                                IS UNSUCCESSFUL. MARK SUBINTERVAL "
               0  "                                FOR FURTHER SUBDIVISION. SET UP   "
               0  "                                NEXT SUBINTERVAL.                 "
               0  170 REGLAR=.TRUE.;
               0  175 IF(ISTAGE.EQ.MXSTGE) GO TO 205;
               0  IF(RIGHT) GO TO 185;
               0  REGLSV(ISTAGE+1)=REGLAR;
               0  BEGIN(ISTAGE)=BEG;
               0  IBEGS(ISTAGE)=IBEG;
               0  STAGE=STAGE*HALF;
               0  180 RIGHT=.TRUE.;
               0  BEG=(BEG+END)*HALF;
               0  IBEG=(IBEG+IEND)/2;
               0  TS(IBEG)=TS(IBEG)*HALF;
               0  FBEG=TS(IBEG);
               0  GO TO 10;
               0  185 NNLEFT=IBEG - IBEGS(ISTAGE);
               0  IF(IEND+NNLEFT.GE.MAXTS) GO TO 200;
               0  III=IBEGS(ISTAGE);
               0  II=IEND;
               0  DO 190 I=III,IBEG;
               0  II=II + 1;
               0  TS(II)=TS(I);
               0  190 CONTINUE;
               0  DO 195 I=IBEG,II;
               0  TS(III)=TS(I);
               0  III=III + 1;
               0  195 CONTINUE;
               0  IEND=IEND + 1;
               0  IBEG=IEND - NNLEFT;
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  FINIS(ISTAGE)=END;
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  BEGIN(ISTAGE)=END;
               0  REGLSV(ISTAGE)=REGLAR;
               0  ISTAGE=ISTAGE + 1;
               0  REGLAR=REGLSV(ISTAGE);
               0  EST(ISTAGE)=VINT;
               0  CUREST=CUREST + EST(ISTAGE);
               0  GO TO 5;
               0  "                              FAILURE TO HANDLE GIVEN INTEGRA-    "
               0  "                                TION PROBLEM                      "
               0  200 IER=131;
               0  GO TO 215;
               0  205 IER=132;
               0  GO TO 215;
               0  210 IER=133;
               0  215 CADRE=CUREST + VINT;
               0  220 DCADRE=CADRE;
               0  9000 CONTINUE;
               0  9005 RETURN;
               0  END;  "END OF FUNCTION DCADRE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE SPINIT(density_file);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0
               0  COMIN/PMCONS,SPCOMM,DERCON,MOLVAR,BREMPRP,ELEMTB,LSPION,EPSTAR,THRESHP,
               0  EGS-IO,MIXDAT,MISC/;
               0
               0  $REAL4 IMEV;
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,egs_get_unit;
               0  $REAL4    VPLASM,ALIADG,EDENL,ALGASP,EPSTRH,
               0           TLRNCE,EPSTWT;
               0  CHARACTER*256 density_file;
               0
               0  TOLN10=2.0*LOG(10.0);IM=-100;
               0
               0  IF(EPSTFLP < 0 | EPSTFLP > 1) [
               1          EPSTFLP = 0;
               1  ]
               0  "ABOVE IS NRCC MOD DEC 1988"
               0
               0  IF(EPSTFLP=0)["DEFAULT TO STANDARD PEGS4 METHODS"
               1
               1  "MATERIAL MUST BE FOUND IN THE SSB TABLE OR THE S-P"
               1  "      GENERAL FORMULA WILL BE USED.
               1
               1  "CHECK TO SEE IF MATERIAL IS A 'STERNHEIMER-SELTZER-BERGER' (SSB)"
               1  "MATERIAL, FOR WHICH THE DENSITY EFFECT PARAMETERS ARE ALREADY"
               1  "SPECIFIED.  IF IT IS NOT, THEN CALCULATE THEM USING THE GENERAL"
               1  "FORMULA BY STERNHEIMER-PEIERLS (S-P)."
               1
               1  "STERNHEIMER-SELTZER-BERGER (SSB) LOOKUP TABLE SECTION:"
               1  :TRY: DO IM=1,NUMSTMED [DO J=1,LMED
               2  [IF (IDSTRN(J).NE.MEDTBL(J,IM)) NEXT :TRY:;]
               2  "CALCULATION FOLLOWS IF A MATCH IS FOUND"
               2  AFACT=STDATA(1,IM); SK=STDATA(2,IM); X0=STDATA(3,IM);
               2  X1=STDATA(4,IM); IEV=STDATA(5,IM); CBAR=STDATA(6,IM);
               2  IMEV=IEV*1.0E-6; "EV TO MEV"
               2  VPLASM=SQRT(EDEN*R0*C**2/PIP);
               2  GO TO :SSB-PARAMETERS-DEFINED:;]
               1
               1  "STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION:"
               1  IM=0;
               1  "DETERMINE THE MEAN EXCITATION ENERGY, IMEV (IN MEV)"
               1  IF (NEP.EQ.1) ["ELEMENT"
               2  IZ=ZELEMP(1);
               2  IF (IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8) ["I.E., DIATOMIC MOLECULE"
               3  OUTPUT ; (' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/,
               3   ' ELEMENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/,
               3   ' REMEDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/,
               3   '          AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/,
               3   '          (I.E., IDSTRN) LIKE H2-GAS');
               3  $CALL_EXIT(21);]
               2  IEV=ITBL(IZ);     "EV"
               2  ]
               1
               1  ELSE ["COMPOUND/MIXTURE---USE BRAGG ADDITIVITY RULE"
               2  ALIADG=0.0;
               2  DO IE=1,NEP [
               3  IZ=ZELEMP(IE);
               3  IF (IZ.EQ.1) [IEV=19.2;]   "EV"
               3  ELSEIF (IZ.EQ.6) [IF (GASPP.EQ.0.0) [IEV=81.0;] ELSE [IEV=70.0;]]
               3  ELSEIF (IZ.EQ.7) [IEV=82.0;]
               3  ELSEIF (IZ.EQ.8) [IF (GASPP.EQ.0.0) [IEV=106.0;] ELSE [IEV=97.0;]]
               3  ELSEIF (IZ.EQ.9) [IEV=112.0;]
               3  ELSEIF (IZ.EQ.17) [IEV=180.0;]
               3  ELSE [IEV=1.13*ITBL(IZ);]
               3  "NRCC comment - above 7 lines reflect table 6 in ref 59 of SLAC-265"
               3  "       Berger and Seltzer's fudge to get better agreement with expt"
               3  ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV);
               3  ]
               2  ALIADG=ALIADG/ZC;
               2  IEV=EXP(ALIADG);    "EV"
               2  ]
               1
               1  IMEV=IEV*1.0E-6;  "EV TO MEV"
               1  "COMPUTE VARIOUS STERNHEIMER CONSTANTS"
               1  IF (GASPP.EQ.0.0) [EDENL=EDEN;]
               1  ELSE ["VPLASM MUST BE FOR NTP FOR A GAS, AND EDEN HAS"
               2  "      BEEN DEFINED IN MIX FOR THE ACTUAL PRESSURE"
               2         EDENL=EDEN/GASPP;]
               1  VPLASM = SQRT(EDENL*R0*C**2/PIP);
               1  "ABOVE PATCHED JAN 9,1989 TO REFLECT ERROR POINTED OUT BY"
               1  "PROF KAMAE, TOKYO UNIVERSITY, VIA HIDEO HIRAYAMA"
               1
               1  CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV));
               1
               1  IF (NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)[
               2            "SPECIAL HE(GAS) CASE"
               2  X0=2.191; X1=3.0; SK=3.297;
               2  ]
               1
               1  ELSEIF (NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1
               1          .AND.INT(ZELEMP(2)).EQ.1) [
               2  IF (GASPP.EQ.0.0) ["SPECIAL H2(LIQUID) CASE"
               3  X0=0.425; X1=2.0; SK=5.949;
               3  ]
               2  ELSE ["SPECIAL H2(GAS) CASE"
               3  X0=1.837; X1=3.0; SK=4.754;
               3  ]
               2  ]
               1
               1  ELSE ["REGULAR CASES"
               2  SK=3.0;
               2  IF (GASPP.EQ.0.0) ["SOLIDS AND LIQUIDS"
               3  IF (IEV.LT.100.0) [
               4  IF (CBAR.LT.3.681) [X0=0.2; X1=2.0;]
               4  ELSE [X0=0.326*CBAR - 1.0; X1=2.0;]
               4  ]
               3  ELSE ["IEV GE 100.0"
               4  IF (CBAR.LT.5.215) [X0=0.2; X1=3.0;]
               4  ELSE [X0=0.326*CBAR - 1.5; X1=3.0;]
               4  ]
               3  IF (X0.GE.X1) [OUTPUT X0,X1,CBAR;
               4  (' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',3G15.5,/
               4  ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)'); $CALL_EXIT(21);]
               3  ]
               2  ELSE ["GASES---AT NTP AT THIS STAGE"
               3  IF (CBAR.LT.10.0) [X0=1.6; X1=4.0;]
               3  ELSEIF (CBAR.LT.10.5) [X0=1.7; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.0) [X0=1.8; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.5) [X0=1.9; X1=4.0;]
               3  ELSEIF (CBAR.LT.12.25) [X0=2.0; X1=4.0;]
               3  ELSEIF (CBAR.LT.13.804) [X0=2.0; X1=5.0;]
               3  ELSE [X0=0.326*CBAR - 2.5; X1=5.0;]
               3  ]
               2  ]  "END OF STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION"
               1
               1  :SSB-PARAMETERS-DEFINED:
               1
               1  "GAS PRESSURE CORRECTION COMES NEXT"
               1  IF (GASPP.NE.0.0) [
               2  ALGASP=LOG(GASPP);
               2  CBAR=CBAR - ALGASP;
               2  X0=X0 - ALGASP/TOLN10;
               2  X1=X1 - ALGASP/TOLN10;
               2  ]
               1
               1  IF (IM.EQ.0) [AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK;]
               1  ]"END OF EPSTFL=0 BLOCK"
               0
               0  ELSE[ "EPSTFL=1 BLOCK  I.E. READ IN THE INPUT FROM THE DENSITY"
               1       "INPUT FILE"
               1  "get the name of the density file"
               1  density_file=$cstring(density_file);
               1  density_unit=20;
               1  density_unit=egs_get_unit(density_unit);
               1  IF( density_unit < 1 ) [
               2          $egs_fatal(*,'SPINIT: failed to get a free fortran unit');
               2  ]
               1  open(density_unit,file=density_file,status='old',err=:no_density_file:);
               1
               1  READ(density_unit,:A:)EPSTTL;:A:  FORMAT(A);
               1  READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS;
               1  READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS);
               1  READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST);
               1
               1  close(density_unit);
               1
               1  IF(NEPST>150)[OUTPUT NEPST;
               2  (//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED');$CALL_EXIT(22);]
               1  "CONVERT TO TOTAL ENERGIES"
               1  DO I=1,NEPST[EPSTEN(I) = EPSTEN(I) + RMP;]
               1  IMEV = IEV*1.E-06;
               1
               1  "CHECK THAT WE HAVE COVERED ENERGY RANGES NEEDED"
               1  IF( AEP < EPSTEN(1))[OUTPUT EPSTEN(1),AEP;
               2  (//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO AE***'//);EPSTEN(1) = AEP;]
               1  IF( UEP > EPSTEN(NEPST))[ OUTPUT EPSTEN(NEPST),UEP;
               2  (//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO UE***'//);EPSTEN(NEPST) = UEP;]
               1
               1  "DO A CHECK ON THE COMPOSITION AND DENSITY TO INSURE THE RIGHT DELTA"
               1  "HAS BEEN PICKED UP. ALLOW A TOLERANCE OF 1 PERCENT ERROR ON THE"
               1  "COMPOSITION BY WEIGHT."
               1
               1  ICHECK=0; "FLAG GETS SET TO UNITY IF THE COMPOSITION DOES NOT MATCH"
               1      TLRNCE=0.01; "TOLERANCE ALLOWED ON FRACTION BY WEIGHT"
               1
               1  "FIRST CHECK THAT THE NUMBER OF ELEMENTS ARE THE SAME"
               1  IF(NELEPS.NE.NEP) ICHECK=1;
               1
               1  "NOW CHECK THAT THE DENSITIES ARE THE SAME WITHIN TOLERANCE"
               1  IF( (ICHECK.EQ.0)  .AND.
               1    ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR.
               1      (EPSTRH.GT.((1.0+TLRNCE)*RHOP))
               1    ) ) ICHECK=1; "DENSITY IS OUT OF RANGE"
               1  "WE MUST FIRST NORMALIZE THE PEGS FRACTIONS BY WEIGHT TO ENSURE THEY"
               1  "ARE NORMALIZED TO UNITY"
               1  EPSTWT = 0.0;DO I=1,NEP[ EPSTWT = EPSTWT + RHOZP(I);]
               1  IF(EPSTWT=0.0)[
               2  OUTPUT;(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHT OF',
               2  'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//);]
               1
               1  IF(ICHECK.EQ.0)[
               2      IESPEL=0;    "INITIALIZE ESP ELEMENT COUNTER"
               2      ICHECK=1;    "ASSUME FAILURE"
               2      LOOP["LOOP OVER ESP COMPONENTS"
               3          IESPEL=IESPEL+1;
               3          IPEGEL=0;    "INITIALIZE PEGS ELEMENT COUNTER"
               3          LOOP["LOOP OVER PEGS COMPONENTS"
               4              IPEGEL=IPEGEL+1;
               4              IF(INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))[ICHECK=0;EXIT;]
               4              ]WHILE(IPEGEL.LT.NEP);
               3              IF( (ICHECK.EQ.0) "Z OF ELEMENT MATCHES"
               3              .AND.
               3              ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3               .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3              ) ) ICHECK=1; "MATCHED ELEMENT BUT WEIGHT FRACTION WRONG"
               3          ]WHILE(IESPEL.LT.NELEPS);
               2      ] "END OF TEST FOR ICHECK = 0"
               1
               1  IF(ICHECK.EQ.1)[ "PRINT MESSAGE AND STOP"
               2  OUTPUT;
               2  (////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MATCH ',
               2  ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////);
               2  $CALL_EXIT(23); " ERRORS DETECTED";
               2  ]
               1
               1
               1  ]"END OF EPSTFL=1 BLOCK"
               0
               0
               0  SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP;
               0  SPC2=LOG((IMEV/RMP)**2/2.0);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP SPC1,SPC2;"
               0
               0  RETURN;
               0  :no_density_file:
               0  $egs_fatal(*,' Failed to open density file ',density_file);
               0  RETURN;
               0  END;  "END OF SUBROUTINE SPINIT"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE MIX;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0  implicit none;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER I,IZZ;
               0  $REAL4    AL183,ZAB,V2000;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 FCOULCP,XSIFP;
               0
               0  COMIN/MIMSD,MIXDAT,MOLVAR,PMCONS,DERCON,RADLEN,BREMPRP/;
               0  $REAL4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20);
               0  " MOLVAR - - MOLECULAR VARIABLES NEEDED BY DIFFER, AND MOLIER      "
               0
               0  " THE FOLLOWING ASSUMES THAT THE MATERIAL BEING DEALT WITH         "
               0  " IS EITHER A COMPOUND, OR A HOMOGENEOUS MIXTURE.                  "
               0  "          MOLECULAR VARIABLES                                     "
               0  " NE       NUMBER OF DIFFERENT TYPES OF ATOMS IN THE MATERIAL.     "
               0  " PZ(I)    PROPORTION OF ELEMENT OF TYPE I.  IF A COUMPOUND,       "
               0  " THEN PZ(I) WILL BE THE NUMBER OF ATOMS OF TYPE I IN THE MOLECULE."
               0  " IF A MIXTURE,SUCH AS CONCRETE, PZ(I) COULD BE THE PER CENT OF    "
               0  " THE ATOMS WHICH ARE OF TYPE I.                                   "
               0  " Z(I)     PERIODIC NUMBER OF ATOMS OF TYPE I                      "
               0  " WA(I)    ATOMIC WEIGHT FOR ATOMS OF TYPE I.                      "
               0  " WM = SUM(PZ(I)*WA(I)) = MOLECULAR  WEIGHT IF A COUMPOUND         "
               0  " OR A 'MIXTURE WEIGHT' IF A MIXTURE.                              "
               0  " RHO      DENSITY OF THE MATERIAL. (IN GRAMS/CM**3)               "
               0  " RHOZ(I)  PARTIAL DENSITY DUE TO ATOMS OF TYPE I. (GM/CM**3)      "
               0  "          ELECTRON DENSITY VARIABLE                               "
               0  " ZC = SUM(PZ(I)*Z(I)) = NUMBER OF ELECTRONS/MOLECULE              "
               0  "          BREMSSTRAHLUNG AND PAIR PRODUCTION VARIABLES ARE WEIGHTE"
               0  " BY PZ(I)*Z(I)**2 FOR THE NUCLEUS, AND BY PZ(I)*Z(I)*XSI(I) FOR   "
               0  " ATOMIC ELECTRONS.                                                "
               0  " TPZ = SUM(PZ(I))                                                 "
               0  " XSI(I) = LOG(A1440/Z(I)**(2./3.))/(LOG(A183/Z(I)**(1./3.))  -    "
               0  "               FCOUL(Z(I)) )                                      "
               0  " ZZX(I) =  PZ(I)*Z(I)*(Z(I)+XSI(I)) = BREMS AND PAAR WEIGHTS      "
               0  " EZ = ZC/TPZ  EFFECTIVE Z                                         "
               0  " ZT = SUM(ZZX(I))                                                 "
               0  " ZA = LOG(A183)*ZT   BUTCHER AND MESSELS L.C.'A' (1960)P.18       "
               0  " ZB = SUM(ZZX(I)*LOG(Z(I)**(-1./3.)  B&M'S L.C.'B' IBID.          "
               0  " ZF = SUM(ZZX(I)*FCOUL(Z(I))),WHERE FCOUL IS THE COULOMB          "
               0  " CORRECTION FUNCTION.                                             "
               0  " RATIOS--                                                         "
               0  " ZG = ZB/ZT ,EXP(ZG)=WEIGHTED GEOMETRIC MEAN OF Z**(-1/3)         "
               0  " ZP = ZB/ZA , B&M IBID.P18 L.C.'P'                                "
               0  " ZV= (ZB-ZF)/ZT                                                   "
               0  " ZU = (ZB-ZF)/ZA                                                  "
               0  "          MULTIPLE SCATTERING VARIABLES                           "
               0  " ACCORDING TO MESSEL AND CRAWFORD(1970), MOST OF THE MULTIPLE     "
               0  " SCATTERING DUE TO THE FIELD OF THE ATOMIC ELECTRONS IS ALREADY   "
               0  " ACCOUNTED FOR BY THE DISCRETE MOLLER SCATTERING. HENCE,THE       "
               0  " FOLLOWING VARIABLES ARE ONLY WEIGHTED BY PZ(I)*Z(I)**2           "
               0  " HOWEVER I HAVE NOT JUSTIFIED THE ABOVE ASSERTION THEORETICALLY   "
               0  " THEORETICALLY, AND COMPARISON OF EXPERIMENTS WITH EGS HAVE       "
               0  " SHOWN EGS PHOTON SPECTRUM DEFICIENT IN THE BACKWARD DIRECTION.   "
               0  " THEREFORE, I WILL EXPERIMENT WITH RESTORING THE ELECTRON SCATTER-"
               0  " ING TERM.  ITS CONTRIBUTION WILL BE REPRESENTED BY THE MACRO VAR-"
               0  " IABLE, $FUDGEMS, WHICH WILL HAVE THE VALUE 0.0 FOR NO ELECTRON   "
               0  " SCATTERING AND 1.0 FOR FULL ELECTRON SCATTERING.  AND WE NOW HAVE"
               0  " WEIGHTING BY PZ(I)*Z(I)*(Z(I)+$FUDGEMS).                         "
               0  " ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS) "
               0  " ZS = SUM(ZZ(I))                                                  "
               0  " ZE = SUM(ZZ(I)*LOG(Z(I)**(-2./3.)))                              "
               0  " ZX = SUM(ZZ(I)*LOG(1.+3.34*(FSC*Z(I))**2))                       "
               0  "               ELECTON DENSITY(ELECTRONS/CM**3)                   "
               0  " EDEN=AN*RHO/WM*ZC                                                "
               0  "          RADIATION LENGTH                                        "
               0  " USEFUL FOR GAUGING THE STEP SIZE, EVEN IF IT IS NOT USED AS THE  "
               0  " UNIT OF DISTANCE.                                                "
               0  "  1./RLC =(AN*RHO/WM)*4.0*FSC*R0**2*                              "
               0  "    SUM( Z(I)*(Z(I)+XSI(I))*(LOG(A183*Z(I)**(-1./3.)-FCOUL(Z(I))) "
               0  "        =(AN*RHO/WM)*4.*FSC*R0**2*(ZAB-ZF)                        "
               0  " INPUT MOLECULAR VARIABLES AND COMPUTE Z-RELATED PARAMETERS       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "SCALE RHO FOR GASES BY THE GAS PRESSURE"
               0  IF (GASPP.NE.0.0) [RHOP=GASPP*RHOP;]
               0  "     FIND VARIOUS SUMS AND SET OTHER VARIABLES                        "
               0  AL183 = LOG(A183);
               0  /TPZ,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZAB/=0.0;
               0  DO I=1,NEP[
               1  TPZ = TPZ + PZP(I);
               1  WM = WM + PZP(I)*WAP(I);
               1  ZC = ZC + PZP(I)*ZELEMP(I);
               1  FZC(I) =(FSC*ZELEMP(I))**2;
               1  FCOUL(I) = FCOULCP(ZELEMP(I));
               1  XSI(I) = XSIFP (ZELEMP(I));
               1  ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I));
               1  IF (ZELEMP(I).LE.4.0) [IZZ=ZELEMP(I);
               2  ZAB=ZAB+ZZX(I)*ALRAD(IZZ);] "IN THE CASE OF Z.LE.4 "
               1  ELSE [ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)));] "Z.GT.4"
               1  ZT = ZT + ZZX(I);
               1  ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.));
               1  ZF = ZF + ZZX(I)*FCOUL(I);
               1  ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+$FUDGEMS);
               1  ZS = ZS + ZZ(I);
               1  ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)));
               1  ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I));
               1  ]
               0  "END OF I LOOP"
               0  EZ = ZC/TPZ;
               0  ZA = AL183*ZT;
               0  ZG = ZB/ZT;
               0  ZP = ZB/ZA;
               0  ZV = (ZB-ZF)/ZT;
               0  ZU = (ZB-ZF)/ZA;
               0  EDEN=AN*RHOP/WM*ZC;
               0  RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) );
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP EDEN;"
               0
               0  "NOW COMPUTE MATERIAL-DEPENDENT CONSTANTS FOR MULTIPLE SCATTERING"
               0  "LET B BE MOLIERE'S UPPER CASE B, AND LET BLC BE MOLIERE'S LOWER CASE B"
               0  "THEN USING SCOTT'S NOTATION, A MEASURE OF THE NUMBER OF SCATTERS IS"
               0  "OMEGA0=EXP(BLC).  NOW B AND BLC ARE RELATED BY"
               0  "BLC=B-ALOG(B);, OR EXP(BLC)=EXP(B)/B; "
               0  "NOW LET T BE THE TRANSPORT DISTANCE IN RL. THEN,"
               0  "OMEGA0=EXP(BLC)"
               0  "      =( A6680*RHO*ZS*EXP(ZE/ZS)*RLC/(WM*EXP(ZX/ZS)) )*T/BETA**2"
               0  "WHERE BETA IS V/C FOR THE PARTICLE"
               0  "NOW SUPPOSE THAT XC IS CHI-SUB-C, THE CHARACTERISTIC ANGLE OF"
               0  "MOLIERE'S THEORY.  THEN IT IS GIVEN BY"
               0  "XC= (A22P9/RADDEG)*SQRT( ZS*RHO*RLC/WM ) * SQRT(T) /(E*BETA**2) "
               0  " WHERE E IS THE ENERGY OF THE PARTICLE IN MEV."
               0  "NOW IN MOLIERE'S THEORY, LET XRM BE XC*SQRT(B).  THEN"
               0  " (MOLIERE'S REDUCE ANGLE)=(REAL ANGLE)/XRM."
               0  "FOR THE VARIABLE SAMPLING DONE IN EGS, A DIFFERENT REDUCED"
               0  "ANGLE IS USED:"
               0  " (REDUCED ANGLE FOR VARIABLE SAMPLING)=(REAL ANGLE)/XRV "
               0  " WHERE NOW XRV=XC*SQRT(BLC)."
               0  "THIS IS DONE BECAUSE BLC IS MORE SIMPLY RELATED TO THE TRANSPORT"
               0  "DISTANCE THAN IS B."
               0
               0  "WITH THIS BACKGROUND WE NOW PROCEED TO COMPUTE"
               0  "XR0, TEFF0, BLCC, AND XCC, WHICH ARE PARAMETERS NEEDED IN EGS"
               0  "THESE PARAMETERS ARE USED AS FOLLOWS:(IN OUR NOTATION)"
               0  "XRM=XR0*SQRT(T*B/(T0*BMIN))/(E*BETA) "
               0  "  WHERE B IS EVALUATED FOR DISTANCE T, AND T0 IS THE"
               0  "  DISTANCE THAT WOULD GIVE B=BMIN. T0 IS A FUNCTION OF BETA, AND"
               0  "  IS GIVEN BY THE EXPRESSION  "
               0  "T0=TEFF0*BETA**2;  THIS IS ALSO THE DEFINING RELATION FOR TEFF0"
               0  "BMIN IS THE MINIMUM VALUE OF B FOR WHICH MOLIERE CONSIDERED HIS THEORY"
               0  "VALID.  WE CURRENTLY GIVE BMIN A VALUE OF 4.5."
               0  "OMEGA0=BLCC*T/BETA**2  IS THE USEAGE OF BLCC"
               0  "XRV= XCC*SQRT( T*BLC )/(E*BETA**2) IS THE USAGE OF XCC"
               0
               0  "WE NOW PROCEED TO SOLVE FOR THE ABOVE QUANTITIES."
               0  "COMPARING THE TWO EXPRESSIONS FOR OMEGA0, WE CONCLUDE THAT:"
               0
               0  BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS)) ;
               0  "NOW USING THE EXPRESSION FOR OMEGA0 AT B=BMIN,WE HAVE"
               0  " OMEGA0=EXP(BLCMIN)"
               0  "       =EXP(BMIN)/BMIN"
               0  "       =BLCC*T0/BETA**2"
               0  "       =BLCC*TEFF0    ,     THEREFORE"
               0
               0  TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP;
               0
               0  "COMPARING THE TWO EXPRESSION FOR XRV WE CONCLUDE THAT"
               0  "XC= XCC * SQRT(T) /(E*BETA**2)"
               0  "COMPARING THIS WITH OUR PREVIOUS EXPRESSION FOR XC, WE OBTAIN"
               0
               0  XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM );
               0
               0  "NOW COMPARING THE TWO EXPRESSIONS FOR XRM WE OBTAIN"
               0  "XRM=XC*SQRT(B)       USING DEFINITION OF XRM"
               0  "   =(XCC(i_med)*SQRT(T)/(E*BETA**2)) *SQRT(B)  AFTER SUBSTITUTING FOR XC"
               0  "   =XR0*SQRT((T*B)/(T0*BMIN))/(E*BETA)  USING EXPRESSION DEFINING XR0"
               0  "   =XR0*SQRT((T*B)/(TEFF0*BETA**2*BMIN))/(E*BETA)  EXPANDING T0"
               0  " THUS AFTER SOME CANCELLATION AND SOLVING FOR XR0 WE OBTAIN"
               0
               0  XR0P = XCCP*SQRT(TEFF0P*BMIN);
               0
               0  "THIS COMPLETE THE MS CALCULATIONS"
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE MIX"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE DIFFER;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN;
               0  INTEGER I;
               0
               0  COMIN/MOLVAR,BREMPRP,DBRPR,DERCON,RADLEN/;
               0  "**********************************************************************"
               0  "***THE DIFFERENTIAL CROSS-SECTIONS OF BREMSSTRAHLUNG AND PAIR       "
               0  "   PRODUCTION ARE Z-DEPENDENT.  BUTCHER AND MESSEL USE A SAMPLING   "
               0  "   TECHNIQUE FOR BREMSSTRAHLUNG WHICH ALSO DEPENDS ON THE LARGEST   "
               0  "   AND SMALLEST ALLOWED ENERGY VALUES.                              "
               0  "   THIS IS NOW TAKEN INTO ACCOUNT BY THE FUNCTION ILOG2(E/AP) WHICH "
               0  "   GIVES THE NUMBER OF SUBDISTRIBUTIONS NEED TO PRODUCE PHOTONS DOWN"
               0  "   TO THE LIMIT AP.                                                 "
               0  "   THE DIFFERENTAL CROSS SECTIONS USED FOR BREMS AND PAIR ARE--     "
               0  "   (THEY ARE CROSS SECTION PER RADIATION LENGTH)                    "
               0
               0  "***BELOW 50MEV (BETHE-HEITLER)--                                      "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZP)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3 - 1/(36*LOG(A183)*(1+ZP)))*(1) * C(DELTAPRIME)         "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZP))))* (12*(EPS-1/2)**2)       "
               0  "    2 * A(DELTAPRIME)                                                 "
               0  "       WHERE A,B,C ARE SCREENING REJECTION FUNCTIONS GIVEN BY         "
               0  "       A(D)=(3*F1(D)-F2(D)+8*ZG)/(3*F1(0)-F2(0)+8*ZG)                 "
               0  "       B(D)=(F1(D)+4*ZG)/(F1(0)+4*ZG)                                 "
               0  "       C(D)=(3*F1(D)+F2(D)+16*ZG)/(3*F1(0)+F2(0)+16*ZG)               "
               0  "       AND WHERE                                                      "
               0  "       DELTAPRIME= 136.*EXP(ZG)*RM*DEL= DELCM *DEL                    "
               0  "       AND                                                            "
               0  "       DEL =  EPS/(E*(1-EPS))      BREMSSTRAHLUNG                     "
               0  "           =  1/(E*EPS*(1-EPS))    PAIR PRODUCTION                    "
               0  "       F1(D) AND F2(D) ARE SCREENING FUNCTIONS GIVEN APPROXIMATELY BY "
               0  "             IF D.LE.1 ,THEN                                          "
               0  "       F1(D) = 20.867 - 3.242*D + 0.625*D**2                          "
               0  "       F2(D) = 20.209 - 1.930*D - 0.086*D**2                          "
               0  "         BUT IF D.GT.1 ,THEN                                          "
               0  "       F1(D)=F2(D)= 21.12 - 4.184*ALOG(D+0.952)                       "
               0  "         IN ADDITION WE HAVE THAT                                     "
               0  "       F1(0)= 4.*ALOG(A183)                                           "
               0  "       F2(0)= F1(0) - 2./3.                                           "
               0  "***ABOVE 50 MEV (COULOMB CORRECTED BETHE HEITLER)                     "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZU)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3-1/(36*LOG(A183)*(1+ZU)))* 1 * C(DELTAPRIME)            "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZU))))* (12*(EPS-1/2)**2)       "
               0  "    2  * A(DELTAPRIME)                                                "
               0  "       WHERE A,B,AND C ARE NOW GIVEN BY                               "
               0  "       A(D) = (3*F1(D)-F2(D)+8*ZV)/(3*F1(0)-F2(0)+8*ZV)               "
               0  "       B(D) = (F1(D)+4*ZV)/(F1(0)+4*ZV)                               "
               0  "       C(D) = (3*F1(D)+F2(D)+16*ZV)/(3*F1(0)+F2(0)+16*ZV)             "
               0  "       AND DELTAPRIME,DEL,F1, AND F2 ARE THE SAME AS BELOW 50 MEV.    "
               0  "   BREMSSTRAHLUNG ALPHA(I), I=1,...,N.  ALPHA(N+1)=0.5                "
               0  AL2 = LOG(2.);
               0  AL183= LOG(A183);
               0  ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)));
               0  ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)));
               0  "*****PAIR PRODUCTION DIFFERENTIAL CROSS-SECTION NUMBERS               "
               0  ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP));
               0  ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU));
               0  ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)));
               0  ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)));
               0  "*****BRANCHING RATIO FOR PAIR PRODUCTION SAMPLING                     "
               0  BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1));
               0  BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2));
               0
               0  "*****WE MUST ALWAYS HAVE A,B,C(DELTA) POSITIVE. SHOWER ASSURES THIS BY"
               0  "     REQUIRING DEL.LT.DELPOS(),AND HENCE THAT DELTA.LT.DELCM *DELPOS()"
               0  "     THE CROSS-OVER POINT IS IN THE DELTA.GT.1 REGION,AND THE CROSSING"
               0  "     CONDITION REDUCES TO --                                          "
               0  "       F1(D) + 4*ZG = 0     IF  E.LT.50 MEV                           "
               0  "       F1(D) + 4*ZV = 0     IF  E.GT.50 MEV                           "
               0  "     OR --                                                            "
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(1)+0.952) +4.*ZG =0     E.LT.5"
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(2)+0.952) +4.*ZV =0     E.GT.5"
               0  "       THUS DELPOS IN THE TWO ENERGY REGIONS IS GIVEN BY              "
               0  DELCMP= 136.0*EXP(ZG)*RMP;
               0  DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP;
               0  DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP;
               0  "     CALCULATION OF THE BETHE-HEITLER(B-H) A,B,C(DELTA).AND THE       "
               0  "     COULUMB CORRECTED(CC) A,B,C(DELTA).  THE SHOWER PROGRAM COMPUTES "
               0  "     THESE SIX SCREENING REJECTION FUNCTION WITH THE EXPRESSIONS--    "
               0  "       DL1(LVL)+DELTA*(DL2(LVL)+DELTA*DL3(LVL))   IF DELTA.LT.1 ,AND B"
               0  "       DL4(LVL)+DL5(LV)*ALOG(DELTA+DL6(LVL))      IF DELTA.GE.1       "
               0  "       WHERE LVL IS USED TO SELECT THE FUNCTION--                     "
               0  "       LVL=1   B-H A(DELTA)                                           "
               0  "          =2   B-H B(DELTA)                                           "
               0  "          =3   B-H C(DELTA)                                           "
               0  "          =4   CC  A(DELTA)                                           "
               0  "          =5   CC  B(DELTA)                                           "
               0  "          =6   CC  C(DELTA)                                           "
               0  "     FIRST COMPUTE THE DENOMINATORS                                   "
               0  F10=4.*AL183;
               0  F20=F10 - 2./3.;
               0  A1DEN =3.0*F10- F20 + 8.0*ZG;
               0  A2DEN =3.0*F10- F20 + 8.0*ZV;
               0  B1DEN = F10 + 4.0*ZG;
               0  B2DEN = F10 + 4.0*ZV;
               0  C1DEN = 3.0*F10+ F20 + 16.0*ZG;
               0  C2DEN = 3.0*F10+ F20 + 16.0*ZV;
               0  "     LVL=1, B-H A(DELTA)                                              "
               0  DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN;
               0  DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN;
               0  DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN;
               0  DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN;
               0  DLP5(1)=  2.0*(-4.184)/A1DEN;
               0  DLP6(1)=  0.952;
               0  "     LVL=4, CC  A(DELTA)                                              "
               0  DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN;
               0  DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN;
               0  DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN;
               0  DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN;
               0  DLP5(4)=  2.0*(-4.184)/A2DEN;
               0  DLP6(4)=  0.952;
               0  "     LVL=2, B-H B(DELTA)                                              "
               0  DLP1(2)= (20.867+4.0*ZG)/B1DEN;
               0  DLP2(2)= -3.242/B1DEN;
               0  DLP3(2)=  0.625/B1DEN;
               0  DLP4(2)= (21.12+4.0*ZG)/B1DEN;
               0  DLP5(2)= -4.184/B1DEN;
               0  DLP6(2)= 0.952;
               0  "     LVL=5, CC B(DELTA)                                               "
               0  DLP1(5)= (20.867+4.0*ZV)/B2DEN;
               0  DLP2(5)= -3.242/B2DEN;
               0  DLP3(5)= 0.625/B2DEN;
               0  DLP4(5)= (21.12+4.0*ZV)/B2DEN;
               0  DLP5(5)= -4.184/B2DEN;
               0  DLP6(5)= 0.952;
               0  "     LVL=3, B-H C(DELTA)                                              "
               0  DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN;
               0  DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN;
               0  DLP3(3)= (3.0*0.625+(-0.086))/C1DEN;
               0  DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN;
               0  DLP5(3)=  4.0*(-4.184)/C1DEN;
               0  DLP6(3)=  0.952;
               0  "     LVL=6, CC  C(DELTA)                                              "
               0  DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN;
               0  DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN;
               0  DLP3(6)= (3.0*0.625+(-0.086))/C2DEN;
               0  DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN;
               0  DLP5(6)=  4.0*(-4.184)/C2DEN;
               0  DLP6(6)=  0.952;
               0  "*****PUNCHED AND PRINTED OUTPUT                                       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE DIFFER"
               0
               0  $REAL4 function FCOULCP(Z);
               0  "************************"
               0  implicit none;
               0  $REAL4 Z,ASQ;
               0  COMIN/DERCON/;
               0  ASQ=(FSC*Z)**2;
               0  FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+
               0   ASQ*(0.0083+ASQ*(-0.002))));
               0  RETURN;
               0  END;  "END OF FUNCTION FCOULC"
               0
               0  $REAL4 function XSIFP(Z);
               0  "**********************"
               0  implicit none;
               0  $REAL4 Z,FCOULCP;
               0  $INTEGER IZ;
               0  COMIN/RADLEN/;
               0  IF (Z.LE.4.0) [IZ=Z;
               1  XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z));]
               0  ELSE [
               1  XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z));]
               0  RETURN;
               0  END;  "END OF FUNCTION XSIF"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ZTBL(IASYM);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  COMIN/ELEMTB,EGS-IO/;
               0  $TYPE IASYM,IA;
               0  $INTEGER ie;
               0  DATA IA/'A'/;
               0  save ia;
               0  IF (IASYM.EQ.IA)["ALTERNATE SYMBOL FOR ARGON" ZTBL=18.0;RETURN;]
               0  "     PUT IN THE REST LATER                                 "
               0  DO IE=1,NET[
               1  IF (IASYM.EQ.ASYMT(IE)) [ZTBL=IE; RETURN;]
               1  ]
               0  OUTPUT IASYM,NET;
               0  (1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3);
               0  ZTBL=0.0;
               0  RETURN;
               0  "END OF FUNCTION ZTBL" END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc core source code                                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but NOTE, this doesn't happen inside a REPLACE macro
               0              "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
               0  "   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
               0  "                                                                  "
               0  "   If the user requests radiative splitting (via nbr_split > 1),  "
               0  "   this routine produces 2*nbr_split annihilation photons at once,"
               0  "   each carying the fraction 1/nbr_split of the weight of the     "
               0  "   incident positron.                                             "
               0  "                                                                  "
               0  "   Except for taking out the calculation of                       "
               0  "   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
               0  "   rejection function normalized to its maximum, the sampling     "
               0  "   technique is the same as the original EGS4 implementation.     "
               0  "                                                                  "
               0  "   I. Kawrakow, January 2000                                      "
               0  "                                                                  "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                   "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
               0                   "EGS-VARIANCE-REDUCTION/;                         "
               0
               0  $DEFINE-LOCAL-VARIABLES-ANNIH;
               0  $INTEGER ip;
               0
               0  NPold = NP; "Set the old stack counter"
               0  IF( nbr_split <= 0 ) [ return; ]
               0  PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
               0                   "i.e. electron assumed to be at rest
               0  AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
               0  A=AVIP/RM;
               0  "AI=1.0/A;  AI not necessary, IK Oct 97"
               0  G=A-1.0;
               0  T=G-1.0;
               0  P=SQRT(A*T);
               0  POT=P/T;
               0  EP0=1.0/(A+P);
               0  "   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
               0  "Take the calculation of the logarithm out of the loop, IK Oct 97"
               0  WSAMP=LOG((1.0-EP0)/EP0);
               0
               0  aa = u(np); bb = v(np); cc = w(np);
               0  sinpsi = aa*aa + bb*bb;
               0  IF( sinpsi > 1e-20 ) [
               1     sinpsi = sqrt(sinpsi);
               1     sindel = bb/sinpsi; cosdel = aa/sinpsi;
               1  ]
               0
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0
               0  DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
               1                          "radiative event                              "
               1
               1      IF( np+1 > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1
               1      LOOP[
               2          $RANDOMSET RNNO01;
               2          EP=EP0*EXP(RNNO01*WSAMP);
               2          "   NOW DECIDE WHETHER TO ACCEPT"
               2          $RANDOMSET RNNO02;
               2          "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
               2          "The above rejection function has a maximum = 1 - 2/A**2"
               2          "For efficiency, it is better to divide by the maximum value, IK Oct 97"
               2          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
               2      ] UNTIL (RNNO02 <= REJF);
               1
               1
               1      "   SET UP ENERGIES"
               1      ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
               1      PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
               1      E(NP)=PESG1; IQ(NP)=0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1));
               1      SINTHE=SQRT(1.0-COSTHE*COSTHE);
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1      PESG2=PAVIP-PESG1; esg2 = pesg2;
               1      e(np) = pesg2; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2));
               1      SINTHE=-SQRT(1.0-COSTHE*COSTHE);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1
               1  ]
               0  np = np-1;
               0
               0  RETURN;
               0  "END OF SUBROUTINE ANNIH"   END;
               0
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH_AT_REST;
               0  "                                                                  "
               0  " It is handy to be able to initiate annihilation at rest from     "
               0  " places other than the electron discard section (e.g. AUSGAB)     "
               0  " Annihilation at rest takes a sufficent amount of time to not     "
               0  " have any real benefit from this code being inline in the         "
               0  " ELECTR subroutine.                                               "
               0  " I. Kawrakow, June 2005.                                          "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-ANNIH-ATREST;
               0  $REAL costhe,sinthe,cphi,sphi;
               0  $INTEGER ibr,ip;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  NPold = NP;
               0  $CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0      " nbr_split > 1 means user wants to use radiative "
               0      " splitting => produce 2*nbr_split annihilation   "
               0      " photons at once                                 "
               0  DO ibr = 1, nbr_split [
               1      "Pick random direction for first gamma
               1      $RANDOMSET costhe; costhe = 2*costhe-1;
               1      sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      e(np) = prm; iq(np) = 0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               1      np = np+1;
               1      e(np) = prm; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               1      np = np+1;
               1  ]
               0  np = np-1;
               0  return; end;
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BHABHA;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
               0  "   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
               0  "   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                     "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
               0                                  "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BHABHA;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
               0  EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
               0  PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
               0  EKIN=PEKIN;
               0  T0=EKIN/RM;
               0  E0=T0+1.;
               0  YY=1./(T0+2.);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
               0  BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  EP0C=1.-EP0;
               0  Y2=YY*YY;
               0  YP=1.-2.*YY;
               0  YP2=YP*YP;
               0  B4=YP2*YP;
               0  B3=B4+YP2;
               0  B2=YP*(3.+Y2);
               0  B1=2.-Y2;
               0  "   SAMPLE BR FROM MINIMUM(EP0) TO 1."
               0  LOOP[$RANDOMSET RNNO03;
               1  BR=EP0/(1.-EP0C*RNNO03);
               1  "   APPLY REJECTION FUNCTION"
               1  $RANDOMSET RNNO04;
               1  "REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
               1  REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
               1  ]UNTIL RNNO04.LE.REJF2 ;
               0  "   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
               0  $CHECK-STACK(np+1,'BHABHA');
               0  IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
               0  "THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
               0  "   DIVIDE UP THE ENERGY"
               0  BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
               0  PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
               0  PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
               0  ESE1=PESE1;
               0  ESE2=PESE2;
               0  E(NP)=PESE1;
               0  E(NP+1)=PESE2;
               0  "   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
               0  H1=(PEIP+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"
               0
               0  "AFB modified the following statement 92/10/28 to avoid"
               0  "numerical difficulties"
               0  "DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
               0  DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));
               0
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(2,1);
               0  NP=NP+1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE BHABHA"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BREMS;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Samples bremsstrahlung energy using                            "
               0  "    - Coulomb corrected Bethe-Heitler above 50 MeV                "
               0  "    - Bethe-Heitler below 50 MeV                                  "
               0  "   if ibr_nist = 0, or                                            "
               0  "    - the NIST bremsstrahlung cross section data base             "
               0  "      (prepared in a form of an alias table for rapid sampling)   "
               0  "   if ibr_nist = 1  or                                            "
               0  "    - the NRC bremsstrahlung cross section data base, which is    "
               0  "      the same as the NIST database, but with corrections to      "
               0  "      the electron-electron contribution, which are mostly        "
               0  "      important for low Z and low k                               "
               0  "   if ibr_nist = 2                                                "
               0  "   and direction using                                            "
               0  "    - formula 2BS from from Koch and Motz if IBRDST=1             "
               0  "    - leading term of the brems angular dsstr. if IBRDST=0        "
               0  "    - photon direction = electron direction if IBRDST<0           "
               0  "                                                                  "
               0  "   This version replaces the original EGS4 implementation         "
               0  "   because of a bug discovered in the EGS4 brems routine          "
               0  "   In order to work properly, the parameter DL1,..,DL6            "
               0  "   are re-calculated in subroutine fix_brems which is called      "
               0  "   from HATCH                                                     "
               0  "   In addition, this version has the internal capability of       "
               0  "   bremsstrahlung splitting.                                      "
               0  "   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
               0  "   to the desired number > 1 (1 is the default)                   "
               0  "   Be aware that event-by-event energy conservation is NOT        "
               0  "   guaranteed, so don't use for calculations where this is        "
               0  "   important (e.g. calculation of detector response functions)    "
               0  "   The result will be nbr_split photons, all with the weight      "
               0  "   wt(npold)/nbr_split, and an electron with the original weight  "
               0  "   and energy given by the incident energy - energy of last photon"
               0  "                                                                  "
               0  " I. Kawrakow, January 2000                                        "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
               0                             "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BREMS;
               0  $REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;
               0
               0  IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
               0                               "by setting nbr_split to zero!"
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
               0  EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
               0  weight = wt(np)/nbr_split;
               0
               0  "   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
               0  "   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
               0  IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
               0  L1 = L+1;
               0
               0  ekin = peie-prm;
               0  brmin = ap(medium)/ekin;
               0  "waux = -log(brmin);"
               0  waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
               0                                "log_ap = log(ap(medium)) is calculated in   "
               0                                "fix_brems for each medium, elke is needed   "
               0                                "in electr to calculate the branching ratios "
               0                                "and therefore it must be known at this point"
               0
               0  IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
               1                      "angle from KM-2BS (ibrdst=1) or from the leading"
               1                      "term (ibrdst=0). If nbr_split > 1, we can re-use"
               1                      "the following quantities several time"
               1
               1      a = u(np); b = v(np); c = w(np);
               1      sinpsi = a*a + b*b;
               1      IF( sinpsi > 1e-20 ) [
               2         sinpsi = sqrt(sinpsi);
               2         sindel = b/sinpsi; cosdel = a/sinpsi;
               2      ]
               1
               1      ztarg = zbrang(medium);
               1      tteie = eie/rm;
               1      beta = sqrt((tteie-1)*(tteie+1))/tteie;
               1      y2max = 2*beta*(1+beta)*tteie*tteie;
               1      y2maxi = 1/y2max;
               1      IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]
               1
               1  ]
               0
               0  IF( ibr_nist >= 1 ) [
               1      ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
               1      jj = ajj; ajj = ajj - jj;
               1      IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
               1  ]
               0
               0  DO ibr = 1,nbr_split [
               1
               1      IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
               2                           "data base"
               2          IF( ekin > nb_emin(medium) ) [
               3              $RANDOMSET r1;
               3              IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
               3              br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
               3                                 nb_fdata(0,j,medium),
               3                                 nb_wdata(1,j,medium),nb_idata(1,j,medium));
               3          ]
               2          ELSE [ $RANDOMSET br; ]
               2          esg = ap(medium)*exp(br*waux); pesg = esg;
               2          pese = peie - pesg; ese = pese;
               2      ]
               1      ELSE [
               2
               2          LOOP [ "User wants to use Bethe-Heitler"
               3
               3              $RANDOMSET rnno06; $RANDOMSET rnno07;
               3              br = brmin*exp(rnno06*waux);
               3              esg = ekin*br; pesg = esg;
               3              pese = peie - pesg; ese = pese;
               3              delta = esg/eie/ese*delcm(medium); aux = ese/eie;
               3              IF( delta < 1 ) [
               4                  phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4                  phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
               4                          delta*dl3(l1,medium));
               4              ]
               3              ELSE [
               4                  phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
               4                  phi2 = phi1;
               4              ]
               3              rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;
               3
               3          ] UNTIL (rnno07 < rejf);
               2      ]
               1
               1      "   SET UP THE NEW PHOTON                                          "
               1      np=np+1;
               1      IF( np > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1      e(np) = pesg; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      wt(np) = weight;
               1      IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
               2                          "the electron. This option is given so that "
               2                          "the user can implement their own brems angle "
               2                          "schemes via a call to ausgab"
               2          u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
               2      ]
               1      ELSE [
               2         IF( ibrdst = 1 ) [
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3             ttese = ese/rm; esedei = ttese/tteie;
               3             rjarg1 = 1+esedei*esedei;
               3             rjarg2 = rjarg1 + 2*esedei;
               3             aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
               3             IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
               3             ELSE [ rjarg3 = log(aux/(1+aux1)); ]
               3             rejmax = rjarg1*rjarg3-rjarg2;
               3             LOOP [
               4                 $RANDOMSET y2tst; $RANDOMSET rtest;
               4                 aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               4                 rtest = rtest*aux3*rejmax;
               4                 y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               4                 aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               4                 IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               4                 aux2 = log(aux/(1+aux1/aux3**4));
               4                 rejtst = aux4+aux5*aux2;
               4             ] UNTIL (rtest < rejtst );
               3
               3         ]
               2         ELSE [
               3             $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
               3         ]
               2         costhe = 1 - 2*y2tst*y2maxi;
               2         sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
               2         $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               2         IF( sinpsi >= 1e-10 ) [
               3             us = sinthe*cphi; vs = sinthe*sphi;
               3             u(np) = c*cosdel*us - sindel*vs + a*costhe;
               3             v(np) = c*sindel*us + cosdel*vs + b*costhe;
               3             w(np) = c*costhe - sinpsi*us;
               3         ]
               2         ELSE [
               3             u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
               3         ]
               2      ]
               1  ]
               0
               0  e(npold) = pese;
               0
               0  RETURN;
               0  "END OF SUBROUTINE BREMS"   END;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impulse approximation  "
               0  "   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections lead to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "                                                                  "
               0  "   I.Kawrakow, March 2008:                                        "
               0  "      If ibcmp = 2 or 3, the actual bound Compton scattering      "
               0  "      cross section is used and rejections lead to resampling     "
               0  "      instead of rejecting the entire interactions as stated above"
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT;
               0  $LOGICAL first_time;
               0  $INTEGER ibcmpl;
               0
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  $RADC_CHECK;
               0
               0  irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);
               0
               0  :resample-compton:;
               0  IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
               1                     "=>first sample the shell and see whether an    "
               1                     "  interaction is possible                      "
               1      $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
               1      i = int(rnno17); "rnno17 = rnno17 - i;
               1      IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:;     ]
               2      ]
               1      Jo = Jo_array(j);          "Jo is the Compton profile parameter"
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      IF( first_time ) [
               2          broi2 = broi*broi;
               2          alph1 = Log(broi);
               2          bro   = 1/broi;
               2          alph2 = ko*(broi+1)*bro*bro;
               2          alpha = alph1+alph2;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)*bro;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
               3          ]
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          aux = 1+br*br;
               2          rejf3 = aux - br*sinthe;
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19*aux.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      IF( first_time ) [
               2          bro = 1./broi; bro1 = 1 - bro;
               2          rejmax = broi + bro;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 + br*br - br*sinthe;
               2      ] UNTIL rnno16*br*rejmax.le.rejf3;
               1  ]
               0  first_time = .false.;
               0
               0  IF(br < bro | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2          $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE: ;
               1  ]
               0
               0  $RADC_REJECTION;
               0
               0  costhe = 1 - temp;
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0;
               1      goto :FINISHED-COMPTON-SAMPLING:;
               1  ]
               0
               0  " Check for rejection due to the limited range of pzmax "
               0  br2 = br*br;
               0  aux = ko*(ko-Uj)*temp;
               0  aux1 = 2*aux + Uj*Uj;
               0  pzmax = aux - Uj;
               0  IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0  pzmax = pzmax/sqrt(aux1);
               0
               0
               0
               0
               0
               0
               0
               0  qc2 = 1 + br*br - 2*br*costhe;
               0  qc  = sqrt(qc2);
               0
               0  IF( pzmax > 1 ) [
               1      pzmax = 1; af = 0; Fmax = 1; fpz = 1;
               1      goto :RETRY-PZ:;
               1  ]
               0
               0  aux3 = 1 + 2*Jo*abs(pzmax);
               0  aux4 = 0.5*(1-aux3*aux3);
               0  fpz  = 0.5*exp(aux4);
               0  af   = qc*(1+br*(br-costhe)/qc2);
               0
               0  IF( af < 0 ) [
               1      IF( pzmax > 0 ) fpz = 1 - fpz;
               1      $RANDOMSET eta_incoh;
               1      IF( eta_incoh > fpz ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:; ]
               2      ]
               1      af = 0; Fmax = 1; goto :RETRY-PZ:;
               1  ]
               0
               0  IF( pzmax < -0.15 ) [
               1      Fmax = 1-af*0.15;
               1      fpz1 = fpz*Fmax*Jo;
               1  ]
               0  ELSE IF( pzmax < 0.15 ) [
               1      Fmax = 1 + af*pzmax;
               1      aux3 = 1/(1+0.33267252734*aux3);
               1              "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
               1              "of Abramowitz and Stegun, needed for approximating Erf        "
               1      aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
               1             erfJo_array(j);
               1      IF( pzmax > 0 ) [
               2          "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
               2          fpz = 1 - fpz;
               2      ]
               1      ELSE [
               2          "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
               2      ]
               1  ]
               0  ELSE [
               1      Fmax = 1 + af*0.15;
               1      fpz1 = (1 - Fmax*fpz)*Jo;
               1      fpz = 1 - fpz;
               1  ]
               0  $RANDOMSET eta_incoh;
               0  IF(eta_incoh*Jo > fpz1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0
               0  "At this point, all rejections are handled, now we need to sample pz "
               0  "between -1 and pzmax using the Compton profile of the selected shell"
               0  "and F(pz,cos(theta)) as a rejection function                        "
               0
               0  :RETRY-PZ:;
               0  IF( ibcmpl ~= 2 ) [
               1    $RANDOMSET rnno18; rnno18 = rnno18*fpz;
               1    IF( rnno18 < 0.5 ) [
               2      rnno18 = Max(1e-30,2*rnno18);
               2      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
               2    ]
               1    ELSE [
               2      rnno18 = 2*(1-rnno18);
               2      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
               2    ]
               1    IF( abs(pz) > 1 ) goto :RETRY-PZ:;
               1        "Due to the non-relativistic approximation"
               1        "for pz, it has to be between -1 and 1    "
               1    IF( pz < 0.15  ) [
               2      IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
               2      ELSE             [ frej = 1 + af*pz;   ]
               2      $RANDOMSET eta;
               2      IF( eta*Fmax > frej ) goto :RETRY-PZ:;
               2    ]
               1    "If pz > 0.15, F is always 1 => no need for rejection"
               1  ]
               0  ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]
               0
               0  " Calculate energy of scattered photon "
               0  pz2 = pz*pz;
               0  IF( abs(pz) < 0.01 ) [
               1      br = br*(1 + pz*(qc + (br2-costhe)*pz));
               1  ]
               0  ELSE [
               1      aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               1      aux2 = qc2 - br2*pz2*sinthe;
               1      IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               1  ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmpl = 1 | ibcmpl = 3 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = pzero;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2          "relax will put all particles with energies above ecut,pcut on the "
               2          "stack, the remaining energy will be scored in edep and deposited  "
               2          "locally (via the call to ausgab below)                            "
               2      ]
               1      ELSE [
               2          edep = Uj;
               2          edep_local = edep;
               2          $AUSCALL($SPHOTONA);
               2      ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE old_COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impuls approximation   "
               0  "    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections leed to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "   This version ignores the function F(cos(theta),pz).            "
               0  "   This leads to a small error (at least compared to the cross    "
               0  "   section we want to sample) at low energies (say, below Z keV)  "
               0  "   The advantage is that it is substantially faster then the      "
               0  "   version with F taken into account.                             "
               0  "                                                                  "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
               0                                 "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT-old;
               0
               0  i_survived_RR = 0;"0=> all survived russian roulette if played"
               0                    "must set here since, if bound compton and event is"
               0                    "rejected, this wouldn't be set to the new 0 value"
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  irl = ir(np);
               0  IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
               1                         "=>first sample the shell and see whether an    "
               1                         "  interaction is possible                      "
               1      $RANDOMSET rnno17;
               1      DO i=1,n_shell(medium) [
               2          rnno17 = rnno17 - eno_array(i,medium);
               2          IF( rnno17 <= 0 ) EXIT;
               2      ]
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE-old:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      broi2 = broi*broi;
               1      alph1 = Log(broi);
               1      alph2 = ko*(broi+1)/broi2;
               1      alpha = alph1/(alph1+alph2);
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15 < alpha ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)/broi;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16 + (1-rnno16)/broi2);
               3          ]
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 - br*sinthe/(1+br*br);
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      bro = 1./broi; bro1 = 1 - bro;
               1      rejmax = broi + bro;
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = (br + 1./br - sinthe)/rejmax;
               2      ] UNTIL rnno16.le.rejf3;
               1  ]
               0
               0  IF(br < 1./broi | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2      $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE-old: ;
               1  ]
               0
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0; costhe = 1 - temp;
               1      goto :FINISHED-COMPTON-SAMPLING-old:;
               1  ]
               0
               0  " Sample Doppler broadening using the Compton profile of the selected shell"
               0  br2 = br*br;
               0  costhe = 1 - temp;
               0  aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
               0  pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
               0  :RETRY-PZ-old:;
               0  $RANDOMSET rnno18;
               0  IF( rnno18 < 0.5 ) [
               1      rnno18 = Max(1e-30,2*rnno18);
               1      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  ELSE [
               1      IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
               1      rnno18 = 2*(1-rnno18);
               1      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;
               0
               0  " Calculate energy of scattered photon "
               0  aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               0  aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
               0  IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING-old:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmp(irl) = 1 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = 0;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2            "relax will put all particles with energies above ecut,pcut on the "
               2            "stack, the remaining energy will be scored in edep and deposited  "
               2            "localy (via the call to ausgab below)                             "
               2      ]
               1      ELSE [ edep = Uj; ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED-old:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  SUBROUTINE ELECTR(IRCODE);
               0  "******************************************************************"
               0  "   This subroutine has been almost completely recoded to include  "
               0  "   the EGSnrc enhancements.                                       "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Complete recoding            "
               0  "   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
               0  "                                     fictitious method (important "
               0  "                                     for low energy transport     "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE;
               0
               0  $COMIN-ELECTR; "default replacement produces the following:
               0                 "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
               0                          "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
               0                          "UPHIOT,USEFUL,USER,RANDOM/;"
               0  ;COMIN/EII-DATA/;
               0  ;COMIN/EM/;
               0  $REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
               0  LOGICAL random_tustep;
               0
               0  $DEFINE-LOCAL-VARIABLES-ELECTR;
               0
               0
               0
               0
               0
               0  data ierust/0/;         "To count negative ustep's"
               0
               0  save ierust;
               0
               0  $CALL-USER-ELECTRON;
               0
               0  ircode = 1; "Set up normal return-which means there is a photon
               0              "with less available energy than the lowest energy electron,
               0              "so return to shower so it can call photon to follow it.
               0              "(For efficiency's sake, we like to stay in this routine
               0              " as long as there are electrons to process. That's why this
               0              " apparently convoluted scheme of STACK contro is effected.)
               0
               0  irold = ir(np);    "Initialize previous region
               0                     "(ir() is an integer that is attached to the particle's
               0                     " phase space. It contains the region
               0                     " number that the current particle is in.
               0                     " Np is the stack pointer, it points to where on the
               0                     " stack the current particle is.)
               0  irl    = irold;    "region number in local variable
               0
               0
               0  $start_new_particle;
               0  " Default replacement for the above is medium = med(irl); "
               0  " This is made a macro so that it can be replaced with a call to a "
               0  " user provided function start_new_particle(); for the C/C++ interface "
               0
               0  :NEWELECTRON:LOOP
               0  [
               1      "Go once through this loop for each 'new' electron whose charge and
               1      "energy has not been checked
               1
               1      lelec = iq(np); "Save charge in local variable
               1                      "(iq = -1 for electrons, 0 for photons and 1 for positrons)
               1      qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
               1      peie  = e(np);  "precise energy of incident electron (double precision)
               1      eie   = peie;   "energy incident electron (conversion to single)
               1
               1      IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               1          "(Ecut is the lower transport threshold.)
               1
               1      "medium = med(irl);" "(This renders the above assignment redundant!)
               1      "The above assignment is unnecessary, IK, June 2003"
               1
               1      IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"
               1
               1      :TSTEP:LOOP
               1      [
               2          "Go through this loop each time we recompute distance to an interaction
               2
               2
               2
               2          compute_tstep = .true.; "MFP resampled => calculate distance to the
               2                                  "interaction in the USTEP loop
               2          eke = eie - rm; "moved here so that kinetic energy will be known"
               2                          "to user even for a vacuum step, IK January 2000"
               2          IF(medium ~= 0)
               2          [
               3              "Not vacuum. Must sample to see how far to next interaction.
               3
               3              $SELECT-ELECTRON-MFP;
               3                  " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
               3                  "                                       demfp = -log(rnne1);
               3                  "($RANDOMSET is a macro'ed random number generator)
               3                  "(demfp = differential electron mean free path)
               3
               3              elke = log(eke);
               3              "(eke = kinetic energy, rm = rest mass, all in units of MeV)
               3              $SET INTERVAL elke,eke; "Prepare to approximate cross section
               3
               3              $EVALUATE-SIG0;
               3                 "The fix up of the fictitious method uses cross section per"
               3                 "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               3                 "until the next discrete interaction occures (see below)"
               3                 "As this quantity is a single constant for a material,"
               3                 "$SET INTERVAL is not necessary at this point. However, to not"
               3                 "completely alter the logic of the TSTEP and USTEP loops,"
               3                 "this is left for now"
               3
               3          ] "end non-vacuum test
               2
               2          :USTEP:LOOP
               2          [
               3              "Here for each check with user geometry.
               3              "Compute size of maximum acceptable step, which is limited
               3              "by multiple scattering or other approximations.
               3              IF(medium = 0)
               3              [
               4                      "vacuum
               4                      $EMFIELD_INITIATE_SET_TUSTEP;
               4                      tstep = vacdst; ustep = tstep; tustep = ustep;
               4                      callhowfar = .true.; "Always call HOWFAR for vacuum steps!"
               4
               4                      "(Important definitions:
               4                      " tstep  = total pathlength to the next discrete interaction
               4                      " vacdst = infinity (actually 10^8)
               4                      " tustep = total pathlength of the electron step
               4                      " ustep  = projected transport distance in the
               4                      "          direction of motion at the start of the step
               4                      " Note that tustep and ustep are modified below.
               4                      " The above provide defaults.)
               4
               4                      " EM field step size restriction in vacuum
               4                      $SET-TUSTEP-EM-FIELD;
               4                      ustep = tustep;
               4              ]
               3              ELSE
               3              [
               4                  "non-vacuum
               4                  $SET-RHOF;    "density ratio scaling template
               4                                "EGS allows the density to vary
               4                                "continuously (user option)
               4
               4                  $SCALE-SIG0;
               4                  IF(sig <= 0)
               4                  [
               5                      "This can happen if the threshold for brems,
               5                      "(ap + rm), is greater than ae.  Moller threshold is
               5                      "2*ae - rm. If sig is zero, we are below the
               5                      "thresholds for both bremsstrahlung and Moller.
               5                      "In this case we will just lose energy by
               5                      "ionization loss until we go below cut-off. Do not
               5                      "assume range is available, so just ask for step
               5                      "same as vacuum.  Electron transport will reduce
               5                      "into little steps.
               5                      "(Note: ae is the lower threshold for creation of a
               5                      "       secondary Moller electron, ap is the lower
               5                      "       threshold for creation of a brem.)
               5                      tstep = vacdst;
               5                      sig0 = 1.E-15;
               5                  ]
               4                  ELSE
               4                  [
               5                      $CALCULATE-TSTEP-FROM-DEMFP;
               5                  ] "end sig if-else
               4
               4                  "calculate stopping power"
               4                  IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
               4                  ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
               4                  dedx  = rhof*dedx0;
               4
               4                  "Determine maximum step-size (Formerly $SET-TUSTEP)
               4                  $EVALUATE tmxs USING tmxs(elke);
               4                  tmxs = tmxs/rhof;
               4
               4                  "Compute the range to E_min(medium) (e_min is the first
               4                  "energy in the table). Do not go more than range.
               4                  "Don't replace this macro and don't override range, because
               4                  "the energy loss evaluation below relies on the accurate
               4                  "(and self-consistent) evaluation of range!
               4                  $COMPUTE-RANGE;
               4
               4                  "The RANDOMIZE-TUSTEP option as coded by AFB forced the
               4                  "electrons to approach discrete events (Moller,brems etc.)
               4                  "only in a single scattering mode => waste of CPU time.
               4                  "Moved here and changed by IK Oct 22 1997
               4                  random_tustep = $RANDOMIZE-TUSTEP;
               4                  IF(random_tustep)
               4                  [
               5                      $RANDOMSET rnnotu;
               5                      tmxs = rnnotu*min(tmxs,smaxir(irl));
               5                  ]
               4                  ELSE
               4                  [
               5                      tmxs = min(tmxs,smaxir(irl));
               5                  ]
               4                  tustep = min(tstep,tmxs,range);
               4                  $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field
               4
               4                  $CALL-HOWNEAR(tperp);
               4                  dnear(np) = tperp;
               4                  $RANGE-DISCARD;       "optional regional range rejection for"
               4                                        "particles below e_max_rr if i_do_rr set"
               4
               4                  $USER-RANGE-DISCARD;  "default is ;, but user may implement"
               4
               4                  $SET-SKINDEPTH(eke,elke);
               4                    "This macro sets the minimum step size for a condensed"
               4                    "history (CH) step. When the exact BCA is used, the minimum"
               4                    "CH step is determined by efficiency considerations only"
               4                    "At about 3 elastic MFP's single scattering becomes more"
               4                    "efficient than CH and so the algorithm switches off CH"
               4                    "If one of the various inexact BCA's is invoked, this macro"
               4                    "provides a simple way to include more sophisticated"
               4                    "decisions about the maximum acceptable approximated CH step"
               4
               4                  tustep = min(tustep,max(tperp,skindepth));
               4                  $EMFIELD_INITIATE_SET_TUSTEP;
               4                  "The transport logic below is determined by the logical
               4                  "variables callhhowfar, domultiple and dosingle
               4                  "
               4                  "There are the following possibilities:
               4                  "
               4                  "   callhowfar = .false.  This indicates that the
               4                  "   ====================  intended step is shorter than tperp
               4                  "                         independent of BCA used
               4                  "  - domultiple = .false. dosingle = .false. and
               4                  "                         callmsdist = .true.
               4                  "       ==> everything has been done in msdist
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only if exact_bca = .false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only if exact_bca = .true.
               4                  "           sampled distance to a single scattering event is
               4                  "           shorter than tperp ==> do single scattering at the
               4                  "           end of the step
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4                  "
               4                  "   callhowfar = .true. This indicates that the intended step
               4                  "   =================== is longer than tperp and forces a
               4                  "                       call to hawfar which returns the
               4                  "                       straight line distance to the boundary
               4                  "                       in the initial direction of motion
               4                  "                       (via a modification of ustep)
               4                  "  - domultiple = .false. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           simply put the particle on the boundary
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           single elastic scattering has to be done
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4
               4                  "IF(tustep <= tperp & tustep > skindepth)"
               4                  "This statement changed to be consistent with PRESTA-I"
               4                  count_all_steps = count_all_steps + 1;
               4                  is_ch_step = .false.;
               4                  IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
               4                  [
               5                      "We are further way from a boundary than a skindepth, so
               5                      "perform a normal condensed-history step
               5                      callhowfar = .false.; "Do not call HAWFAR
               5                      domultiple = .false.; "Multiple scattering done here
               5                      dosingle   = .false.; "MS => no single scattering
               5                      callmsdist = .true.;  "Remember that msdist has been called
               5
               5                      "Fourth order technique for de
               5                      $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);
               5
               5                      tvstep = tustep; is_ch_step = .true.;
               5
               5                      IF (transport_algorithm = $PRESTA-II)
               5                      [
               6                        call msdist_pII
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                      ELSE
               5                      [
               6                        call msdist_pI
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "We are within a skindepth from a boundary, invoke
               5                      "one of the various boundary-crossing algorithms
               5                      callmsdist = .false.;
               5                           "Remember that msdist has not been called
               5                      IF (exact_bca)
               5                      [
               6                          "Cross the boundary in a single scattering mode
               6                          domultiple = .false.; "Do not do multiple scattering
               6                          "Sample the distance to a single scattering event
               6                          $RANDOMSET rnnoss;
               6                          IF( rnnoss < 1.e-30 ) [
               7                              rnnoss = 1.e-30;
               7                          ]
               6                          lambda = - Log(1 - rnnoss);
               6                          lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
               6                          IF( lambda >= 0 & lambda_max > 0 ) [
               7                              IF( lambda < lambda_max ) [
               8                                  tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
               8                              ]
               7                              ELSE [
               8                                tuss = 0.5 * lambda * ssmfp;
               8                              ]
               7                              IF (tuss < tustep) [
               8                                  tustep = tuss;
               8                                  dosingle = .true.;
               8                              ]
               7                              ELSE [
               8                                  dosingle = .false.;
               8                              ]
               7                          ]
               6                          ELSE [
               7                            $egs_warning(*,' lambda > lambda_max: ',
               7                               lambda,lambda_max,' eke dedx: ',eke,dedx,
               7                               ' ir medium blcc: ',ir(np),medium,blcc(medium),
               7                               ' position = ',x(np),y(np),z(np));
               7                            dosingle = .false.;
               7                            np=np-1; return;
               7                          ]
               6                          ustep = tustep;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Boundary crossing a la EGS4/PRESTA-I but using
               6                          "exact PLC
               6                          dosingle = .false.;
               6                          domultiple = .true.;
               6                          $SET-USTEP;
               6                      ]
               5                      IF(ustep < tperp)
               5                      [
               6                          callhowfar = .false.;
               6                      ]
               5                      ELSE
               5                      [
               6                          callhowfar = .true.;
               6                      ]
               5                  ]
               4              ] "end non-vacuum test
               3
               3              $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
               3                                    "default for $SET-USTEP-EM-FIELD; is ;(null)
               3              irold  = ir(np); "save current region
               3              irnew  = ir(np); "default new region is current region
               3              idisc  = 0; "default is no discard (this flag is initialized here)
               3              ustep0 = ustep; "Save the intended ustep."
               3
               3              "IF(callhowfar) [ call howfar; ]"
               3              $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"
               3
               3              "Now see if user requested discard
               3              IF(idisc > 0) "(idisc is returned by howfar)
               3              [
               4                  "User requested immediate discard
               4                  go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              $CHECK-NEGATIVE-USTEP;
               3
               3              IF(ustep = 0 | medium = 0)
               3              [
               4                  "Do fast step in vacuum
               4                  IF(ustep ~= 0)
               4                  [
               5                      IF $EM_MACROS_ACTIVE
               5                      [
               6                          edep = pzero; "no energy loss in vacuum
               6                          "transport in EMF in vacuum:"
               6                          "only a B or and E field can be active"
               6                          "(not both at the same time)"
               6                          $EMFieldInVacuum;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Step in vacuum
               6                          vstep  = ustep;
               6                          tvstep = vstep;
               6                          "( vstep is ustep truncated (possibly) by howfar
               6                          " tvstep is the total curved path associated with vstep)
               6                          edep = pzero; "no energy loss in vacuum
               6                          $VACUUM-ADD-WORK-EM-FIELD;
               6                              "additional vacuum transport in em field
               6                          e_range = vacdst;
               6                          $AUSCALL($TRANAUSB);
               6                          "Transport the particle
               6                          x(np) = x(np) + u(np)*vstep;
               6                          y(np) = y(np) + v(np)*vstep;
               6                          z(np) = z(np) + w(np)*vstep;
               6                          dnear(np) = dnear(np) - vstep;
               6                              "(dnear is distance to the nearest boundary
               6                              " that goes along with particle stack and
               6                              " which the user's howfar can supply (option)
               6                          $SET-ANGLES-EM-FIELD;
               6                              "default for $SET-ANGLES-EM-FIELD; is ; (null)
               6                               "(allows for EM field deflection
               6                      ] "end of EM_MACROS_ACTIVE block"
               5                  ] "end of vacuum step
               4
               4                  IF(irnew ~= irold) [ $electron_region_change; ];
               4
               4                  IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
               4                  IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               4                  IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
               4                  NEXT :TSTEP: ; "(Start again at :TSTEP:)
               4
               4              ] "Go try another big step in (possibly) new medium
               3
               3              vstep = ustep;
               3              $EM_FIELD_SS;
               3              IF(callhowfar)
               3              [
               4                  IF(exact_bca)
               4                  [
               5                      "If callhowfar=.true. and exact_bca=.true. we are"
               5                      "in a single scattering mode"
               5                      tvstep = vstep;
               5                      IF(tvstep ~= tustep)
               5                      [
               6                         "Boundary was crossed. Shut off single scattering"
               6                          dosingle = .false.;
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "callhowfar=.true. and exact_bca=.false."
               5                      "=>we are doing an approximate CH step"
               5                      "calculate the average curved path-length corresponding"
               5                      "to vstep"
               5                      $SET-TVSTEP;
               5                  ]
               4                  "Fourth order technique for dedx
               4                  "Must be done for an approx. CH step or a
               4                  "single scattering step.
               4                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               4              ]
               3              ELSE
               3              [
               4                 "callhowfar=.false. => step has not been reduced due to
               4                 "                      boundaries
               4                 tvstep = tustep;
               4                 IF ( ~callmsdist )
               4                 [
               5                    "Second order technique for dedx
               5                    "Already done in a normal CH step with call to msdist
               5                    $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               5                 ]
               4              ]
               3
               3              $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
               3                  "( Calculates tvstep given vstep
               3                  " default for $SET-TVSTEP-EM-FIELD; is ; (null)
               3
               3              save_de = de;     "the energy loss is used to calculate the number
               3                                "of MFP gone up to now. If energy loss
               3                                "fluctuations are implemented, de will be
               3                                "changed in $DE-FLUCTUATION; => save
               3
               3              "The following macro template allows the user to change the
               3              "ionization loss.
               3              "(Provides a user hook for Landau/Vavilov processes)
               3              $DE-FLUCTUATION;
               3                  "default for $DE-FLUCTUATION; is ; (null)
               3              edep = de; "energy deposition variable for user
               3              $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
               3              $ADD_WORK_EM_FIELD;  "EEMF implementation"
               3                  "Default for $ADD-WORK-EM-FIELD; is ; (null)
               3              ekef = eke - de;  "(final kinetic energy)
               3              eold = eie;       "save old value
               3              enew = eold - de; "energy at end of transport
               3
               3              "Now do multiple scattering
               3              IF ( ~callmsdist )   "everything done if callmsdist = .true.
               3              [
               4                  IF ( domultiple )
               4                  [
               5                      "Approximated CH step => do multiple scattering
               5                      "
               5                      "ekems, elkems, beta2 have been set in either $SET-TUSTEP
               5                      "or $SET-TVSTEP if spin_effects is .true., they are
               5                      "not needed if spin_effects is .false.
               5                      "
               5                      "chia2,etap,xi,xi_corr are also set in the above macros
               5                      "
               5                      "qel (0 for e-, 1 for e+) and medium are now also required
               5                      "(for the spin rejection loop)
               5                      "
               5                      lambda = blccl*tvstep/beta2/etap/(1+chia2);
               5                      xi = xi/xi_corr;
               5                      findindex = .true.; spin_index = .true.;
               5                      call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
               5                                 spin_effects,findindex,spin_index,
               5                                 costhe,sinthe);
               5                  ]
               4                  ELSE
               4                  [
               5                      IF(dosingle)
               5                      [
               6                         "Single scattering
               6
               6                         ekems = Max(ekef,ecut(irl)-rm);
               6                         p2 = ekems*(ekems + rmt2);
               6                         beta2 = p2/(p2 + rmsq);
               6                         chia2 = xcc(medium)/(4*blcc(medium)*p2);
               6                         IF( spin_effects ) [
               7                           elkems = Log(ekems);
               7                           $SET INTERVAL elkems,eke;
               7                           IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
               7                           ELSE          [$EVALUATE etap USING etap_ms(elkems);]
               7                           chia2 = chia2*etap;
               7                         ]
               6                         call sscat(chia2,elkems,beta2,qel,medium,
               6                                    spin_effects,costhe,sinthe);
               6                      ]
               5                      ELSE
               5                      [
               6                         theta  = 0; "No deflection in single scattering model
               6                         sinthe = 0;
               6                         costhe = 1;
               6                      ]
               5                  ]
               4              ]
               3
               3              "We now know distance and amount of energy loss for this step,
               3              "and the angle by which the electron will be scattered. Hence,
               3              "it is time to call the user and inform him of this transport,
               3              "after which we will do it.
               3
               3              "Now transport, deduct energy loss, and do multiple scatter.
               3              e_range = range;
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3              IF( callmsdist ) [
               4                 "Deflection and scattering have been calculated/sampled in msdist
               4                  u_final = uscat;
               4                  v_final = vscat;
               4                  w_final = wscat;
               4                  x_final = xtrans;
               4                  y_final = ytrans;
               4                  z_final = ztrans;
               4              ]
               3              ELSE
               3              [
               4                  IF ~($EM_MACROS_ACTIVE)
               4                  [
               5                      x_final = x(np) + u(np)*vstep;
               5                      y_final = y(np) + v(np)*vstep;
               5                      z_final = z(np) + w(np)*vstep;
               5                  ]
               4
               4                  IF ( domultiple | dosingle )
               4                  [
               5                      u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
               5                      call uphi(2,1); "Apply the deflection, save call to uphi if
               5                                      "no deflection in a single scattering mode
               5                      u_final = u(np); v_final = v(np); w_final = w(np);
               5                      u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
               5                  ]
               4                  ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
               4              ]
               3
               3              $AUSCALL($TRANAUSB);
               3
               3              "Transport the particle
               3
               3              x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3              u(np) = u_final; v(np) = v_final; w(np) = w_final;
               3
               3              dnear(np) = dnear(np) - vstep;
               3              irold = ir(np); "save previous region
               3              $SET-ANGLES-EM-FIELD;
               3              "Default for $SET-ANGLES-EM-FIELD; is ; (null)
               3
               3
               3              "Now done with multiple scattering,
               3              "update energy and see if below cut
               3              "below subtracts only energy deposited"
               3              peie  = peie - edep;
               3              "below subtracts energy deposited + work due to E field"
               3              "peie = peie - de;"
               3              eie   = peie;
               3              e(np) = peie;
               3
               3              "IF( irnew ~= irl & eie <= ecut(irl)) [
               3              "IK: the above is clearly a bug. If the particle energy falls "
               3              "    below ecut, but the particle is actually entering a new "
               3              "    region, the discard will happen in the current region "
               3              "    instead the next. If the particle is a positron, all "
               3              "    resulting annihilation photons will have the new position "
               3              "    but the old region => confusion in the geometry routine "
               3              "    is very likely.      Jan 27 2004 "
               3              IF( irnew = irl & eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              medold = medium;
               3              IF(medium ~= 0)
               3              [
               4                  ekeold = eke; eke = eie - rm; "update kinetic energy
               4                  elke   = log(eke);
               4                  $SET INTERVAL elke,eke; "Get updated interval
               4              ]
               3
               3              IF(irnew ~= irold) [ $electron_region_change; ]
               3
               3              "After transport call to user scoring routine
               3              $AUSCALL($TRANAUSA);
               3
               3              IF(eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              "Now check for deferred discard request.  May have been set
               3              "by either howfar, or one of the transport ausgab calls
               3              IF(idisc < 0) [
               4                go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              IF(medium ~= medold) NEXT :TSTEP:;
               3
               3              $USER_CONTROLS_TSTEP_RECURSION;
               3                  "NRCC update 87/12/08--default is null
               3
               3              $UPDATE-DEMFP;
               3
               3          ] UNTIL(demfp < $EPSEMFP); "end ustep loop
               2
               2          "Compute final sigma to see if resample is needed.
               2          "this will take the energy variation of the sigma into
               2          "account using the fictitious sigma method.
               2
               2          $EVALUATE-SIGF;
               2
               2          sigratio = sigf/sig0;
               2
               2          $RANDOMSET rfict;
               2
               2      ] UNTIL (rfict <= sigratio) ; "end tstep loop
               1
               1      " Now sample electron interaction
               1
               1      IF(lelec < 0)
               1      [
               2          "e-,check branching ratio
               2          $EVALUATE-EBREM-FRACTION;
               2            "Default is $EVALUATE ebr1 USING ebr1(elke);"
               2          $RANDOMSET rnno24;
               2          IF(rnno24 <= ebr1)
               2          [
               3              "It was bremsstrahlung
               3              go to :EBREMS:;
               3          ]
               2          ELSE
               2          [
               3              "It was Moller, but first check the kinematics.
               3              "However, if EII is on, we should still permit an interaction
               3              "even if E<moller threshold as EII interactions go down to
               3              "the ionization threshold which may be less than thmoll.
               3              IF(e(np) <= thmoll(medium) & eii_flag = 0)
               3                   "(thmoll = lower Moller threshold)
               3              [
               4                  "Not enough energy for Moller, so
               4                  "force it to be a bremsstrahlung---provided ok kinematically.
               4                  IF(ebr1 <= 0) [go to :NEWELECTRON:;]
               4                      "Brems not allowed either.
               4                  go to :EBREMS:;
               4              ]
               3              $AUSCALL($MOLLAUSB);
               3              call moller;
               3              "The following macro template allows the user to change the
               3              "particle selection scheme (e.g., adding importance sampling
               3              "such as splitting, leading particle selection, etc.).
               3              "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
               3              "which in turn has the 'null' replacement ';')
               3              $PARTICLE-SELECTION-MOLLER;
               3              $AUSCALL($MOLLAUSA);
               3              IF( iq(np) = 0 ) return;
               3          ]
               2
               2          go to :NEWELECTRON:; "Electron is lowest energy-follow it
               2      ]
               1
               1      "e+ interaction. pbr1 = brems/(brems + bhabha + annih
               1      $EVALUATE-PBREM-FRACTION;
               1         "Default is $EVALUATE pbr1 USING pbr1(elke);"
               1      $RANDOMSET rnno25;
               1      IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
               1      "Decide between bhabha and annihilation
               1      "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
               1      $EVALUATE-BHABHA-FRACTION;
               1         "Default is $EVALUATE pbr2 USING pbr2(elke);"
               1      IF(rnno25 < pbr2)
               1      [
               2          "It is bhabha
               2          $AUSCALL($BHABAUSB);
               2          call bhabha;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-BHABHA;
               2          $AUSCALL($BHABAUSA);
               2          IF( iq(np) = 0 ) return;
               2      ]
               1      ELSE
               1      [
               2          "It is in-flight annihilation
               2          $AUSCALL($ANNIHFAUSB);
               2          call annih;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-ANNIH;
               2          $AUSCALL($ANNIHFAUSA);
               2          EXIT :NEWELECTRON:; "i.e., in order to return to shower
               2          "After annihilation the gammas are bound to be the lowest energy
               2          "particles, so return and follow them.
               2      ] "end pbr2 else
               1
               1  ] REPEAT "newelectron
               0
               0  return; "i.e., return to shower
               0
               0
               0  "---------------------------------------------
               0  "Bremsstrahlung-call section
               0  "---------------------------------------------
               0  :EBREMS:
               0  $AUSCALL($BREMAUSB);
               0  call brems;
               0  "The following macro template allows the user to change the particle
               0  "selection scheme (e.g., adding importance sampling such as splitting,
               0  "leading particle selection, etc.).  (default macro is template
               0  "'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
               0  $PARTICLE-SELECTION-BREMS;
               0  $AUSCALL($BREMAUSA);
               0  IF(iq(np) = 0)
               0  [
               1      "Photon was selected.
               1      return;
               1      "i.e., return to shower
               1  ]
               0  ELSE
               0  [
               1      "Electron was selected
               1      go to :NEWELECTRON:;
               1  ]
               0
               0  "---------------------------------------------
               0  "Electron cutoff energy discard section
               0  "---------------------------------------------
               0  :ECUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(eie > ae(medium)) [
               2          idr = $EGSCUTAUS;
               2          IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
               2      ]
               1      ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
               1  ] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]
               0
               0
               0  $ELECTRON-TRACK-END; "The default replacement for this macros is "
               0                       "          $AUSCALL(idr);                   "
               0                       "Use this macro if you wish to modify the   "
               0                       "treatment of track ends                    "
               0
               0  :POSITRON-ANNIHILATION:; "NRCC extension 86/9/12
               0
               0  IF(lelec > 0) [
               1      "It's a positron. Produce annihilation gammas if edep < peie
               1      IF(edep < peie) [
               2          $AUSCALL($ANNIHRAUSB);
               2          call annih_at_rest;
               2          $PARTICLE-SELECTION-ANNIHREST;
               2          $AUSCALL($ANNIHRAUSA);
               2          "Now discard the positron and take normal return to follow
               2          "the annihilation gammas.
               2          return; "i.e., return to shower
               2      ]
               1  ] "end of positron block
               0
               0  np = np - 1;
               0  ircode = 2; "tell shower an e- or un-annihilated
               0              "e+ has been discarded
               0
               0  return; "i.e., return to shower"
               0
               0  "---------------------------------------------
               0  "User requested electron discard section
               0  "---------------------------------------------
               0  :USER-ELECTRON-DISCARD:
               0
               0  idisc = abs(idisc);
               0
               0  IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
               0  ELSE                          [edep = e(np) + prm;]
               0
               0  $AUSCALL($USERDAUS);
               0
               0  IF(idisc = 99) goto :POSITRON-ANNIHILATION:;
               0
               0  np = np - 1; ircode = 2;
               0
               0  return; "i.e., return to shower
               0  end;    "End of subroutine electr
               0  "*******************************************************************************
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE HATCH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Setup which the user is expected to do before calling HATCH is:"
               0  "     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
               0  "     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
               0  "        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
               0  "        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
               0  "        THE IM'TH MEDIUM IN A1 FORMAT."
               0  "     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
               0  "        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
               0  "        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
               0  "        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
               0  "     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
               0  "        REGIONS."
               0  "     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
               0  "        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
               0  "        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
               0  "        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
               0  "     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
               0  "        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
               0  "     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
               0  "        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
               0  "
               0  "   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
               0  "   The echo to unit 8 has been removed since it is sent"
               0  "                                          to /dev/null anyway!"
               0  "           To put it back search $UOUTPUT  and $ECHO and uncomment"
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  character*512 toUpper;
               0  $COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
               0                        "ELECIN,MEDIA,MISC,PHOTIN,STACK,
               0                        "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;
               0
               0  $DECLARE-PEGS4-COMMON-BLOCKS;
               0
               0  $DEFINE-LOCAL-VARIABLES-HATCH;
               0
               0  character*256 tmp_string;
               0  $INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
               0                        " support this"
               0
               0  DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
               0  DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;
               0
               0  $INIT-PEGS4-VARIABLES;
               0
               0  "   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
               0  :INT:FORMAT(1X,14I5);
               0  :FLT:FORMAT(1X,1PE14.5,4E14.5);
               0  :BYTE:FORMAT(72A1);
               0
               0  IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
               1  "   DO FIRST TIME INITIALIZATION"
               1
               1  $HATCH-USER-INPUT-INIT;
               1
               1  "   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
               1  "   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
               1  "   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
               1  "   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
               1  "   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
               1  "   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
               1  "   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
               1  "   FOR GOOD MEASURE."
               1  NISUB=MXSINC-2;FNSSS=NSINSS;
               1  WID=PI5D2/FLOAT(NISUB);
               1  WSS=WID/(FNSSS-1.0);
               1  ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;
               1
               1  DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
               2  SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"
               2
               2  XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
               2  "   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
               2  IZ=0; DO IZZ=1,3 [
               3  IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
               3  ] "END OF LOOP OVER ZEROS"
               2  IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
               2  DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
               3  XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
               3  YS=SIN(XS+XSI); "SINE OF ANGLE"
               3  SX=SX+XS; "ACCUMULATE SUMS"
               3  SY=SY+YS;
               3  SXX=SXX+XS*XS;
               3  SXY=SXY+XS*YS;
               3  ] "END SUB-SUBINTERVAL LOOP"
               2
               2  "   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
               2  IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
               3  "             FOR SMALL REL.ERR.&GOOD"
               3  "   VALUES OF SINTHE/THETA NEAR ZERO"
               3  SIN1(ISUB)=SXY/SXX;
               3  SIN0(ISUB)=-SIN1(ISUB)*XSI;]
               2  ELSE["DO FULL LEAST SQUARES"
               3  DEL=FNSSS*SXX-SX*SX;
               3  SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
               3  SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
               2  ] "END SUB-INTERVAL LOOP"
               1
               1  SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
               1  SINC1=1.0/WID;
               1
               1  "   NOW TEST FIT, IF REQUESTED"
               1  IF (ISTEST.NE.0)[
               2  "   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
               2  "   END SUBINTERVALS"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
               4  THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
               4  CTHET=PI5D2-THETA;
               4  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               4  $EVALUATE SINTHE USING SIN(THETA);
               4  $EVALUATE COSTHE USING SIN(CTHET);
               4  SINT=SIN(THETA); COST=COS(THETA);
               4  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               4  ADEV=max(ADEV,ASD,ACD);
               4  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               4  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               4  S2C2=SINTHE**2+COSTHE**2;
               4  S2C2MN=min(S2C2MN,S2C2);
               4  S2C2MX=max(S2C2MX,S2C2);
               4  IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
               4  ] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
               2  $egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
               2  $egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                   ADEV,RDEV,S2C2MN,S2C2MX);
               2  "   NOW DO RANDOM TEST"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
               3  CTHET=PI5D2-THETA;
               3  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               3  $EVALUATE SINTHE USING SIN(THETA);
               3  $EVALUATE COSTHE USING SIN(CTHET);
               3  SINT=SIN(THETA); COST=COS(THETA);
               3  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               3  ADEV=max(ADEV,ASD,ACD);
               3  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               3  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               3  S2C2=SINTHE**2+COSTHE**2;
               3  S2C2MN=min(S2C2MN,S2C2);
               3  S2C2MX=max(S2C2MX,S2C2);
               3  ] "END RANDOM ANGLE LOOP"
               2  $egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
               2  $egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                 ADEV,RDEV,S2C2MN,S2C2MX);
               2  ] "END OF SINE TABLE TEST"
               1
               1  "   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
               1  P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]
               1
               1  ] "END OF FIRST TIME INITIALIZATION"
               0
               0  "FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
               0  $need_rayleigh_data;
               0
               0  "Ali:photonuc, 2 lines"
               0  "FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
               0  $need_photonuc_data;
               0  $egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);
               0
               0  "   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
               0  IF(~is_pegsless) REWIND KMPI;
               0  "explicit file name for HP compiler  Nov 23, 1996   DR"
               0  IUECHO=KMPO;
               0  NM=0; "NUMBER OF MEDIA FOUND"
               0  DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
               1    "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
               1    IF(IRAYLM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  "Ali:photonuc, 1 block"
               0  DO IM=1,NMED [
               1    "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
               1    IF(IPHOTONUCM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  IF(~is_pegsless)[
               1  :MEDIUM:
               1  LOOP["MEDIUM SEARCH LOOP"
               2
               2  :MDLOOK:
               2  LOOP["MEDIUM HEADER SEARCH LOOP"
               3    "   FIRST LOOK FOR MEDIUM HEADER"
               3    READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
               3    DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
               3    "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
               3    :MDNAME:
               3    DO IM=1,NMED [
               4      DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
               5      IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
               4    ] "END :MDNAME: DO"
               3    "   NOT IN NAME TABLE, SO IGNORE IT"
               3  ]REPEAT "MDLOOK"
               2
               2  "   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
               2  IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
               2  LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"
               2
               2  "   NOW READY TO READ IN DATA FOR THIS MEDIUM"
               2  "$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"
               2
               2  "   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
               2  "THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  "The next two lines were line prior to Dec 89 mods to get IUNRST"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,5X,F11.0,4X,I2);"
               2  "following used to pick up IUNRST, IAPRIM and EPSTFL"
               2  "Problem is that GASP may or may not be printed, so we make"
               2  "a kludge which will work with all old data files"
               2  "FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
               2  "Note that this reading scheme counts on there being an"
               2  "error when GASP does exist on the line--an error does"
               2  "occur on most compilers, however, we have found that on"
               2  "the rs6000 an error does not occur.  Instead, a warning"
               2  "is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
               2  "This will make no difference in simulations but will cause"
               2  "a problem when running EXAMIN"
               2
               2  " IK: backspace(kmpi) fails under windows using g77 with I/O error"
               2  "     therefore we read the line in a temporary string and then "
               2  "     use memoty I/O to try to read with and without gasp there. "
               2
               2  read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
               2  goto :no_hatch_read_error1:;
               2  :hatch_read_error1:
               2  $egs_fatal(*,'Error while reading pegs4 file');
               2
               2  :no_hatch_read_error1:;
               2  read(tmp_string,1,ERR=:GASP-THERE:)
               2  "READ(KMPI,1,ERR=:GASP-THERE:)"
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
               2  1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
               2  "IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
               2  GO TO :GASP-NOT-THERE:;
               2
               2  :GASP-THERE:;
               2  "WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
               2  "BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
               2  "READ(KMPI,2)"
               2
               2  "The following output is only there because without it"
               2  "code compiled with the new gfortran GNU compiler "
               2  "fails with run time error. Another bug in their "
               2  "pre-alpha quality I/O system ----IK, Oct 26 2005 "
               2  "write(6,*) 'Found medium with gas pressure';"
               2  $egs_info(*,'Found medium with gas pressure');
               2  read(tmp_string,2)
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
               2  IAPRIM(IM);
               2  2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);
               2
               2  :GASP-NOT-THERE:
               2
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  ";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "DO IE=1,NE["
               2  DO IE=1,NNE(IM)[
               3      "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
               3      "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
               3      "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
               3      "IN COMMON BREMPR. AFB 88/05/31.                                  "
               3      "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
               3      $UINPUT(KMPI)
               3      (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
               3      ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
               3      (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
               3      "$UOUTPUT(KMPO)"
               3      "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
               3      "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
               3      "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
               3      ]
               2
               2  "   MEDIA AND THRESH"
               2  "$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
               2  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
               2
               2  "   ACTUAL ARRAY SIZES FROM PEGS"
               2  "$ECHO" READ(KMPI,:INT:)
               2  $LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
               2  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
               2  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
               2
               2  "   BREMPR"
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
               2  "$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
               2     DELPOS(I,IM)),I=1,2);
               2
               2  "   ELECIN"
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)
               2  ($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
               2     TMXS(I,IM)/0,1/),I=1,NEKE);
               2
               2  "   PHOTIN"
               2  "$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);
               2
               2  "   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"
               2
               2
               2  IF (IRAYL.EQ.1) [
               3  "$ECHO" READ(KMPI,:INT:) NGR(IM);
               3  NGRIM=NGR(IM);
               3  "$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
               3   "IF(IRAYLM(IM).NE.1) ["
               3   $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
               3            IM, ' in PEGS4 data set.');
               3   "]"
               3  ]
               2
               2
               2
               2
               2
               2  IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
               3    IF(IRAYL.NE.1) ["No data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["Rayleigh not possible"
               5       $egs_fatal('(a,i3 /,a /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
               5       ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
               5      ]
               4      ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
               5       $egs_warning('(a,i3 /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
               5      ]
               4    ]
               3   ELSE["Rayleigh data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["PEGS4 data selected"
               5        "***********************************************************"
               5        "Preparing data for new Rayleigh angular sampling when using"
               5        "the pegs4 data set,                                        "
               5        "***********************************************************"
               5         call egs_init_rayleigh_sampling(IM);
               5      ]
               4      "ELSE[Taking photon data from either si,epdl,xcom or user]"
               4    ]
               3  ]
               2
               2
               2  "   THAT'S ALL FOR THIS MEDIUM"
               2  ]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"
               1
               1  CLOSE (UNIT=KMPI);
               1
               1  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
               1  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
               1  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
               1  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
               1  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
               1  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
               1  DUNITR=DUNIT; "SAVE REQUESTED"
               1  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
               2     DUNIT=RLC(ID);]
               1  IF(DUNIT.NE.1.0) [
               2  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
               2           DUNITR,DUNIT,'(CM.)' );
               2  ]
               1  DO IM=1,NMED [
               2  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
               2  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
               2
               2  FOR I=1 TO MEKE(IM) [
               3  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
               3  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
               2  $SCALE TEFF0(IM) BY DFACT;
               2  $SCALE BLCC(IM) BY DFACTI;
               2  $SCALE XCC(IM) BY SQRT(DFACTI);
               2  RLDU(IM)=RLC(IM)/DUNIT;
               2  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
               2  ] "END IM DO"
               1
               1  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
               1  VACDST=VACDST*DUNITO/DUNIT;
               1  DUNITO=DUNIT; "SAVE OLD DUNIT"
               1
               1  ]"end regular pegs4 intake"
               0  ELSE["pegsless intake of medium data"
               1
               1  $egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');
               1
               1  $GET-PEGSLESS-XSECTIONS;
               1
               1  ]
               0
               0  "   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
               0  "   ALSO SET DEFAULT DENSITIES"
               0  $adjust_rhor_ecut_pcut;
               0
               0  "BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 88/05/31"
               0  $INITIALIZE-BREMS-ANGLE;
               0
               0  "PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 91/05/29"
               0  $INITIALIZE-PAIR-ANGLE;
               0
               0  " See if user has requested PEGS4 photon cross section data "
               0  IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
               1    $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
               1    'However, the new Rayleigh angular sampling will be used.',
               1    'The original EGS4 angular sampling undersamples large scattering ',
               1    'angles. This may have little impact as Rayleigh scattering ',
               1    'is forward peaked.',
               1    '*********************************************************');
               1
               1  ]
               0  ELSE["re-calculates photon xsections using available or user data"
               1  "Ali:photonuc, 2 lines"
               1      call egs_init_user_photon(photon_xsections,comp_xsections,
               1      photonuc_xsections,xsec_out);
               1  "    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
               1  ]
               0
               0  call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"
               0
               0  "Calling order of the subroutines below is important when using"
               0  "detailed atomic relaxation in order to use the binding energies"
               0  "corresponding to the requested photon cross section library"
               0  IF ( eadl_relax & photon_xsections = 'xcom' )[
               1     call init_compton; "Initialize bound Compton scattering"
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
               1  ]
               0  ELSE[
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
               1                        "if requested
               1     call init_compton; "Initialize bound compton scattering, IK, Jan 99"
               1                        "if requested
               1  ]
               0
               0  IF( xsec_out = 1 & eadl_relax) [
               1    call egs_print_binding_energies;
               1  ]
               0
               0  call fix_brems;    "Re-calculate dl1,... for the different technique"
               0                     "employed in BREMS. Note that the old EGS sampling"
               0                     "technique for BREMS had a bug that shows up only"
               0                     "if AP is not much smaller than electron kinetic energy"
               0
               0  IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
               0                     "initializes the sampling tables and modifies the total"
               0                     "brems cross sections if the NIST brems data base is to"
               0                     "be used                                               "
               0
               0  IF( pair_nrc = 1 ) [ call init_nrc_pair; ]
               0
               0  " Load and initialize EII data if needed. "
               0  call eii_init;
               0
               0  " Load and initialize the triplet data if needed "
               0  call init_triplet;
               0
               0  "   SETUP IS NOW COMPLETE"
               0  IF (NMED.EQ.1)[
               1     $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
               1  ]
               0  ELSE[
               1     $egs_info('(a,i5,a)',
               1               'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
               1  ]
               0
               0  RETURN;
               0
               0  :MDNOMORE:
               0  $egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
               0    ' PROGRAM STOPPED IN HATCH BECAUSE THE',
               0    ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
               0  DO IM=1,NMED [
               1     IF(LOK(IM).NE.1) [
               2        $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
               2     ]
               1  ]
               0  STOP;
               0  "END OF SUBROUTINE HATCH"   END;
               0
               0  subroutine fix_brems;
               0  "******************************************************************"
               0  "
               0  " Calculates the parameter for the rejection function used in
               0  " the current implementation of bremsstrahlung sampling
               0  "
               0  " I Kawrakow, January 2000
               0  "
               0  "*******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;
               0
               0  $INTEGER medium,i;
               0  $REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
               0           XSIF,FCOULC;
               0
               0  DO medium = 1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      Zt = 0; Zb = 0; Zf = 0;
               1      DO i=1, NNE(medium) [
               2          Zi = ZELEM(medium,i); pi = PZ(medium,i);
               2          fc = FCOULC(Zi); xi = XSIF(Zi);
               2          aux = pi*Zi*(Zi + xi);
               2          Zt = Zt + aux;
               2          Zb = Zb - aux*Log(Zi)/3;
               2          Zf = Zf + aux*fc;
               2      ]
               1      Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
               1      fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
               1      fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;
               1
               1      "These are used in BREMS"
               1      dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
               1      dl2(1,medium) = -3.242/fmax1;
               1      dl3(1,medium) = 0.625/fmax1;
               1      dl4(1,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(1,medium) = -4.184/fmax1;
               1      dl6(1,medium) = 0.952;
               1      dl1(2,medium) = (20.029+4*Zg)/fmax1;
               1      dl2(2,medium) = -1.93/fmax1;
               1      dl3(2,medium) = -0.086/fmax1;
               1      dl4(2,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(2,medium) = -4.184/fmax1;
               1      dl6(2,medium) = 0.952;
               1      dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
               1      dl2(3,medium) = -3.242/fmax2;
               1      dl3(3,medium) = 0.625/fmax2;
               1      dl4(3,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(3,medium) = -4.184/fmax2;
               1      dl6(3,medium) = 0.952;
               1      dl1(4,medium) = (20.029+4*Zv)/fmax2;
               1      dl2(4,medium) = -1.93/fmax2;
               1      dl3(4,medium) = -0.086/fmax2;
               1      dl4(4,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(4,medium) = -4.184/fmax2;
               1      dl6(4,medium) = 0.952;
               1
               1      "and these in PAIR"
               1      dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
               1      dl2(5,medium) = (3*(-3.242) - (-1.930));
               1      dl3(5,medium) = (3*(0.625)-(-0.086));
               1      dl4(5,medium) = (2*21.12+8*Zg);
               1      dl5(5,medium) = (2*(-4.184));
               1      dl6(5,medium) = 0.952;
               1      dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
               1      dl2(6,medium) = (3*(-3.242) + (-1.930));
               1      dl3(6,medium) = (3*0.625+(-0.086));
               1      dl4(6,medium) = (4*21.12+16*Zg);
               1      dl5(6,medium) = (4*(-4.184));
               1      dl6(6,medium) = 0.952;
               1      dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
               1      dl2(7,medium) = (3*(-3.242) - (-1.930));
               1      dl3(7,medium) = (3*(0.625)-(-0.086));
               1      dl4(7,medium) = (2*21.12+8*Zv);
               1      dl5(7,medium) = (2*(-4.184));
               1      dl6(7,medium) = 0.952;
               1      dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
               1      dl2(8,medium) = (3*(-3.242) + (-1.930));
               1      dl3(8,medium) = (3*0.625+(-0.086));
               1      dl4(8,medium) = (4*21.12+16*Zv);
               1      dl5(8,medium) = (4*(-4.184));
               1      dl6(8,medium) = 0.952;
               1
               1      bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1      bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1
               1  ]
               0  return;
               0  end;
               0
               0
               0  $REAL function FCOULC(Z);
               0  "************************"
               0  $IMPLICIT-NONE;
               0  $REAL Z;
               0  $REAL fine,asq;
               0  data fine/137.03604/;
               0  asq = Z/fine; asq = asq*asq;
               0  FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
               0  return;
               0  end;
               0
               0  $REAL function XSIF(Z);
               0  "**********************"
               0  $IMPLICIT-NONE;
               0  $REAL    Z;
               0  $INTEGER iZ;
               0  $REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
               0  data     alrad/5.31,4.79,4.74,4.71/;
               0  data     alradp/6.144,5.621,5.805,5.924/;
               0  data     a1440/1194.0/,A183/184.15/;
               0  IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
               0  ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  subroutine init_compton;
               0  "
               0  "  Reads in bound Compton scattering data from unit $INCOHUNIT
               0  "  and performs necessary initializations
               0  "
               0  "  See definitions of variables in egsnrc.macros with definition
               0  "  of COMIN/COMPTON-DATA/
               0  "
               0  "  I.Kawrakow, January 99
               0  "******************************************************************"
               0
               0  implicit none;
               0
               0  $COMIN-INIT-COMPT;
               0
               0  $INTEGER i,j,iz,nsh,j_l,j_h;
               0  $REAL    aux,pztot,atav;
               0  $REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
               0                          "compiler don't have an intrinsic error function"
               0  $LOGICAL getd;
               0
               0  " Initialize radiative Compton corrections, if needed "
               0  $RADC_HATCH;
               0
               0  $need_bound_compton_data(getd);
               0  IF( ~getd ) [
               1      IF( eadl_relax & photon_xsections = 'xcom' )[
               2          $egs_fatal('(a,/a,/a)',
               2                     'You must turn ON Compton binding corrections when using',
               2                     'a detailed atomic relaxation (eadl_relax=true) since ',
               2                     'binding energies taken from incoh.data below 1 keV!');
               2      ]
               1      $egs_info('(a/)',' Bound Compton scattering not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
               0  rewind($INCOHUNIT);
               0  DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
               0  iz = 0;
               0  DO j=1,$MXTOTSH [
               1      read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
               1                         Jo_array(j),be_array(j);
               1      Jo_array(j) = Jo_array(j)*137.;
               1      be_array(j) = be_array(j)*1e-6/PRM;
               1      aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
               1      erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
               1                      "0.82436063535 is exp(0.5)/2"
               1
               1      "For detailed atomic relaxations set shell type
               1      "to actual shell number and update binding energies
               1      "with values from the photo-electric cross sections
               1      IF (eadl_relax)[
               2         IF (iz_array(j) ~= iz)[
               3            shn_array(j) = 1; iz = iz_array(j);
               3         ]
               2         ELSE[
               3            shn_array(j) = shn_array(j-1)+1;
               3         ]
               2         IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
               3           be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
               3         ]
               2         ELSE IF(photon_xsections = 'xcom') [
               3           "Use binding energies from incoh.data below 1 keV"
               3           binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
               3         ]
               2      ]
               1
               1  ]
               0  $egs_info(*,' Done');
               0  $egs_info('(/a)',' Initializing Bound Compton scattering ......');
               0  DO medium = 1,nmed [
               1      pztot = 0; nsh = 0;
               1      DO i = 1, nne(medium) [
               2          iz = int(zelem(medium,i));
               2          DO j = 1, $MXTOTSH [
               3              IF( iz = iz_array(j) ) [
               4                  nsh = nsh + 1;
               4                  IF( nsh > $MXMDSH ) [
               5                      $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
               5                                ' the number of shells is > ',$MXMDSH,'!',
               5                                ' Increase the parameter $MXMDSH! ');
               5                  ]
               4                  shell_array(nsh,medium) = j;
               4                  aux = pz(medium,i)*ne_array(j);
               4                  eno_array(nsh,medium) = aux;
               4                  pztot = pztot + aux;
               4              ]
               3          ]
               2      ]
               1      IF( nsh = 0 ) [
               2          $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
               2      ]
               1      n_shell(medium) = nsh;
               1      $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
               1      DO i=1,nsh [
               2          j = shell_array(i,medium);
               2          eno_array(i,medium) = eno_array(i,medium)/pztot;
               2          $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
               2                    i,j,shn_array(j),eno_array(i,medium),
               2                    Jo_array(j),be_array(j)*PRM*1000.);
               2          eno_array(i,medium) = -eno_array(i,medium);
               2          eno_atbin_array(i,medium) = i;
               2      ]
               1      atav = 1./nsh;
               1      DO i=1,nsh-1 [
               2          DO j_h = 1,nsh-1 [
               3              IF( eno_array(j_h,medium) < 0 ) [
               4                  IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
               4              ]
               3          ]
               2          DO j_l = 1,nsh-1 [
               3              IF( eno_array(j_l,medium) < 0 ) [
               4                  IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
               4              ]
               3          ]
               2          aux = atav - abs(eno_array(j_l,medium));
               2          eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
               2          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
               2          eno_atbin_array(j_l,medium) = j_h;
               2          IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
               2      ]
               1      DO i=1,nsh [
               2          IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
               2      ]
               1  ]
               0
               0  $egs_info('(a/)',' ...... Done.');
               0
               0  $need_relaxation_data(getd);
               0  IF( getd ) return;
               0  $egs_fatal('(/a,/a,/a,/a)',
               0  ' In subroutine init_compton: ',
               0  '   Scattering off bound electrons creates atomic vacancies,',
               0  '   potentially starting an atomic relaxation cascade. ',
               0  '   Please turn ON atomic relaxations.');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE MOLLER;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
               0  "   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
               0  "   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
               0  "   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
               0  "   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
               0  "   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
               0  "   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
               0  "   LOSS DURING TRANSPORT.                                         "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
               0                                            "UPHIOT,USEFUL,RANDOM/;"
               0  ;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;
               0
               0  $DEFINE-LOCAL-VARIABLES-MOLLER;
               0
               0  $REAL sigm,pbrem,rsh,Uj,sig_j;
               0  $INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;
               0
               0  "IRCODE=1;  appears to be unused, IK Oct 97"
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
               0  EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
               0  PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
               0  EKIN=PEKIN;
               0
               0  IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
               1      "The EII flag is set and this medium has shells for which we want to"
               1      "simulate EII => sample if the interaction is with a EII shell"
               1      $SET INTERVAL elke,eke;
               1      $EVALUATE sigm USING esig(elke);
               1      $EVALUATE pbrem USING ebr1(elke);
               1      sigm = sigm*(1 - pbrem);
               1      $RANDOMSET rsh; rsh = sigm*rsh;
               1      DO iele=1,nne(medium) [
               2          iZ = int(zelem(medium,iele)+0.5);
               2          nsh = eii_no(medium,iele);
               2          IF( nsh > 0 ) [
               3              ifirst = eii_first(medium,iele);
               3              DO ish = 1,nsh [
               4                  Uj = binding_energies(ish,iZ);
               4                  IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
               5                      jj = ifirst + ish - 1;
               5                      i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
               5                      sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
               5                      sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
               5                      rsh = rsh - sig_j;
               5                      IF( rsh < 0 ) [
               6                          $AUSCALL($EIIB);
               6                          call eii_sample(ish,iZ,Uj);
               6                          $AUSCALL($EIIA);
               6                          return;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1  ]
               0  IF( ekin <= 2*te(medium) ) return;
               0  T0=EKIN/RM;
               0  E0=T0+1.0;
               0  EXTRAE = EIE - THMOLL(MEDIUM);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  "G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  G2=T0*T0/E02;
               0  G3=(2.*T0+1.)/E02;
               0  "   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
               0  "   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
               0  "   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
               0  "   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
               0  "   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
               0  "   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
               0  "   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
               0  "   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "
               0
               0  "   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
               0  "   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
               0  "   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
               0  "   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
               0  "   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "
               0
               0  GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
               0  LOOP[" TO RETRY IF REJECTED"
               1  $RANDOMSET RNNO27;
               1  BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);
               1
               1  "   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
               1  R=BR/(1.-BR);
               1  $RANDOMSET RNNO28;
               1  REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
               1  RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
               1  ]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"
               0
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
               0  PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
               0  PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
               0  ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
               0  ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
               0  E(NP)=PESE1;
               0  $CHECK-STACK(np+1,'MOLLER');
               0  E(NP+1)=PESE2;
               0  "   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
               0  "   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "
               0
               0  " One possible way of dealing with double counting of angular      "
               0  " deflections in inelastic scattering would be to                  "
               0  " not deflect the 'old' electron as these deflections are          "
               0  " already taken into account in the multiple elastic scattering    "
               0  " This approach has the disadvantage of loosing correlations       "
               0  " between big energy losses and strong angular deflections         "
               0  " The advantage of such an approach is its simplicity.             "
               0  " If spin effects for multiple elastic scattering are turned on,   "
               0  " the double counting is taken into account by the appropriate     "
               0  " modification of the scattering power (which depends on AE)       "
               0  "                                                                  "
               0  "                                                                  "
               0  " IK, June 1999                                                    "
               0
               0  H1=(PEIE+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
               0  DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0
               0  "sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"
               0
               0  CALL UPHI(2,1);
               0
               0  "   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
               0  NP=NP+1;
               0  IQ(NP)=-1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE MOLLER"  END;
               0
1              0  %E
               0
               0  subroutine mscati;
               0  "**********************************************************************"
               0
               0  " Subroutine to read the pre-calculated q^(2+)-surface, prepare data
               0  " required by the mscat and msdist subroutines, initialize spin effect
               0  " corrections
               0  "
               0  " I.Kawrakow, NRC
               0  "**********************************************************************"
               0
               0  implicit none;
               0
               0  $REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
               0  $REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
               0  $INTEGER
               0      i,leil,leip1l,neke,lelke,lelkef,lelktmp;
               0  $LOGICAL  ise_monoton, isp_monoton;
               0
               0  $declare_write_buffer;
               0
               0  "cross section per energy loss"
               0  $REAL sigee,sigep,sig,sige_old,sigp_old;
               0
               0  "entry mscat variables
               0  "======================
               0
               0  $COMIN-MSCATI;
               0
               0  " moved the following from prestaII_inputs, "
               0  " if transport_algorithm = presta-I, exact_bca = .false. and
               0  " skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"
               0
               0  IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               0  ELSE                    [ exact_bca = .false.; ]
               0  IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
               0  IF( ximax <= 0  | ximax >= 1 ) [
               1      IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
               1      ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
               1  ]
               0  IF (transport_algorithm ~= $PRESTA-II &
               0      transport_algorithm ~= $PRESTA--I &
               0      transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
               0  IF( skindepth_for_bca <= 1e-4 ) [
               1      "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
               1      IF( ~exact_bca ) [
               2          $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
               2          $set_ecutmn;
               2          $egs_info(*,'     minimum ECUT found: ',ecutmn);
               2          tstbmn = 1e30;
               2          DO medium = 1,nmed [
               3              tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
               3              tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
               3              aux = Log(tstbm);
               3              IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
               3              tstbm = Log(tstbm/aux);
               3              "Changed the following to the above so that the Intel compiler"
               3              " does not vectorize the loop with -xK. Vectorizing this loop"
               3              " on an Athlon CPU results in segmentation fault."
               3              " IK, Jan 29 2004."
               3              "tstbm = Log(tstbm/Log(tstbm));"
               3              tstbmn = Min(tstbmn,tstbm);
               3          ]
               2          $egs_info(*,'     default BLCMIN is: ',tstbmn);
               2          skindepth_for_bca = Exp(tstbmn);
               2          $egs_info(*,'     this corresponds to ',skindepth_for_bca,
               2           ' elastic MFPs ');
               2      ]
               1      ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
               1  ]
               0
               0  " read MS data for screened Rutherford scattering "
               0  call init_ms_SR;
               0
               0  DO medium = 1,nmed
               0  [
               1      "Absorb Euler constant into the multiple scattering parameter
               1      "1.16699413758864573 = Exp[2 EulerGamma - 1]
               1      blcc(medium) = 1.16699413758864573*blcc(medium);
               1
               1      "Take its square as this is employed throughout
               1      xcc(medium)  = xcc(medium)**2;
               1  ]
               0
               0  IF( spin_effects ) [ call init_spin; ]
               0
               0  "Determine maximum cross section per energy loss for every medium
               0  $egs_info(*,' ');
               0  esige_max = 0;
               0  psige_max = 0;
               0  DO medium = 1,nmed
               0  [
               1
               1    sigee = 1E-15; sigep = 1E-15;
               1    neke = meke(medium); "Number of elements in storage array
               1    ise_monoton = .true.; isp_monoton = .true.;
               1    sige_old = -1; sigp_old = -1;
               1    DO i = 1,neke
               1    [
               2
               2      ei   = exp((float(i) - eke0(medium))/eke1(medium));
               2      eil  = log(ei);
               2      leil = i;
               2      $EVALUATE ededx USING ededx(eil);
               2      $EVALUATE sig USING esig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigee) sigee = sig;
               2      IF( sig < sige_old ) ise_monoton = .false.;
               2      sige_old = sig;
               2      $EVALUATE ededx USING pdedx(eil);
               2      $EVALUATE sig USING psig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigep) sigep = sig;
               2      IF( sig < sigp_old ) isp_monoton = .false.;
               2      sigp_old = sig;
               2
               2    ]
               1    $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
               1            ise_monoton,isp_monoton);
               1    sig_ismonotone(0,medium) = ise_monoton;
               1    sig_ismonotone(1,medium) = isp_monoton;
               1    esig_e(medium) = sigee; psig_e(medium) = sigep;
               1    IF( sigee > esige_max ) esige_max = sigee;
               1    IF( sigep > psige_max ) psige_max = sigep;
               1  ]
               0  $egs_info(*,' ');
               0
               0  $egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
               0  $egs_info(*,' ');
               0
               0  "Determine upper limit in step size for multiple scattering
               0  DO medium = 1,nmed
               0  [
               1      " Calculate range array first "
               1      " =========================== "
               1      ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
               1      eil  = log(ei);
               1      leil = 1;
               1      E_array(1,medium) = ei;
               1      expeke1(medium) = Exp(1./eke1(medium))-1;
               1      range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
               1      neke = meke(medium); "Number of elements in storage array
               1      DO i = 1,neke - 1
               1      [
               2          eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
               2          E_array(i+1,medium) = eip1;
               2          " Calculate range. The following expressions result from the"
               2          " logarithmic interpolation for the (restricted) stopping power "
               2          " and a power power series expansion of the integral "
               2          eke = 0.5*(eip1+ei); elke = Log(eke);
               2          $SET INTERVAL elke,eke;
               2          $EVALUATE ededx USING pdedx(elke);
               2          aux = pdedx1(i,medium)/ededx;
               2          range_ep(1,i+1,medium) = range_ep(1,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          $EVALUATE ededx USING ededx(elke);
               2          aux = ededx1(i,medium)/ededx;
               2          range_ep(0,i+1,medium) = range_ep(0,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          ei = eip1;
               2      ]
               1
               1      " Now tmxs "
               1      " ======== "
               1
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
               1      p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
               1      chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               1      $EVALUATE dedx0 USING ededx(eil);
               1      estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               1      estepx = estepx*ximax;
               1      IF( estepx > estepe ) [ estepx = estepe; ]
               1      si = estepx*ei/dedx0;
               1
               1      DO i = 1,neke - 1
               1      [
               2
               2          elke = (i + 1 - eke0(medium))/eke1(medium);
               2          eke  = Exp(elke); lelke = i+1;
               2          p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
               2          chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               2          $EVALUATE ededx USING ededx(elke);
               2          estepx = 2*p2*beta2*ededx/eke/
               2                    Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               2          estepx = estepx*ximax;
               2          IF( estepx > estepe ) [ estepx = estepe; ]
               2          ekef = (1-estepx)*eke;
               2          IF( ekef <= E_array(1,medium) )
               2          [
               3              sip1 = (E_array(1,medium) - ekef)/dedx0;
               3              ekef = E_array(1,medium);
               3              elkef = (1 - eke0(medium))/eke1(medium);
               3              lelkef = 1;
               3          ]
               2          ELSE
               2          [
               3              elkef = Log(ekef);
               3              $SET INTERVAL elkef,eke;
               3              leip1l = lelkef + 1;
               3              eip1l  = (leip1l - eke0(medium))/eke1(medium);
               3              eip1   = E_array(leip1l,medium);
               3              aux    = (eip1 - ekef)/eip1;
               3              elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
               3              ektmp  = 0.5*(ekef+eip1);
               3              lelktmp = lelkef;
               3              $EVALUATE ededx USING ededx(elktmp);
               3              aux = ededx1(lelktmp,medium)/ededx;
               3              sip1 = (eip1 - ekef)/ededx*(
               3                       1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
               3          ]
               2          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);
               2
               2          "Now solve these equations
               2          "  si   = tmxs1 * eil   + tmxs0
               2          "  sip1 = tmxs1 * eip1l + tmxs0
               2
               2          tmxs1(i,medium) = (sip1 - si)*eke1(medium);
               2          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;
               2
               2          si  = sip1;
               2      ]
               1
               1      "Now pick up last table entry which applies only to last energy
               1      tmxs0(neke,medium) = tmxs0(neke - 1,medium);
               1      tmxs1(neke,medium) = tmxs1(neke - 1,medium);
               1
               1  ]
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
               0                   spin_effects,find_index,spin_index,
               0                   cost,sint);
               0  "========================================================================="
               0  "                                                                         "
               0  " Subroutine to sample multiple electron scattering angles from the exact "
               0  " distribution resulting from elastic scattering described by the screened"
               0  " Rutherford cross section (spin_effects=.false.) or by the screened      "
               0  " Rutherford cross times Mott correction (spin_effects=.true.)            "
               0  "                                                                         "
               0  " I.Kawrakow, NRC                                                         "
               0  "========================================================================="
               0
               0  implicit none;
               0
               0  $REAL    lambda, chia2,q1,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects,find_index,spin_index;
               0
               0  COMIN/MS-Data,RANDOM,EGS-IO/;
               0
               0  $declare_write_buffer;
               0
               0  $REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
               0           cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
               0  $INTEGER icount,i,j,k;
               0
               0  save     i,j,omega2;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  IF(lambda <= 13.8)
               0  [
               1      "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
               1      "that contribute to the forward no-scattering amplitude.
               1      $RANDOMSET sprob;
               1      explambda = Exp(-lambda);
               1      IF (sprob < explambda)
               1      [
               2          "It was a no scattering event
               2          cost = 1; sint = 0;
               2          return;
               2      ]
               1      wsum = (1+lambda)*explambda;
               1      IF ( sprob < wsum )
               1      [
               2        :RETRY_1:;
               2        $RANDOMSET xi;
               2        xi  = 2*chia2*xi/(1 - xi + chia2);
               2        cost = 1 - xi;
               2        IF( spin_effects ) [
               3            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
               3                                  spin_index,.false.);
               3            $RANDOMSET rnno;
               3            IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
               3        ]
               2        sint = sqrt(xi*(2 - xi));
               2        return;
               2      ]
               1      IF ( lambda <= 1 )      "IK introduced this portion because with
               1                              "alternative BCAs mscat can be called with
               1                              " lambda < 1 where there are no pre-calculated
               1                              "data
               1      [
               2          wprob = explambda; wsum = explambda;
               2          cost = 1; sint = 0;
               2          icount = 0;
               2          LOOP
               2          [
               3              icount = icount + 1;
               3              IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
               3              wprob = wprob*lambda/icount;
               3              wsum = wsum + wprob;
               3              :RETRY_2:;
               3              $RANDOMSET xi;
               3              xi  = 2*chia2*xi/(1 - xi + chia2);
               3              cosz = 1 - xi;
               3              IF( spin_effects ) [
               4                  rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
               4                                        spin_index,.false.);
               4                  $RANDOMSET rnno;
               4                  IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
               4              ]
               3              sinz = xi*(2 - xi);
               3              IF ( sinz > 1.e-20 )
               3              [
               4                 sinz = Sqrt(sinz);
               4                 $RANDOMSET xi;
               4                 phi = xi*6.2831853;
               4                 cost = cost*cosz - sint*sinz*Cos(phi);
               4                 sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
               4               ]
               3          ] UNTIL ( wsum > sprob);
               2          return;
               2      ]
               1  ]
               0
               0  "It was a multiple scattering event
               0  "Sample the angle from the q^(2+) surface
               0
               0  IF (lambda <= $LAMBMAX_MS ) [
               1
               1      IF (find_index)
               1      [
               2          llmbda = log(lambda);
               2
               2          " First fix lambda bin
               2          ai = llmbda*dllambi; i = ai; ai = ai - i;
               2          $RANDOMSET xi;
               2          IF(xi < ai) i = i + 1;
               2
               2          " fix now q1 bin
               2          IF( q1 < $QMIN_MS ) [ j = 0; ]
               2          ELSE IF( q1 < $QMAX_MS ) [
               3              aj = q1*dqmsi; j = aj; aj = aj - j;
               3              $RANDOMSET xi;
               3              IF( xi < aj ) j = j + 1;
               3          ]
               2          ELSE [ j = $MAXQ_MS; ]
               2
               2          " Calculate omega2 "
               2          IF(llmbda < 2.2299) [
               3            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
               3              0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
               3          ]
               2          ELSE [
               3            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
               3                     llmbda*(0.1535754 - llmbda*0.00552888)));
               3          ]
               2
               2          find_index = .false.;
               2      ]
               1      "If this is a re-iteration with the same lambda, then omega2, i, and k
               1      "should have been defined in the previous iteration
               1
               1  :RETRY_3:;
               1      $RANDOMSET xi;
               1      ak = xi*$MAXU_MS; k = ak; ak = ak - k;
               1      IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
               1      a = fms_array(i,j,k); u = ums_array(i,j,k);
               1      du = ums_array(i,j,k+1) - u;
               1      $RANDOMSET xi;
               1      IF( abs(a) < 0.2 ) [
               2          x1 = 0.5*(1-xi)*a;
               2          u  = u + xi*du*(1+x1*(1-xi*a));
               2      ]
               1      ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]
               1
               1      xi      = omega2*u/(1 + 0.5*omega2 - u);
               1      IF( xi > 1.99999 ) [ xi = 1.99999; ]
               1        "some machines have trouble when xi is very close to 2 in subsequent"
               1        "calculations. IK, April 25 2002"
               1      cost    = 1 - xi;
               1      IF( spin_effects ) [
               2          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
               2          $RANDOMSET rnno;
               2          IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
               2      ]
               1      sint    = sqrt(xi*(2-xi));
               1      return;
               1  ]
               0
               0  "This is an error condition
               0
               0  $egs_info(*,' ');
               0  $egs_info(*,' *************************************');
               0  $egs_info(*,' Maximum step size in mscat exceeded! ');
               0  $egs_info(*,' Maximum step size initialized: 100000');
               0  $egs_info(*,' Present lambda: ',lambda);
               0  $egs_info(*,' chia2: ',chia2);
               0  $egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
               0  $egs_info(*,' medium: ',medium);
               0  $egs_fatal(*,' Stopping execution');
               0
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  $REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
               0                                spin_index,is_single);
               0  "============================================================================="
               0  "                                                                             "
               0  " Determines the rejection function due to spin effects for                   "
               0  "   charge        qel (=0 for e-, =1 for e+)                                  "
               0  "   log(energy)   elke                                                        "
               0  "   speed         beta2                                                       "
               0  "   1. MS moment  q1                                                          "
               0  "   cos(theta)    cost                                                        "
               0  "                                                                             "
               0  " I.Kawrakow, NRC                                                             "
               0  "============================================================================="
               0
               0  implicit none;
               0
               0  $REAL      elke,beta2,q1,cost;
               0  $INTEGER   qel,medium;
               0  $LOGICAL   spin_index,is_single;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,RANDOM/;
               0
               0  $REAL      rnno,ai,qq1,aj,xi,ak;
               0  $INTEGER   i,j,k;
               0
               0  save       i,j;
               0
               0  IF( spin_index ) [  "Determine the energy and q1 index
               1      spin_index = .false.;
               1      IF( beta2 >= b2spin_min ) [
               2          ai = (beta2 - b2spin_min)*dbeta2i;
               2          i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
               2      ]
               1      ELSE IF( elke > espml ) [
               2          ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
               2      ]
               1      ELSE [ i = 0; ai = -1; ]
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) i = i + 1;
               1      IF( is_single ) [ j = 0; ]
               1      ELSE [
               2          qq1 = 2*q1; qq1 = qq1/(1 + qq1);
               2          aj = qq1*dqq1i; j = aj;
               2          IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
               2          ELSE [  aj = aj - j;
               3                  $RANDOMSET rnno;
               3                  IF( rnno < aj ) j = j + 1;
               3          ]
               2      ]
               1  ]
               0  xi = Sqrt(0.5*(1-cost));
               0  ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
               0  spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
               0                       ak*spin_rej(medium,qel,i,j,k+1);
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0
               0  subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
               0  "============================================================================"
               0  "                                                                            "
               0  " single elastic scattering                                                  "
               0  "                                                                            "
               0  " I.Kawrakow, NRC                                                            "
               0  "============================================================================"
               0
               0  implicit none;
               0
               0  $REAL    chia2,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects;
               0
               0  COMIN/RANDOM/;
               0
               0  $REAL    xi,rnno,rejf,spin_rejection,qzero;
               0  $LOGICAL spin_index;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  spin_index = .true.;
               0  :RETRY-SPIN:;
               0  $RANDOMSET xi;
               0  xi  = 2*chia2*xi/(1 - xi + chia2);
               0  cost = 1 - xi;
               0  IF( spin_effects ) [
               1      qzero=0;
               1      rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
               1      $RANDOMSET rnno;
               1      IF( rnno > rejf ) goto :RETRY-SPIN:;
               1  ]
               0  sint = sqrt(xi*(2 - xi));
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_ms_SR;
               0  "================================================================"
               0  "                                                                "
               0  " Reads in pre-calculated screened Rutherford multiple elastic   "
               0  " scattering data                                                "
               0  "                                                                "
               0  " I. Kawrakow, NRC                                               "
               0  "================================================================"
               0
               0  implicit none;
               0
               0  COMIN/MS-Data,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  integer*4 i,j,k;
               0
               0  $egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
               0  rewind($MSCAT-DATAFILE);
               0  DO i=0,$MAXL_MS [
               1      DO j=0,$MAXQ_MS [
               2          read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
               2          read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
               2          DO k=0,$MAXU_MS-1 [
               3             fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
               3             ims_array(i,j,k) = ims_array(i,j,k)-1;
               3          ]
               2          fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
               2      ]
               1  ]
               0  $egs_info('(a)',' done ');
               0
               0  llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
               0  dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
               0  dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_spin;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline,dloge,eloge;
               0
               0  real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"
               0
               0  real*4        fmax_array(0:$MAXQ_SPIN);
               0  integer*2     i2_array(512),ii2;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,ii4,irec;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0
               0  $INTEGER      spin_unit, rec_length, want_spin_unit;
               0  integer       egs_get_unit;
               0  character     data_version*32,endianess*4;
               0  $LOGICAL      swap;
               0
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " stupid GNU compiler complains that the arguments to egs_swap_ are of "
               0  " one kind here, but of some other kind there => need character arrays and "
               0  " equivalence statements"
               0  real*4        tmp_4;
               0  character     c_2(2), c_4(4);
               0  equivalence   (ii2,c_2), (tmp_4,c_4);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
               0  want_spin_unit = 61;
               0  spin_unit = egs_get_unit(want_spin_unit);
               0  IF( spin_unit < 1 ) [
               1      $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               1  ]
               0  rec_length = 276*$RECL-FACTOR;
               0  open(spin_unit,file=spin_file,form='unformatted',access='direct',
               0       status='old',recl=rec_length,err=:spin-open-error:);
               0  read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
               0                        espin_min,espin_max,b2spin_min,b2spin_max;
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
               1      tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
               1      tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
               1      tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
               0  $egs_info('(a)',data_version);
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,
               0          ' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
               0  $egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
               0          b2spin_min,b2spin_max);
               0  n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
               0  dloge = log(espin_max/espin_min)/n_ener;
               0  eloge = log(espin_min); earray(0) = espin_min;
               0  $FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
               0  DO i=1,n_ener [
               1      eloge = eloge + dloge; earray(i) = exp(eloge);
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0  dbeta2 = (b2spin_max - b2spin_min)/n_ener;
               0  beta2 = b2spin_min; earray(n_ener+1) = espin_max;
               0  DO i=n_ener+2,2*n_ener+1 [
               1      beta2 = beta2 + dbeta2;
               1      IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
               1      ELSE [ earray(i) = 50585.1; ]
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0
               0  " Convert to MeV and set interpolation interavals"
               0
               0
               0
               0
               0  espin_min = espin_min/1000; espin_max = espin_max/1000;
               0  dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               0  espml = Log(espin_min);
               0  dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               0  dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              DO i=0,$MAXE_SPI1 [
               4                  irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
               4                  $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
               4                  read(spin_unit,rec=irec,err=:spin-read-error:)
               4                    dum1,dum2,dum3,aux_o,fmax_array,i2_array;
               4                  IF( swap ) [
               5                    tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
               5                    tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
               5                    tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
               5                    tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
               5                  ]
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      tmp_4 = fmax_array(j);
               5                      IF( swap ) call egs_swap_4(c_4);
               5                      DO k=0,$MAXU_SPIN [
               6                          ii2 = i2_array((n_point+1)*j + k+1);
               6                          IF( swap ) call egs_swap_2(c_2);
               6                          ii4 = ii2;
               6                          IF( ii4 < 0 ) ii4 = ii4 + 65536;
               6                          dum1 = ii4; dum1 = dum1*tmp_4/65535;
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*dum1;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2          $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
               2            c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
               2      ]
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
               2           etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
               2            q1ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
               2            q1cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
               2            q2ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
               2            q2cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  close(spin_unit);
               0  return;
               0
               0  :spin-open-error:
               0  $egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));
               0
               0  :spin-read-error:
               0  $egs_fatal(*,'Error while reading spin data file for element',iZ);
               0
               0  return; end;
1              0  %E
               0
               0  subroutine init_spin_old;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " This version uses the old EGSnrc ASCII spin data format.              "
               0  " If the installation failed to figure out the byte order of your       "
               0  " machine, rename this subroutine to init_spin, the current init_spin   "
               0  " to init_spin_new (or whatever) and download the old spinms data       "
               0  " directory.
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
               0               $file_sep // 'z000';
               0  length = lnblnk1(spin_file);
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
               1                            ' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
               2          iiZ = iZ - iii*100;
               2          iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
               2          iiZ = iiZ - 10*iii;
               2          spin_file(length:length) = char(iiZ+48);
               2          want_spin_unit = 61;
               2          spin_unit = egs_get_unit(want_spin_unit);
               2          IF( spin_unit < 1 ) [
               3              $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               3          ]
               2          open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
               2          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
               2          read(spin_unit,*) n_ener,n_q,n_point;
               2          IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
               3              $egs_fatal(*,' Wrong spin file for Z = ',iZ);
               3          ]
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              read(spin_unit,*); read(spin_unit,*);
               3              DO i=0,$MAXE_SPI1 [
               4                  read(spin_unit,'(a,g14.6)') string,earray(i);
               4                  read(spin_unit,*) dum1,dum2,dum3,aux_o;
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      read(spin_unit,*) tmp_array;
               5                      DO k=0,$MAXU_SPIN [
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
               6                      ]
               5                  ]
               4              ]
               3          ]
               2          close(spin_unit);
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2      ]
               1
               1      " Convert to MeV and set interpolation interavals"
               1      espin_min = espin_min/1000; espin_max = espin_max/1000;
               1      dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               1      espml = Log(espin_min);
               1      dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               1      dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  return;
               0
               0  :SPIN-DBASE-ERROR:
               0  $egs_info(*,' ******************** Error in init_spin ******************* ');
               0  $egs_info('(a,a)','  could not open file ',spin_file);
               0  $egs_fatal(*,' terminating execution ');
               0
               0  end;
1              0  %E
               0  ; "buffer flush
               0
               0  "======================================================================"
               0  "                 subroutine msdist_pII                                "
               0  "                 =====================                                "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep.                         "
               0  "  For description of input and output variables see below             "
               0  "                                                                      "
               0  "  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
               0  "  March 1997          Alex Bielajew        Adaption for EGS4          "
               0  "  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
               0  "                                           mortran version by Bielajew"
               0  "  June 1997           Iwan Kawrakow        Improved energy loss       "
               0  "                                           corrections                "
               0  "  June 1999           Iwan Kawrakow        spin effects, removed      "
               0  "                                           $SUBSTEP-ELOSS-EVALUATION  "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pII
               0  (
               0      e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      med,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects;
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      b,         "substep transport distance,
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      c,         "substep transport distance,
               0      eta,eta1,  "randomization of the substep transport distances
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi1,     "cosine of the first azimuthal angle
               0      cphi2,     "cosine of the second azimuthal angle
               0      w1,        "cosine of the first substep polar scattering angle
               0      w2,        "cosine of the second substep polar scattering angle
               0      w1v2,      "w1*v2;
               0      delta,     "transport parameter (see paper)
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)"
               0      beta2,     "speed at e in units of c, squared"
               0      etap,      "correction to the screening parameter derived from PWA
               0      xi_corr,   "correction to the first MS moments due to spin
               0      ms_corr,
               0      tau,       "average kinetic energy over the step divided by electron mass
               0      tau2,      "tau squared
               0      epsilon,   "fractional energy loss
               0      epsilonp,  "fractional energy loss
               0      temp,temp1,"auxilarity variables for energy loss corrections
               0      temp2,     "
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      gamma,     "q2/q1
               0      lambda,    "distance in number of elastic scattering mean free paths
               0                 "for each sample of the multiple scattering angle
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of ap2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sint1,     "sine   of the first substep polar scattering angle
               0      sint2,     "sine   of the second substep polar scattering angle
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      sphi1,     "sine   of the first azimuthal angle
               0      sphi2,     "sine   of the second azimuthal angle
               0      u2p,       "intermediate scatter or transport direction cosine
               0      u2,        "sint2*cphi2;
               0      v2,        "sint2*sphi2;
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index,  "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index   "saves locating the spin rejection index in 2. call to mscat"
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  medium  = med;
               0
               0  count_pII_steps = count_pII_steps + 1;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  "Commonly used factors
               0  e       = e0 - 0.5*eloss;
               0  tau     = e/prm;
               0  tau2    = tau*tau;
               0  epsilon = eloss/e0;
               0  epsilonp= eloss/e;
               0  "e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
               0  e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
               0  p2      = e*(e + rmt2);
               0  "p2i     = 1/p2;
               0  beta2   = p2/(p2 + rmsq);
               0  "chia2   = xcccc*p2i/(4*blccc);
               0  chia2   = xcccc/(4*p2*blccc);
               0  lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step
               0
               0  temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
               0               (epsilonp/((tau+1)*(tau+2)))**2;
               0  lambda = lambda*(1 - temp2);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2         $EVALUATE gamma USING q2ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2         $EVALUATE gamma USING q2cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]
               0
               0  chia2  = chia2*etap;
               0  lambda = lambda/(etap*(1+chia2))*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
               0  xi     = q1*lambda;
               0
               0  "Sample first substep scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w1,sint1);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);
               0
               0  "Sample second substep scattering angle
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w2,sint2);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);
               0
               0  "Final direction of motion, relative to z-axis motion
               0  u2  = sint2*cphi2;
               0  v2  = sint2*sphi2;
               0  u2p = w1*u2 + sint1*w2;
               0  us  = u2p*cphi1 - v2*sphi1;
               0  vs  = u2p*sphi1 + v2*cphi1;
               0  ws  = w1*w2 - sint1*u2;
               0
               0  "Calculate delta, b, c
               0
               0  xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects
               0
               0  $RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
               0  delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;
               0
               0  "Correct the coefficients for energy loss
               0  temp1 = 2 + tau;
               0  temp = (2+tau*temp1)/((tau+1)*temp1);
               0  "Take logarithmic dependence into account as well
               0  temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
               0  temp = temp * epsilonp;
               0  temp1 = 1 - temp;
               0  delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
               0            (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
               0             "0.40824829 is 1/Sqrt(6)"
               0  b      = eta*delta;
               0  c      = eta*(1-delta);
               0
               0  "Calculate transport direction cosines
               0  w1v2 = w1*v2;
               0  ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
               0  vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
               0  wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;
               0
               0  "Calculate transport distance
               0  ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PII;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
               0
               0  "                 subroutine msdist_pI                                 "
               0  "                 ====================                                 "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep                          "
               0  "  resampling PRESTA-I behaviour.                                      "
               0  "                                                                      "
               0  "  October 1997        Iwan Kawrakow        Initial coding             "
               0  "  June    1999        Iwan Kawrakow        spin effects               "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pI
               0  (
               0      e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      medium,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
               0      r2max,
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi,      "cosine of the azimuthal scattering angle
               0      sphi,      "sine of the  azimuthal scattering angle
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)
               0      beta2,     "speed at e in units of c, squared
               0      etap,      "correction to the screening angle derived from PWA
               0      xi_corr,   "correction to the first MS moment due to spin
               0      ms_corr,
               0      epsilon,   "fractional energy loss
               0      temp,      "auxilarity variable for energy loss corrections
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      lambda,    "distance in number of elastic scattering mean free paths
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of p2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint,      "sine of the MS angle
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      u2p,       "intermediate scatter or transport direction cosine
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index, "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  e       = e0 - 0.5*eloss;
               0  p2      = e*(e + rmt2);
               0  p2i     = 1/p2;
               0  chia2   = xcccc*p2i/(4*blccc);
               0  beta2   = p2/(p2 + rmsq);
               0  lambda  = tustep*rhof*blccc/beta2;
               0
               0  "Account for energy loss in the MS distribution
               0  factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
               0  epsilon= eloss/e0;
               0  epsilon= epsilon/(1-0.5*epsilon);
               0  temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
               0  lambda = lambda*(1 + temp);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]
               0
               0  chia2   = xcccc*p2i/(4*blccc)*etap;
               0  lambda = lambda/etap/(1+chia2)*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  xi     = q1*lambda;
               0
               0  "Sample multiple scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             ws,sint);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               0  us  = sint*cphi;
               0  vs  = sint*sphi;
               0
               0  "Correct xi used for the PLC calc. for spin effects
               0  xi     = xi*xi_corr;
               0
               0  "Calculate PLC and lateral transport a la PRESTA-I
               0  "Note that we use here the exact expression for <z>
               0  "because it is much simpler and faster than the original PRESTA-I formulas
               0  "(which are also second order approximations)
               0  IF ( xi < 0.1 )
               0  [
               1     z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
               1  ]
               0  ELSE
               0  [
               1     z = (1 - Exp(-xi))/xi;
               1  ]
               0  r  = 0.5*sint;
               0  r2 = r*r; z2 = z*z;
               0  r2max = 1 - z2;
               0  IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]
               0
               0  "Calculate final position vector
               0  ut   = r*cphi; vt = r*sphi; wt = z;
               0
               0  "Calculate transport distance
               0  ustep = Sqrt(z2 + r2)*tustep;
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PI;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PAIR;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   For a photon energy below 2.1 MeV, the energies of the pair    "
               0  "   particles are uniformly distributed in the allowed range via   "
               0  "   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
               0  "   If the user has a better approach, modify this macro.          "
               0  "   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
               0  "   cross section is employed, above 50 MeV the Coulomb-corrected  "
               0  "   Bethe-Heitler is used.                                         "
               0  "   Modified from its original version to make compatible with the "
               0  "   changes made in BREMS.                                         "
               0  "                                                                  "
               0  "   I. Kawrakow                                                    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
               0                                   "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PAIR;
               0
               0  $DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;
               0
               0  $REAL    k,xx,abin,rbin,alias_sample1;
               0  $INTEGER ibin, iq1, iq2, iprdst_use;
               0  $LOGICAL do_nrc_pair;
               0  $INTEGER itrip;
               0  $REAL    ftrip;
               0
               0  NPold = NP;      "Set the old stack counter"
               0
               0  IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
               1                        " it is much more efficient to do it BEFORE the "
               1                        " actual sampling "
               1      i_survived_RR = 0;  "flag they all survive inititally"
               1      IF( prob_RR <= 0 ) [
               2          IF( n_RR_warning < $MAX-RR-WARNING ) [
               3            n_RR_warning = n_RR_warning + 1;
               3            $egs_warning('(a,g14.6)',
               3                        'Attempt to play Russian Roulette with prob_RR<0! ');
               3          ]
               2      ]
               1      ELSE [
               2          $RANDOMSET rnno_RR;
               2          IF( rnno_RR > prob_RR ) [  "The pair was killed "
               3              i_survived_RR =2; "flag both particles eliminated"
               3              IF( np > 1 ) [ np = np-1; ]
               3              ELSE [ " We have just one photon left on the stack. In order to  "
               4                     " get a proper exit from PHOTO, we have to leave at least "
               4                     " one particle on the stack                               "
               4                  wt(np) = 0; e(np) = 0;
               4              ]
               3              return;
               3          ]
               2          ELSE [ "The pair survived, increase the weight"
               3              wt(np) = wt(np)/prob_RR;
               3          ]
               2      ]
               1  ]
               0
               0  $CHECK-STACK(np+1,'PAIR');
               0  PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
               0  EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
               0  do_nrc_pair = .false.;
               0
               0  IF( itriplet > 0 & eig > 4*rm ) [
               1      itrip = dli_triplet*gle + bli_triplet;
               1      ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
               1      $RANDOMSET rnno34;
               1      IF( rnno34 < ftrip ) [  " Triplet production "
               2          call sample_triplet;
               2          return;
               2      ]
               1  ]
               0
               0  IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
               1                        "(privided the energy is within the available range)"
               1      k = eig/rm;
               1      IF( k < nrcp_emax ) [
               2          do_nrc_pair = .true.;
               2          IF( k <= nrcp_emin ) [ ibin = 1; ]
               2          ELSE [
               3              abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
               3              ibin = abin; abin = abin - ibin;
               3              $RANDOMSET rbin;
               3              IF( rbin < abin ) ibin = ibin + 1;
               3          ]
               2          xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
               2                  nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
               2                  nrcp_idata(1,ibin,medium));
               2             " The above returns the energy fraction of the positron "
               2          IF( xx > 0.5 ) [
               3              pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
               3              pese2 = peig - pese1; iq2 = -1;
               3          ]
               2          ELSE [
               3              pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
               3              pese1 = peig - pese2; iq1 = -1;
               3          ]
               2      ]
               1  ]
               0
               0
               0  IF( ~do_nrc_pair ) [
               1  IF (EIG.LE.2.1) [
               2      "   BELOW 2.1,USE APPROXIMATION"
               2      $SELECT-LOW-ENERGY-PAIR-PRODICTION;
               2  ]
               1  ELSE[   "ABOVE 2.1, MUST SAMPLE"
               2
               2      "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
               2      "   COULOMB CORRECTED
               2
               2      IF (EIG.LT.50.) [ "Use BH without Coulomb correction"
               3
               3          L = 5;
               3          L1 = L + 1;
               3
               3          "Find the actual rejection maximum for this photon energy"
               3          delta = 4*delcm(medium)/eig;
               3          IF( delta < 1 ) [
               4             Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4             Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4             aux2 = log(delta+dl6(l,medium));
               4             Amax = dl4(l,medium)+dl5(l,medium)*aux2;
               4             Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
               4          ]
               3          "and then calculate the probability for sampling from (br-1/2)**2"
               3          aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
               3          aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
               3      ]
               2      ELSE [
               3          "Use BH Coulomb-corrected"
               3          L = 7;
               3          "The absolute maxima are close to the actual maxima at high energies"
               3          "=>use the absolute maxima to save time"
               3          Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
               3          aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
               3      ]
               2
               2      del0 = eig*delcm(medium);
               2      Eavail = eig - rmt2;
               2
               2      LOOP [
               3
               3          $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
               3          IF( rnno30 > aux1 ) [ "use the uniform part"
               4              br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
               4          ]
               3          ELSE [  "use the (br-1/2)**2 part of the distribution"
               4              $RANDOMSET rnno32; $RANDOMSET rnno33;
               4              br = 0.5*(1-max(rnno31,rnno32,rnno33));
               4              rejmax = Amax; l1 = l;
               4          ]
               3          Eminus = br*Eavail + rm;
               3          Eplus  = eig - Eminus;
               3          delta = del0/(Eminus*Eplus);
               3          IF( delta < 1 ) [
               4             rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4            rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
               4          ]
               3
               3      ] UNTIL ( rnno34*rejmax <= rejf );
               2
               2      pese2 = Eminus; pese1 = peig - pese2;
               2      $RANDOMSET RNNO34;
               2      IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
               2
               2  ]
               1  ]
               0
               0  "   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
               0  ESE2=PESE2;
               0  E(NP)=PESE1; E(NP+1)=PESE2;
               0  "   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
               0  "   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
               0  "   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
               0  "   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
               0  "   SET UP A NEW 'ELECTRON'  "
               0  $SET-PAIR-ANGLE;
               0  " DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
               0  " of the angular distribution "
               0  CALL UPHI(1,1);
               0  "   SET UP A NEW 'ELECTRON' "
               0  NP=NP+1;
               0  SINTHE=-SINTHE;
               0  CALL UPHI(3,2);
               0
               0  IQ(NP)=iq2; IQ(NP-1)=iq1;
               0  RETURN;
               0  "END OF SUBROUTINE PAIR"    END;
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " Sampling of triplet production events.                                    "
               0  "                                                                           "
               0  " The treatment is based on Borsellino's first Born approximation           "
               0  " result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
               0  " As the kinematic of the process is already complicated enough and the     "
               0  " cross section itself is not simple either, a Markov-chain method is used  "
               0  " to sample triplet events from the Borsellino equation without any         "
               0  " additional approximations (other then the use of the first Born           "
               0  " approximation and the assumption of free electrons implied by             "
               0  " Borsellino's derivation)                                                  "
               0  "                                                                           "
               0  " Iwan Kawrakow, April 2005.                                                "
               0  "***************************************************************************"
               0
               0  subroutine sample_triplet;
               0
               0  "***************************************************************************"
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  " We use double precision throughout as in many cases the kinematically "
               0  " permitted angular interval is too small to be resolved accurately enough "
               0  " in single precision "
               0
               0  real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
               0         eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
               0         eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
               0         wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);
               0
               0  real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;
               0
               0  real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
               0         Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
               0         aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
               0  real*8 Er,pr,pr2,eta_pr;
               0  real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
               0         eta_costp,Epp,pp_sintp,pp_sntp2;
               0  real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
               0         eta_costm;
               0  real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
               0  real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
               0         a,c,sindel,cosdel,sinpsi;
               0
               0  $INTEGER i;
               0  $LOGICAL use_it;
               0  $INTEGER iscore; " needed for BEAM "
               0
               0  $LOGICAL is_initialized;
               0  data is_initialized/.false./;
               0  save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
               0       eta_costm_array,ebin_array,wp_array,qmin_array,
               0       kmin,kmax,dlogki,alogkm,prmi,tiny_eta;
               0
               0  IF( ~is_initialized ) [
               1      is_initialized = .true.;
               1      tiny_eta = 1e-6;
               1      " Set current cross section value to -1 in each energy bin "
               1      DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
               1      " Find the maximum energy of the cross section data "
               1      kmax = 0; kmin = 4.1*prm;
               1      DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
               1      IF( kmax <= kmin ) return;
               1      dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
               1      alogkm = 1 - dlogki*log(kmin);
               1      prmi = 1/prm;
               1      DO i=1,$MAX_TRIPLET [
               2          k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
               2          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
               2          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
               2          qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
               2      ]
               1  ]
               0
               0  peig = e(np);
               0  IF( peig <= 4*prm ) return;
               0  $CHECK-STACK(np+2,'sample_triplet');
               0
               0  " Determine energy bin "
               0  IF( peig <= kmin ) [ i = 1; ]
               0  ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
               0  ELSE [
               1      ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) [ i = i+1; ]
               1  ]
               0
               0  " First use the bin energy to sample the random numbers "
               0  " that determine recoil momentum and electron/postron angles "
               0  k = ebin_array(i);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  :retry_triplet:;
               0
               0  " Pick the recoil electron momentum from 1/p.
               0  $RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
               0  pr = qmin_array(i)*exp(eta_pr*wp_array(i));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  " Determine min./max. kinematically permitted postron energy for "
               0  " this k and p "
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  " Pick the positron energy "
               0  $RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0
               0  " Now we can determine the pair electron energy from energy conservation "
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  " The minimum cosine of the positron angle follows from the kinematics. "
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0
               0  " Now pick the positron direction from 1/(Ep-pp*cost_p) "
               0  $RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  wmup = wmup*(cost_p - Epp);
               0  sint_p = 1-cost_p*cost_p;
               0  IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  " The minimum amd maximum cosine of the pair electron angle follows from "
               0  " the kinematics "
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0
               0  " Now pick the electron direction from "
               0  "  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
               0  " We have to take into account the "
               0  " 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
               0  " otherwise we end up with 1/sqrt() singularities near the ends of the "
               0  " allowed cost_m range                                                 "
               0  $RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
               0  wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
               0  wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
               0  cost_m = cost_m/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  " Now we have selected all independent kinematic variables. "
               0  " Determine the azimuthal angle between the pair electrons "
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0  " And now evaluate the Borsellino cross section "
               0  k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
               0  k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
               0  s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
               0  s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
               0  S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
               0  aux4 = k3*Ep-k2*Em;
               0  S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
               0  sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));
               0
               0  " We get the following factor due to the transformation from phi to "
               0  " the recoil momentum pr "
               0  cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);
               0
               0  " We have to also multiply by the various factors from the sampling of "
               0  " pr, Ep, cost_p and cost_m "
               0  sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
               0  IF( sigma < 0 ) [
               1      $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
               1  ]
               0
               0  " Now determine if we accept this new event "
               0  use_it = .true.;
               0  IF( sigma < fmax_array(i) ) [
               1      $RANDOMSET rnno;
               1      IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
               1  ]
               0  IF( use_it ) [       " Yes, event accepted "
               1      fmax_array(i) = sigma;
               1      eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
               1      eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
               1  ] ELSE [             " Nop, event rejected => use last accepted "
               1      eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
               1      eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
               1  ]
               0
               0  " We now have a set of random number accepted for sampling around "
               0  " the i'th bin energy. We need to recalculate all variables using "
               0  " the actual photon energy "
               0
               0  k = peig*prmi;
               0  aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
               0  qmin = 4*k/aux5; qmax = aux5/(2*k+1);
               0  pr = qmin*exp(eta_pr*log(qmax/qmin));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  sint_p = sqrt(1-cost_p*cost_p);
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $RANDOMSET phi; phi = phi*6.283185307179586;
               0  ppx = pp*sint_p; ppy = 0;
               0  pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
               0  cphi = cos(phi); sphi = sin(phi);
               0  tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
               0  tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
               0  ppz = pp*cost_p; pmz = pm*cost_m;
               0  prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
               0  " Set up particles on the stack ";
               0  " We always put the recoil electron on top (even if its energy is higher "
               0  " then the energies of the pair particles) because                       "
               0  "   - that way, we know which particle is the recoil  electron in case   "
               0  "     we want to score some quantity related to it                       "
               0  "   - its energy is, on average, lower than the pair particle energies   "
               0  NPold = np;
               0  $TRANSFER PROPERTIES TO (np)   FROM (np);
               0  $TRANSFER PROPERTIES TO (np+1) FROM (np);
               0  $TRANSFER PROPERTIES TO (np+2) FROM (np+1);
               0  pp = 1/pp; pm = 1/pm; pr = 1/pr;
               0  a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
               0  IF( sinpsi > 1e-20 ) [
               1      sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
               1      IF( Ep > Em ) [
               2          u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
               1      v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
               1      w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
               1  ] ELSE [
               1      IF( Ep > Em ) [
               2          u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
               2          iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
               2          iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
               2          iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
               2          iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
               1      iq(np) = -1; E(np) = Er*prm;
               1  ]
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE PHOTO;
               0  "******************************************************************"
               0  " Programmers:  I. Kawrakow, complete recoding,                    "
               0  "                            Fluorescent X-rays, Auger,            "
               0  "                            Coster-Kronig treated in RELAX        "
               0  "               A.F. Bielajew (NRC) photoelectric angular distn    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0
               0  data n_warning/0/;
               0
               0  IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  IF( peig < edge_energies(2,1) ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine PHOTO called with E = ',peig,
               2                     ' which is below the current min. energy of 1 keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  iZ = iedgfl(irl);
               0  do_relax = .false.;
               0  edep = pzero;
               0  IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
               1                             " first sample the element "
               1      IF( nne(medium) = 1 ) [
               2          iZ = int( zelem(medium,1) + 0.5 );
               2          DO j=1,edge_number(iZ) [
               3              IF( peig >= edge_energies(j,iZ) ) EXIT;
               3          ]
               2      ]
               1      ELSE [
               2          aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
               2          sigtot = 0;
               2          DO k=1,nne(medium) [
               3              iZ = int( zelem(medium,k) + 0.5 );
               3              IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                  $egs_info(*,' Error in PHOTO: ');
               4                  $egs_fatal(*,'   Atomic number of element ',k,
               4                     ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4              ]
               3              IF( peig > edge_energies(1,iZ) ) [
               4                  j = 1;
               4                  sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
               4                       edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
               4              ]
               3              ELSE [
               4                  DO j=2,edge_number(iZ) [
               5                      IF( peig >= edge_energies(j,iZ) ) EXIT;
               5                  ]
               4                  sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
               4                          gle*edge_d(j,iZ) ));
               4                  sigma = Exp(sigma);
               4              ]
               3              sigma = sigma * pz(medium,k);
               3              sigtot = sigtot + sigma;
               3              probs(k) = sigma;
               3              ints(k) = j;
               3          ]
               2          $RANDOMSET br; br = br*sigtot;
               2          DO k=1,nne(medium) [
               3              br = br - probs(k);
               3              IF( br <= 0 ) EXIT;
               3          ]
               2          iZ = int( zelem(medium,k) + 0.5 );
               2          j  = ints(k);
               2      ]
               1      " Now we know the atomic number (iZ) and the energy interval the "
               1      " photon energy is in (j). It is time to sample the shell the photon "
               1      " is interacting with. "
               1      " left for now as before, to be changed!!! "
               1      IF( peig <= binding_energies($MXSHELL,iZ) )
               1      [   "Outer shells, no atomic relaxation"
               2             "EADL relax: Below  M2-shell -> just emit e- "
               2             iq(np) = -1;
               2             e(np) = peig + prm;
               2      ]
               1      ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
               2          $RANDOMSET br;
               2          DO k=1,$MXINTER [
               3              IF( peig > binding_energies(k,iZ) ) [
               4                  IF( br < interaction_prob(k,iZ) ) EXIT;
               4                  br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
               4              ]
               3          ]
               2          "Interaction possible with any shell from k=1 to $MXSHELL"
               2          "Defaults to $MXSHELL interaction if DO loop completes"
               2          "****************"
               2          "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
               2          "**************** from previous EGSnrc approach as it doesn't"
               2          "                 generate e- nor x-rays from <M> and <N> shells."
               2          IF (eadl_relax & k > 4)[
               3             "No initial vacancy below L3 for now, just emit e-"
               3             iq(np) = -1;
               3             e(np) = peig + prm;
               3          ]
               2          ELSE["EADL:    Interacts with K,L1..L3 shells"
               3               "default: Interacts with K,L1..L3,<M>, and <N> shells"
               3             e_vac = binding_energies(k,iZ);
               3             e(np) = peig - e_vac + prm; do_relax = .true.;
               3             iq(np) = -1;
               3          ]
               2      ]
               1  ]
               0  ELSE [
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  "****************"
               0  "EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
               0  "**************** but vacancies below L3 deposit energy locally. It wont"
               0  "                 produce x-rays from <M> and <N> shells."
               0  "IF ($EADL_RELAX & k > 4)[
               0  "   edep = e_vac; do_relax = .false.;
               0  "]
               0  IF( do_relax ) [
               1      call relax(e_vac,k,iZ);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  subroutine egs_shellwise_photo;
               0  "******************************************************************"
               0  " Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
               0  " Shellwise implementation and      "
               0  "                                sampling optimizations            "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0  ;COMIN/PE-SHELL-DATA/;
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0  $REAL slope, logE, int_prob;
               0  $INTEGER zpos, ibsearch;
               0  data n_warning/0/;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  do_relax = .false.;
               0  IF( peig < $RELAX-CUTOFF ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
               2                      peig,' which is below the current min. energy of ',
               2                     $RELAX-CUTOFF,' keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  edep = pzero;
               0
               0  IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
               1                          " sample element and atomic shell for"
               1     j = -1;              " the interaction."
               1     IF( nne(medium) = 1 ) [
               2      iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
               2      IF( pe_nshell(zpos) > 0) [
               3        logE = log(peig);
               3        j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3      ]
               2     ]
               1     ELSE [
               2        $RANDOMSET br; logE = log(peig);
               2        "DO k=1,nne(medium) ["
               2        DO k=nne(medium),1,-1 [
               3            iz = int(pe_zsorted(k,medium)+0.5); zpos = pe_zpos(iZ);
               3            IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                $egs_info(*,' Error in egs_shellwise_photo: ');
               4                $egs_fatal(*,'   Atomic number of element ',k,
               4                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4            ]
               3            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3            slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
               3            slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               3            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
               3            br -= exp(int_prob);
               3            IF ( br <= 0 ) EXIT;
               3        ]
               2     ]
               1     " Now we know the atomic number (iZ) and the energy interval the "
               1     " photon energy is in (j). It is time to sample the shell the photon "
               1     " is interacting with. "
               1     IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
               1     [   "no atomic relaxation, create photo-electron"
               2           iq(np) = -1;
               2           e(np) = peig + prm;
               2     ]
               1     ELSE ["sample the shell the photon is interacting with"
               2        $RANDOMSET br; sigtot = 0;
               2        DO k=1,pe_nshell(zpos) [
               3            IF( peig > pe_be(zpos,k) ) [
               4              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
               4              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               4              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
               4              br -= exp(int_prob); sigtot += exp(int_prob);
               4              IF ( br <= 0 ) EXIT;
               4            ]
               3        ]
               2        IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
               3           iq(np) = -1;
               3           e(np) = peig + prm;
               3        ]
               2        ELSE[
               3           e_vac = pe_be(zpos,k);
               3           e(np) = peig - e_vac + prm; do_relax = .true.;
               3           iq(np) = -1;
               3        ]
               2     ]
               1  ]
               0  ELSE ["No atomic relaxations, just create photo-electron"
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  IF( do_relax ) [
               1      call egs_eadl_relax(iZ,k);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_read_shellwise_pe;
               0  "*************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-SHELLWISE-PE-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,l,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  $REAL      rest_xs($MXNE,$MXELEMENT);
               0  $REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
               0  $REAL      new_e($MXNE),deltaEb,slope;
               0  $INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
               0  character  data_dir*128,pe_sw_file*144;
               0
               0  $INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
               0  real*4    egs_read_real,e_r, e_old,sigma_r;
               0  integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
               0  $LOGICAL  is_open, is_there, shift_required;
               0
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0              ' M1',' M2',' M3',' M4',' M5',
               0              ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0
               0
               0
               0  $egs_info('(/a$)',
               0  ' Reading renormalized photoelectric cross sections ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';
               0
               0
               0  pe_sw_unit = egs_get_unit(0);
               0  IF( pe_sw_unit < 1 ) [
               1    $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
               1  ]
               0  open(pe_sw_unit,file=pe_sw_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=1,
               0       err=:no-pe-sw-file:);
               0  GOTO :read-pe-sw:;
               0  :no-pe-sw-file:
               0  $egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
               0             pe_sw_file);
               0  :read-pe-sw:
               0  is_open = .true.;
               0
               0
               0
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [
               2        pe_nshell(i*medio) = 0;
               2        pe_nge(i*medio) = 0;
               2        pe_zsorted(i,medio) = 0;
               2     ]
               1  ]
               0  DO l = 1,$MXELEMENT [
               1     pe_zpos(l) = -1;
               1     DO k = 1,$MXNE [
               2        pe_energy(k,l) = 0.0;
               2        DO m = 1,$MXPESHELL [
               3           pe_xsection(k,l,m) = 0.0;
               3        ]
               2     ]
               1     DO k = 1,$MXPESHELL [
               2        pe_be(l,k) = -99;
               2     ]
               1  ]
               0
               0
               0
               0
               0  curr_rec = 1; iZpos = 0;
               0  nz = egs_read_short(pe_sw_unit,curr_rec);
               0  "$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,medio-1 [
               3           DO k = 1, nne(j)[
               4             IF( iZ = pe_zsorted(k,j) ) [
               5                 is_there = .true.; EXIT;
               5             ]
               4           ]
               3        ]
               2        IF (is_there) NEXT;
               2        "Read data for this element"
               2        iZpos += 1; zread(iZpos) = iZ;
               2        pe_zpos(iZ) = iZpos;
               2        pos         = 3 + (iZ-1)*4;
               2        curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
               2        i_nge       = egs_read_short(pe_sw_unit,curr_rec);
               2        i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
               2        "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
               2        "  ' energy points and ',i_nshell,' shells');
               2        pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
               2        e_old = -1.0; ish = 0;
               2        DO j = 1,i_nge[
               3           e_r = egs_read_real(pe_sw_unit,curr_rec);
               3           sigma_r = egs_read_real(pe_sw_unit,curr_rec);
               3           pe_energy(j,iZpos) = e_r;
               3           pe_xsection(j,iZpos,0) = sigma_r;
               3           rest_xs(j,iZpos) = sigma_r;
               3           DO k = 1, i_nshell[
               4              sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
               4              pe_xsection(j,iZpos,k) = sigma_r;
               4              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;
               4
               4           ]
               3           "Extract binding energies from the data base"
               3           IF (e_r - e_old < 1e-15)[
               4              pe_be(iZpos,i_nshell-ish) = e_r;
               4              ish += 1;
               4           ]
               3           e_old = e_r;
               3
               3        ]
               2        "DO k = 1, i_nshell[
               2        "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
               2        "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
               2        "]
               2
               2     ]
               1  ]
               0  pe_ne = iZpos;
               0  "$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');
               0
               0
               0
               0
               0
               0
               0  "$egs_info(*,' Adjusting cross sections to new binding energies ...');
               0  DO i=1,pe_ne[
               1     iZ = zread(i);
               1     IF (pe_nshell(i) = 0)[
               2        DO j=1,pe_nge(i)[
               3           pe_energy(j,i) =  log(pe_energy(j,i));
               3        ]
               2        NEXT;
               2     ]
               1     "Shift energy scale for different binding energy sets"
               1     DO l=1,pe_nshell(i)[
               2        IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
               3             shift_required = .true.;
               3             deltaEb = binding_energies(l,iZ)-pe_be(i,l);
               3             "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
               3             "           'Eb_p_',labels(l),' = ',pe_be(i,l),
               3             "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
               3             "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
               3             "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
               3             "          );
               3        ]
               2        ELSE[shift_required =.false.;]
               2        is_there = .false.;
               2        DO j=1,pe_nge(i)[
               3           tmp_e(j,l)  = pe_energy(j,i);
               3           tmp_xs(j,l) = pe_xsection(j,i,l);
               3           IF ( shift_required &
               3                pe_energy(j,i) => pe_be(i,l) )[
               4              tmp_e(j,l) += deltaEb;
               4              "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
               4              "Determine edge position in energy array"
               4              IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               5                 ib(l) = j; is_there = .true.;
               5              ]
               4              "Update new energy grid"
               4              IF (l = 1)[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4              "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
               4              ELSE IF(j < ib(l-1))[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4           ]
               3        ]
               2        pe_be(i,l) = binding_energies(l,iZ);
               2     ]
               1     "Re-compute sub-shell xsections for new energy grid new_e"
               1     "Not needed for K shell"
               1     DO l=2,pe_nshell(i)[
               2        DO j=1,pe_nge(i)[
               3           IF ( new_e(j) >= pe_be(i,l-1) )[
               4              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
               4              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
               4              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = log(tmp_xs(m,l));
               4              pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
               4           ]
               3        ]
               2     ]
               1     "Re-compute total xsections for new energy grid new_e"
               1     "$egs_info(*,'-> Z = ',iZ);"
               1     DO j=1,pe_nge(i)[
               2        IF ( j < ib(pe_nshell(i)))[
               3           new_e(j) = pe_energy(j,i);
               3        ]
               2        m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
               2        slope = log(rest_xs(m+1,i)/rest_xs(m,i));
               2        slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
               2        pe_xsection(j,i,0)  = log(rest_xs(m,i));
               2        pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
               2        pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,0) += pe_xsection(j,i,l);
               3        ]
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0));
               2     ]
               1     "Normalize shell cross sections to total for sampling"
               1     "and update energy grid of ith element."
               1     " Prepare for log/log interpolation."
               1     DO j=1,pe_nge(i)[
               2        pe_energy(j,i) =  log(new_e(j));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
               3        ]
               2     ]
               1  ]
               0
               0  $egs_info('(a/)',' done');
               0
               0  IF( is_open ) close(pe_sw_unit);
               0  return;
               0  end;
               0
               0
               0  "******************************************************************"
               0  SUBROUTINE RELAX(energy,n,iZ);
               0  "******************************************************************"
               0  " Subroutine to fill a vacancy in shell n, element iZ              "
               0  " by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
               0  " Transitions between K,L1,L2,L3,average M,average N are taken into"
               0  " account. Particles with energies above the transport cut-offs    "
               0  " (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
               0  " particles is stored in EDEP.                                     "
               0  " In this version a global cut-off of 1 keV applies                "
               0  "  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
               0  "  1 keV will still be absorbed locally (due to lack of data)      "
               0  "                                                                  "
               0  " Version 1:  I. Kawrakow, December 1998                           "
               0  "******************************************************************"
               0  implicit none;
               0
               0  " Input variables "
               0  "================="
               0  $INTEGER n,iZ;
               0  $REAL    energy;  "
               0
               0  $declare_write_buffer;
               0
               0  " Local variables "
               0  "================="
               0  REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
               0                              "relaxation cascade                    "
               0
               0  $INTEGER vac_array($MXVAC), "array with shell vacancies            "
               0           n_vac,             "current number of vacancies           "
               0           shell;             "current shell                         "
               0  $INTEGER final,finala,      "code of final state                   "
               0           final1,final2,     "two vacancies in the final state in   "
               0                              "the case of Auger transitions         "
               0           iql,               "particle charge                       "
               0           irl;               "present region"
               0  $INTEGER first_transition($MXINTER),
               0           last_transition($MXINTER);
               0                              "first and last transition for a given "
               0                              "shell in the list of all possible     "
               0                              "transitions                           "
               0  $INTEGER final_state($MXTRANS);
               0             " final_state(i) is the final atomic state                "
               0             " after transition i coded as follows:                    "
               0             "   * fluorescence - final_state is the shell number      "
               0             "                    of the new vacancy                   "
               0             "   * Coster-Kronig - final_state is the shell number     "
               0             "                     of the new vacancy + 10             "
               0             "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
               0             "             are the shell numbers of the 2 new vacancies"
               0
               0  $INTEGER k, np_old, ip, iarg;
               0  $REAL    e_array($MXVAC),   "array with vacancy energies           "
               0           Ei,Ef,             "initial,final binding energies        "
               0           Ex,                "kinetic energy of emitted particle    "
               0           eta,               "a random number                       "
               0           e_check,           "energy conservation check             "
               0           min_E,ekcut,pkcut,elcut; "cut-off energies  "
               0
               0  $REAL    xphi,yphi,xphi2,yphi2,rhophi2,
               0           cphi,sphi;         "for azimuthal angle selection"
               0
               0  " Global EGS4 variables "
               0  "======================="
               0  $COMIN-RELAX;
               0  ;COMIN/RELAX-USER/;
               0
               0  data first_transition/1,20,27,33,38/;
               0  data last_transition/19,26,32,37,39/;
               0  data final_state/ "See the final_state definition above"
               0           4,3,5,6,                           " K-shell fluorescence    "
               0           202,302,402,404,403,303,           " K-shell Auger           "
               0           502,503,504,602,603,604,           " K-shell Auger           "
               0           505,605,606,                       " K-shell Auger           "
               0           13,14,                             " L1 Coster-Kronig        "
               0           5,6,                               " L1 fluorescence         "
               0           505,605,606,                       " L1 Auger                "
               0           14,                                " L2 Coster-Kronig        "
               0           5,6,                               " L2 fluorescence         "
               0           505,605,606,                       " L2 Auger                "
               0           5,6,                               " L3 fluorescence         "
               0           505,605,606,                       " L3 Auger                "
               0           6,                                 " M  fluorescence         "
               0           606/;                              " M  Auger                "
               0
               0  save first_transition,last_transition,final_state; "to avoid problems with "
               0                                                     "non-static compiler options"
               0
               0  IF (eadl_relax)[
               1     call egs_eadl_relax(iZ,n);
               1     return;
               1  ]
               0
               0  IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"
               0
               0  iz_relax = iZ;
               0  irl = ir(np);
               0  ekcut = ecut(irl)-rm; pkcut = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  IF( energy <= min_E ) [
               1      edep = edep + energy;  "We assume that edep is zeroed "
               1                          "(or set to the appropriate value) in the routine "
               1                          "calling RELAX "
               1      edep_local = energy;
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return;
               1  ]
               0
               0  " Set-up the array of vacancies for the relaxation cascade "
               0  n_vac = 1; vac_array(n_vac) = n; np_old = np;
               0  e_check = 0; e_array(n_vac) = energy;
               0
               0  :START: LOOP[     "Until no  >N-shell vacancies"
               1
               1      shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;
               1
               1      IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
               2          edep = edep + Ei;
               2
               2          edep_local = Ei;
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1
               1      "Set the relax_user common block variables, IK March 22 2004"
               1      ish_relax = shell; u_relax = Ei;
               1      IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
               2          IF( Ei > ekcut ) [
               3              np = np + 1;
               3              $CHECK-STACK(np,'RELAX');
               3              e(np) = Ei + prm; iq(np) = -1;
               3              $TRANSFER PROPERTIES TO (np) FROM (np-1);
               3              $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
               3              eta = (1-eta)*(1+eta);
               3              IF( eta > 1e-20 ) [
               4                  eta = Sqrt(eta);
               4                  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               4                  u(np) = eta*cphi; v(np) = eta*sphi;
               4              ]
               3              ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               3              $AUSCALL($AUGERTRA);
               3          ]
               2          ELSE             [
               3              edep = edep + Ei;
               3
               3              edep_local = Ei;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1      " Sample transition number for this vacancy "
               1      $RANDOMSET eta;
               1      DO k=first_transition(shell),last_transition(shell)-1 [
               2          eta = eta - relaxation_prob(k,iZ);
               2          IF( eta <= 0 ) EXIT;
               2      ]
               1      final = final_state(k); finala = final;
               1      IF( final < 100 ) [
               2          IF( final < 10 ) [ "fuorescence"
               3              iql = 0; elcut = pkcut;
               3          ]
               2          ELSE             [ "Coster-Kronig"
               3              final = final - 10;
               3              iql = -1; elcut = ekcut;
               3          ]
               2          Ef = binding_energies(final,iZ);
               2          Ex = Ei - Ef;
               2          n_vac = n_vac + 1;
               2          vac_array(n_vac) = final;
               2          e_array(n_vac) = Ef
               2      ]
               1      ELSE [  "Auger"
               2          final1 = final/100; final2 = final - final1*100;
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final1;
               2          e_array(n_vac) = binding_energies(final1,iZ);
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final2;
               2          e_array(n_vac) = binding_energies(final2,iZ);
               2          iql = -1;
               2          Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
               2          elcut = ekcut;
               2      ]
               1      IF( Ex <= elcut ) [ "Below cut-off"
               2          edep = edep + Ex;
               2
               2          IF( finala <  10 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ]
               2          ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ]
               1      ELSE [
               2          np = np + 1;
               2          $CHECK-STACK(np,'RELAX');
               2          iq(np) = iql;
               2          IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
               2          $TRANSFER PROPERTIES TO (np) FROM (np-1);
               2          $RANDOMSET eta;
               2          eta = 2*eta - 1;
               2          w(np) = eta;
               2          eta = (1-eta)*(1+eta);
               2          IF( eta > 1e-20 ) [
               3              eta = Sqrt(eta);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = eta*cphi;
               3              v(np) = eta*sphi;
               3          ]
               2          ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               2          IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
               2          ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
               2          ELSE                    [ $AUSCALL($AUGERTRA);  ]
               2      ]
               1  ]
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_init_relax;
               0  "*************************************************************************"
               0  " Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
               0  " data base was originally created by I. Kawrakow to be used with C++ user"
               0  " codes. It has been re-created using 4 bytes integers instead of using   "
               0  " optimized integer sizes to save space. It is now about 34% larger (760K)"
               0  " than before (557K). Reason for this was that some compilers need a switch"
               0  " to get it to read binary files on byte at a time. This would have been a"
               0  " nuisance for users when configuring the already complex system.         "
               0  "                                                                        "
               0  " The final relaxation state from radiative transitions assumes C-style  "
               0  " array indexing and hence needs to be increased by 1.                   "
               0  " Similarly, for non-radiative transitions, there is need to increase the"
               0  " codified value of the two electron states by 65. The reason is that the"
               0  " two transition states are encoded as 64*state1+state2. Because of the C"
               0  " style indexing, state1 and state2 must be increased by 1, increasing the"
               0  " above codified value by 65.                                            "
               0  "                                                                        "
               0  "Shell information for all media elements stored in one-dimensional arrays:"
               0  "                                                                        "
               0  " ish              => absolute shell index (1...shell_ntot)              "
               0  " shell_be(ish)    => shell binding energy                               "
               0  " shell_type(ish)  => shell type according to EADL notation              "
               0  " shell_Z(ish)     => Z of shell element                                 "
               0  " shell_num(ish)   =>  relative shell position within one element        "
               0  " shell_ntot       => total number of shells for all media elements      "
               0  " relax_first(ish) => initial absolute relaxation position               "
               0  " relax_ntran(ish) => number of transitions                              "
               0  " shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
               0  "                                                                        "
               0  "Transition information for all shells also stored in one-dimensional arrays:"
               0  "                                                                         "
               0  " transition index itran runs from 1...relax_ntot                         "
               0  " relax_prob(itran)  => transition probabilities                          "
               0  " relax_atbin(itran) => holds the alias indices                           "
               0  " relax_state(itran) => final relaxation state:                           "
               0  "                       radiative: relative shell position                "
               0  "                   non-radiative: relative position of shells(64*sh1+sh2)"
               0  "                                                                         "
               0  "                              Originally coded by IK in a standalone code"
               0  "                          Modified for use with EGSnrc by EMH, June 2011 "
               0  "                          Corrected bugs and commented by EMH, April 2012"
               0  "*************************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  character  data_dir*128,relax_file*144;
               0
               0  $INTEGER  ish,medio,iZ,ntran;
               0  $REAL     Ec, Pc, tmp, min_be, sumw,Ex;
               0  $LOGICAL  is_open, is_there;
               0  $REAL     wtmp($MAXTRANS);
               0  $INTEGER  itmp($MAXTRANS);
               0
               0  integer*4 pos, curr_rec, sh_eadl;
               0  integer*4 nz, nshell, tr_type;
               0  integer*4 ttype;
               0  real*4    be_r, prob_r;
               0
               0
               0  DO iZ=1,$MXELEMENT[
               1   DO k=1,$MXESHLL[
               2     shell_eadl(iZ,k) = -1;
               2   ]
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  min_be = $RELAX-CUTOFF;
               0  $egs_debug('(a)',' ************ relax_init **************** ');
               0  $egs_debug('(a,f10.7)',
               0          ' Minimum binding energy requiring relaxation data: ',min_be);
               0
               0
               0
               0
               0  $egs_info('(/a)',' Reading EADL relaxation data ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  relax_file = $cstring(data_dir) // 'relax.data';
               0
               0
               0  relax_unit = egs_get_unit(0);
               0  IF( relax_unit < 1 ) [
               1     $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
               1  ]
               0  open(relax_unit,file=relax_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
               0       err=:no-relax-file:);
               0  GOTO :read-relax:;
               0  :no-relax-file:
               0  $egs_fatal('(2a)','egs_init_relax: failed to open ',
               0             relax_file);
               0  :read-relax:
               0  is_open = .true.;
               0
               0
               0
               0  curr_rec = 1;
               0  read(relax_unit,rec=curr_rec) nz;
               0  "$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
               0  shell_ntot = 0;relax_ntot = 0;
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,shell_ntot [
               3           IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
               3        ]
               2        IF (is_there) NEXT;
               2        pos = iZ + 1;
               2        read(relax_unit,rec=pos) curr_rec;
               2        read(relax_unit,rec=curr_rec) nshell;
               2        IF( shell_ntot + nshell > $MAXSHELL ) [
               3           $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
               3                  shell_ntot + nshell,' (at least).',
               3                  ' Increase the parameter $MAXSHELL and retry ');
               3        ]
               2        $egs_info('(a,i3,a,i2,a)',
               2        '  Z = ',iZ,' has ',nshell,' shells');
               2        DO ish=shell_ntot+1,shell_ntot+nshell[
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) shell_type(ish);
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) ntran;
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;
               3
               3          shell_Z(ish) = iZ;
               3          shell_num(ish) = ish - shell_ntot;
               3          shell_eadl(iZ,shell_num(ish)) = ish;
               3          IF (binding_energies(shell_num(ish),iZ) > 0)[
               4             shell_be(ish) = binding_energies(shell_num(ish),iZ);
               4          ]
               3          ELSE IF( photon_xsections = 'epdl' )[
               4            "Use binding energies from relax.data below 1 keV"
               4             binding_energies(shell_num(ish),iZ) = shell_be(ish);
               4          ]
               3          DO k=1,ntran[
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) itmp(k);
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
               4
               4
               4
               4              IF (itmp(k)<64) [itmp(k) +=1;]
               4              ELSE            [itmp(k) += 65;]
               4          ]
               3          IF( shell_be(ish) < min_be ) [
               4              relax_first(ish) = -1;
               4              relax_ntran(ish) = -1;
               4          ]
               3          ELSE [
               4              sumw = 0;
               4              DO k=1,ntran [  sumw = sumw + wtmp(k); ]
               4              IF( sumw > 1 ) [
               5                  DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
               5              ]
               4              ELSE IF( sumw < 1 ) [
               5                  ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
               5              ]
               4              IF( relax_ntot + ntran > $MAXRELAX ) [
               5                 $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
               5                   relax_ntot + ntran,' (at least).',
               5                   ' Increase $MAXRELAX and retry ');
               5              ]
               4              relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
               4              call prepare_alias_histogram(ntran,wtmp,
               4                                   relax_atbin(relax_ntot+1));
               4              DO k=1,ntran [
               5                 j = relax_ntot + k;
               5                 relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
               5              ]
               4              relax_ntot = relax_ntot + ntran;
               4          ]
               3        ]
               2
               2        shell_ntot = shell_ntot + nshell;
               2
               2     ]
               1
               1  ]
               0  $egs_debug('(a,i4,a)',' There are ',
               0          shell_ntot,' shells in the list of shells ');
               0  $egs_info('(a/)',' ...... Done.');
               0
               0
               0  IF( is_open ) close(relax_unit);
               0  return;
               0
               0  stop;
               0  end;
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_warning('(3(a,f10.6),a,i2)',
            {  0         'Evac = ',Evac, ' Ef = ',Ef,
            {  0         "' Z = ',iZ,' Nvac = ',Nvac,"
            {  0         ' min_E = ', min_E,' iq = ',iqf);
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0  "***********************************************************************"
               0    subroutine egs_eadl_relax(iZ, shell_egs);
               0  "************************************************************************"
               0  " Subroutine, called from subroutine relax, to fill a vacancy in         "
               0  " shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
               0  " and Coster-Kronig electrons.  Uses EADL data.                          "
               0  " Results passed via variables in comins.                                "
               0  "   edep                                                                 "
               0  "   edep_local                                                           "
               0  "   e(np)                                                                "
               0  "                                                                        "
               0  " There are calls to ausgab with IARG values                             "
               0  "   24  A fluorescent transition just occurred                           "
               0  "   26  An Auger transition just occurred                                "
               0  "   32  Sub-threshold fluorescent transition just occurred               "
               0  "   33  Sub-threshold Auger transition just occurred                     "
               0  "                                                                        "
               0  " There is an inconsistency in the binding energies (BE) as COMPT uses   "
               0  " different BE (incoh.data)                                              "
               0  "                                                                        "
               0  " Explain need to reduce new_state by 1 below as alias sampling provides "
               0  " bin number from 1...nbin and not 0...nbin-1                            "
               0  "                                                                        "
               0  "                             Originally coded by IK in a standalone code"
               0  "                         Modified for use with EGSnrc by EMH, June 2011 "
               0  "                         Corrected bugs and commented by EMH, April 2012"
               0  "************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-EADL;
               0  ;COMIN/RELAX-USER/;
               0
               0  $REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
               0           cost,sint,cphi,sphi;
               0  "Ec      ecut as k.e. for current region"
               0  "Pc      pcut for current region"
               0  "min_E   the minimum energy for transitions to continue"
               0  "rnno    a random number"
               0  "Evac    binding energy of current vacancy"
               0  "Ef      the sum of the binding energies of the new vacancies"
               0  "Ef1     the first new binding energy of for non-radiative transitions"
               0  "Ef2     the second new binding energy of for non-radiative transitions"
               0  "Ex      the change in total binding energy"
               0  "Ecc     the cutoff energy (Ec or Pc)"
               0  "cost,sint,cphi,sphi variables for calculating particle direction"
               0
               0  $INTEGER  shell, shell_egs, iZ, iarg;
               0  "shell       number in master eadl list"
               0  "shell_egs   shell number in current element"
               0  "iZ          atomic number of element"
               0
               0  $INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
               0  "irl           current region"
               0  "vacs($MAXVAC) array of vacancy shell numbers"
               0  "nvac          current number of vacancies in vacs"
               0  "vac           shell number of current vacancy"
               0  "new_state     the state number that represents the new vacancy"
               0  "iqf           the charge of the emitted relaxation particle"
               0  "np_save       the stack index of the particle inducing in relaxations"
               0  "new1          the first new vacancy for non-radiative transitions"
               0  "new2          the second new vacancy for non-radiative transitions"
               0
               0  $INTEGER sample_alias_histogram;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  shell = shell_eadl(iZ,shell_egs);
               0  IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"
               0
               0  irl = ir(np);
               0  Ec = ecut(irl) - rm;
               0  Pc = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
               0  "store some information in comin RELAX-FOR-USER.  This just duplicates"
               0  "various pieces of info so the user can access them."
               0  rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
               0  rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
               0  rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
               0  rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
               0  rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
               0  "
               0  "Local energy deposition for vacancies below L3 shell."
               0  "Added here for consistency in algorithm for as long as"
               0  "<M> and <N> shells considered instead of proper shells."
               0  "AUSGAB call should be updated when charge of particle"
               0  "creating vacancy becomes available."
               0  IF (shell_egs > 4 & ~mcdf_pe_xsections) [
               1      edep = Evac;        "add energy of vacancy to edep"
               1      edep_local = Evac;  "set value of edep_local to energy of vacancy"
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
               1  ]
               0
               0  vac = shell; Nvac = 0; np_save = np;
               0  LOOP [ "from here to end of routine over all vacancies created"
               1
               1      "check if energy of vacancy < cutoff OR no transitions from this shell"
               1      IF( Evac < min_E | relax_ntran(vac) < 1 ) [
               2          edep += Evac;         "add energy of vacancy to edep"
               2          edep_local = Evac;    "set value of edep_local to energy of vacancy"
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
               2      ]
               1
               1      "prepare_alias_histogram is called from subroutine egs_init_relax and"
               1      "sample_alias_histogram uses the array of bin probabilities and bin"
               1      "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
               1      "to return the bin which has been sampled, i.e. new_state"
               1      "relax_ntran(vac) tells how many transitions are available"
               1      new_state = sample_alias_histogram(relax_ntran(vac),
               1                    relax_prob(relax_first(vac)),
               1                    relax_atbin(relax_first(vac)));
               1      IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
               2                            "EADL was < 1. In this case the entire energy is"
               2                            "given to an electron and no new vacancy is created"
               2          Ef = 0;
               2          iqf = -1;
               2          Ecc = Ec;
               2      ]
               1      ELSE[
               2          new_state = relax_state(relax_first(vac)+new_state-1);
               2          IF( new_state <= 64 ) [ "It was a radiative transition (fluorescence)"
               3            iqf = 0;
               3            new_state += vac - shell_num(vac);
               3            Ef = shell_be(new_state);
               3            Nvac += 1;
               3            vacs(Nvac) = new_state;
               3            Ecc = Pc;
               3          ] "end of fluorescence block"
               2          ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
               3            iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
               3            new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
               3            Ef1 = shell_be(new1); Ef2 = shell_be(new2);
               3            Nvac += 1; vacs(Nvac) = new1;
               3            Nvac += 1; vacs(Nvac) = new2;
               3            Ef = Ef1 + Ef2; Ecc = Ec;
               3          ] "end Auger or Coster-Kronig block"
               2      ]
               1      Ex = Evac - Ef;
               1      edep_local = 0;
               1      IF( Ex > Ecc ) [
               2          np += 1; $CHECK-RELAX-STACK(np,'new_relax');
               2          iq(np) = iqf;
               2          $TRANSFER PROPERTIES TO (np) FROM (np_save);
               2          $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
               2          IF( sint > 0 ) [
               3              sint = sqrt(sint);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
               3          ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
               2          rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
               2          rfu_E = shell_be(vac);
               2          IF( iqf = 0 ) [
               3              e(np) = Ex; $AUSCALL($FLUORTRA);
               3          ]
               2          ELSE [
               3              e(np) = Ex + rm; $AUSCALL($AUGERTRA);
               3          ]
               2      ] ELSE [ "Ex <= Ecc"
               2          edep += Ex;
               2
               2          IF( iqf = 0 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ] ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ] "end Ex <= Ecc block"
               1      :VACANCY:;
               1      IF( Nvac = 0 ) EXIT;
               1      "get next vacancy to process"
               1      vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
               1  ] "end of main loop"
               0  return;
               0  end;
               0  ;
               0
               0  "***************************************************************************"
               0  "     Triplet production stuff                                              "
               0  "***************************************************************************"
               0
               0  REPLACE {$N_TRIPLET_DATA} WITH {55}
               0  REPLACE {$N_ELEMENT} WITH {100}
               0  ;
               0  subroutine init_triplet;
               0  implicit none;
               0  $declare_max_medium;
               0  $COMIN-INIT-TRIPLET;
               0  $REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
               0         sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
               0         sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
               0         as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
               0         ds($N_TRIPLET_DATA);
               0  character*128  triplet_data_file;
               0  $INTEGER want_triplet_unit, triplet_unit, triplet_out;
               0  $INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
               0  $REAL    logE, f_new, f_old, spline;
               0
               0  IF( itriplet = 0 ) return;
               0  $set_string(triplet_data_file,' ');
               0  triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
               0                      'triplet.data';
               0  want_triplet_unit = 63;
               0  triplet_unit = egs_get_unit(want_triplet_unit);
               0  IF( triplet_unit < 1 ) [
               1      $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
               1  ]
               0  open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
               0  $egs_info('(a,$)',' init_triplet: reading triplet data ... ');
               0  read(triplet_unit,*) ntrip;
               0  IF( ntrip > $N_TRIPLET_DATA ) [
               1      $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
               1  ]
               0  read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
               0  DO iel=1,$N_ELEMENT [
               1      read(triplet_unit,*);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_pair(iel,i),i=1,ntrip);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_triplet(iel,i),i=1,ntrip);
               1  ]
               0  $egs_info(*,'OK');
               0  ifirst = 0;
               0  DO i=1,ntrip [
               1      IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
               1      energies(i) = log(energies(i));
               1  ]
               0  log_4rm = log(4*rm);
               0  energies(ifirst-1) = log_4rm;
               0  dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
               0  dli_triplet = 1/dl_triplet;
               0  bli_triplet = 1 - log_4rm/dl_triplet;
               0
               0  DO imed = 1, nmed [
               1
               1      $egs_info('(a,i3,a,$)',
               1        '   Preparing triplet fraction data for medium ',imed,' ... ');
               1      iz1 = zelem(imed,1) + 0.1;
               1      DO i=1,ntrip [
               2          sigp(i) = pz(imed,1)*sig_pair(iz1,i);
               2          sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
               2          DO iel=2,nne(imed) [
               3              izi = zelem(imed,iel) + 0.1;
               3              sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
               3              sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
               3          ]
               2      ]
               1
               1      DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
               1      f_triplet(1) = 0;
               1      call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);
               1
               1      logE = log_4rm; f_old = 0;
               1      DO i=1, $MAX_TRIPLET-1 [
               2          logE = logE + dl_triplet;
               2          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
               2          a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
               2          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
               2          f_old = f_new;
               2      ]
               1      $egs_info(*,'OK');
               1
               1  ]
               0  close(triplet_unit);
               0  return;
               0
               0  :no-triplet-file:;
               0  $egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
               0               triplet_data_file(:lnblnk1(triplet_data_file)));
               0
               0  :error_triplet_data:;
               0  $egs_fatal(*,' init_triplet: error while reading triplet data ');
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE EDGSET(NREGLO,NREGHI);
               0  "******************************************************************"
               0  " SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
               0  " and proper handling of photo-electric absorption
               0  "******************************************************************"
               0  " Programmer:   I. Kawrakow, (NRC)                                 "
               0  "******************************************************************"
               0  "                                                                  "
               0  "  Input:  NREGLO and NREGHI, not needed but left there for        "
               0  "                             compatibility with older user codes  "
               0  "
               0  "  This routine is called from HATCH, it checks whether one of the "
               0  "  elements of IEDGFL has been set to an integer number between    "
               0  "  1 and 100 and if so reads in photo-absorption and relaxation    "
               0  "  data. Note that the array IEDGFL, which used to be the          "
               0  "  `effecvtive' atomic number of a medium is not used for any      "
               0  "  purpose other than to indicate that relaxations are requested   "
               0  "  (if non-zero).
               0  "******************************************************************"
               0  "                                                                  "
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EDGE,X-OPTIONS,EGS-IO/;
               0
               0  "Input variables"
               0  integer  NREGLO,NREGHI;
               0
               0  $INTEGER i,j,k,jj,iz;
               0  logical  do_relax;
               0  logical  got_data;
               0  save     got_data;
               0  data     got_data/.false./;
               0
               0  IF( got_data ) return;
               0     "EDGSET is now called from HATCH. In older user codes it was called
               0     "from within the user code. If this happens, and the data is already
               0     "available, we don't need to read it again. That's why the above
               0     "statement.
               0
               0  $egs_info('(a/,a)',
               0            'Output from subroutine EDGSET:',
               0            '==============================');
               0
               0  $need_relaxation_data(do_relax);
               0  IF( ~do_relax ) [
               1
               1      IF(eadl_relax)[
               2          $egs_fatal('(a,/a)',
               2                     'You must turn ON atomic relaxations when requesting',
               2                     'detailed atomic relaxation (eadl_relax=true)!');
               2      ]
               1      $egs_info('(a/)',' Atomic relaxations not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(a/)',' Atomic relaxations requested! ');
               0
               0  $egs_info('(a$)',' Reading simplified photo-absorption data .....');
               0
               0  got_data = .true.;
               0  rewind($PHOTOUNIT);
               0
               0  DO i=1,$MXELEMENT
               0  [
               1      IF (eadl_relax)[
               2         "Skip, using binding_energies from *_photo.data file
               2         read($PHOTOUNIT,*);
               2      ]
               1      ELSE[
               2         read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
               2         DO k=1,$MXSHELL [
               3            binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
               3         ]
               2      ]
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT
               0  [
               1      read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
               1      interaction_prob($MXSHELL,i)=1.01;
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  $egs_info('(/a$)',' Reading simplified relaxation data .....');
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
               1  ]
               0  $egs_info('(a)',' Done');
               0  $egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
               0  rewind($PHOCSUNIT);
               0  DO i=1,$MXELEMENT [
               1      read($PHOCSUNIT,*) j,edge_number(i);
               1      DO j=1,edge_number(i) [
               2          read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
               2                             edge_d(j,i),edge_energies(j,i);
               2      ]
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  IF (eadl_relax)[
               1   call egs_init_relax;
               1  ]
               0
               0  RETURN;
               0  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PHOTON(IRCODE);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE; "1 => normal return"
               0
               0  $COMIN-PHOTON;   "default replacement produces the following:
               0                   "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
               0                   "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PHOTON;
               0
               0
               0  IRCODE=1;"set up normal return"
               0  PEIG=E(NP);
               0  EIG=PEIG; "energy of incident gamma"
               0  IRL=IR(NP);
               0  $start_new_particle;
               0
               0  IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               0
               0  :PNEWENERGY:
               0  LOOP["enter this loop for each photon with new energy"
               1
               1  IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"
               1
               1  GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"
               1
               1  "   here to sample no. mfp to transport before interacting"
               1
               1  $SELECT-PHOTON-MFP;
               1  " DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
               1  "                                      DPMFP=-LOG(RNNO35);"
               1  "NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
               1  "       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."
               1
               1  IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"
               1
               1  :PNEWMEDIUM:
               1  LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
               2  IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
               3  $EVALUATE GMFPR0 USING GMFP(GLE);]
               2
               2  :PTRANS:
               2  LOOP["PHOTON TRANSPORT LOOP"
               3  IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
               3  ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
               4  GMFP=GMFPR0/RHOF;
               4  $RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
               4  "Ali:photonuc, 1 line"
               4  $PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
               4  TSTEP=GMFP*DPMFP;]
               3  "   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
               3  IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
               3  IDISC=0;"ASSUME PHOTON NOT DISCARDED"
               3  USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
               3  TUSTEP=USTEP;
               3
               3  "IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
               3  $CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"
               3
               3
               3  "   NOW CHECK FOR USER DISCARD REQUEST"
               3  IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
               4  GO TO :USER-PHOTON-DISCARD:;]
               3
               3  VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
               3  TVSTEP=VSTEP;
               3  EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"
               3
               3  x_final = x(np) + u(np)*vstep;
               3  y_final = y(np) + v(np)*vstep;
               3  z_final = z(np) + w(np)*vstep;
               3
               3  $AUSCALL($TRANAUSB);
               3
               3  "   TRANSPORT THE PHOTON"
               3  x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3  DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
               3  IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
               3  IROLD=IR(NP); "SAVE PREVIOUS REGION"
               3
               3  MEDOLD=MEDIUM;
               3  IF (IRNEW.NE.IROLD) ["REGION CHANGE"
               4    $photon_region_change;
               4  ]
               3
               3  "   AFTER TRANSPORT CALL TO USER"
               3  $AUSCALL($TRANAUSA);
               3  "oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
               3  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               3
               3  "   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
               3  "   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
               3  IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;
               3
               3  IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;
               3
               3  IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
               4  EXIT :PNEWMEDIUM:;]
               3  ]REPEAT ":PTRANS: LOOP"
               2
               2  ]REPEAT ":PNEWMEDIUM: LOOP"
               1
               1
               1  "   IT IS FINALLY TIME TO INTERACT."
               1  "   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
               1  $RAYLEIGH-SCATTERING;
               1  "Ali:photonuclear, 1 line"
               1  $PHOTONUCLEAR;
               1  $RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
               1  "   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
               1  $EVALUATE GBR1 USING GBR1(GLE);
               1  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
               2      $AUSCALL($PAIRAUSB);
               2      CALL PAIR;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PAIR;
               2      $AUSCALL($PAIRAUSA);
               2      IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
               2      ELSE [ "this may happen if pair electrons killed via Russian Roulette"
               3          goto :PAIR-ELECTRONS-KILLED:;
               3      ]
               2  ]
               1  "GBR2=(PAIR+COMPTON)/GTOTAL"
               1  $EVALUATE GBR2 USING GBR2(GLE);
               1  IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
               2      $AUSCALL($COMPAUSB);
               2      CALL COMPT;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-COMPT;
               2      $AUSCALL($COMPAUSA);
               2      IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
               2  ]
               1  ELSE["IT WAS PHOTOELECTRIC EFFECT"
               2      $AUSCALL($PHOTOAUSB);
               2      CALL PHOTO;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PHOTO;
               2      IF (NP = 0 | NP < NPOLD ) [RETURN;]
               2        "The above may happen if Russian Roulette is on"
               2        "NP<NPOLD means that only electrons were created in the interaction"
               2        "and that all of them were killed. Hence, the top particle on the "
               2        "stack is from a previous interaction and may be in another region"
               2        "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
               2        "a return to shower so that ELECTR or PHOTON are properly re-entered."
               2        "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
               2        "wrong dose with brems splitting and Russian Roulette on in a low "
               2        "energy calculation."
               2
               2      $AUSCALL($PHOTOAUSA);
               2      IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
               2  ] "END OF PHOTO ELECTRIC BLOCK"
               1
               1  :PAIR-ELECTRONS-KILLED:
               1
               1  "   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
               1  PEIG=E(NP);
               1  EIG=PEIG;
               1  IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
               1  ]REPEAT ":PNEWENERGY: LOOP"
               0
               0  "   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "PHOTON CUTOFF ENERGY DISCARD SECTION         "
               0  "---------------------------------------------"
               0  :PCUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
               1  ] ELSE [ IDR=$EGSCUTAUS; ]
               0  EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
               0  $PHOTON-TRACK-END;
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "User requested photon discard section        "
               0  "---------------------------------------------"
               0  :USER-PHOTON-DISCARD:
               0  EDEP=PEIG;
               0  $AUSCALL($USERDAUS);
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "END OF SUBROUTINE PHOTON"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  $REAL EI,      "initial shower energy"
               0        XI,YI,ZI,"initial co-ordinates"
               0        UI,VI,WI,"initial direction cosines"
               0        WTI;     "initial weight"
               0
               0  $INTEGER
               0        IQI,     "initial particle charge"
               0        IRI;     "initial region number"
               0
               0  "Local variables"
               0  DOUBLE PRECISION
               0        DEG,    "energy for pi-zero option"
               0        DPGL,   "angle factor for pi-zero option"
               0        DEI,    "incident energy for pi-zero option"
               0        DPI,    "intermediate factor for pi-zero option"
               0        DCSTH,  "random number for pi-zero option"
               0        DCOSTH, "cos(theta) for pi-zero option"
               0        PI0MSQ; "pi-zero mass squared (in MeV**2)"
               0
               0  $REAL DNEARI, "initial distance to closest boundary"
               0        CSTH;   "random number for pi-zero option"
               0
               0  $INTEGER
               0        IRCODE; "status returned by ELECTR or PHOTON"
               0
               0  DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"
               0
               0  NP=1; NPold = NP;      "Set the old stack counter"
               0  DNEARI=0.0;
               0  IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
               0  $TRANSFER PROPERTIES TO (1) FROM I;
               0
               0  IF (IQI = 2) ["PI-ZERO OPTION"
               1    "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
               1    "                  noted by      Dr.  Muroyama at Nagoya University
               1    IF(EI**2 <= PI0MSQ) [
               2       $egs_fatal('(//a/,a,g15.5,a)',
               2       ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
               2       ' but the total energy was too small (EI=',EI,' MeV)');
               2    ]
               1    $RANDOMSET CSTH;
               1    DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
               1    DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(1)=0; E(1)=DEG/2.;
               1    CALL UPHI(2,1);
               1    NP=2;
               1    DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(2)=0; E(2)=DEG/2.;
               1    CALL UPHI(3,2);
               1  ]"end of pi-zero option"
               0
               0  LOOP [
               1      ;
               1      IF( np <= 0 ) EXIT;
               1      IF( iq(np) = 0 ) [ call photon(ircode); ]
               1      ELSE             [ call electr(ircode); ]
               1
               1  ]
               0
               0  RETURN;
               0  "end of subroutine shower"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE UPHI(IENTRY,LVL);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
               0  "   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
               0  "   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
               0  "   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  integer  IENTRY,LVL; "entry switches"
               0
               0  "Local variables"
               0  $REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
               0        RNNO38, "random number for azimuthal angle selection"
               0        PHI,    "azimuthal scattering angle"
               0        CPHI,   "5/2*pi-PHI"
               0        A,B,C,  "direction cosines before rotation"
               0        SINPS2, "SINPS2=A*A+B*B"
               0        SINPSI, "Sqrt(SINPS2)"
               0        US,VS,  "x- and y- component of scattering vector"
               0        SINDEL,COSDEL;
               0                "aux. variables for the rotation algorithm"
               0
               0  $INTEGER
               0        IARG,   "index for AUSGAB"
               0        LPHI,LTHETA,LCTHET,LCPHI;
               0                "indeces for sine table"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0  save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;
               0
               0  $AUSCALL($UPHIAUSB);
               0  GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
               0  "   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;
               0
               0  :UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
               0          "TABLE LOOK-UP"
               0  $SET INTERVAL THETA,SINC;
               0  $EVALUATE SINTHE USING SIN(THETA);
               0  CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
               0  $EVALUATE COSTHE USING SIN(CTHET);
               0
               0  "   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
               0  "   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
               0  "   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
               0  "   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "
               0
               0  :UPHI2:;
               0
               0  " It is much faster to use the box method for azimuthal angle selection"
               0  " than the following                                                   "
               0  " $RANDOMSET RNNO38;
               0  " PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
               0  " $EVALUATE SINPHI USING SIN(PHI);
               0  " CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
               0  " $EVALUATE COSPHI USING SIN(CPHI);
               0  $SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);
               0
               0  "   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
               0  "   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
               0  "   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
               0  "   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
               0  "   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
               0  "   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
               0  "   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
               0  "   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
               0  "   SO THAT IT CAN BE USED ON BOTH CALLS."
               0
               0  "   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
               0  "   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
               0  "   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
               0  "   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."
               0
               0  :NRK:
               0  GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
               0  "   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;
               0
               0  :OLD-PARTICLE:
               0  A=U(NP);B=V(NP);C=W(NP);
               0  GO TO :ADJUST:;
               0
               0  :BREMS-GAMMA:
               0  A=U(NP-1);B=V(NP-1);C=W(NP-1);
               0
               0  :NEW-PARTICLE:
               0  $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
               0
               0  "   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
               0  "   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
               0  "   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "
               0
               0  :ADJUST:
               0  SINPS2=A*A+B*B;
               0  "   If SINPS2 is small, no rotation is needed    "
               0  IF (SINPS2.LT.1.0E-20)["small polar angle case"
               1     U(NP)=SINTHE*COSPHI;
               1     V(NP)=SINTHE*SINPHI;
               1     W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
               1  ] "end small polar angle case"
               0  ELSE["large polar angle case"
               1     SINPSI=SQRT(SINPS2);
               1     US=SINTHE*COSPHI;
               1     VS=SINTHE*SINPHI;
               1     SINDEL=B/SINPSI;
               1     COSDEL=A/SINPSI;
               1     U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
               1     V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
               1     W(NP)=-SINPSI*US+C*COSTHE;
               1  ]"end large polar angle case"
               0
               0  $AUSCALL($UPHIAUSA);
               0
               0  RETURN;
               0
               0  :ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
               0  $egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);
               0
               0  "END OF SUBROUTINE UPHI"    END;
               0
               0  ;
1              0  %E
               0  "*************************************************************************
               0  "
               0  " The following is a set of macros and subroutines that implement
               0  " bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
               0  " (which are the basis for ICRU radiative stopping powers, into the
               0  " EGSnrc environment) or the NRC cross sections, which are essentially
               0  " the same as NIST, but with corrections to the electron-electron
               0  " contribution (corrections are only significant for low values of
               0  " atomic number Z and low values of the emitted photon energy k.
               0  "
               0  " In order to use it, you have to `turn on' this option by
               0  " setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
               0  " original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
               0  " data (nrc_brems.data).
               0  "
               0  " If this option is turned on, subroutine HATCH will call
               0  " subroutine init_nist_brems.
               0  " In init_nist_brems the NIST cross sections are read in,
               0  " total bremsstrahlung cross sections are calculated using
               0  " 64 point Gauss-Legendre quadrature, the interpolation arrays
               0  " that are used for total cross sections and brems fraction interpolations
               0  " (esig0, esig1, ebr10, ebr11               for electrons)
               0  " (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
               0  " are updated and alias sampling tables for rapid sampling of brems
               0  " energies are created. These alias sampling tables are then used
               0  " during the simulation in subroutine BREMS.
               0  " Be aware that there is a slight inconsistency when using this option
               0  " as resttricted radiative stopping powers used are the ones coming
               0  " from PEGS and so, they are calculated using Bethe-Heitler.
               0  " This will not matter at all if
               0  "   - AP is much smaller than the electron energy
               0  "       and/or
               0  "   - the restricted radiative stopping power is much smaller
               0  "     then the restricted collision stopping power
               0  " Both conditions are usually satisfied.
               0  "
               0  " I. Kawrakow, NRC, January 2000.
               0  "
               0  " Added NRC brems cross-sections
               0  " F. Tessier, NRC, August 2007.
               0  "
               0  "****************************************************************************
               0
               0  subroutine init_nist_brems;
               0  "**************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL    energy_array($MXBREN),x_array($MXBRXX),
               0           cs_array($MXBREN,$MXBRXX,$MXBREL);
               0  $REAL    xi_array($MXBRXX);
               0  real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);
               0
               0  $INTEGER nmix,kmix,i,n,k,j,ii;
               0  $INTEGER ngauss,i_gauss;
               0  $INTEGER lnblnk1,egs_get_unit;
               0  $INTEGER ifirst,ilast,nener,neke,leil;
               0
               0  $REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
               0  $REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
               0  $REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
               0  $REAL    Z,sumA;
               0  $REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
               0  $REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
               0           sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
               0  $INTEGER iz;
               0  $REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
               0  $INTEGER ndat,k_max_error;
               0  character tmp_string*512, tmp1_string*512;
               0  integer  itmp;
               0
               0  $declare_write_buffer;
               0
               0  $REAL amu;
               0  parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
               0                                "to cm^2/g"
               0  $LOGICAL ex,is_opened;
               0  $declare_max_medium;
               0  $COMIN-INIT-NIST-BREMS;
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  IF( ibr_nist = 1 ) [
               1      $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE [
               1      $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
            '  1      ibr_nist = ', ibr_nist);
               1  ]
               0
               0  "Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
               0  "
               0  rewind($NIST-DATA-UNIT);
               0  read($NIST-DATA-UNIT,*);
               0  read($NIST-DATA-UNIT,*) nmix,kmix;
               0  IF (kmix > $MXBRXX) [
               1      $egs_fatal(*,' init_nist_brems: to many k values in data file!');
               1  ]
               0  IF (nmix > $MXBREN) [
               1      $egs_fatal(*,' init_nist_brems: to many T values in data file!');
               1  ]
               0
               0  read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
               0  DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
               0  read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
               0  read($NIST-DATA-UNIT,*);
               0  DO i=1,$MXBREL [
               1      read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
               1  ]
               0  close($NIST-DATA-UNIT);
               0
               0  DO k=1,kmix [
               1      xi_array(k)=Log(1-x_array(k)+1e-6);
               1      IF( fool_intel_optimizer ) [
               2          $egs_info(*,'xi_array(k): ',xi_array(k));
               2      ]
               1  ]
               0
               0  "Get abscissas and weights for Gauss-Legendre quadrature"
               0  "
               0  ngauss = $MXGAUSS;
               0  call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);
               0
               0  "Calculate total brems cross sections and sampling tables"
               0  "for all media                                           "
               0
               0  $egs_info(*,' ');
               0  IF (ibr_nist = 1) [
               1  $egs_info(*,'Using NIST brems cross sections! ');
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $egs_info(*,'Using NRC brems cross sections! ');
               1  ]
               0  $egs_info(*,' ');
               0  DO medium=1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      $egs_info(*,' Initializing brems data for medium ',medium,'...');
               1      emin = max(ae(medium) - rm, ap(medium));
               1      DO i=1,nmix [
               2          IF( energy_array(i) >= emin ) EXIT;
               2      ]
               1      ifirst = i;
               1      DO i=nmix,1,-1 [
               2          IF( energy_array(i) < ue(medium) - rm ) EXIT;
               2      ]
               1      ilast = i+1;
               1      IF( ifirst < 1 | ilast > nmix ) [
               2          $egs_info(*,' init_nist_brems: data available only for ');
               2          $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
               2          $egs_info(*,' will use spline interpolations to get cross ');
               2          $egs_info(*,' sections beyond the available data but this may');
               2          $egs_info(*,' produce nonsense!');
               2          IF( ifirst < 1 ) ifirst=1;
               2          IF( ilast > nmix ) ilast = nmix;
               2      ]
               1      DO i=ifirst,ilast [
               2          ii = i+1 - ifirst;
               2          ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
               2          sumA = 0;
               2          DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
               2          sumA = sumA*amu;
               2          DO k=1,kmix [
               3              cs(ii,k) = 0;
               3              DO j=1,NNE(medium) [
               4                  Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
               4                  cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
               4              ]
               3              csx(k) = Log(cs(ii,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " Integrate
               2          "
               2          cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
               2          DO i_gauss = 1,ngauss [
               3              xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
               3              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               3              cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
               3          ]
               2      ]
               1      nener = ilast - ifirst + 1;
               1      call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
               1      "
               1      " Now replace the PEGS cross sections "
               1      "
               1      neke = meke(medium);
               1      sigee = 1E-15; sigep = 1E-15;
               1      DO i = 1,neke [
               2          eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
               2          leil = i;
               2          beta2 = ei*(ei+2*rm)/(ei+rm)**2;
               2          IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
               2          ELSE [
               3              sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
               3              sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
               3          ]
               2          $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
               2          $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
               2                                           " then the brems cross section "
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( i > 1 ) [
               3              si_esig = si1_esig;
               3              si_ebr1 = si1_ebr1;
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3              esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
               3              esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
               3              ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
               3              ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3          ]
               2
               2          "
               2          " Positrons "
               2          "
               2          $EVALUATE sigt USING psig(eil);
               2          $EVALUATE ebr1 USING pbr1(eil);
               2          $EVALUATE ebr2 USING pbr2(eil);
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( ebr2 > 1 ) ebr2 = 1;
               2          IF( ebr2 < 0 ) ebr2 = 0;
               2          sig_bhabha = sigt*(ebr2 - ebr1);
               2          IF( sig_bhabha < 0 ) sig_bhabha = 0;
               2          IF( i > 1 ) [
               3              si_psig = si1_psig;
               3              si_pbr1 = si1_pbr1;
               3              si_pbr2 = si1_pbr2;
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3              psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
               3              psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
               3              pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
               3              pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
               3              pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
               3              pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3          ]
               2          $EVALUATE ededx USING ededx(eil);
               2          sige = si1_esig/ededx;
               2          IF( sige > sigee ) sigee = sige;
               2          $EVALUATE ededx USING pdedx(eil);
               2          sige = si1_psig/ededx;
               2          IF( sige > sigep ) sigep = sige;
               2      ]
               1      esig1(neke,medium) = esig1(neke-1,medium);
               1      esig0(neke,medium) = esig0(neke-1,medium);
               1      ebr11(neke,medium) = ebr11(neke-1,medium);
               1      ebr10(neke,medium) = ebr10(neke-1,medium);
               1      psig1(neke,medium) = psig1(neke-1,medium);
               1      psig0(neke,medium) = psig0(neke-1,medium);
               1      pbr11(neke,medium) = pbr11(neke-1,medium);
               1      pbr10(neke,medium) = pbr10(neke-1,medium);
               1      pbr21(neke,medium) = pbr21(neke-1,medium);
               1      pbr20(neke,medium) = pbr20(neke-1,medium);
               1      $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
               1      esig_e(medium) = sigee; psig_e(medium) = sigep;
               1      IF( sigee > esige_max ) esige_max = sigee;
               1      IF( sigep > psige_max ) psige_max = sigep;
               1
               1      "
               1      " Now prepare the arrays for brems sampling
               1      "
               1      nb_emin(medium) = energy_array(ifirst);
               1      IF( nb_emin(medium) <= ap(medium) ) [
               2          nb_emin(medium) = energy_array(ifirst+1);
               2      ]
               1      nb_emax(medium) = energy_array(ilast);
               1      nb_lemin(medium) = log(nb_emin(medium));
               1      nb_lemax(medium) = log(nb_emax(medium));
               1      nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
               1      nb_dlei(medium) = 1/nb_dle(medium);
               1      "
               1      eil = nb_lemin(medium) - nb_dle(medium);
               1      DO i=1,$MXBRES [
               2          eil = eil + nb_dle(medium); ei = exp(eil);
               2          DO ii=1,nener [
               3              IF( ei < ee(ii) ) EXIT;
               3          ]
               2          ii = ii-1;
               2          IF( ii < 1) ii = 1;
               2          IF( ii > nener-1 ) ii = nener-1;
               2          "
               2          " ple and qle are energy interpolation coefficients
               2          "
               2          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
               2          DO k=1,kmix [
               3              csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " fill the abscissas for this energy
               2          "
               2          x = ap(medium)/ei; aux = -log(x);
               2          xi = log(1 - x+1e-6);
               2          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               2          nb_xdata(0,i,medium) = 0;
               2          nb_fdata(0,i,medium) = exp(res);
               2
               2          DO k=1,kmix [
               3              IF( x_array(k) > x ) EXIT;
               3          ]
               2          IF( k > kmix ) k = kmix;
               2          ndat = 0;
               2          DO j=k+1,kmix-1 [
               3              ndat = ndat+1;
               3              nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
               3              nb_fdata(ndat,i,medium) = exp(csx(j));
               3              IF( fool_intel_optimizer ) [
               4                  $egs_info(*,'nb_xdata(ndat,i,medium): ',
               4                          nb_xdata(ndat,i,medium));
               4              ]
               3          ]
               2          ndat = ndat+1;
               2          nb_xdata(ndat,i,medium) = 1;
               2          nb_fdata(ndat,i,medium) = exp(csx(kmix));
               2          "
               2          " Now expand the arrays by filling intermediate points
               2          " at the positions that show the maxium relative error
               2          " when using linear interpolation in x.
               2          " If arrays were allocated dynamically one could use
               2          " a certain condition to stop the iteration but in our case
               2          " memory is allocated anyway and so we use the maximum
               2          " space provided
               2          "
               2          IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
               2          LOOP [
               3              x_max_error = 0; f_max_error = 0; k_max_error = 0;
               3              max_error = 0;
               3              DO k=0,ndat-1 [
               4                  x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
               4                  f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
               4                  xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
               4                  res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               4                  res = exp(res);
               4                  error = abs(1-f/res);
               4                  IF( error > max_error ) [
               5                      x_max_error = x;
               5                      f_max_error = res;
               5                      max_error = error;
               5                      k_max_error = k;
               5                  ]
               4              ]
               3              ndat = ndat+1;
               3              DO k=ndat,k_max_error+2,-1 [
               4                  nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
               4                  nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
               4              ]
               3              nb_xdata(k_max_error+1,i,medium) = x_max_error;
               3              nb_fdata(k_max_error+1,i,medium) = f_max_error;
               3          ] UNTIL (ndat = $MXBRXS);
               2
               2          :SKIP-LOOP:
               2          "
               2          " Now generate the alias tables for rapid brems sampling
               2          " during run time
               2          "
               2          call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               2                 nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));
               2
               2      ]
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,' ');
               0  return;
               0  " Errors "
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0  return;
               0  end;
               0
1              0  %E
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine init_nrc_pair;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  character     nrcp_file*256, endianess*4;
               0  integer       egs_get_unit;
               0  $INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
               0  $INTEGER      i, lnblnk1;
               0  $REAL         tmp, ddx, xx, Z;
               0  real*4        emin, emax;
               0  integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
               0  REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
               0  character     endian, cdum($cdum_size);
               0  $LOGICAL      swap;
               0  real*4        tmp_4, tarray($NRC-PAIR-NXX);
               0  integer*4     itmp_4;
               0  character     c_4(4), ic_4(4);
               0  equivalence   (tmp_4,c_4), (itmp_4, ic_4);
               0
               0  $set_string(nrcp_file,' ');
               0  nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
               0  want_nrcp_unit = 62;
               0  nrcp_unit = egs_get_unit(want_nrcp_unit);
               0  IF( nrcp_unit < 1 ) [
               1      $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
               1  ]
               0
               0  rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
               0  open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
               0          status='old',recl=rec_length,err=:nrcp-open-error:);
               0  read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
               0  IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
               1      tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
               1      itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
               1      itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
               0  $egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
               0  IF( nb ~= $NRC-PAIR-NXX ) [
               1      $egs_fatal(*,'Inconsistent x-grid size');
               1  ]
               0  IF( ne ~= $NRC-PAIR-NEE ) [
               1      $egs_fatal(*,'Inconsistent energy grid size');
               1  ]
               0  nrcp_emin = emin; nrcp_emax = emax;
               0  nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;
               0
               0  nbb = nb/2; ddx = sqrt(0.5)/nbb;
               0  DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
               0  do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO ie=1,$NRC-PAIR-NEE [
               2          DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
               2      ]
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*Z;
               2          irec = (iz-1)*ne + 2;
               2          DO ie=1,$NRC-PAIR-NEE [
               3              read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
               3              DO ix=1,$NRC-PAIR-NXX [
               4                  tmp_4 = tarray(ix);
               4                  IF( swap ) [ call egs_swap_4(c_4); ]
               4                  nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
               4              ]
               3              irec = irec + 1;
               3          ]
               2      ]
               1      DO ie=1,$NRC-PAIR-NEE [
               2          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
               2                  nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
               2      ]
               1
               1      $egs_info('(a)',' done');
               1
               1  ]
               0  $egs_info(*,' ');
               0  close(nrcp_unit);
               0  return;
               0
               0  :nrcp-open-error:;
               0  $egs_fatal(*,'Failed to open NRC pair data file');
               0
               0  :nrcp-read-error:;
               0  $egs_fatal(*,'I/O error while reading NRC pair data file');
               0
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  "                                                                  "
               0  subroutine vmc_electron(ircode);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   This subroutine performs condensed history simulation of       "
               0  "   electron/positron transport according to VMC                   "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Initial coding               "
               0  "                                     coding is in EGSnrc style    "
               0  "                                     for maximum compatibility    "
               0  "                                     with EGSnrc user codes       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  $INTEGER ircode;
               0  $egs_fatal('(//a//)',
               0  ' ********* VMC Transport option not in this distribution ****** ');
               0  end;
               0
               0  " Subroutine versions of the random number generator "
               0  " Included here because it makes life easier for using the EGSnrc RNG"
               0  " from within the C-interface. "
               0  subroutine egs_init_default_rng;
               0  ;COMIN/RANDOM/;
               0  $RNG-DEFAULT-INITIALIZATION;
               0  return; end;
               0
               0  subroutine egs_init_rng(arg1,arg2);
               0  $INTEGER arg1,arg2;
               0  ;COMIN/RANDOM/;
               0  $declare_write_buffer;
               0  $INITIALIZE RNG USING arg1 AND arg2;
               0  return; end;
               0
               0  subroutine egs_get_rndm(ran);
               0  $REAL ran;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET ran;
               0  return; end;
               0
               0  subroutine egs_get_rndm_array(n,rarray);
               0  $INTEGER n;
               0  $REAL    rarray(*);
               0  ;COMIN/RANDOM/;
               0  $REAL    rtmp;
               0  $INTEGER i;
               0  IF( n < 1 ) return;
               0  DO i=1,n [
               1      $RANDOMSET rtmp; rarray(i) = rtmp;
               1  ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "**************************************************************************"
               0  "Init EII. This subroutine is called from HATCH after all media are known, "
               0  "threshold energies and interpolation data have been initialized.          "
               0  "**************************************************************************"
               0  subroutine eii_init;
               0  "**************************************************************************"
               0  implicit none;
               0  $COMIN-EII-INIT;
               0  $INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
               0  $INTEGER jj,jjj;
               0  integer*4 lnblnk1;
               0  $INTEGER tmp_array($MXELEMENT);
               0  $INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
               0  integer  egs_get_unit;
               0  $REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
               0  $REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
               0  $REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
               0  $REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
               0  $REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
               0  $REAL    sigma,sigma_old,wbrem_old,sig_j,de;
               0  $INTEGER lloge;
               0  $LOGICAL check_it,is_monotone,getd;
               0  $REAL    sigma_max;
               0  character eii_file*128;
               0  character*512 toUpper;
               0  $INTEGER occn_numbers(4);
               0  $declare_write_buffer;
               0  $REAL    cons;
               0  parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
               0  data     occn_numbers/2,2,2,4/;
               0
               0  DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
               0  DO j=1,$MXMED [ eii_nsh(j) = 0; ]
               0  IF( eii_flag = 0 ) [ return; ]
               0
               0  $need_relaxation_data(getd);
               0  IF( ~getd )[
               1    $egs_fatal('(/a,/a,/a,/a)',
               1            ' In subroutine eii_init: ',
               1            '   Scattering off bound electrons creates atomic vacancies,',
               1            '   potentially starting an atomic relaxation cascade. ',
               1            '   Please turn ON atomic relaxations.');
               1  ]
               0
               0
               0
               0
               0  e_eii_min = 1e30;
               0  DO imed = 1,nmed [
               1      IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
               1      IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      DO iele = 1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          IF( eii_nshells(iZ) = 0 ) [
               3              nsh = 0;
               3              DO ish=1,4 [
               4                  IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
               4              ]
               3              eii_nshells(iZ) = nsh;
               3          ]
               2      ]
               1  ]
               0
               0
               0  nsh = 0;
               0  DO iZ=1,$MXELEMENT [
               1      nsh = nsh + eii_nshells(iZ);
               1  ]
               0  IF( nsh = 0 ) [
               1      $egs_info(*,'*** EII requested but no shells with binding energies ');
               1      $egs_info(*,'    above the specified threshold found');
               1      $egs_info(*,'    => turning off EII');
               1      eii_flag = 0;
               1  ]
               0  IF( nsh > $MAX_EII_SHELLS ) [
               1      $egs_info(*,'*** Number of shells with binding energies greater than ');
               1      $egs_info(*,'    the specified thresholds is ',nsh);
               1      $egs_info(*,'    This is more than the allocated arrays can hold');
               1      $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
               1  ]
               0  $egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
               0  nsh_tot = nsh;
               0  tmp_array(1) = 0;
               0  DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]
               0
               0
               0  DO imed=1,nmed [
               1      nsh = 0;
               1      DO iele=1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          eii_no(imed,iele) = eii_nshells(iZ);
               2          nsh = nsh + eii_nshells(iZ);
               2          IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
               2          ELSE [ eii_first(imed,iele) = 0; ]
               2      ]
               1      eii_nsh(imed) = nsh;
               1  ]
               0
               0
               0  $set_string(eii_file,' ');
               0  eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
               0             $cstring(eii_xfile) //'.data';
               0  want_eii_unit = 62;
               0  eii_unit = egs_get_unit(want_eii_unit);
               0  IF( eii_unit < 1 ) [
               1      $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
               1  ]
               0  open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
               0  $egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
               0  $egs_info('(a,$)',' eii_init: reading EII data ... ');
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
               0  DO j=1,nskip [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
               1  ]
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
               0  IF( nbin ~= $N_EII_BINS ) [
               1      $egs_fatal(*,'Inconsistent EII data file');
               1  ]
               0  IF (xsec_out = 1)[
               1     eii_out = egs_open_file(93,0,1,'.eiixsec');
               1  ]
               0  ii = 0;
               0  DO j=1,$MXELEMENT [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
               1      IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
               2       write(eii_out,*) '=================================';
               2       write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
               2       write(eii_out,*) '=================================';
               2      ]
               1      IF( nsh < eii_nshells(iZ) ) [
               2          $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
               2          $egs_info(*,iZ,' but according');
               2          $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
               2          $egs_info(*,'shells are required');
               2          $egs_fatal(*,'This is a fatal error.');
               2      ]
               1      DO ish=1,nsh [
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
               2             aux_array;
               2          "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
               2          IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
               2          IF( ish <= eii_nshells(iZ) ) [
               3              IF (xsec_out = 1)[
               4                IF(ish = 1)[
               5                 write(eii_out,'(a,f10.2,a)')
               5                 'K-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 2)[
               5                 write(eii_out,'(a,f9.2,a)')
               5                 '=> LI-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 3)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 4)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LIII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
               4                write(eii_out,*) '   E/keV     sigma/(b/atom)';
               4                write(eii_out,*) '---------------------------';
               4              ]
               3              ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
               3              eii_a(ii) = nbin;
               3              eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
               3              eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
               3              DO k=1,nbin [
               4                  IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
               4                  ELSE [ sigo = 0; ]
               4                  loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
               4                  eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
               4                  eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
               4                  IF (xsec_out = 1)[
               5                     write(eii_out,'(f12.2,2X,10f9.2)')
               5                     Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
               5                  ]
               4              ]
               3          ]
               2      ]
               1      IF( ii = nsh_tot ) [ EXIT; ]
               1  ]
               0  close(eii_unit);
               0  IF (xsec_out = 1)[ close(eii_out); ]
               0  $egs_info(*,' OK '); $egs_info(*,' ');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
               1      /sum_z,sum_pz,sum_a,sum_wa/=0;
               1      DO iele=1,nne(imed) [
               2          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
               2          sum_pz = sum_pz + pz(imed,iele);
               2          sum_wa = sum_wa + rhoz(imed,iele);
               2          sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
               2      ]
               1      con_med = rho(imed)/1.6605655/sum_a;
               1      eii_cons(imed) = con_med;
               1      IF( eii_nsh(imed) > 0 ) [
               2          is_monotone = .true.;
               2          sigma_max = 0;
               2          DO j=1,meke(imed) [
               3              loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
               3              tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              p2 = 2*rm*tau*(tau+2);
               3              lloge = j;
               3              medium = imed;
               3              $EVALUATE dedx USING ededx(loge);
               3              IF( e > ap(medium) | e > 2*Ec ) [
               4                  $EVALUATE sig USING esig(loge);
               4              ] ELSE [ sig = 0; ]
               3              IF( e > 2*Ec ) [
               4                  $EVALUATE wbrem USING ebr1(loge);
               4                  sigm = sig*(1-wbrem);
               4              ] ELSE [ sigm = 0; wbrem = 1; ]
               3              /sum_occn,sum_sigma,sum_dedx/=0;
               3              DO iele=1,nne(imed) [
               4                  iZ = int(zelem(imed,iele)+0.5);
               4                  sum_sh = 0;
               4                  DO ish = 1,eii_no(imed,iele) [
               5                      "jj is the shell index in the list of EII shells "
               5                      jj = eii_first(imed,iele) + ish - 1;
               5                      "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
               5                      jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
               5                      Wmax = (e+U)/2; uwm = U/Wmax;
               5                      "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
               5                      IF( U < e & U > Ecc ) [
               6                          " At this energy interactions with this shell will "
               6                          " be done using the EII differential x-section "
               6                          sum_sh = sum_sh + occn_numbers(jjj);
               6                          ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
               6                            (beta2+0.833333)*(1-uwm**3))/3/U;
               6                          sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
               6                            - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
               6                          ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
               6                            (beta2+1)*(1-uwm**2);
               6                          sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
               6                            +(Wmax**2-U**2)/(e+rm)**2/2
               6                            -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
               6                          av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
               6                            "av_E is the average energy lost in a collision"
               6                            "with this shell"
               6                          i = eii_a(jjj)*loge + eii_b(jjj);
               6                          i = (jj-1)*$N_EII_BINS + i;
               6                          sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
               6                          sig_j = sig_j*pz(imed,iele)*con_med;
               6                          sum_sigma = sum_sigma + sig_j;
               6                          sum_dedx = sum_dedx + sig_j*av_E;
               6                      ]
               5                  ]
               4                  sum_occn = sum_occn + sum_sh*pz(imed,iele);
               4              ]
               3              sigm = sigm + sum_sigma;
               3              dedx = dedx - sum_dedx;
               3              aux = Ec/e;
               3              IF( e > 2*Ec ) [
               4                  sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
               4                          (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
               4                          (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
               4                  de = cons*sum_occn*rho(imed)/beta2*(
               4                    log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
               4                    (tau/(tau+1))**2*(1-4*aux*aux)/8-
               4                    (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
               4                  sigm = sigm - sigo;
               4                  "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
               4                  dedx = dedx + de;
               4              ]
               3              sigma = sigm + wbrem*sig;
               3              IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
               3              IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
               3              ELSE [ wbrem = 1; ]
               3              IF( j > 1 ) [
               4                  ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
               4                  ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
               4                  esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
               4                  esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
               4                  ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
               4                  ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
               4                  IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
               4              ]
               3              dedx_old = dedx; sigm_old = sigm;
               3              sigma_old = sigma; wbrem_old = wbrem;
               3          ]
               2          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
               2          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
               2          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
               2          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
               2          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
               2          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
               2          $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
               2                  sigma_max,' monotone = ',is_monotone);
               2          sig_ismonotone(0,imed) = is_monotone;
               2          esig_e(imed) = sigma_max;
               2      ]
               1  ]
               0  return;
               0
               0  :eii-reading-error:
               0  $egs_fatal(*,'I/O error while reading EII data');
               0
               0  :no-eii-file:
               0  $egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
               0            'Make sure file exists in your $HEN_HOUSE/data directory!',
               0            '****BEWARE of case sensitive file names!!!');
               0
               0  return; end;
               0
               0  "*****************************************************************************"
               0
               0  subroutine eii_sample(ish,iZ,Uj);
               0  implicit none;
               0  $INTEGER ish,iZ;
               0  $REAL    Uj;
               0
               0  $COMIN-EII-SAMPLE;
               0
               0  $REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
               0  $REAL r1,r2,r3,wx,wxx,aux,frej;
               0  real*8 peie,pese1,pese2,dcosth,h1;
               0  $INTEGER iarg;
               0  $REAL    eta,cphi,sphi;
               0  $INTEGER np_save,ip,j;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0
               0  peie = e(np);
               0  T = peie - rm; tau = T/rm; tau1 = tau+1;
               0  tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
               0  beta2 = p2/tau12;
               0  "c1 = tau2/tau12; "
               0  Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
               0  c1 = (Wmax/peie)**2;
               0  c2 = (2*tau+1)/tau12;
               0  fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
               0  prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
               0  "fm_h = 1 + c1 - c2;"
               0  fm_h = 2 + c1 - c2;
               0  IF( fm_h < 1 ) fm_h = 1;
               0  prob = fm_h + prob_s;
               0
               0  LOOP [
               1      $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
               1      IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
               2          wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
               2          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
               2      ] ELSE [               "Use the soft collision cross section "
               2          wx = 1/(r2*xmax**3+1-r2)**0.333333333;
               2          frej = 1 - log(wx)/fm_s;
               2      ]
               1  ] UNTIL ( r3 < frej );
               0
               0  wx = wx*Uj;
               0
               0
               0  h1 = (peie + prm)/T; pese1 = peie - wx;
               0  e(np) = pese1;
               0  dcosth = h1*(pese1-prm)/(pese1+prm);
               0  sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               0  call uphi(2,1);
               0
               0  pese2 = wx - Uj + prm;
               0  edep_local = 0;
               0  IF( pese2 > ae(medium) ) [
               1      $CHECK-STACK(np+1,'eii_sample');
               1      np = np+1; e(np) = pese2;
               1      dcosth = h1*(pese2-prm)/(pese2+prm);
               1      sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               1      iq(np) = -1; call uphi(3,2);
               1      edep = 0;
               1  ] ELSE [
               1      edep = wx - Uj;
               1      edep_local = edep;
               1      $AUSCALL($SELECTRONA);
               1  ]
               0  "ish ranges from 1 to 4 for K,L1,L2,L3 shells"
               0  call relax(Uj,ish,iZ);
               0
               0  IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_scale_photon_xsection(imed,fac,which);
               0  "============================================================================"
               0  "
               0  "  Scale the photon cross section 'which' by factor fac for medium imed.
               0  "  which = 0 for all cross sections
               0  "        = 1 for Rayleigh scattering
               0  "        = 2 for Compton scattering
               0  "        = 3 for Pair production
               0  "        = 4 for photo-absorption
               0  "  If imed = 0, scaling is done for all media.
               0  "============================================================================"
               0  implicit none;
               0  $INTEGER imed,which;
               0  $REAL    fac;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,PHOTIN,EGS-IO/;
               0  $INTEGER ifirst,ilast,medium,j;
               0  $LOGICAL has_r;
               0  $REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
               0  character*8 strings(5);
               0  data       strings/'photon','Rayleigh','Compton','pair','photo'/;
               0
               0  IF( which < 0 | which > 4 ) [ return; ]
               0  IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
               0  ELSE [ ifirst = 1; ilast = nmed; ]
               0  IF( which = 1 ) [
               1      has_r = .false.;
               1      DO medium = ifirst, ilast [
               2          IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
               2      ]
               1      IF( ~has_r ) return;
               1  ]
               0  $egs_info(*,' ');
               0  DO medium = ifirst,ilast [
               1
               1      $egs_info('(a,a,a,i3,a,f9.5)',
               1              'Scaling ',strings(which+1),' x-section data for medium',
               1              medium,' with ',fac);
               1
               1      DO j = 1,mge(medium) [
               2
               2          gle = (j - ge0(medium))/ge1(medium);
               2          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
               2          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
               2          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
               2          IF( iraylm(medium) = 1 ) [
               3              cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
               3          ] ELSE [ cohfac = 1; ]
               2          IF( which = 0 ) [ gmfp = gmfp/fac; ]
               2          ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
               2          ELSE [
               3              IF( which = 2 ) [
               4                  aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
               4                  gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
               4              ]
               3              ELSE IF( which = 3 ) [
               4                  aux = fac*gbr1 + 1 - gbr1;
               4                  gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
               4              ]
               3              ELSE [
               4                  aux = gbr2 + fac*(1-gbr2);
               4                  gbr1 = gbr1/aux; gbr2 = gbr2/aux;
               4              ]
               3              gmfp = gmfp/aux;
               3              cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
               3          ]
               2          IF( j > 1 ) [
               3              gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
               3              gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
               3              gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
               3              cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
               3              cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;
               2
               2      ]
               1      gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
               1      gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
               1      gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
               1      gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
               1      gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
               1      gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
               1      cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
               1      cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$OPEN-UNIT(#,#,#);} WITH {
            {  0      {P1} = {P2};
            {  0      {P1} = egs_get_unit({P1});
            {  0      IF( {P1} < 1 ) [
            {  0          $egs_fatal(*,
            {  0           'egs_init_user_photon: failed to get a free Fortran I/O unit');
            {  0      ]
            {  0      tmp_string = {P3};
            {  0      open({P1},file={P3},status='old',err=:no-user-data-file:);
            {  0  };
               0
               0  REPLACE {$MXINPUT} WITH {2000};
               0  REPLACE {$MXBCINP} WITH {183};
               0
               0  "============================================================================="
               0  "Ali:photonuc, 1 line"
               0   subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
               0  "subroutine egs_init_user_photon(prefix,comp_prefix,out);"
               0  "============================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  character*(*) prefix, comp_prefix,
               0  "Ali:photonuc, 1 line"
               0                photonuc_prefix;
               0  $INTEGER      out;
               0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
               0  $INTEGER   lnblnk1,egs_get_unit,medium,
               0             photo_unit,pair_unit,rayleigh_unit,triplet_unit,
               0             ounit,egs_open_file,compton_unit,
               0  "Ali:photonuc, 1 line"
               0             photonuc_unit;
               0  $INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
               0  $REAL      z_sorted($MXEL),pz_sorted($MXEL);
               0  $REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
               0             sig_rayleigh($MXGE),sig_compton($MXGE);
               0  $REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
               0  $REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
               0  "Ali:photonuc, 3 lines"
               0             sig_photonuc($MXGE),
               0             photonuc,
               0             photonuc_old;
               0
               0  $REAL      etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
               0  $REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
               0  $INTEGER   bc_ne;
               0  $LOGICAL   input_compton_data,
               0  "Ali:photonuc, 1 line"
               0             input_photonuc_data;
               0  character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
               0             triplet_file*142,tmp_string*144,compton_file*144,
               0  "Ali:photonuc, 1 line"
               0             photonuc_file*144;
               0
               0  $egs_info('(/a$)','(Re)-initializing photon cross sections');
               0  $egs_info('(a,a/)',' with files from the series: ',
               0        prefix(:lnblnk1(prefix)));
               0
               0  $egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   $egs_info('(a,a)',' Photonuclear cross sections: ',
               1   $cstring(photonuc_prefix));
               1   input_photonuc_data = .false.;
               1   IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
               2     input_photonuc_data = .true.;
               2   ]
               1  ]
               0
               0  input_compton_data = .false.;
               0  IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
               1      IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
               1  ]
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
               0  pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
               0  triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
               0  rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
               0  IF( input_compton_data ) [
               1      compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
               1                     '_compton.data';
               1  ]
               0  ELSE [
               1      compton_file = $cstring(data_dir) // 'compton_sigma.data';
               1  ]
               0  "Ali: I moved this info line from inside the IF statement
               0  " because it's useful to print the cross section file either way
               0  $egs_info('(a,a)',' Using Compton cross sections from ',
               0            $cstring(compton_file));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   IF( input_photonuc_data ) [
               2      photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
               2                      '_photonuc.data';
               2   ]
               1   ELSE [
               2      photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
               2   ]
               1   $egs_info('(a,a)',' Using photonuclear cross sections from ',
               1    $cstring(photonuc_file));
               1  ]
               0
               0  $OPEN-UNIT(photo_unit,83,photo_file);
               0  $OPEN-UNIT(pair_unit,84,pair_file);
               0  $OPEN-UNIT(triplet_unit,85,triplet_file);
               0  $OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
               0  IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
               0  " Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
               0  "       without rejections. For this we have to use the actual bound   "
               0  "       Compton scattering cross section, which is now available in a  "
               0  "       file called bound_compton.data (the file actually contains the "
               0  "       ratio of the Bound Compton to the KN cross section).           "
               0  "       Because this option is not available on a region by region     "
               0  "       basis, we just need to check ibcmp(1)                          "
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]
               0
               0  IF( out = 1 ) [
               1      ounit = egs_open_file(87,0,1,'.xsections');
               1      write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
               1         $cstring(prefix),' data files';
               1      write(ounit,'(a,/)')
               1  '============================================================================';
               1      write(ounit,'(a,/)') 'Grid energies and cross sections are output';
               1  "Ali:photonuc, 1 block"
               1      IF(iphotonuc = 1) [
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
               2           'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
               2           ' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
               2           '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
               2           'w/ Ray + photnuc';
               2      ]
               1      ELSE[
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
               2              'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
               2              '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
               2     ]
               1  ]
               0
               0  DO iz=1,100 [
               1      read(photo_unit,*) ndat;
               1      read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
               1      k = 0;
               1      DO j=ndat,2,-1 [
               2          IF( etmp(j)-etmp(j-1) < 1e-5 ) [
               3              k = k+1;
               3              IF ( k <= $MXSHXSEC )[
               4                 binding_energies(k,iz) = exp(etmp(j));
               4              ]
               3              ELSE[
               4                $egs_fatal('(i3,a,i3,//a)',
               4                           k,' binding energies read exceeding array size of',
               4                           $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
               4              ]
               3              IF( ~eadl_relax & k >= 4 ) EXIT;
               3          ]
               2      ]
               1  ]
               0
               0  IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]
               0
               0  DO medium = 1,nmed [
               1
               1      mge(medium) = $MXGE; nge = $MXGE;
               1      ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
               1      ge0(medium) = 1 - ge1(medium)*log(ap(medium));
               1
               1      $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
               1      IF( out = 1 ) [
               2          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
               2            (media(k,medium),k=1,24);
               2      ]
               1      /sumZ,sumA/ = 0;
               1      DO i=1,nne(medium) [
               2          z_sorted(i) = zelem(medium,i);
               2          sumZ = sumZ + pz(medium,i)*zelem(medium,i);
               2          sumA = sumA + pz(medium,i)*wa(medium,i);
               2      ]
               1      con1 = sumZ*rho(medium)/(sumA*1.6605655);
               1      con2 = rho(medium)/(sumA*1.6605655);
               1      call egs_heap_sort(nne(medium),z_sorted,sorted);
               1      DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]
               1
               1      IF (mcdf_pe_xsections)[
               2         call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
               2                                  ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      ELSE[
               2         call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                         ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_rayleigh);
               1      call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_pair);
               1      call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_triplet);
               1  "Ali:photonuc, 1 block"
               1      IF( iphotonuc = 1 ) [
               2        call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                          ge1(medium),ge0(medium),sig_photonuc);
               2      ]
               1
               1      IF( ibcmp(1) > 1 ) [
               2          "Get the bound compton cross section data"
               2          IF( input_compton_data ) [
               3              call egsi_get_data(0,compton_unit,nge,nne(medium),
               3                      z_sorted,pz_sorted,ge1(medium),ge0(medium),
               3                      sig_compton);
               3          ]
               2          ELSE [
               3              rewind(compton_unit);
               3              read(compton_unit,*) bc_emin,bc_emax,bc_ne;
               3              IF( bc_ne > $MXBCINP ) [
               4                $egs_fatal(*,'Number of input Compton data exceeds array size');
               4              ]
               3              "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
               3              bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
               3              DO j=1,bc_ne [ bc_data(j) = 0; ]
               3              iz_old = 1;
               3              DO i=1,nne(medium) [
               4                  iz = int(z_sorted(i)+0.5);
               4                  "write(6,*) ' reading bc data for ',iz;
               4                  DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
               4                  DO j=1,bc_ne [
               5                      bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
               5                  ]
               4                  iz_old = iz+1;
               4              ]
               3              DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
               3          ]
               2      ]
               1
               1
               1      call egs_init_rayleigh(medium,sig_rayleigh);
               1
               1      DO i=1,nge [
               2
               2          gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
               2          sig_KN = sumZ*egs_KN_sigma0(e);
               2          IF( ibcmp(1) > 1 ) [
               3              IF( input_compton_data ) [
               4                  sig_KN = sig_compton(i);
               4              ]
               3              ELSE [
               4                  "Apply the bound Compton correction to sig_KN"
               4                  IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
               4                  ELSE IF( e < bc_emax ) [
               5                      aj = 1 + log(e/bc_emin)/bc_dle;
               5                      j = int(aj); aj = aj - j;
               5                      bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
               5                  ]
               4                  ELSE [ bcf = 1; ]
               4                  sig_KN = sig_KN*bcf;
               4                  "write(6,*) 'e = ',e,' bcf = ',bcf;
               4              ]
               3          ]
               2          sig_p  = sig_pair(i) + sig_triplet(i);
               2          sigma  = sig_KN + sig_p + sig_photo(i);
               2          gmfp   = 1/(sigma*con2);
               2          gbr1   = sig_p/sigma;
               2          gbr2   = gbr1 + sig_KN/sigma;
               2          cohe   = sigma/(sig_rayleigh(i) + sigma);
               2  "Ali:photonuc, 1 line"
               2          photonuc = sigma/(sig_photonuc(i) + sigma);
               2
               2          IF( out = 1 ) [
               3  "Ali:photonuc, 1 block"
               3             IF(iphotonucm(medium) = 1) [
               4                write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
               4                gmfp*cohe,gmfp*cohe*photonuc;
               4             ]
               3             ELSE[
               4                write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
               4             ]
               3          ]
               2          IF( i > 1 ) [
               3              gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
               3              gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
               3              gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
               3              cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
               3              cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
               3  "Ali:photonuc, 2 lines"
               3              photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
               3              photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
               2  "Ali:photonuc, 1 line"
               2          photonuc_old = photonuc;
               2      ]
               1
               1      gmfp1(nge,medium) = gmfp1(nge-1,medium);
               1      gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
               1      gbr11(nge,medium) = gbr11(nge-1,medium);
               1      gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
               1      gbr21(nge,medium) = gbr21(nge-1,medium);
               1      gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
               1      cohe1(nge,medium) = cohe1(nge-1,medium);
               1      cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
               1  "Ali:photonuc, 2 lines"
               1      photonuc1(nge,medium) = photonuc1(nge-1,medium);
               1      photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;
               1
               1      $egs_info('(a)','OK');
               1  ]
               0
               0  close(photo_unit); close(pair_unit);
               0  close(triplet_unit); close(rayleigh_unit);
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ close(photonuc_unit);]
               0  IF( ibcmp(1) > 1 ) [ close(compton_unit);]
               0  IF( out = 1 )      [ close(ounit); ]
               0  return;
               0
               0  :no-user-data-file:;
               0  $egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh(medium,sig_rayleigh);
               0
               0
               0
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
               0  DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
               0  DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
               2     ff_file = iray_ff_file(i);
               2  ];]
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0
               0
               0
               0
               0
               0  IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
               1       open(ff_unit,file=$cstring(ff_file),
               1            status='old',err=:no-ff-file:);
               1       GOTO :read-ff:;
               1       :no-ff-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
               1               $cstring(ff_file));
               1       :read-ff:
               1       $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
               1       " read Rayleigh molecular form factor data from a file"
               1       " which is given as Fmol/sqrt(MW) hence no need to compute"
               1       " MW to get the xsections in cm-1. See conv variable below"
               1       j = 0;
               1       LOOP [
               2         j = j + 1;
               2         read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
               2         IF (EOF < 0) EXIT;
               2         IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
               2       ] REPEAT
               1       nff = j-1;
               1       IF (nff > $MXRAYFF)[
               2          $egs_fatal('(a,/,a,i5,a,i5,/,a)',
               2          'subroutine egs_init_rayleigh: form factors size too small!!',
               2          '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
               2          ' and try again!!!');
               2       ]
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
               1
               1       "Since MW already included in the molecular FF,"
               1       "must multiply by sumA which is MW for compound"
               1       "or unity for mixtures."
               1       sumA = 0.0;
               1       DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
               1       DO j=1,MGE(medium) [
               2         gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
               2         sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
               2                         xgrid(1,medium),ff(1,medium))*sumA;
               2       ]
               1  ]
               0  ELSE[
               1       $set_string(afac_file,' ');
               1       afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               1       open(ff_unit,file=$cstring(afac_file),
               1         status='old',err=:no-afac-file:);
               1       GOTO :read-afac:;
               1       :no-afac-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
               1               $cstring(afac_file));
               1       :read-afac:
               1       " read Rayleigh atomic form factor data from a file"
               1       read(ff_unit,*) xval, aff;
               1       "calculate form factor using independent atom model"
               1       DO i=1,$MXRAYFF[
               2         ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               2         DO j=1,nne(medium)[
               3          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               3         ]
               2         ff(i,medium) = sqrt(ff(i,medium));
               2       ]
               1       nff = $MXRAYFF;
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               1  ]
               0  close(ff_unit);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
               0  dlei=1/dle;
               0  DO i=1,ne-1 [
               1
               1
               1
               1
               1
               1
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh_sampling(medium);
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0  $set_string(afac_file,' ');
               0  afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               0  open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
               0  GOTO :read-afac:;
               0  :no-afac-file:
               0  $egs_fatal('(2a)',
               0          'egs_init_rayleigh_sampling: failed to open atomic ff file ',
               0          $cstring(afac_file));
               0  :read-afac:
               0  " read Rayleigh atomic form factor data from a file"
               0  read(ff_unit,*) xval, aff;
               0  "calculate form factor using independent atom model"
               0  DO i=1,$MXRAYFF[
               1    ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               1    DO j=1,nne(medium)[
               2     ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               2    ]
               1    ff(i,medium) = sqrt(ff(i,medium));
               1  ]
               0  nff = $MXRAYFF;
               0  "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               0  "and much less for higher energies"
               0  IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               0  "write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
               0  $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               0
               0  close(ff_unit);
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);
               0  DO i=1,ne-1 [
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0
               0
               0  $REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
               0  $IMPLICIT-NONE;
               0  $INTEGER i, j, k,imed, ndat;
               0  $REAL hc2,conv,b,hc;
               0  parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
               0             hc2 = 0.0001537222280); "h*c squared"
               0  $REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
               0  real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
               0  C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
               0  egs_rayleigh_sigma = 0.0;
               0  DO i=1,ndat-1[
               1     IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
               1     IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
               1     b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
               1     x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
               1     pow_x1=x1**(2*b);pow_x2=x2**(2*b);
               1     raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
               1     raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
               1     raysig = raysig*f(i)*f(i)/pow_x1;
               1     egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
               1     IF(x(i+1)>xmax)[EXIT;]"exit loop"
               1  ]
               0
               0
               0
               0  egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
               0  return;
               0  end;
               0
               0
               0
               0  subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  real*8 e;
               0  $REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
               0  $REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
               0  parameter(hc_i=80.65506856998,      "h*c inverse"
               0            twice_hc2=0.000307444456);"2*(hc)^2"
               0            "h*c=0.0123984768438 [Armstrong]*[MeV]"
               0  $INTEGER lgle,ib,ibin,medium, trials;
               0  ;COMIN/RANDOM,rayleigh_sampling/;
               0  dwi = $RAYCDFSIZE-1;
               0  $EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
               0  LOOP [
               1      $RANDOMSET rnnray1;
               1      LOOP [
               2          $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
               2          ibin = 1 + rnnray0*dwi;
               2          ib = i_array(ibin,medium);
               2          IF( i_array(ibin+1,medium) > ib ) [
               3            LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
               3          ]
               2          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
               2          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
               2      ] UNTIL (xv < xmax);
               1      xv = xv/e;
               1      costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
               1  ] UNTIL ( 2*rnnray1 < 1 + csqthe );
               0  sinthe=sqrt(1.0-csqthe);
               0  return;
               0  end;
               0
               0
               0
               0  subroutine prepare_rayleigh_data(ndat,x,f,
               0                                   ne,emin,emax,pe_array,
               0                                   ncbin,fcum,i_array,
               0                                   b_array,c_array);
               0  $IMPLICIT-NONE;
               0
               0
               0  $INTEGER    ndat;         " number of F data points "
               0  $REAL       x(ndat),      " x values of F data "
               0              f(ndat);      " F data "
               0
               0
               0  $INTEGER    ne;           " number of energy bins "
               0  $REAL       emin,         " minimum photon energy (i.e. AP(medium))"
               0              emax,         " maximum photon energy (i.e. UP(medium))"
               0              pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
               0                            " i.e., pe_array(E) = fcum(xmax(E))      "
               0
               0
               0
               0  $INTEGER    ncbin;          " number of cumulative bins (input)"
               0  $REAL       fcum(ndat);     " cumulative distribution (output)"
               0  $INTEGER    i_array(ncbin); " original data bin in which the i'th "
               0                              " cumulative bin edge falls.          "
               0
               0
               0  $REAL       b_array(ndat),  " F interpolation coefficient "
               0              c_array(ndat);  " needed for sampling at run time "
               0
               0  $REAL zero;
               0
               0  real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
               0         anorm,anorm1,anorm2,w,dw,xold,t,aux;
               0  $INTEGER i,j,k,ibin;
               0
               0  ;COMIN/USEFUL/;
               0
               0  write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';
               0
               0
               0  DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]
               0
               0
               0
               0
               0
               0
               0  sum0=0; fcum(1)=0;
               0  DO i=1,ndat-1 [
               1      b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
               1      x1 = x(i); x2 = x(i+1);
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1      fcum(i+1) = sum0;
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0  dle = log(emax/emin)/(ne-1); i = 1;
               0  DO j=1,ne [
               1      e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
               1      DO k=i,ndat-1 [
               2          IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
               2      ]
               1      i = k; b = b_array(i);
               1      x1 = x(i); x2 = xmax;
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      pe_array(j) = fcum(i) +
               1        f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1  ]
               0  i_array(ncbin) = i;
               0
               0
               0
               0
               0
               0
               0
               0
               0  anorm = 1d0/sqrt(pe_array(ne));
               0  anorm1 = 1.005d0/pe_array(ne);
               0  anorm2 = 1d0/pe_array(ne);
               0  DO j=1,ne [
               1      pe_array(j) = pe_array(j)*anorm1;
               1      IF( pe_array(j) > 1 ) pe_array(j) = 1;
               1  ]
               0  DO j=1,ndat [
               1      f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
               1      c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
               1  ]
               0
               0
               0
               0
               0
               0
               0  dw = 1d0/(ncbin-1);
               0  xold = x(1); ibin = 1;
               0  b = b_array(1);
               0  pow_x1 = x(1)**(2*b);
               0  i_array(1) = 1;
               0  DO i=2,ncbin-1 [
               1      w = dw;
               1      LOOP [
               2          x1 = xold; x2 = x(ibin+1);
               2          t = x1*x1*x1**(2*b);
               2          pow_x2 = x2**(2*b);
               2          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
               2          IF( aux > w ) [
               3              xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
               3              i_array(i) = ibin;
               3              EXIT;
               3          ]
               2          w = w - aux; xold = x2; ibin = ibin+1;
               2          b = b_array(ibin); pow_x1 = xold**(2*b);
               2      ]
               1  ]
               0
               0
               0
               0
               0
               0
               0  DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]
               0
               0
               0  write(*,'(a /)') 'done';
               0
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma0(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm;
               0  IF( ko < 0.01 ) [
               1      egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
               1      return;
               1  ]
               0  c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
               0                  eps1*(c3+0.5*eps1))/e*con;
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma1(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma1 = c1*(1./eps1-1./eps2);
               0  egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
               0  egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
               0  egs_KN_sigma1 = egs_KN_sigma1 +
               0           (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
               0  egs_KN_sigma1 = egs_KN_sigma1*con;
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL    eth;
               0  $INTEGER flag,iunit,n,ne;
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL    gle,sig,p,e;
               0  $INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;
               0
               0  ;COMIN/USEFUL/;
               0
               0  "Ali:photonuc. The whole routine is commented out and re-written
               0  "to accommodate reading photonuclear cross sections. A copy of the
               0  "commented original routine is at the bottom.
               0  " flag = 0: photoelectric, Rayleigh, Compton
               0  " flag = 1: pair
               0  " flag = 2: triplet
               0  " flag = 3: photonuclear
               0
               0  rewind(iunit);
               0  iz_old = 0;
               0  DO k=1,n [ data(k) = 0; ]
               0  DO i=1,ne [
               1      iiz = int(zsorted(i)+0.5);
               1      DO iz=iz_old+1,iiz [
               2          read(iunit,*,err=:user-data-failure:) ndat;
               2          IF( ndat > $MXINPUT ) [
               3              $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
               3          ]
               2          IF( flag = 0 | flag = 3) [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
               3          ]
               2          ELSE [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
               3                  k=1,ndat);
               3              IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
               3              ndat = ndat + 1;
               3              DO k=2,ndat [
               4                  ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
               4              ]
               3              ftmp(1) = ftmp(2); etmp(1) = log(eth);
               3          ]
               2      ]
               1      iz_old = iiz;
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1; e = exp(gle);
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              IF( flag = 0 ) [
               4                  $egs_fatal(*,'Energy ',exp(gle),
               4                     ' is outside the available data range of ',
               4                     exp(etmp(1)),exp(etmp(ndat)));
               4              ]
               3              ELSEIF (flag = 1 | flag = 2) [
               4                  IF( gle < etmp(1) ) [ sig = 0; ]
               4                  ELSE [ sig = exp(ftmp(ndat)); ]
               4              ]
               3              ELSE [ "photonuclear, zero it before and after
               4               sig = 0;
               4              ]
               3          ] ELSE [
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              IF( flag ~= 3) ["log/log interpolation"
               4                 p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               4                 sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               4              ]
               3              ELSE["lin/lin interpolation for photonuc"
               4                 p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               4                 sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
               4              ]
               3          ]
               2          IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2      ]
               1  ]
               0
               0  return;
               0
               0  :user-data-failure:;
               0  $egs_fatal(*,'Error while reading user photon cross sections from unit ',
               0       iunit);
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0  "============================================================================="
               0  subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
               0  $INTEGER n,   "number of data points requested"
               0           ne,  "number of elements in medium"
               0           ndat;"number of data points from original grid"
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    sigma($MXNE),sigmaMedium;
               0  "$INTEGER sorted(*);
               0  real*4    etmp($MXINPUT),ftmp($MXINPUT);
               0  real*4    gle,sig,p;
               0  $INTEGER i,j,k,kk,iz,zpos,imed;
               0
               0  DO k=1,n  [ data(k)  = 0;]
               0  DO k=1,ne [ sigma(k) = 0;]
               0  DO i=1,ne [
               1      iz = int(zsorted(i)+0.5);
               1      zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1      "Total cross sections for a given element"
               1      "on initial energy grid"
               1      DO k=1,ndat[
               2         pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
               2         "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
               2         etmp(k) = pe_energy(k,zpos);
               2         ftmp(k) = log(pe_xsection(k,zpos,0));
               2      ]
               1      "Total cross sections for a given element"
               1      "on requested energy grid"
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1;
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
               3                           ' is outside the available data range of ',
               3                           exp(etmp(1)),exp(etmp(ndat)));
               3          ] ELSE [
               3              "Find energy interval gle falls in"
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              "log/log interpolation"
               3              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               3              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               3          ]
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2          "data(k) = data(k) + pz(imed,sorted(i))*sig;
               2      ]
               1  ]
               0  "Normalize elemental cross section to medium cross section"
               0  "Prepare for log/log interpolation"
               0  DO i=1,ne [
               1     iz = int(zsorted(i)+0.5);
               1     zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1     DO k=1,ndat[
               2        sig = sigmaMedium(imed,pe_energy(k,zpos));
               2        pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
               2     ]
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0  $REAL function sigmaMedium(imed, logE);
               0
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,PE-SHELL-DATA/;
               0  $REAL logE, slope, sigma;
               0  $INTEGER k,imed,Z,zpos,m,ibsearch;
               0
               0  sigmaMedium = 0;
               0  DO k=1,nne(imed) [
               1     Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
               1     m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               1     slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
               1     slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
               1     sigma = log(pe_xsection(m,zpos,0));
               1     sigma += slope*(logE - pe_energy(m,zpos));
               1     sigma = exp(sigma);
               1     sigmaMedium += pz(imed,k)*sigma;
               1  ]
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egs_heap_sort(n,rarray,jarray);
               0  "************************************************************************
               0  "  egs_heap_sort will sort the real array rarray of dimension n in
               0  "  ascending order and at the same time put into the integer array
               0  "  jarray the original position of the elements, e.g.
               0  "  if rarray was on input (5,14,8,2), it will be after completion
               0  "  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
               0  "  heap_sort uses the heap sort algorithm, the implementation is
               0  "  based  on hpsort from Numerical Recipies with a couple of
               0  "  modifications.
               0  "
               0  "  Iwan Kawrakow, NRC, July 2001
               0  "*************************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER n,jarray(*);
               0  $REAL    rarray(*);
               0  $INTEGER i,ir,j,l,ira;
               0  $REAL    rra;
               0
               0  DO i=1,n [ jarray(i)=i; ]
               0  IF (n < 2) return;
               0  l=n/2+1; ir=n;
               0
               0  LOOP [
               1     IF (l > 1)  [
               2         l=l-1; rra=rarray(l); ira=l;
               2     ]
               1     ELSE [
               2         rra=rarray(ir); ira=jarray(ir);
               2         rarray(ir)=rarray(1); jarray(ir)=jarray(1);
               2         ir=ir-1;
               2         IF (ir = 1) [
               3             rarray(1)=rra; jarray(1)=ira; return;
               3         ]
               2     ]
               1     i=l; j=l+l;
               1     LOOP [
               2         IF( j > ir ) EXIT;
               2         IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
               2         IF (rra < rarray(j)) [
               3             rarray(i)=rarray(j); jarray(i)=jarray(j);
               3             i=j; j=j+j;
               3         ] ELSE [ j=ir+1; ]
               2     ]
               1     rarray(i)=rra; jarray(i)=ira;
               1  ]
               0  return; end;
               0
1              0  %E
               0  "Ali:photonuc, 1 subroutine"
               0  "******************************************************************"
               0  SUBROUTINE PHOTONUC;
               0  "******************************************************************"
               0  " Placeholder for photonuclear modelling. Currently the photon is
               0  " discarded and its energy is thrown away (i.e. not deposited).
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-PHOTONUC; "current default replacement is:
               0                   "COMIN/STACK,EPCONT,USEFUL/"
               0  $DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"
               0
               0  npold = np; "set the old stack counter"
               0  edep = pzero; e(np) = pzero; wt(np) = 0;
               0
               0  return;
               0  end;
               0  "******************************************************************"
               0
          END OF MORTRAN INPUT
  55      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
