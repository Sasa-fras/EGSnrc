Mortran 3.2 Mon Feb  5 23:07:30 2024
               0  %L                                                                     ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0                                        "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0                                        "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0    {SETR F=$FORTVER}
            {  0     [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0    }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0     WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0              [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0      "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0   WITH {;{SETR X=NEWLABEL}
            {  0   WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0   [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0   WRITE(IUECHO,{P4}){P5};]
            {  0   [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0   WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0   }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0    WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0     {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0    {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0    {{EMIT;{P1}}={WAIT {P1}};
            {  0    IF QDEBUG [OUTPUT{P1};
            {  0    (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0    {{SETR A=NEWLABEL}
            {  0      REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0         WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0             IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0                  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0                      (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0                         G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0    {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0    {;IF (QDEBUG)[OUTPUT;
            {  0      (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0           {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0      {;{SETR A=NEWLABEL}
            {  0           V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0           [IF] {EXIST 2} [$DUMP{P2};] ;}
               0     "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0     "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  REPLACE {$CONFIG_TIME} WITH {'unknown'}
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0     { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0     {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0     {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0      {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0      {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0      {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0      {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0      {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0      {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0              {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0      ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0       $REAL         ECUT,   "Minimum electron transport energy"
            {  0                     PCUT,   "Minimum photon transport energy"
            {  0                     VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0      ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0    ;COMMON/BREMPR/
            {  0               $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0               $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0               $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0               PWR2I($MXPWR2I),
            {  0               $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0               IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0               ASYM($MXMED,$MXEL,2);
            {  0     $TYPE     ASYM;
            {  0     $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0                                      "rejection function, eq. (2.7.14 and 15)"
            {  0               ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0               BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0               DELPOS, "maximum delta, eq. (2.7.31)"
            {  0               WA,     "atomic weight"
            {  0               PZ,     "atomic fraction of an element in a compound"
            {  0               ZELEM,  "Z for a given component"
            {  0               RHOZ,   "density of an element in a compound"
            {  0               PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0               DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0               ZBRANG, "composite factor for angular distributions"
            {  0               LZBRANG;"-Log(ZBRANG)"
            {  0     $INTEGER  NNE,    "number of elements/compound"
            {  0               IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0               IPRDST, "flag to switch on pair angular distributions"
            {  0               ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0               itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0               pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0                          "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0    common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_emin($MXMED),nb_emax($MXMED),
            {  0                       nb_lemin($MXMED),nb_lemax($MXMED),
            {  0                       nb_dle($MXMED),nb_dlei($MXMED),
            {  0                       log_ap($MXMED);
            {  0    $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0             nb_dle,nb_dlei,log_ap;
            {  0    $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0      common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_xdata($NRC-PAIR-NXX),
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0          common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0                               b_triplet($MAX_TRIPLET,$MXMED),
            {  0                               dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0          $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0                               bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0    ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0                          be_array($MXTOTSH), "Shell binding energies      "
            {  0                          Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0                          erfJo_array($MXTOTSH),"needed for the calculation"
            {  0                                              "of the incoherent scattering"
            {  0                                              "function                    "
            {  0                          ne_array($MXTOTSH), "Occupation number           "
            {  0                          shn_array($MXTOTSH),"shell type                  "
            {  0                                              "(=1     for K,              "
            {  0                                              " =2,3,4 for L1,L2,L3        "
            {  0                                              " =5     for M               "
            {  0                                              " =6     for N               "
            {  0                                              " =7     for all others      "
            {  0                          shell_array($MXMDSH,$MXMED),
            {  0                          eno_array($MXMDSH,$MXMED),
            {  0                          eno_atbin_array($MXMDSH,$MXMED),
            {  0                          n_shell($MXMED),
            {  0                          radc_flag,          "flag for radiative corrections"
            {  0                          ibcmp($MXREG);      "flag to turn on binding effects"
            {  0     $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0                          shell_array,n_shell,radc_flag;
            {  0     $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0     $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0     COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0                 interaction_prob($MXSHELL,$MXELEMENT),
            {  0                 relaxation_prob($MXTRANS,$MXELEMENT),
            {  0                 edge_energies($MXEDGE,$MXELEMENT),
            {  0                 edge_number($MXELEMENT),
            {  0                 edge_a($MXEDGE,$MXELEMENT),
            {  0                 edge_b($MXEDGE,$MXELEMENT),
            {  0                 edge_c($MXEDGE,$MXELEMENT),
            {  0                 edge_d($MXEDGE,$MXELEMENT),
            {  0                 IEDGFL($MXREG),IPHTER($MXREG);
            {  0     $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0                 interaction_prob, " prob. for interaction with one of"
            {  0                                   " the above shells (provided photon"
            {  0                                   " energy is above be)              "
            {  0                 relaxation_prob,  " relaxation probabilities         "
            {  0                 edge_energies,    " photo-absorption edge energies   "
            {  0                 edge_a,edge_b,edge_c,edge_d;
            {  0                                   " photo cross section fit parameters "
            {  0     $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0                 IPHTER;  "flag for switching on photo-electron angular distr."
            {  0     $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0     COMMON/ELECIN/
            {  0     esig_e($MXMED),psig_e($MXMED),
            {  0     esige_max, psige_max,
            {  0     range_ep(0:1,$MXEKE,$MXMED),
            {  0     E_array($MXEKE,$MXMED),
            {  0     $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0          blcce($MXEKE,$MXMED)/0,1/),
            {  0     $LGN(EKE($MXMED)/0,1/),
            {  0     $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0     $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0     expeke1($MXMED),
            {  0     IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0     sig_ismonotone(0:1,$MXMED);
            {  0     $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0                             "for each medium"
            {  0              psig_e,        "maximum positron cross section per energy loss"
            {  0                             "for each medium"
            {  0              esige_max,     "maximum electron cross section per energy loss"
            {  0              psige_max,     "maximum electron cross section per energy loss"
            {  0              range_ep,      "electron (0) or positron (1) range"
            {  0              E_array,       "table energies"
            {  0              etae_ms0,etae_ms1,
            {  0                             "for interpolation of screening parameter (e-)"
            {  0              etap_ms0,etap_ms1,
            {  0                             "for interpolation of screening parameter (e+)"
            {  0              q1ce_ms0,q1ce_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e-)"
            {  0              q1cp_ms0,q1cp_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e+)"
            {  0              q2ce_ms0,q2ce_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e-)"
            {  0              q2cp_ms0,q2cp_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e+)"
            {  0              blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0                            "necessary to account for scattering already taken  "
            {  0                            "into account in discrete Moller/Bhabha             "
            {  0              expeke1,       "Exp(1/eke1)-1"
            {  0              $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0              XR0,           "unused, but read in HATCH"
            {  0              TEFF0,         "unused, but read in HATCH"
            {  0              BLCC,          "b lower case sub c"
            {  0              XCC,           "chi sub-c-c"
            {  0              ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0              PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0              EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0              PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0              EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0              PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0              PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0              TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0     $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0              EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0              IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0     $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0                             "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0                                        "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0                                        "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0      common/eii_data/
            {  0          eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_cons($MXMED),
            {  0          eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0          eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0          eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0          eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0          eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0          eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0          eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0          eii_flag;                      "EII flag                          "
            {  0                                         "         = 0 => no EII            "
            {  0                                         "         = 1 => simple EII        "
            {  0                                         "         > 1 => future use        "
            {  0      $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0      $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0      $INTEGER  eii_first,eii_no;
            {  0      $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0      ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0             UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0      ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0      common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0                       EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0                       BxIN, ByIN, BzIN,       "B field: initial region"
            {  0                       Bx, By, Bz,             "B field: current region"
            {  0                       Bx_new, By_new, Bz_new, "B field: in new region"
            {  0                       emfield_on;             "true if EM fields not null"
            {  0
            {  0     $REAL    ExIN,EyIN,EzIN,
            {  0              EMLMTIN,
            {  0              BxIN,ByIN,BzIN,
            {  0              Bx,By,Bz,
            {  0              Bx_new,By_new,Bz_new;
            {  0     $LOGICAL emfield_on;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0     common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0     $REAL              u_relax;
            {  0     $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
               0  REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0    common/shell_data/
            {  0      shell_be($MAXSHELL),      "binding energies"
            {  0      shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0      shell_num($MAXSHELL),     "the shell position in the element"
            {  0      shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0      shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0      shell_ntot;               "total number of shells in the list"
            {  0    $REAL    shell_be;
            {  0    $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0    common/relax_data/
            {  0      relax_first($MAXSHELL),    "first transition"
            {  0      relax_ntran($MAXSHELL),    "number of transitions"
            {  0      relax_state($MAXRELAX),    "final state of the transition"
            {  0      relax_prob($MAXRELAX),     "probability"
            {  0      relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0      relax_ntot;                "total number of transitions in the list"
            {  0    $REAL     relax_prob;
            {  0    $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0      common/relax_for_user/
            {  0       rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0       rfu_E,  "binding energy of current vacancy"
            {  0       rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0       rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0       rfu_n0, "same but number is shell number in the element"
            {  0       rfu_t0, "same but number is shell type according to EADL notation"
            {  0       rfu_j,  "shell number of current vacancy"
            {  0       rfu_n,  "same but number is shell number in the element"
            {  0       rfu_t;  "same but number is shell type according to EADL notation"
            {  0      $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0      $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001D0"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0    common/pe_shell_data/
            {  0      pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0      pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0                                             "element of a medium"
            {  0      pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0      pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0      pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0      pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0      pe_zpos($MXELEMENT),       "position of each Z element"
            {  0      pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0      pe_ne;                    "number of elements in the simulation"
            {  0    $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0    $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0      PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0    ;common/ET_control/
            {  0                smaxir($MXREG),estepe,ximax,
            {  0                "ximin_for_bca,"
            {  0                skindepth_for_bca,transport_algorithm,
            {  0                bca_algorithm,exact_bca,spin_effects;
            {  0      $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0                estepe,             "global energy loss constrain"
            {  0                ximax,              "max. first GS moment per step"
            {  0                                    "(roughly half the average MS angle squared"
            {  0                "ximin_for_bca,"
            {  0                                    "min. first GS moment per step for boundary"
            {  0                                    "crossing in VMC mode"
            {  0                skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0                                    "to switch to one of the BCAs "
            {  0      $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0                bca_algorithm;      "will be used if other inexact BCAs"
            {  0                                    "implemented in the future"
            {  0      $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0                spin_effects;       "if .true. electron/positron spin effects"
            {  0                                    "are taken into account in the single and"
            {  0                                    "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0    common/ms_data/
            {  0                ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    real*4      ums_array,fms_array,wms_array,
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0    common/spin_data/
            {  0                spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0                espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0                fool_intel_optimizer;
            {  0    real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0    $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0    common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0    real*8           count_pII_steps,count_all_steps;
            {  0    $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0    COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0                  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0                  x_final,y_final,z_final,
            {  0                  u_final,v_final,w_final,
            {  0                  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0      $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0                        EDEP_LOCAL; "local energy deposition in MeV"
            {  0      $REAL             TSTEP,  "distance to a discrete interaction"
            {  0                        TUSTEP, "intended step length, befor check with geometry"
            {  0                        USTEP,  "transport distance calculated from TUSTEP"
            {  0                        VSTEP,  "transport distance after truncation by HOWFAR"
            {  0                        TVSTEP, "curved path-length calculated from TVSTEP"
            {  0                        RHOF,   "mass density ratio"
            {  0                        EOLD,   "energy before deduction of energy loss"
            {  0                        ENEW,   "energy after  deduction of energy loss"
            {  0                        EKE,    "kinetic energy"
            {  0                        ELKE,   "Log(EKE)"
            {  0                        GLE,    "Log(energy) in PHOTON"
            {  0                        E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0                        x_final,y_final,z_final, "position at end of step"
            {  0                        u_final,v_final,w_final; "direction at end of step"
            {  0                                                 "only set (and relevant) "
            {  0                                                 "for electrons"
            {  0      $INTEGER          IDISC,  "flag indicating user discard"
            {  0                        IROLD,  "region before transport"
            {  0                        IRNEW,  "region after transport"
            {  0                        IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0     COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0         $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0              IRAYLM,IPHOTONUCM($MXMED)),
            {  0              MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0              photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0     $TYPE    MEDIA;"media names"
            {  0     $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0              RLDU, "radiation length after user scaling over-ride"
            {  0              RHO,  "mass density of a given medium"
            {  0              apx, upx;"new photon xsection data thresholds"
            {  0     $INTEGER MSGE, "??? "
            {  0              MGE,  "number of photon mapped energy intervals for a given medium"
            {  0              MSEKE,"??? "
            {  0              MEKE, "number of e mapped energy intervals for a given medium"
            {  0              MLEKE,"??? "
            {  0              MCMFP,"??? "
            {  0              MRANGE,"??? "
            {  0              IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0              IPHOTONUCM,"photonuclear switch for a given medium"
            {  0              IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0              NMED;  "number of media"
            {  0     character*16 eii_xfile;
            {  0              "Defaults to eii_ik.data if On or Off options selected"
            {  0              "which is the EII implemented by Iwan for EGSnrc"
            {  0              "else, following options available: "
            {  0              "  eii_'casnati'.data    "
            {  0              "  eii_'kolbenstvedt'.data "
            {  0              "  eii_'gryzinski'.data"
            {  0              "these must be in $HEN_HOUSE/data"
            {  0     character*16 photon_xsections;
            {  0              "If photon_xsections is not empty, photon cross sections will be"
            {  0              "re-initialized using data files  "
            {  0              "  'photon_xsection'_photo.data   "
            {  0              "  'photon_xsection'_pair.data    "
            {  0              "  'photon_xsection'_triplet.data "
            {  0              "  'photon_xsection'_rayleigh.data"
            {  0              "that must be placed in $HEN_HOUSE/data"
            {  0     character*16 comp_xsections;
            {  0              "If comp_xsections is not empty or not set to 'default' and"
            {  0              "bound Compton scattering is On, then total Compton cross sections"
            {  0              "will be taken from 'comp_xsections'_compton.data"
            {  0              "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0     character*16 photonuc_xsections;
            {  0              "If photonuc_xsections is not empty or not set to 'default',"
            {  0              "the photonuclear cross sections will be taken from"
            {  0              "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0              "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0    COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0             DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0    $REAL    DUNIT,   "unit scaling factor"
            {  0             RHOR;    "density of a given region"
            {  0    $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0             KMPO;    "fortran unit number of pegs4 echo file"
            {  0    $SHORT_INT MED,   "medium number for a given region"
            {  0               IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0               IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0      COMMON/PHOTIN/
            {  0         EBINDA($MXMED),
            {  0         $LGN(GE($MXMED)/0,1/),
            {  0         $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0         $LGN(RCO($MXMED)/0,1/),
            {  0         $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0         $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0         $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0         DPMFP,
            {  0         MPGEM($MXSGE,$MXMED),
            {  0         NGR($MXMED);
            {  0      $REAL
            {  0         EBINDA,      "energy of the K-edge for a given medium"
            {  0         GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0         GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0         GBR10,GBR11, "used for branching into pair interpolation"
            {  0         GBR20,GBR21, "used for branching into Compton interpolation"
            {  0         RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0         RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0         COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0         PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0         DPMFP;       "number of MFP's to go to the next interaction"
            {  0      $INTEGER
            {  0         MPGEM,       "??? "
            {  0         NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0     COMMON/STACK/
            {  0         $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0         LATCHI,NP,NPold;
            {  0     $ENERGY PRECISION
            {  0         E;     "total particle energy"
            {  0     $REAL
            {  0         X,Y,Z, "particle co-ordinates"
            {  0         U,V,W, "particle direction cosines"
            {  0         DNEAR, "perpendicular distance to nearest boundary"
            {  0         WT;    "particle weight"
            {  0     $INTEGER
            {  0         IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0         IR,    "current region"
            {  0         LATCH, "extra phase space variable"
            {  0         LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0         NP,    "stack pointer"
            {  0         NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0     COMMON/THRESH/RMT2,RMSQ,
            {  0                   $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0     $REAL         RMT2,  "2*electron mass in MeV"
            {  0                   RMSQ,  "electron mass squared in MeV**2"
            {  0                   AP,    "photon creation threshold energy"
            {  0                   AE,    "electron creation threshold energy (total)"
            {  0                   UP,    "upper photon energy in PEGS4 data set"
            {  0                   UE,    "upper electron energy in PEGS4 data set"
            {  0                   TE,    "electron creation threshold energy (kinetic)"
            {  0                   THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0     COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0     $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0     COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0                   COSPHI,PI,TWOPI,PI5D2;
            {  0     $REAL         THETA,  "polar scattering angle"
            {  0                   SINTHE, "sin(THETA)"
            {  0                   COSTHE, "cos(THETA)"
            {  0                   SINPHI, "sine of the azimuthal scattering angle"
            {  0                   COSPHI, "cosine of the azimuthal scattering angle"
            {  0                   PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0     COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0     $ENERGY PRECISION PZERO,   "precise zero"
            {  0                       PRM,     "precise electron mass in MeV"
            {  0                       PRMT2;   "2*PRM"
            {  0     $REAL             RM;      "electron mass in MeV"
            {  0     $INTEGER          MEDIUM,  "medium index of current region"
            {  0                       MEDOLD;  "medium index of previous region"
            {  0     " The rest mass value is as recommended by CODATA 2014"
            {  0     " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0     DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0           ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0      ;
            {  0    common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0                     mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0    $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0       ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0      ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0      ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0             EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0      ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0             EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0     ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0     ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0     ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0     ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0            STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0    ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0    ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0    EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0    THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0    ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0         EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0    ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0    ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0    ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0    ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0           BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0      IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0      [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0      [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0    [IF] '{P2}'=SNAME1
            {  0    [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0    [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0    {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0    {P2}2(L{P3},L{P4})*
            {  0    {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0      X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0      WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0     "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0     "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0     "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0     "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0     "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0    ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0    ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0                                    "energy dependent quantities"
            {  0    $CALCULATE-XI(tustep);
            {  0    IF ( xi < 0.1 )
            {  0      [
            {  0        ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        ustep = tustep*(1 - Exp(-xi))/xi;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0    p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0    chia2 = xccl/(4*blccl*p2);
            {  0                                  "Note that our chia2 is Moliere chia2/4"
            {  0                                  "Note also that xcc is now old egs xcc**2"
            {  0    xi = 0.5*xccl/p2/beta2*{P1};
            {  0    IF( spin_effects ) [
            {  0        elkems = Log(ekems);
            {  0        $SET INTERVAL elkems,eke;
            {  0        IF(lelec < 0) [
            {  0            $EVALUATE etap USING etae_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0        ]
            {  0        ELSE          [
            {  0            $EVALUATE etap USING etap_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0        ]
            {  0        chia2 = chia2*etap; xi = xi*xi_corr;
            {  0        $EVALUATE ms_corr USING blcce(elkems);
            {  0        blccl = blccl*ms_corr;
            {  0    ]
            {  0    ELSE [ xi_corr = 1; etap = 1; ]
            {  0    xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0      ;IF ( vstep < ustep0 )
            {  0      [
            {  0        ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0           "This estimates the energy loss to the boundary."
            {  0           "tustep was the intended curved path-length,"
            {  0           "ustep0 is the average transport distance in the initial direction"
            {  0           "       resulting from tustep"
            {  0           "vstep = ustep is the reduced average transport distance in the "
            {  0           "              initial direction due to boundary crossing"
            {  0        $CALCULATE-XI(vstep);
            {  0        IF ( xi < 0.1 )
            {  0        [
            {  0          tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0        ]
            {  0        ELSE
            {  0        [
            {  0
            {  0          IF ( xi < 0.999999 )
            {  0          [
            {  0             tvstep = -vstep*Log(1 - xi)/xi;
            {  0          ]
            {  0          ELSE
            {  0          [
            {  0             "This is an error condition because the average transition "
            {  0             "in the initial direction of motion is always smaller than 1/Q1"
            {  0             $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0             $egs_info(*,' Medium: ',medium);
            {  0             $egs_info(*,' Initial energy: ',eke);
            {  0             $egs_info(*,' Average step energy: ',ekems);
            {  0             $egs_info(*,' tustep: ',tustep);
            {  0             $egs_info(*,' ustep0: ',ustep0);
            {  0             $egs_info(*,' vstep:  ',vstep);
            {  0             $egs_info(*,' ==> xi = ',xi);
            {  0             $egs_fatal(*,'This is a fatal error condition');
            {  0          ]
            {  0        ]
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        tvstep = tustep;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0              "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0              "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0      ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0      $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0     ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0     $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0    IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0     ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0     IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0     (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0     4E14.6);
            {  0     IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0     USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0      IF(ustep <= 0) [
            {  0          "Negative ustep---probable truncation problem at a"
            {  0          "boundary, which means we are not in the region we think"
            {  0          "we are in.  The default macro assumes that user has set"
            {  0          "irnew to the region we are really most likely to be"
            {  0          "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0          IF(ustep < -1e-4) [
            {  0              ierust = ierust + 1;
            {  0              OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0                     ir(np),irnew,irold,x(np),y(np),z(np);
            {  0              (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0               ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0              IF(ierust > 1000) [
            {  0                  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0                  $CALL_EXIT(1);
            {  0              ]
            {  0          ]
            {  0          ustep = 0;
            {  0      ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0           $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0     WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0          $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0           DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0         $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0           DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0    ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0        IF(tperp >= range) ["particle cannot escape local region"
            {  0            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0            go to :USER-ELECTRON-DISCARD: ;
            {  0        ]
            {  0    ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0                              fcum($MXRAYFF,$MXMED),
            {  0                             b_array($MXRAYFF,$MXMED),
            {  0                             c_array($MXRAYFF,$MXMED),
            {  0                             i_array($RAYCDFSIZE,$MXMED),
            {  0                             $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0       ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0      GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0        ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0     $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0     Q2=X2*RMSQ/(20.60744*20.60744);
            {  0     COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0     IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0     CSQTHE=COSTHE*COSTHE;
            {  0     REJF=(1.0+CSQTHE)/2.0;
            {  0     $RANDOMSET RNNORJ;
            {  0     ] UNTIL (RNNORJ <= REJF);
            {  0     SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0    }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0     ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0     CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0       ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0      GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0     ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0        $RANDOMSET RNNO39;
            {  0        IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0          $AUSCALL($PHOTONUCAUSB);
            {  0          call PHOTONUC;
            {  0          $AUSCALL($PHOTONUCAUSA);
            {  0          GOTO :PNEWENERGY:;
            {  0        ]
            {  0      ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
               0  REPLACE {;COMIN/EM/;} WITH {;}
               0  REPLACE {$EMFIELD_PII;} WITH {;}
               0  REPLACE{$EMFIELD_PI;}WITH{;}
               0  REPLACE{$EM_FIELD_SS;}WITH{;}
               0  REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
               0  REPLACE{$EMFieldInVacuum;}WITH{;}
               0  REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0        ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0        $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0   UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0   V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0   IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0   [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0   (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0   (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0   (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0   [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0   [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0      $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0     $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0     IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0     ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0     $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0     IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0     BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0     -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0     IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0     {P4}=-2.0*BCYL/ACYL;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0     [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0     ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0     ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0   $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0     ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0     $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0     {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0     CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0     WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0     CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0     DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0     ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0     BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0     CCON=DCON1*CPCON-ZNP*ZNP;
            {  0     IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0     [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0     IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0     TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0     [{P4}=TCON1;{P3}=1;]]]]]
            {  0     ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0     IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0     [BPRIM=BCON1-WNP*DCON2;
            {  0     IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0     IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0     [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0     IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0     IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0     ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0     IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0     ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0     IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0     IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0     ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0     TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0     IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0     ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0     [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0     ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0     $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0     BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0     +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0     IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0     {P4}=-2.0*BSPH/ASPH;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0     [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0     [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0   $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0      ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0     {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0     {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0    EELEC=E(NP);
            {  0    IF(EELEC.GT.ECUT(IR(NP)))[
            {  0      BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0      GAMMA=EELEC/RM;
            {  0      ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0      RATIO=BETA/ALPHA;
            {  0      LOOP[
            {  0        $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0        IF(RATIO.LE.0.2)[
            {  0          FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0          IF( gamma < 100 ) [
            {  0              COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0          ]
            {  0          ELSE [
            {  0              IF( fkappa > 0 ) [
            {  0                  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0              ]
            {  0              ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0          ]
            {  0          "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0          "                            at high energies, IK"
            {  0          xi = (1+beta*fkappa)*gamma*gamma;
            {  0        ]
            {  0        ELSE[
            {  0          XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0          COSTHE=(1.-1./XI)/BETA;
            {  0        ]
            {  0        SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0        $RANDOMSET RNPHT2;
            {  0        ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0      SINTHE=SQRT(SINTH2);
            {  0      CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0                  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0      IF( iprdst > 0 ) [
            {  0          IF( iprdst = 4 ) [
            {  0              $RANDOMSET rtest;
            {  0              "gbeta = (1-rmt2/eig)**8;"
            {  0              gbeta = PESE1/(PESE1+10);
            {  0              IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0              ELSE [ iprdst_use = 4; ]
            {  0          ]
            {  0          ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0          ELSE [ iprdst_use = iprdst; ]
            {  0          DO ichrg = 1,2 [
            {  0              IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0                  ESE=ESE2;
            {  0                  IF( iprdst = 4 ) [
            {  0                      gbeta = ESE/(ESE+10);
            {  0                      $RANDOMSET rtest;
            {  0                      IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0                      ELSE [ iprdst_use = 4; ]
            {  0                  ]
            {  0              ]
            {  0              IF( iprdst_use = 1 ) [
            {  0                  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0                  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 2 ) [
            {  0                  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0                  ZTARG=ZBRANG(MEDIUM);
            {  0                  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTEIG=EIG/RM;
            {  0                  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTESE=ESE/RM;
            {  0                  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0                  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0                  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0                  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0                  ESEDER=1.0/ESEDEI;
            {  0                  "DETERMINE THE NORMALIZATION "
            {  0                  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0                  YA=(2.0/TTEIG)**2;
            {  0                  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0                  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0                  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0                  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0                  XIMID=GALPHA/(3.0*GBETA);
            {  0                  IF(GALPHA.GE.0.0)[
            {  0                      XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  ELSE[
            {  0                      XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0                  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0                  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0                  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0                  LOOP[
            {  0                      $RANDOMSET XITST;
            {  0                      $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0                      $RANDOMSET RTEST;
            {  0                      "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0                      THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0                      "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0                      REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0                  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0                  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 3 ) [
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0              ]
            {  0              ELSE [
            {  0                  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0                  "$RANDOMSET costhe;"
            {  0                  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0                  $RANDOMSET costhe;
            {  0                  costhe=1-2*sqrt(costhe);
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0              ]
            {  0              IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0              ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0          ]
            {  0          iq(np) = iq2; iq(np-1) = iq1; return;
            {  0      ]
            {  0      ELSE[
            {  0          THETA=0; "THETA=RM/EIG; "
            {  0      ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0          4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0              1.0+0.25*LOG(
            {  0                  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0                  )
            {  0              )
            {  0          ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0    $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0    PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0    elktmp = elke + Log(1 - {P1});
            {  0    $SET INTERVAL elktmp,eke;
            {  0    lelktmp = max(1,lelktmp);
            {  0    IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0    ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0    dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0                     "0.17408298 is 2/3*m**2"
            {  0    {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0    "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0    "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0                                          "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Uniform Run Control (URC) is false by default"
               0  REPLACE {$URC-DEFAULT} WITH {.false.}
               0  ;
               0  "SLEEP INTERVAL for URC (1 s by default)"
               0  "Time to wait for jobs to complete after last job finished"
               0  REPLACE {$URC-SLEEP} WITH {1}
               0  "Times to check for jobs to complete after last job finished"
               0  REPLACE {$URC-INTERVALS} WITH {1}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0              "This macro sets the minimum step size for a condensed"
               0              "history (CH) step. When the exact BCA is used, the minimum"
               0              "CH step is determined by efficiency considerations only"
               0              "At about 3 elastic MFP's single scattering becomes more"
               0              "efficient than CH and so the algorithm switches off CH"
               0              "If one of the various inexact BCA's is invoked, this macro"
               0              "provides a simple way to include more sophisticated"
               0              "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0     $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0     skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0      blccl = rhof*blcc(medium);
            {  0      xccl  = rhof*xcc(medium);
            {  0      p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0      IF ( spin_effects ) [
            {  0        IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0        ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0        $EVALUATE ms_corr USING blcce({P3});
            {  0        blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0      ]
            {  0      {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0      $SET-SCREENING-ANGLE({P1});
            {  0      call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0      chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0    IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0    IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0      (
            {  0          ' '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' PRESTA-II is aborting execution because you have not defined   '/
            {  0          ' the HOWNEAR macro for your geometry.                           '/
            {  0          ' '/
            {  0          ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0          ' which does not attempt the refined boundary crossing or lateral'/
            {  0          ' correlation features of the algorithm.                         '/
            {  0          ' '/
            {  0          ' If you include the following macro in your usercode:           '/
            {  0          ' '/
            {  0          ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0          ' '/
            {  0          ' you can choose between single scattering mode (very slow) and  '/
            {  0          ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0          ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0          ' manual)                                                        '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' '/
            {  0      );
            {  0      stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0                                          "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0      $RANDOMSET xphi;
            {  0      xphi  = 2*xphi - 1;
            {  0      xphi2 = xphi*xphi;
            {  0      $RANDOMSET yphi;
            {  0      yphi2  = yphi*yphi;
            {  0      rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0    $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PAVIP,    "precise total energy in the laboratory frame"
            {  0        PESG1,    "precise energy of 1st annihilation photon"
            {  0        PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0        A,        "total energy in units of the electron's rest energy"
            {  0        G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0        POT,      "P/T"
            {  0        EP0,      "minimum fractional energy"
            {  0        WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0        RNNO01,   "random numbers"
            {  0        RNNO02,
            {  0        EP,       "fractional energy of the more energetic photon"
            {  0        REJF,     "rejection function"
            {  0        ESG1,     "energy of the more energetic photon"
            {  0        ESG2,     "energy of the less energetic photon"
            {  0        aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0                  "for inline rotations"
            {  0  $INTEGER
            {  0        ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIP,     "precise total energy of incident positron"
            {  0        PEKIN,    "precise kinetic energy of incident positron"
            {  0        PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0        PESE1,    "precise total energy of first 'electron'"
            {  0        PESE2,    "precise total energy of second 'electron'"
            {  0        H1,       "used in direction cosine calculations"
            {  0        DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0        EKIN,     "kinetic energy of incident positron"
            {  0        T0,       "kinetic energy of incident positron in units of RM"
            {  0        E0,       "total energy of incident positron in units of RM"
            {  0        E02,      "E0**2"
            {  0        YY,       "1/(T0+2)"
            {  0        Y2,YP,YP2,"various functions of YY"
            {  0        BETA2,    "incident positron velocity in units of c"
            {  0        EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0        EP0C,     "1-EP0"
            {  0        B1,B2,B3,B4,  "used in rejection function calculation"
            {  0        RNNO03,RNNO04,"random numbers"
            {  0        BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0        REJF2,    "rejection function"
            {  0        ESE1,     "total energy of 1st 'electron'"
            {  0        ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0    PEIE,   "precise incident electron energy"
            {  0    PESG,   "presice energy of emitted photon"
            {  0    PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0    EIE,    "total incident electron energy"
            {  0    EKIN,   "kinetic incident energy"
            {  0    brmin,  " ap(medium)/ekin"
            {  0    waux,   "for faster sampling of 1/br"
            {  0    aux,    "ese/eie"
            {  0    r1,     "a random number"
            {  0    ajj,    "for energy bin determination if alias sampling is employed"
            {  0    alias_sample1,
            {  0    RNNO06, "random number"
            {  0    RNNO07, "random number"
            {  0    BR,     "energy fraction of secondary photon"
            {  0    ESG,    "energy of secondary photon"
            {  0    ESE,    "total energy of secondary electron"
            {  0    DELTA,  "scaled momentum transfer"
            {  0    phi1,   "screening function"
            {  0    phi2,   "screening function"
            {  0    REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0    a,b,c,  "direction cosines of incident `electron'"
            {  0    sinpsi, sindel, cosdel, us, vs,
            {  0            "all used for rotations"
            {  0    ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0    tteie,  "total energy in units of rest energy"
            {  0    beta,   "electron velocity in units of speed of light"
            {  0    y2max,  "maximum possible scaled angle"
            {  0    y2maxi, "inverse of the above"
            {  0    ttese,  "new electron energy in units of rm"
            {  0    rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0            "all of them used for angle rejection function calcs"
            {  0    esedei, "new total energy over old total energy"
            {  0    y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0    y2tst1,
            {  0    rtest,  "random number for rejection"
            {  0    xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0            "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0    L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIE,  "total incident electron energy in units of RM"
            {  0        TTESE,  "total scattered electron energy in units of RM"
            {  0        ESEDEI, "TTESE/TTEIE"
            {  0        beta,   "electron speed in units of c"
            {  0        Y2MAX,  "maximum value of the scaled angle"
            {  0        RJARG1,RJARG2,RJARG3,
            {  0                "arguments for which the rejection function is calculated"
            {  0        REJMIN,REJMID,REJMAX,
            {  0                "corresponding values of the rejection function"
            {  0        REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0        Y2TST,  "random number and candidate for a scaled angle"
            {  0        REJTST, "rejection function at Y2TST"
            {  0        Y2TST1, "aux. variable for rejection function calculation"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        Jo,     "the Compton profile parameter"
            {  0        br2,    "br*br"
            {  0        fpz,fpz1,"used for limited pz-range rejection"
            {  0        qc,     "momentum transfer corresponding to the Compton line energy"
            {  0        qc2,    "qc squared"
            {  0        af,     "for calculating F"
            {  0        Fmax,   "maximum of F"
            {  0        frej,   "used for F-rejection"
            {  0        eta_incoh, eta, "random numbers"
            {  0        aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0        pzmax,  "max. possible z-component of the initial electron momentum"
            {  0        pz,     "initial electron momentum projection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        br2,    "br*br"
            {  0        aux,aux1,aux2,"aux. variables"
            {  0        pzmax2, "max. possible momentum transfer squared"
            {  0        pz,     "momentum transfer prejection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0      demfp,        "differential electron mean free path"
            {  0      peie,         "precise energy of incident electron"
            {  0      total_tstep,  "total path-length to next discrete interaction"
            {  0      total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0      ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0      elkems,     "Log(ekems)"
            {  0      chia2,      "Multiple scattering screening angle"
            {  0      etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0      lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0      blccl,      "blcc(medium)*rhof"
            {  0      xccl,       "xcc(medium)*rhof"
            {  0      xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0      xi_corr,    "correction to xi due to spin effects"
            {  0      ms_corr,
            {  0      p2,         "electron momentum times c, squared"
            {  0      beta2,      "electron speed in units of c, squared"
            {  0      de,         "energy loss to dedx"
            {  0      save_de,    "de saved before $DE-FLUCTUATION"
            {  0      dedx,       "stopping power after density scaling"
            {  0      dedx0,      "stopping power before density scaling"
            {  0      dedxmid,    "stopping power at mid-step before density scaling"
            {  0      ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      aux,        "aux. variable"
            {  0      ebr1,       "e- branching ratio into brem"
            {  0      eie,        "energy of incident electron"
            {  0      ekef,       "kinetic energy after a step"
            {  0      elkef,      "Log(ekef)"
            {  0      ekeold,     "kinetic energy before a step"
            {  0      eketmp,     "used to evaluate average kinetic energy of a step"
            {  0      elktmp,     "log(eketmp)"
            {  0      fedep,      "fractional energy loss used in stopping power calculation"
            {  0      tuss,       "sampled path-length to a single scattering event"
            {  0      pbr1,       "e+ branching ratio into brem"
            {  0      pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0      range,      "electron range"
            {  0      rfict,      "rejection function for fictitious cross section"
            {  0      rnne1,      "random number"
            {  0      rnno24,     "random number"
            {  0      rnno25,     "random number"
            {  0      rnnotu,     "random number"
            {  0      rnnoss,     "random number"
            {  0      sig,        "cross section after density scaling but before a step"
            {  0      sig0,       "cross section before density scaling but before a step"
            {  0      sigf,       "cross section before density scaling but after a step"
            {  0      skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0      ssmfp,      "distance of one single elastic scattering mean free path"
            {  0      tmxs,       "electron step-size restriction"
            {  0      tperp,      "perpendicular distance to the closest boundary"
            {  0      ustep0,     "temporary storage for ustep"
            {  0      uscat,      "x-axis direction cosine for scattering"
            {  0      vscat,      "y-axis direction cosine for scattering"
            {  0      wscat,      "z-axis direction cosine for scattering"
            {  0      xtrans,     "final x-axis position after transport"
            {  0      ytrans,     "final y-axis position after transport"
            {  0      ztrans,     "final z-axis position after transport"
            {  0      cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0      iarg,      "calling code for ausgab"
            {  0      idr,       "calling code for ausgab"
            {  0      ierust,    "error counter for negative ustep errors"
            {  0      irl,       "region number"
            {  0      lelec,     "charge of electron"
            {  0      qel,       " = 0 for electrons, = 1 for positrons "
            {  0      lelke,     "index into the energy grid of tabulated functions"
            {  0      lelkems,   "index into the energy grid of tabulated functions"
            {  0      lelkef,    "index into the energy grid of tabulated functions"
            {  0      lelktmp,   "index into the energy grid of tabulated functions"
            {  0      ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0      "BCA = boundary crossing algorithm"
            {  0      callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0                  "= .false. => BCA does not require a call to howfar"
            {  0      domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0      dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0                  "= .false. => exact BCA requires no single scattering"
            {  0      callmsdist, "= .true.  => normal condensed-history transport"
            {  0                  "= .false. => one of the BCA's will be invoked"
            {  0      findindex,  "used for mscat"
            {  0      spin_index, "used for mscat with spin effects"
            {  0      compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0      ACD   , "used to test goodness of sine-table look-up"
            {  0      ADEV  , "absolute deviation in sine-table look-up"
            {  0      ASD   , "used to test goodness of sine-table look-up"
            {  0      COST  , "cos(theta) from instrinsic library function"
            {  0      CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0      DEL   , "leat squares delta for sine-table look-up"
            {  0      DFACT , "converts rl to dunits"
            {  0      DFACTI, "converts rl**-1 to dunits**-1"
            {  0      DUNITO, "units scaling varable"
            {  0      DUNITR, "saved value of dunit"
            {  0      FNSSS , "real form of integer nsinss"
            {  0      P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0      PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0      RDEV  , "relative deviation in sine-table look-up"
            {  0      S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0      S2C2MN, "min(s2c2)"
            {  0      S2C2MX, "max(s2c2)"
            {  0      SINT  , "sin(theta) from instrinsic library function"
            {  0      SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0      SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0      SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0              "table errors"
            {  0      SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0              "errors"
            {  0      WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0      XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0      XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0      WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0      YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0      ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0      I     , "generic do-loop variable"
            {  0      I1ST  , "flag = 0 on first pass"
            {  0      IB    , "do-loop variable used for reading the medium type"
            {  0      ID    , "integer value of -dunit, when dunit is negative"
            {  0      IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0      IL    , "do-loop variable used for reading the medium type"
            {  0      IM    , "do-loop variable looping over nmed, number of media"
            {  0      IRAYL , "Rayleigh switch read in from PEGS"
            {  0      IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0      ISTEST, "flag that switches on test of sine function fit"
            {  0      ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0      ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0      IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0              "sine-table look-up"
            {  0      IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0      J     , "do-loop variable looping over nmed, number of media"
            {  0      JR    , "do-loop variable looping over number of regions"
            {  0      LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0      LMDL  , "character width of medium header ' MEDIUM='"
            {  0      LMDN  , "character width of medium description"
            {  0      LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0      MD    , "temporary storage for the medium number"
            {  0      MXSINC, "number of intervals approximating the sine function"
            {  0      NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be cumulative electron mean free path. Presently unused."
            {  0      NEKE  , "array size input from PEGS."
            {  0              "Number of electron mapped energy intervals."
            {  0      NGE   , "array size input from PEGS."
            {  0              "Number of photon mapped energy intervals."
            {  0      NGRIM , "Rayleigh cross section array size."
            {  0      NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0      NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron energy intervals below threshold."
            {  0              "Presently unused."
            {  0      NM    , "number of media found in the "
            {  0      NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of intervals in an array giving the electron range."
            {  0              "Presently unused."
            {  0      NRNA  , "number of random angles testing sine function fit"
            {  0      NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron small energy intervals. Presently unused."
            {  0      NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of gamma small energy intervals. Presently unused."
            {  0      NSINSS, "number of sub-intervals for each sine function interval"
            {  0      LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0                   "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0       PEIE,   "precise total energy of incident electron"
            {  0       PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0       PESE1,  "precise total energy of 1st secondary electron"
            {  0       PESE2,  "precise total energy of 2nd secondary electron"
            {  0       PEKIN,  "precise kinetic energy of incident electron"
            {  0       H1,     "used for polar scattering angle calculation"
            {  0       DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0       EKIN,   "kinetic energy of incident electron"
            {  0       T0,     "kinetic energy of incident electron in units of RM"
            {  0       E0,     "total energy of incident electron in units of RM"
            {  0       EXTRAE, "energy above the Moller threshold"
            {  0       E02,    "E0**2"
            {  0       EP0,    "minimum alowed kinetic energy fraction"
            {  0       G2,G3,  "used for rejection function calculation"
            {  0       GMAX,   "maximum value of the rejection function"
            {  0       BR,     "kinetic energy fraction to lowew energy electron"
            {  0       R,      "(1-BR)/BR"
            {  0       REJF4,  "rejection function"
            {  0       RNNO27, "random number for BR sampling"
            {  0       RNNO28, "random number for rejection"
            {  0       ESE1,   "energy of 1st secondary electron"
            {  0       ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,      "precise energy of incident photon"
            {  0        PESE1,     "precise energy of 1st 'electron'"
            {  0        PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0        ESE2,      "total energy of lower energy 'electron'"
            {  0        RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0                   "random numbers"
            {  0        DELTA,     "scaled momentum transfer"
            {  0        REJF,      "screening rejection function"
            {  0        rejmax,    "the maximum of rejf"
            {  0        aux1,aux2, "auxilary variables"
            {  0        Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0        Bmax,      "Maximum of the screening function used with the uniform part"
            {  0        del0,      "delcm*eig"
            {  0        br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0                   "lower energy `electron'"
            {  0        Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0        L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0        PSE,   "momentum corresponding to ESE"
            {  0        ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIG, "incident photon energy in units of RM"
            {  0        TTESE, "energy of one of the 'electrons' in units of RM"
            {  0        TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0        ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0        ESEDER,"1/ESEDEI"
            {  0        XIMIN, "1st argument where rejection function might have a maximum"
            {  0        XIMID, "2nd argument where rejection function might have a maximum"
            {  0        REJMIN,"rejection function at XIMIN"
            {  0        REJMID,"rejection function at XIMID"
            {  0        REJTOP,"max(REJMIN,REJMID)"
            {  0        YA,XITRY,GALPHA,GBETA,
            {  0               "aux. variables for XIMID calculation"
            {  0        XITST, "random number for pair angle sampling"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        REJTST,"rejection function at XITST"
            {  0        RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0        ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0        PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0        sigma,        "elemental cross section"
            {  0        aux,aux1,     "aux. variables"
            {  0        probs($MXEL), "probability for an interaction with a given element"
            {  0        sigtot,       "total cross section"
            {  0        e_vac,        "shell binding energy"
            {  0        rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0        IARG,         "AUSGAB calling switch"
            {  0        iZ,           "Atomic number of the element the photon is "
            {  0                      "interactiong with"
            {  0        irl,          "local region number"
            {  0        ints($MXEL),  "energy interval number for a given element"
            {  0        j,ip,         "loop variables"
            {  0        n_warning,    "a warning counter"
            {  0        k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0        do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0        BETA,  "velocity of electron in units of c"
            {  0        GAMMA, "total energy of photo-electron in units of RM"
            {  0        ALPHA, "kinematic factor"
            {  0        RATIO, "=BETA/ALPHA"
            {  0        RNPHT, "random number"
            {  0        FKAPPA,"aux. variable for COSTHE calculation"
            {  0        XI,    "used in rejection function calculation"
            {  0        SINTH2,"SINTHE**2"
            {  0        RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0        "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0      PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0      EIG,    "photon energy"
            {  0      RNNO35, "random number for default MFP selection"
            {  0      GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0      GMFP,   "photon MFP after density scaling"
            {  0      COHFAC, "Rayleigh scattering correction"
            {  0      RNNO37, "random number for Rayleigh scattering selection"
            {  0      XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0      X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0      Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0      CSQTHE, "COSTHE**2"
            {  0      REJF,   "Rayleigh scattering rejection function"
            {  0      RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0      RNNO36, "random number for interaction branching"
            {  0      GBR1,   "probability for pair production"
            {  0      GBR2,   "probability for pair + compton"
            {  0      T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0      PHOTONUCFAC, "photonuclear correction"
            {  0      RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0      IARG,   "parameter for AUSGAB"
            {  0      IDR,    "parameter for AUSGAB"
            {  0      IRL,    "region number"
            {  0      LGLE,   "index for GMFP interpolation"
            {  0      LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0     IF( sig_ismonotone(qel,medium) ) [
            {  0         $EVALUATE-SIGF; sig0 = sigf;
            {  0     ]
            {  0     ELSE [
            {  0         IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0         ELSE            [sig0 = psig_e(medium);]
            {  0     ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0    IF(lelec < 0)
            {  0    [
            {  0        $EVALUATE sigf USING esig(elke);
            {  0        $EVALUATE dedx0 USING ededx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0    ELSE
            {  0    [
            {  0        $EVALUATE sigf USING psig(elke);
            {  0        $EVALUATE dedx0 USING pdedx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0      $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0      $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0      $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0     sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0    IF( compute_tstep ) [
            {  0      total_de = demfp/sig; fedep = total_de;
            {  0      ekef  = eke - fedep;
            {  0      IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0      ELSE
            {  0      [
            {  0        elkef = Log(ekef);
            {  0        $SET INTERVAL elkef,eke;
            {  0        IF( lelkef = lelke )
            {  0        [       " initial and final energy are in the same interpolation bin "
            {  0            $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0        ]
            {  0        ELSE
            {  0        [   " initial and final energy are in different interpolation bins, "
            {  0            " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0            " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0            ekei = E_array(lelke,medium);
            {  0            elkei = (lelke - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0            ekei = E_array(lelkef+1,medium);
            {  0            elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0            tstep=tstep+tuss+
            {  0                    range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0        ]
            {  0      ]
            {  0      total_tstep = tstep;
            {  0      compute_tstep = .false.;
            {  0    ]
            {  0    tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0    fedep = 1 - {P2}/{P1};
            {  0    elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0             " the above evaluates the logarithm of the midpoint energy"
            {  0    lelktmp = {P3};
            {  0    IF(lelec < 0) [
            {  0        $EVALUATE dedxmid USING ededx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = ededx1(lelktmp,medium)*dedxmid;
            {  0        "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0        "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0    "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0    {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0    ekei = E_array(lelke,medium);
            {  0    elkei = (lelke - eke0(medium))/eke1(medium);
            {  0    $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0    range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0    demfp = demfp - save_de*sig;
            {  0    total_de = total_de - save_de;
            {  0    total_tstep = total_tstep - tvstep*rhof;
            {  0    IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0    IF( lelec < 0 ) [
            {  0        $EVALUATE dedxmid USING ededx({P3});
            {  0        aux = ededx1({P4},medium)/dedxmid;
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx({P3});
            {  0        aux = pdedx1({P4},medium)/dedxmid;
            {  0    ]
            {  0
            {  0
            {  0
            {  0    {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0                              "rhof scaling must be done here and NOT in "
            {  0                              "$COMPUTE-ELOSS-G below!"
            {  0    fedep = {P5}/{P2};
            {  0    {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0               0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0    tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0      " here tuss is the range between the initial energy and the next lower "
            {  0      " energy on the interpolation grid "
            {  0    IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0        $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0        "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0        "    $COMPUTE-ELOSS above!                                  "
            {  0    ]
            {  0    ELSE [ " Must find first the table index where the step ends using "
            {  0           " pre-calculated ranges                                     "
            {  0        lelktmp = {P4};
            {  0        tuss = (range - {P1})*rhof;
            {  0           " now tuss is the range of the final energy electron "
            {  0           " scaled to the default mass density from PEGS4      "
            {  0        IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0          " i.e., if the step we intend to take is longer than the particle "
            {  0          " range, the particle energy goes down to the threshold "
            {  0          "({P2} is the initial particle energy)  "
            {  0          "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0          "to deal with such large eloss fractions => changed July 2005."
            {  0        ELSE [
            {  0            WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0                lelktmp = lelktmp - 1; ]
            {  0            elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0            eketmp = E_array(lelktmp+1,medium);
            {  0            "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0            "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0            "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0            tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0            $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0            {P5} = {P5} + {P2} - eketmp;
            {  0        ]
            {  0    ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0    ;COMMON/GetInput/
            {  0          ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0                                     "array index(0:4) for a value sought"
            {  0          VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0          CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0          VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0          DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0          VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0          VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0          NVALUE($NMAX),             "Number of values per value sought  "
            {  0          TYPE($NMAX),               "Type of the value sought           "
            {  0                                     "0 for integer                      "
            {  0                                     "1 for real                         "
            {  0                                     "2 for character                    "
            {  0                                     "3 for character with allowed_inputs"
            {  0          ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0                                     "attempted inputs                   "
            {  0          i_errors,                  "Unit no. for .errors output file   "
            {  0          NMIN, NMAX,                "Minimum and maximum index number of"
            {  0                                     "the values sought                  "
            {  0          ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0          DELIMETER;                 "Name of the delimeter              "
            {  0     character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0               CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
            {  0     $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0     $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0                          "Suppresses warnings from Intel compiler on Windows"
               0                     "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0    common/egs_vr/
            {  0      e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0      prob_RR,          "probability for survival in R. Roulette"
            {  0      nbr_split,        "do brems splitting if > 1"
            {  0      i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0      i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0                        "eliminated by RR in this interaction"
            {  0      n_RR_warning,     "a counter for user errors"
            {  0      i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0    $REAL          e_max_rr,prob_RR;
            {  0    $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0    $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0    i_survived_RR = 0;   "flag all survive"
            {  0    ;IF( i_play_RR = 1 ) [
            {  0        IF( prob_RR <= 0 ) [
            {  0            IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0              n_RR_warning = n_RR_warning + 1;
            {  0              OUTPUT prob_RR;
            {  0    ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0            ]
            {  0        ]
            {  0        ELSE [
            {  0            ip = {P1};
            {  0            LOOP [     "handle all particles from p1 to np"
            {  0                IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0                    $RANDOMSET rnno_RR;
            {  0                    IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0                        wt(ip) = wt(ip)/prob_RR;
            {  0                        ip = ip + 1; "increase local pointer"
            {  0                    ]
            {  0                    ELSE [                    "particle killed"
            {  0                        ;i_survived_RR = i_survived_RR + 1;
            {  0                        ;IF(ip < np) [
            {  0                            "=>replace it with last particle on stack"
            {  0                            e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0                        ]
            {  0                        np = np-1; "reduce stack by one=> particle gone"
            {  0                    ] "end of kill particle block"
            {  0                ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0            ] UNTIL (ip > np);
            {  0            "loops until either np is decreased to ip, or ip increased to np"
            {  0            IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0                           " so that the transport routines can exit properly"
            {  0                np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0            ]
            {  0        ] "end of russian roulette block"
            {  0    ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0      IF( radc_flag = 1 ) [
            {  0          $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0          $egs_info(*,'without having included rad_compton1.mortran');
            {  0          $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0          radc_flag = 0;
            {  0      ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0          ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0          ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0    DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0    $warning('(/a)','***************** Warning: ');
            {  0    $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0  "****************************************************************"
               0  " Useful output macros that do not rely on standard output unit. "
               0  " Useful for debugging code after egs_finish call which closes   "
               0  " all open units (for instance after a parallel job finishes).   "
               0  "****************************************************************"
               0  REPLACE {$egs_track2(#,#,#,#);} WITH {
            {  0        open({P1},file={P2},action='write',position='append');
            {  0        write({P1},{P3}) {P4};
            {  0        $FLUSH_UNIT({P1});
            {  0        close({P1});
            {  0  };
               0  REPLACE {$egs_track1(#,#,#);} WITH {
            {  0        open(666,file={P1},action='write',position='append');
            {  0        write(666,{P2}) {P3};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  REPLACE {$egs_track0(#,#);} WITH {
            {  0        open(666,file='track.log',action='write',position='append');
            {  0        write(666,{P1}) {P2};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  "************************************************************"
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0    common /egs_io/ file_extensions($mx_units),
            {  0                    file_units($mx_units),
            {  0                    user_code,  "The name of the user code"
            {  0                    input_file, "The input file name with path but no extension"
            {  0                    output_file,"Same as above but for output"
            {  0                    pegs_file,  "The pegs file name with path and extension"
            {  0                    hen_house,  "The HEN_HOUSE directory"
            {  0                    egs_home,   "The EGS_HOME directory"
            {  0                    work_dir,   "The working directory within the user code dir."
            {  0                    host_name,  "The name of the host"
            {  0                    n_parallel, "if >0, number of parallel jobs"
            {  0                    i_parallel, "if >0, parallel job number"
            {  0                    first_parallel,"first parallel job (default is 1)"
            {  0                    n_max_parallel,"if parallel run, max. number of running jobs"
            {  0                    n_chunk,    "Histories per calculation chunk"
            {  0                    n_files,
            {  0                    i_input,    "unit no. for .egsinp if required"
            {  0                    i_log,      "unit no. for .egslog if required"
            {  0                    i_incoh,    "unit no. for Compton data"
            {  0                    i_nist_data, "unit no. for NIST data"
            {  0                    i_mscat,     "unit no. for multiple scattering data"
            {  0                    i_photo_cs,  "unit no. for photon cross-section data"
            {  0                    i_photo_relax,  "unit no. for photon relaxation data"
            {  0                    xsec_out,       "switches on/off xsection file output"
            {  0                    is_batch,       "True for batch mode"
            {  0                    is_uniform_run, "True for uniform parallel run control"
            {  0                    is_pegsless;    "true if you are running without pegs file"
            {  0    character input_file*256, output_file*256, pegs_file*256,
            {  0              file_extensions*$max_extension_length,
            {  0              hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0              host_name*64;
            {  0    $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0              n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0              i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0    $LOGICAL  is_batch, is_pegsless, is_uniform_run;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0    $set_string(egs_home,' ');
            {  0    call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0      ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0      ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0      iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0      iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0      smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0      i_do_rr(i) = 0;               "range rejection flag"
            {  0      e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0      med(i) = 1;                   "default medium"
            {  0      rhor(i) = 0;                  "default mass density"
            {  0      iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0      iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0          "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0          IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0      ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        medium = med(j);
            {  0        IF( medium > 0 & medium <= nmed) [
            {  0            IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0    ecutmn = 1e30;
            {  0    DO i=1,$MXREG [
            {  0        IF( med(i) > 0 & med(i) <= nmed ) [
            {  0                  ecutmn = Min(ecutmn,ecut(i));
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0      IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc timing macros                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$DECLARE_TIMING_VARIABLES;} WITH {;
            {  0    real  CPUT0,CPUT1,CPUT2,TDUM;
            {  0    real egs_tot_time, egs_etime;}
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_CPU_TIME;} WITH {;}
               0  ;
               0  REPLACE {$SET_ELAPSED_CPUTIME(#);} WITH { {P1}=egs_etime(); }
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_TOTAL_TIME;} WITH
               0    { tdum = egs_tot_time(1); }
               0  ;
               0  REPLACE {$SET_ELAPSED_TOTAL_TIME(#);} WITH
               0    { {P1} = egs_tot_time(0); }
               0  ;
               0  REPLACE {$CONVERSION_TO_SECONDS} WITH {1.0}
               0  ;
               0  REPLACE {$TIME_RESOLUTION} WITH {0.01}
               0  ;
1              0  %E
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on Mon Feb  5 11:05:46 PM EST 2024         "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2024-02-06 04:05:46 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for ranmar random number generator                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Implementation for EGSnrc of the RANMAR random number generator (RNG),     "
               0  "  proposed by Marsaglia and Zaman.                                           "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  To use this set of macros, you need to initialize the RNG by a call to     "
               0  "  init_ranmar (in ranmar.mortran) or read-in a valid RNG state using the     "
               0  "  macro $RETRIEVE RNG STATE FROM UNIT #;                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$NRANMAR} WITH {128}
               0  REPLACE {;COMIN/RANDOM/;} WITH
               0  {;
            {  0  common/randomm/ rng_array($NRANMAR), urndm(97), crndm, cdrndm, cmrndm,
            {  0  i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed;
            {  0  integer*4       urndm, crndm, cdrndm, cmrndm, i4opt,
            {  0  ixx, jxx, fool_optimizer,rng_seed,rng_array;
            {  0  real*4          twom24;
            {  0  }
               0  "in the above, rng_seed is typed and part of common because it is"
               0  " initialized in BLOCK DATA for the ranlux rng.                  "
               0  " It is not actually used by ranmar."
               0
               0  " The following is the $RANDOMSET macro for EGSnrc."
               0  " Found that using integers it is faster by about 30% on a PIII CPU"
               0  " (which is the NRC computer environment                           "
               0
               0  " Found that when the RNG is not inlined, code runs faster "
               0  " Presumambly because the executable shrinks by a significant amount "
               0  " Iwan Kawrakow, May 2003 "
               0
               0  REPLACE {$RANDOMSET#;} WITH {;
            {  0  IF( rng_seed > $NRANMAR ) call ranmar_get;
            {  0  {P1} = rng_array(rng_seed)*twom24; rng_seed = rng_seed + 1;
            {  0  };
               0
               0  "REPLACE {$RANDOMSET#;} WITH
               0  "{
               0  "    i4opt = urndm(ixx) - urndm(jxx);
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    urndm(ixx) = i4opt;
               0  "    ixx = ixx - 1; jxx = jxx - 1;
               0  "    IF(ixx = 0)        [ ixx = 97; ]
               0  "    ELSE IF( jxx = 0 ) [ jxx = 97; ]
               0  "    crndm = crndm - cdrndm;
               0  "    IF(crndm < 0) crndm = crndm + cmrndm;
               0  "    i4opt = i4opt - crndm;
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    {P1} = twom24*i4opt;
               0  "}
               0  ;
               0
               0  REPLACE {$RNG-INITIALIZATION;} WITH { ;call init_ranmar; }
               0
               0  REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;
            {  0  ixx=0; jxx=0; call init_ranmar;
            {  0  };
               0
               0  REPLACE {$INITIALIZE RNG USING # AND #; } WITH {;
            {  0  ixx = {P1}; jxx = {P2};
            {  0  call init_ranmar;
            {  0  };
               0
               0  "**************************************************************************"
               0  " The macros below are not essential for the operation of the RNG,         "
               0  " they are defined for convinience in our NRC user codes                   "
               0  "**************************************************************************"
               0
               0  REPLACE {$STORE RNG STATE ON UNIT #;} WITH
               0  {
            {  0  rewind({P1});
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$PUT RNG STATE ON UNIT #;} WITH
               0  {
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$RETRIEVE RNG STATE FROM UNIT #;} WITH {;
            {  0  read({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  twom24 = 1./16777216.;  "just in case it is not initialized in rmarin"
            {  0  };
               0
               0  REPLACE {$SHOW-RNG-STATE(#);} WITH {;
            {  0  write({P1},'(a,2i4,$)') ' ixx jxx = ',ixx,jxx;
            {  0  };
               0
               0  REPLACE {$PRINT-RNG-STATE(#,#);} WITH {;
            {  0  write({P1},{P2}) ixx,jxx;
            {  0  };
               0
               0  REPLACE {$RNG-INPUTS(#,#,#,#);} WITH {;
            {  0  ival = ival + 1;
            {  0  VALUES_SOUGHT(IVAL)={P1};
            {  0  nvalue(ival) = 2;
            {  0  type(ival)   = 0;
            {  0  value_min(ival) = 1;
            {  0  value_max(ival) = 30081;
            {  0  default(ival)   = 9373;
            {  0  delimeter = {P2};
            {  0  nmin = ival; nmax = ival;
            {  0  call get_input;
            {  0  IF( error_flags(ival) = 0 ) [
            {  0  {P3} = value(ival,1);
            {  0  {P4} = value(ival,2);
            {  0  ]
            {  0  ELSE [ {P3} = 0; {P4} = 0; ]
            {  0  };
               0
               0  REPLACE {$RNG-STRING-1} WITH {' 1st initial random number seed: '}
               0  REPLACE {$RNG-STRING-2} WITH {' 2nd initial random number seed: '}
               0
               0  "            end of ranmar.macros         "
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosxzynrc application user macros                                   "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Dave Rogers, 1995                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Charlie Ma                                                "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These macros are for use with dosxyznrc.mortran                            "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80        "use 80 columns"                                                   ;
               0  %Q1         "Automatically close quotes at end of the line"                    ;
               0  "*******************************************************************"
               0  "                                                                   "
               0  "                 dosxyz_user_macros.mortran                        "
               0  "                                                                   "
               0  "    These macros are for use with dosxyz.mortran                   "
               0  "                                                                   "
               0  "    The script will check for this file on the users area          "
               0  "    $HOME/egs4/dosxyz and if not there, will use the version on    "
               0  "    $OMEGA_HOME/dosxyz                                             "
               0  "                                                                   "
               0  "    The user can thus freely adapt the code to their situation.    "
               0  "                                                                   "
               0  "*******************************************************************"
               0  "                                                                   "
               0  "*******************************************************************"
               0  "   These define dimensions of phantom etc in dosxyz
               0  "*******************************************************************"
               0  "
               0  REPLACE {$STAT}    WITH {10}  "Number of batches to use in calcn of statistics"
               0  "It works with $STAT = 1 but gives no stats"
               0  REPLACE {$MXMED}   WITH {20}   "Maximum number of media
               0  REPLACE {$MXSTACK} WITH {900000}  "Maximum particle stack size
               0  REPLACE {$IMAX}    WITH {128} "Maximum number of x cells
               0  REPLACE {$JMAX}    WITH {128} "Maximum number of y cells
               0  REPLACE {$KMAX}    WITH {128} "Maximum number of z cells
               0  REPLACE {$MAXDOSE} WITH {{COMPUTE $IMAX*$JMAX*$KMAX+1}}
               0  "Number of dose regions, can be set to < $IMAX*$JMAX*$KMAX if "
               0  "necessary to reduce memory requirement, +1 for outside region"
               0  REPLACE {$MXREG}   WITH {{COMPUTE $IMAX*$JMAX*$KMAX+2}}
               0  "Number of geometrical regions (+2 for vacuum and the surrounding region)"
               0
               0  "Following macro set to 1 to zero doses with error>50% in the .3ddose file
               0  "Note that dose errors do not get zeroed
               0  "Set to any other number to not zero these doses
               0  REPLACE {$DOSEZERO} WITH {1};
               0
               0  "this is the maximum number of user-selected theta-phi combinations"
               0  "in isource=7,8"
               0  REPLACE {$MXANG} WITH {60000};
               0
               0  "default directory in which to output phase space files"
               0  REPLACE {$DIRECTORY-FOR-PHSP} WITH {$cstring(egs_home)//$cstring(user_code)};
               0
               0  "Encoding of the egsphant material types"
               0  REPLACE {$ENCODING} WITH {
            {  0  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'};
               0
               0  "*******************************************************************"
               0  "   These macros define the null macros related to BEAM MODELS      "
               0  "*******************************************************************"
               0  "                                                                   "
               0  "V>The following are the defaults for beam characterization models;
               0  REPLACE {;COMIN/BMODEL/;} WITH {;}
               0  REPLACE {;COMIN/SSMDIS/;} WITH {;}
               0  ;REPLACE {$BEAMMODEL-ENFLAG4-INPUT} WITH { OUTPUT ;
            {  0  (/ ' Beam characterization model not implemented, use source 1 - 3!'//);
            {  0  }
               0  ;REPLACE {$BEAMMODEL-INPUT-MESSAGE} WITH {;}
               0  ;REPLACE {$BEAMMODEL-SOURCE4-INPUT} WITH { OUTPUT;
            {  0  (/ ' Beam characterization model not implemented, use source 1 - 3!'//);
            {  0  }
               0  ;
               0  REPLACE {;$BEAMMODEL_DATA_OUTPUT} WITH {;}
               0  REPLACE {;$BEAMMODEL-SOURCE4-OUTPUT} WITH {;}
               0  REPLACE {$BEAMMODEL-SOURCE4-SUMMARY} WITH {;}
               0  REPLACE {$BEAMMODEL-SOURCE4-ENERGY} WITH {;}
               0  REPLACE {$BEAMMODEL_SOURCE4_SAMPLING} WITH {;}
               0  ;
               0  "*******************************************************************"
               0  "     macros related to LATCH bit testing for phase space sources
               0  "*******************************************************************"
               0  ;
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {IBCLR({P1},{P2});}
               0
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {IBSET({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  REPLACE {$BTEST(#,#)} WITH {BTEST({P1},{P2})}
               0
               0  "*******************************************************************"
               0  "     macros to turn off correlated sampling"
               0  "*******************************************************************"
               0  "  These macros are the null set for those needed for correlated sampling"
               0  "  V1.0 mark holmes 08/16/95                  "
               0
               0  REPLACE {$Corr_Vars} WITH {;};
               0  REPLACE {$Corr_Reseed} WITH {;};
               0  REPLACE {$Corr_Dump} WITH {;};
               0
               0  ;
               0  "*******************************************************************"
               0  "end of dosxyz_user_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosxzynrc application source macros                                 "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Dave Rogers, 1986                                         "
               0  "                                                                             "
               0  "  Contributors:    Alex Bielajew                                             "
               0  "                   Bruce Faddegon                                            "
               0  "                   George Ding                                               "
               0  "                   Charlie Ma                                                "
               0  "                   Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This macro set goes with srcxyz.mortran. This should go ahead of the user  "
               0  "  code in the compilation heirarchy.                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80         "80 column mortran input"                                         ;
               0  !INDENT M 4; "Indent 4 spaces for each nesting level in mortran listing file"
               0  !INDENT F 4; "Indent 4 spaces for each nesting level in fortran output file"
               0  %Q1          "Automatically close quotes at end of the line"                   ;
               0  ;
               0  "*******************************************************************************
               0  "
               0  "                           ***********************
               0  "                           *                     *
               0  "                           *    srcxyz.macros    *
               0  "                           *                     *
               0  "                           ***********************
               0  "
               0  "    This macros set goes with srcxyz.mortran.
               0  "    This should go ahead of the user code in the compilation heirarchy
               0  "    to avoid having to duplicate the definition of the SOURCE common block
               0  "
               0  "    Version  1.1  BAF   11/91  Phase space coding, srcrz structure isource=0,2)
               0  "    Version  1.2  BLIF  11/91  Any direction parallel beam (isource=1)
               0  "    Version  1.3  CMa   10/94  changes for MODE0 file format (isource=2)
               0  "    Version  1.4  CMa   10/94  changes for using the same random # generator
               0  "    Version  1.5  CMa   02/95  added beam characterization models
               0  "    Version  1.6  DWOR  08/95  included ensrc macros
               0  "
               0  "******************************************************************************
               0
               0  REPLACE {;COMIN/SOURCE/;} WITH {
            {  0  "Common used for passing information specific to sources                   "
            {  0  ;
            {  0  common/source/
            {  0  esrc, "Sum of kinetic + Q energy carried by source particles (enflag=1) "
            {  0  nhist,    "no. of primary (non-phsp) histories              "
            {  0  nnread,  "Number of particles read from the ph-sp file     (isource=2,3,8) "
            {  0  nshist,  "Number of particles in source file               (isource=2,3,8) "
            {  0  nphist,  "Number of photons in source file                 (isource=2,3,8) "
            {  0  nnphsp,  "Number of particles already read from source file(isource=2,3,8) "
            {  0  einsrc,  "Source total energy input by full phase-space source(isource=2,8)"
            {  0  xsrcold,  "stores X coordinate in phase space coordinates   (isource=2,8)"
            {  0  ysrcold,  "stores Y coordinate in phase space coordinates   (isource=2,8)"
            {  0  zsrcold,  "stores Z coordinate for IAEA phsp   (isource=20)   (JL and TP)"
            {  0  usrcold,  "stores U cosine in phase space coordinates       (isource=2,8)"
            {  0  vsrcold,  "stores V cosine in phase space coordinates       (isource=2,8)"
            {  0  wsrcold,  "stores W for source 20    (isource=20) "
            {  0  weightold,"stores weight for source 20   (isource=20) "
            {  0  mu_phspold, "stores mu_phsp for source 20                   (isource=20) "
            {  0  frMU_indx, "random MU index that detemines current setting  (isource=20,21)"
            {  0  zinc,    "z-position of beam                                 (isource=0,6) "
            {  0  xinl,    "Lower x-boundary of beam                           (isource=0,6) "
            {  0  xinu,    "Upper x-boundary of beam                           (isource=0,6) "
            {  0  yinl,    "Lower y-boundary of beam                           (isource=0,6) "
            {  0  yinu,    "Upper y-boundary of beam                           (isource=0,6) "
            {  0  zinl,    "Lower z-boundary of source                           (isource=6) "
            {  0  zinu,    "Upper z-boundary of source                           (isource=6) "
            {  0  thetax,  "Source angle angle relative to x-axis (degrees)      (isource=0) "
            {  0  thetay,  "Source angle angle relative to y-axis (degrees)      (isource=0) "
            {  0  thetaz,  "Source angle angle relative to z-axis (degrees)      (isource=0) "
            {  0  uinc,    "Source incident x-axis direction cosine              (isource=0) "
            {  0  vinc,    "Source incident y-axis direction cosine              (isource=0) "
            {  0  winc,    "Source incident z-axis direction cosine              (isource=0) "
            {  0  beamarea,"Source incident z-axis direction cosine          (isource=0,1,7) "
            {  0  xcol,    "x-collimator width in the source plane             (isource=1,7) "
            {  0  ycol,    "y-collimator width in the source plane             (isource=1,7) "
            {  0  xiso,    "x-coordinate of the isocenter        (isource=1,2,7,8,20,21) "
            {  0  yiso,    "y-coordinate of the isocenter        (isource=1,2,7,8,20,21) "
            {  0  ziso,    "z-coordinate of the isocenter        (isource=1,2,7,8,20,21) "
            {  0  phicol,  "(collimator|source plane) rotation angle(isource=1,2,7,8,20,21) "
            {  0  theta($MXANG), "Polar angle of source center       (isource=1,2,7,8,20,21) "
            {  0  phi($MXANG), "Azimuthal angle of source center     (isource=1,2,7,8,20,21) "
            {  0  pang($MXANG), "Prob of particle being incident at theta-phi  (isource=7,8) "
            {  0  angfixed($MXANG), "fixed theta or phi for group i           (isource=7,8) "
            {  0  angmin($MXANG), "Min. varying theta or phi for group i       (isource=7,8) "
            {  0  angmax($MXANG), "Max. varying theta or phi for group i       (isource=7,8) "
            {  0  pgang($MXANG),  "Prob. of particle being in group i         (isource=7,8) "
            {  0  xtemp($MXANG),    "x-coordinate of the isocenter          (isource=20,21) "
            {  0  ytemp($MXANG),    "y-coordinate of the isocenter          (isource=20,21) "
            {  0  ztemp($MXANG),    "z-coordinate of the isocenter          (isource=20,21) "
            {  0  phicoltemp($MXANG),"(collimator|source plane) rotation angle(isource=20,21)"
            {  0  thetatemp($MXANG), "Polar angle of source center           (isource=20,21)"
            {  0  phitemp($MXANG), "Azimuthal angle of source center         (isource=20,21) "
            {  0  muIndex($MXANG), "indices for settings defined in input file(isource=20,21)"
            {  0  r_11($MXANG),"Rotation matrix, row 1 column 1            (isource=1,2,7,8) "
            {  0  r_12($MXANG),"Rotation matrix, row 1 column 2            (isource=1,2,7,8) "
            {  0  r_13($MXANG),"Rotation matrix, row 1 column 3            (isource=1,2,7,8) "
            {  0  r_21($MXANG),"Rotation matrix, row 2 column 1            (isource=1,2,7,8) "
            {  0  r_22($MXANG),"Rotation matrix, row 2 column 2            (isource=1,2,7,8) "
            {  0  r_23($MXANG),"Rotation matrix, row 2 column 3            (isource=1,2,7,8) "
            {  0  r_31($MXANG),"Rotation matrix, row 3 column 1            (isource=1,2,7,8) "
            {  0  r_32($MXANG),"Rotation matrix, row 3 column 2            (isource=1,2,7,8) "
            {  0  r_33($MXANG),"Rotation matrix, row 3 column 3            (isource=1,2,7,8) "
            {  0  dsource,"Distance from isocenter to source plane(isource=1,2,8,20)"
            {  0  dsourcetemp($MXANG),"temp dsource for source 20/21 (isource=20,21)"
            {  0  ein,     "kinetic energy input for monoen beams or max. KE for ph space"
            {  0  eksrcm,  "Maximum energy of source                           (isource=2,8) "
            {  0  esrc_sp, "kinetic energy of source particle  (enflag=1)                    "
            {  0  SSD,     "Source to surface dist for point source particles ( isource=3)"
            {  0  einsrcold,"stores einsrc for source 20          (isource=20) "
            {  0  iaea_SAD, "stores SAD for IAEA phase space sources         (isource=2,8,20)"
            {  0  NINCSRC,  "No. of particles incident from original source   (isource=2,8)  "
            {  0  r_dbs,    "DBS splitting radius used to generate phsp source (isource=2,8)"
            {  0  ssd_dbs,  "SSD at which above DBS radius defined            (isource=2,8)"
            {  0  z_dbs,    "Z at which phsp source generated                 (isource=2,8)"
            {  0  iqinold,  "stores charge for source 20                      (isource=20) "
            {  0  latchold, "stores latch for source 20                       (isource=20) "
            {  0  enflag,  "Flag= 1,2,3 when source energy is different for each particle    "
            {  0  dflag,  "0 for 1 dsurround, 1 for 4 dsurrounds (enflag > 1)               "
            {  0  ismode,  "flag 0 or 2 stating what mode phase space input file is          "
            {  0  isource, "Source type (0=>pb +ve z-axis, 1=>pb any dir'n, 2=>phase space)  "
            {  0  iqin,    "Particle type (-1 => electrons, 0 => photons, 1 => positrons)    "
            {  0  iqphsp,  "Particle type (-1 => electrons, 0 => photons, 1 => positrons)    "
            {  0  "2 => particles of any charge (for isource = 2 only)              "
            {  0  iqinc,   "Particle type (-1 => electrons, 0 => photons, 1 => positrons)    "
            {  0  "2 => particles of any charge (for isource = 9 only)        "
            {  0  SHLflag, "1 => send particle shared lib, 0 => no shared lib (isource=20)   "
            {  0  calflag, "0 => perform calibration run, 1 => no calib run (isource=20)     "
            {  0  MLCflag, "1 => send particles through MLC, 0 => no MLC   (isource=20,21)   "
            {  0  ixinl,   "Index of lower x-boundary of beam                  (isource=0,6) "
            {  0  ixinu,   "Index of upper x-boundary of beam                  (isource=0,6) "
            {  0  jyinl,   "Index of lower y-boundary of beam                  (isource=0,6) "
            {  0  jyinu,   "Index of upper y-boundary of beam                  (isource=0,6) "
            {  0  kzinl,   "Index of lower z-boundary of source                  (isource=6) "
            {  0  kzinu,   "Index of upper z-boundary of source                  (isource=6) "
            {  0  klowx,   "constant factor in irin for lower x-plane search(isource=1,2,7,8)"
            {  0  khix,    "constant factor in irin for upper x-plane search(isource=1,2,7,8)"
            {  0  klowy,   "constant factor in irin for lower y-plane search(isource=1,2,7,8)"
            {  0  khiy,    "constant factor in irin for upper y-plane search(isource=1,2,7,8)"
            {  0  klowz,   "constant factor in irin for lower z-plane search(isource=1,2,7,8)"
            {  0  khiz,    "constant factor in irin for upper z-plane search(isource=1,2,7,8)"
            {  0  survival_ratio, "num that survive MLC/num read from phsp    (isource=20)"
            {  0  nsmiss,  "Number of particles that missed geometry        (isource=1,2,7,8)"
            {  0  nsblocked, "No. of particles blocked by library modules     (isource=20,21)"
            {  0  nsrjct,  "No. particles rejected due to charge/latch/npass (isource=2,8)   "
            {  0  nsoutside, "No. particles rejected because outside BEAM_SIZE (isource=2,8) "
            {  0  nmissm,  "Number of particles not transported properly   (isource=1,2,7,8) "
            {  0  IPRIMARY, "score primary only when=1"
            {  0  OLDSRC,   "flag for old phase space file                    (isource=2,8)  "
            {  0  npassi,   "=1 if a particle read from a phsp source is a multiple passer   "
            {  0  "                                                 (isource=2,8)  "
            {  0  nang,     "No. of incident theta-phi or groups of theta-phi (isource=7,8)  "
            {  0  ivary($MXANG), "0 to vary phi, 1 to vary theta in group i   (isource=7,8)  "
            {  0  ngang($MXANG), "No. of theta-phi pairs in group i           (isource=7,8)"
            {  0  nset,     "No. of incident settings: phi,theta,phicol    (isource=20,21)"
            {  0  more_in_cont,    "acts as boolean to tell dosxyz when a particle container"
            {  0  "is empty and a new particle must be read from the phsp (isource=20,21)"
            {  0  numang,   "Always no. of incident theta-phi                 (isource=7,8)  "
            {  0  dose_stat,"set to 1 if nhist not marked in source           (isource=2,8)"
            {  0  ndbsrjct, "no. of photons rejected because their trajectory takes them  "
            {  0  "outside r_dbs                                    (isource=2,8)"
            {  0  i_dbs,    "set to 1 to reject fat photons created by DBS    (isource=2,8)"
            {  0  iphatsrc, "returned from BEAM sim if this is a phat phot.   (isource=9)"
            {  0  e_split,  "no. of times to split e+/e- (isource=2,8,9)"
            {  0  i_iaea_in, "set to 1 if phase space source is in IAEA format (isource=2,8)"
            {  0  i_mu_phsp, "set to 1 if IAEA phsp source stores MU_INDEX (isource=20)"
            {  0  izscore,   "set to 1 if Z scored for each particle (IAEA format only)"
            {  0  i_unit_in, "stores unit no. for phsp source (IAEA format only)"
            {  0  k_field,   "stores incident angle index for isource=8 or 10"
            {  0  nhist_last, "short integer for storing no. of primary histories"
            {  0  the_beam_code, "name of BEAM treatment head sim.            (isource=9)"
            {  0  the_input_file, "input file for BEAM treatmen head sim.     (isource=9,20)"
            {  0  the_vcu_input_file,         "input file for VCU sim.(isource=21)"
            {  0  the_pegs_file,  "pegs data for BEAM treatmen head sim.     (isource=9)"
            {  0  the_shared_lib, "name of the shared library     (isource=21)"
            {  0  the_vcu_code,    "name of vcu code (particleDmlc)       (isource=21)"
            {  0  the_phsp_file;  "name of phase space file (above MLC)         (isource=20)"
            {  0  "Explicit declarations for compatibility with implicit none"
            {  0  real*8    esrc,muIndex;
            {  0  $LONG_INT nhist, nnread,nshist,nphist,nnphsp;
            {  0  $REAL einsrc, xsrcold, ysrcold,usrcold,vsrcold,wsrcold,weightold,
            {  0  frMU_indx,zsrcold,mu_phspold;
            {  0  real*4    zinc, xinl, xinu, yinl, yinu, zinl, zinu, thetax, thetay, thetaz,
            {  0  uinc, vinc, winc, beamarea, xcol,ycol,xiso, yiso, ziso, phicol,
            {  0  theta, phi, xtemp, ytemp, ztemp, phicoltemp,thetatemp, phitemp,
            {  0  pang,angfixed,angmin,angmax,pgang,r_11, r_12, r_13, r_21,
            {  0  r_22, r_23, r_31, r_32, r_33,dsource,dsourcetemp,
            {  0  ein, eksrcm, esrc_sp, SSD, NINCSRC,
            {  0  r_dbs, ssd_dbs,z_dbs,survival_ratio,einsrcold,iaea_SAD;
            {  0  $INTEGER isource, iqin, iqphsp, iqinc,latchold,iqinold,MLCflag,SHLflag,
            {  0  calflag, ixinl, ixinu, jyinl, jyinu, kzinl, kzinu,
            {  0  klowx, khix, klowy, khiy, klowz, khiz,
            {  0  nsmiss, nsblocked, nsrjct,nsoutside, nmissm,enflag,
            {  0  dflag, ismode, IPRIMARY, OLDSRC,npassi,nang,ivary,ngang,numang,dose_stat,
            {  0  ndbsrjct,i_dbs,iphatsrc,e_split,i_iaea_in,i_mu_phsp,izscore,i_unit_in,
            {  0  num_field,more_in_cont,nset,k_field;
            {  0  $SHORT_INT nhist_last;
            {  0  character*80 the_beam_code, the_vcu_code, the_input_file,the_pegs_file,
            {  0  the_shared_lib,the_vcu_input_file;
            {  0  character*256 the_phsp_file;
            {  0  }
               0  ;
               0  "    macros related to energy spectra input"
               0
               0  REPLACE {$INVDIM} WITH {1000}   "number of elements in inverse CPD"
               0  REPLACE {$NENSRC} WITH {200}    "number of bins in source energy spectra"
               0
               0  REPLACE {;COMIN/ENERGYSRC/;} WITH {
            {  0
            {  0  ;COMMON/ENERGYSRC/NENSRC,IMODE,ENSRCD,SRCPDF,SRCCDF,ENMIN,CDFINV,DELTAK;
            {  0  REAL ENSRCD($NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),ENMIN,
            {  0  CDFINV($INVDIM,2),DELTAK;
            {  0  INTEGER IMODE,NENSRC;
            {  0  }
               0
               0  "dummy macro for write variables in phsp_macros.mortran"
               0  REPLACE {$MAX_SC_PLANES} WITH {1};
               0
               0  "end of srcxyz.macros (Rev 1.12)"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc transport parameter macros                                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These macros are used in conjunction with the get_inputs.mortran routines  "
               0  "  to read in EGSnrc transport physics parameters. Specifically with          "
               0  "  subroutine get_transport_parameter.                                        "
               0  "                                                                             "
               0  "  The following are definitions of code words (values sought) for the        "
               0  "  various transport parameters that can be set. I hope they are              "
               0  "  self-explanatory. If you don't like them:                                  "
               0  "                                                                             "
               0  "  - include this file via the configuration file BEFORE your user code.      "
               0  "                                                                             "
               0  "  - Replace the macros in your user code with code words that you prefer.    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
               0  REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
               0  REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
               0  REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
               0  REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
               0  REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
               0  REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
               0  REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
               0  REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
               0  REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
               0  REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
               0  REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
               0  REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
               0  REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
               0  REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
               0  REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
               0  REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
               0  REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
               0  REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
               0  REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
               0  REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
               0  REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
               0  REPLACE {$IN_REGIONS}             WITH {'Regions'}
               0  REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
               0  REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
               0  REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
               0  REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
               0  REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
               0  "Ali:photonuc, 2 lines"
               0  "Cannot use $PHOTONUC; it clashes with other variables"
               0  REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
               0  REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
               0  REPLACE {$B_FIELD} WITH {'Magnetic Field'}
               0  REPLACE {$E_FIELD} WITH {'Electric Field'}
               0  REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
               0  ;
               0
               0  REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
               0  {;
            {  0  aux_inregions = .false.;
            {  0  IF( error_flags({P1}) = 0 ) [
            {  0  write(i_log,*) {P2};
            {  0  itmp = value({P1},1);
            {  0  IF( itmp = 2 | itmp = 3 ) [
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P2};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P3};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  Nmin = ival-1; Nmax = ival;
            {  0  CALL GET_INPUT;
            {  0  IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            {  0  IF( nvalue(ival) = nvalue(ival-1) ) [
            {  0  iitmp = itmp-2;
            {  0  DO j=1,$MXREG [ {P4}(j) = iitmp; ]
            {  0  "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
            {  0  iitmp = 1 - iitmp;
            {  0  "and then re-set in the specified regions"
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  "Ali:photonuc, 2 lines to crudely print start/stop regions"
            {  0  write(i_log,*) {P2},istart;
            {  0  write(i_log,*) {P3},iend;
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P4}(j) = iitmp; ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [
            {  0  IF( itmp > 3 ) itmp = itmp-2;
            {  0  write(i_log,*) ' Setting all to ',itmp;
            {  0  DO j=1,$MXREG [ {P4}(j) = itmp; ]
            {  0  ]
            {  0  ]
            {  0  ELSE ["Use default value"
            {  0  "Check if default is other than ON or Off"
            {  0  "and shift as no input by regions requested"
            {  0  IF({P4}(1) = 2 | {P4}(1) = 3)[
            {  0  value({P1},1) = {P4}(1)+2;
            {  0  ]
            {  0  ELSE[
            {  0  value({P1},1) = {P4}(1);
            {  0  ]
            {  0  ]
            {  0
            {  0  };
               0
               0  REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
               0  {;
            {  0
            {  0  aux_inregions = .false.;
            {  0  ival                = ival + 1;
            {  0  {P2}                = ival;
            {  0  values_sought(ival) = {P6};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 1;
            {  0  value_min(ival)     = {P3};
            {  0  value_max(ival)     = {P4};
            {  0  default(ival)       = {P5};
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P7};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P8};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
            {  0  CALL GET_INPUT;
            {  0
            {  0  IF( error_flag = 0 ) [
            {  0  IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P1}(j) = value({P2},k); ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 macros                                                        "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0  "MACROS TO SPLIT LONG STRING INTO A1 STRINGS"
               0  REPLACE {$S'{SYMBOL}#'} WITH
               0  {'#1'[IF]{EXIST 2}[,$S'{P2}']};
               0
               0  "pegs4 uses single precision.  real*8 causes problems"
               0  REPLACE {$REAL4} WITH {real*4};
               0
               0  PARAMETER $MXSTC=73;"NUMBER OF MEDIA WITH STERNHEIMER COEFFICIENTS"
               0  PARAMETER $RERR=1.E-5;      "RERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $AERR=1.E-16;     "AERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $FUDGEMS=1.0;  "FULL MS OFF ATOMIC ELECTRONS"
               0
               0  REPLACE {;COMIN/LBREMZ/;} WITH {
            {  0  ;COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  $REAL4 CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  }
               0
               0  REPLACE {;COMIN/PMCONS/;} WITH
               0  {;COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  $REAL4 PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  };
               0
               0  REPLACE {;COMIN/DERCON/;} WITH
               0  {;COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  $REAL4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  };
               0
               0  REPLACE {;COMIN/THRESHP/;} WITH
               0  {;COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP;
            {  0  $REAL4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP;
            {  0  $INTEGER IUNRSTP;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPRP/;} WITH
               0  {;COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6),
            {  0  DELCMP,ALPHIP(2),BPARP(2),DELPOSP(2);
            {  0  $REAL4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP;
            {  0  };
               0
               0  REPLACE {;COMIN/EPSTAR/;} WITH
               0  {;
            {  0  COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20),
            {  0  EPSTTL,NEPST,IEPST,EPSTFLP,
            {  0  NELEPS,ZEPST(20),IAPRFL,IAPRIMP;
            {  0  $INTEGER    ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP;
            {  0  CHARACTER   EPSTTL*80;
            {  0  $REAL4       EPSTEN,EPSTD,WEPST;
            {  0  };
               0
               0  "THIS COMMON IS USED FOR OPTION WHICH READS IN DENSITY EFFECT "
               0  "CORRECTION IN SPINIT AND CALCULATES USING IT IN SPIONB       "
               0  "THE FLAG EPSTFL IS READ UNDER NAMELIST INPUT, AND DEFAULTS   "
               0  "   TO ZERO IN THE BLOCK DATA. SET TO UNITY TO USE THE OPTION "
               0  "PEGS USES THE I-VALUE IN THE DENSITY INPUT FILE              "
               0  "VARIOUS CHECKS ARE DONE TO ENSURE THE DENSITY CORRECTION     "
               0  "   CORRESPONDS TO THE MATERIAL DEFINITION IN PEGS            "
               0  "THE ENERGY TABLE READ IN IS ASSUMED TO BE KINETIC ENERGY IN  "
               0  "   MEV BUT IS CONVERTED TO TOTAL ENERGY BY THE CODE.         "
               0  "THE ENERGY OPTION MUST BE USED IN PEGS PRIOR TO THE MIXT,COMP"
               0  "   OR ELEM OPTIONS TO ALLOW ALL THE CHECKS TO WORK PROPERLY. "
               0  "NELEPS IS THE NUMBER OF ELEMENTS IN THE MATERIAL             "
               0  "ZEPST(I) (INTEGER), WEPST(I) ARE THE Z VALUE AND FRACTION    "
               0  "   BY WEIGHT OF THE I-TH ELEMENT IN THE DATA FILE.           "
               0  "IAPRIM is a flag to tell which correction to the bremsstrahlung        "
               0  "       cross section to use:      0 =>  old Koch and Motz    "
               0  " =1(defaulat) read in new data file; =2, use no corrections. "
               0  "IAPRFL is a flag to say if APRIM file has been initialized   "
               0
               0  REPLACE {;COMIN/MOLVAR/;} WITH
               0  {;COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,
            {  0  RLCP,EDEN,RHOP,XCCP,BLCCP,TEFF0P,XR0P;
            {  0  $REAL4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP,
            {  0  XCCP,BLCCP,TEFF0P,XR0P;
            {  0  };
               0
               0  REPLACE {;COMIN/MIMSD/;} WITH
               0  {;COMMON/MIMSD/BMIN;
            {  0  $REAL4 BMIN;
            {  0  };
               0
               0  REPLACE {;COMIN/RADLEN/;} WITH
               0  {;COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183;
            {  0  $REAL4 ALRAD,ALRADP,A1440,A183;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LSPION--COMMON FOR COMMUNICATION BETWEEN SPINIT AND SPIONB    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LSPION/;} WITH
               0  {;COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  $REAL4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  };
               0
               0  REPLACE {;COMIN/SPCOMM/;} WITH
               0  {;COMMON/SPCOMM/MEDTBL(24,$MXSTC),
            {  0  NUMSTMED,STDATA(6,$MXSTC);
            {  0  $TYPE MEDTBL;
            {  0  $INTEGER NUMSTMED;
            {  0  $REAL4    STDATA;
            {  0  }
               0
               0  REPLACE {;COMIN/PWLFIN/;} WITH
               0  {;COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE;
            {  0  $REAL4 EPE,ZTHRE,ZEPE;
            {  0  $INTEGER NIPE,NALE;
            {  0  };
               0
               0  REPLACE {;COMIN/RSLTS/;} WITH
               0  {;COMMON/RSLTS/NEL,AXE,BXE,AFE($MXEKE,8),BFE($MXEKE,8);
            {  0  $REAL4 AXE,BXE,AFE,BFE;
            {  0  $INTEGER NEL;
            {  0  };
               0
               0  REPLACE {;COMIN/ELEMTB/;} WITH
               0  {;COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100);
            {  0  $INTEGER NET;
            {  0  $REAL4 ITBL,WATBL,RHOTBL;
            {  0  $TYPE ASYMT;
            {  0  }
               0
               0  REPLACE {;COMIN/MIXDAT/;} WITH
               0  {;COMMON/MIXDAT/NEP,LMED,PZP($MXEL),ZELEMP($MXEL),WAP($MXEL),RHOZP($MXEL),
            {  0  GASPP,EZ,TPZ,IDSTRN(24);
            {  0  $INTEGER NEP,LMED;
            {  0  $REAL4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ;
            {  0  $TYPE IDSTRN;
            {  0  }
               0
               0  REPLACE {;COMIN/DBRPR/;} WITH
               0  {;COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2;
            {  0  $REAL4 ALFP1,ALFP2,al2;
            {  0  };
               0
               0  "This block contains some media parameters required for"
               0  "cross-section calculations but not covered in any of the"
               0  "egsnrc common blocks.  It also contains $REAL4 versions"
               0  "of some egsnrc media parameters to allow direct comparison"
               0  "with cross-sections calculated by pegs4.mortran"
               0  REPLACE {;COMIN/MEDINP/;} WITH
               0  {;COMMON/MEDINP/inpdensity_file($MXMED),inpasym($MXMED,$MXEL),
            {  0  inpstrn(24,$MXMED),pz4($MXMED,$MXEL),
            {  0  rhoz4($MXMED,$MXEL),wa4($MXMED,$MXEL),inpgasp($MXMED);
            {  0  character*256 inpdensity_file;
            {  0  $TYPE inpasym,inpstrn;
            {  0  $REAL4 pz4,rhoz4,wa4,inpgasp;
            {  0  };
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {
            {  0  ;COMIN/LBREMZ,PMCONS,DERCON,EPSTAR,MOLVAR,LSPION,PWLFIN,
            {  0  RSLTS,SPCOMM,MIXDAT,RADLEN,MIMSD,THRESHP,BREMPRP,ELEMTB,MEDINP/;
            {  0  $REAL4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI;
            {  0  $INTEGER I01;
            {  0  EXTERNAL ALKE,ALKEI,EFUNS;
            {  0  $TYPE MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13);
            {  0  EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1));
            {  0  $REAL4 STDAT1(6,20),STDAT2(6,20),STDAT3(6,20),STDAT4(6,13);
            {  0  EQUIVALENCE (STDATA(1,1),STDAT1(1,1));
            {  0  EQUIVALENCE (STDATA(1,21),STDAT2(1,1));
            {  0  EQUIVALENCE (STDATA(1,41),STDAT3(1,1));
            {  0  EQUIVALENCE (STDATA(1,61),STDAT4(1,1));
            {  0  }
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH
               0  {;
            {  0
            {  0  call get_media_inputs(-1);
            {  0
            {  0  DO IM=1,NMED[
            {  0
            {  0  "store values in variables used to calculate cross-sections"
            {  0  AEP=AE(IM);
            {  0  UEP=UE(IM);
            {  0  APP=AP(IM);
            {  0  UPP=UP(IM);
            {  0  NEP=NNE(IM);
            {  0  IUNRSTP=IUNRST(IM);
            {  0  IAPRIMP=IAPRIM(IM);
            {  0  EPSTFLP=EPSTFL(IM);
            {  0  GASPP=INPGASP(IM); "recall gasp not an egsnrc variable"
            {  0  RHOP=RHO(IM);
            {  0  DO J=1,NEP[
            {  0  ZELEMP(J)=ZELEM(IM,J);
            {  0  "use the $REAL4 variables from MEDINP for these ones, for now"
            {  0  "since these have been calculated using $REAL4 math"
            {  0  PZP(J)=PZ4(IM,J);
            {  0  RHOZP(J)=RHOZ4(IM,J);
            {  0  WAP(J)=WA4(IM,J);
            {  0  ]
            {  0  DO IB=1,LMDN[
            {  0  IDSTRN(IB)=INPSTRN(IB,IM);
            {  0  ]
            {  0  TEP=AEP-RMP; THMOLLP=AEP+TEP ; "equation in pegs4.mortran"
            {  0
            {  0  IF (UEP.LE.AEP)[
            {  0  write(i_log,'(a,24a1)')'  Error: Material not defined: ',
            {  0  (media(j,IM),j=1,24);
            {  0  $egs_fatal(*,'Material used in the geometry was not defined in the'
            {  0  ,' material data.');
            {  0  ]
            {  0
            {  0  CALL MIX; "calculates MS parameters"
            {  0
            {  0  CALL SPINIT(inpdensity_file(IM)); "density corrections, may open density file"
            {  0
            {  0  CALL DIFFER;
            {  0  "do not know why we call above subroutine since"
            {  0  "bremsstrahlung cross-sections get reset in fix_brems"
            {  0
            {  0  "now call the piecewise linear fit subroutine to generate the remainder of"
            {  0  "the electron cross-sections"
            {  0  CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
            {  0  ALKEI,AXE,BXE,$MXEKE,8,AFE,BFE,EFUNS);
            {  0
            {  0  "cross-sections are now calculated"
            {  0  "store generated data in egsnrc variables"
            {  0
            {  0  "recompute the following two, note the different form of the equation for"
            {  0  "THMOLL compared to pegs4.mortran"
            {  0  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
            {  0
            {  0  "cross-section parameters"
            {  0  RLC(IM)=RLCP;"RLCP gets calculated in MIX"
            {  0
            {  0  XCC(IM)=XCCP;
            {  0  BLCC(IM)=BLCCP;
            {  0  XR0(IM)=XR0P;
            {  0  TEFF0(IM)=TEFF0P;
            {  0
            {  0  "all of the below gets reset in fix_brems"
            {  0  DELCM(IM)=DELCMP;
            {  0  DO I=1,2[
            {  0  ALPHI(I,IM)=ALPHIP(I);
            {  0  BPAR(I,IM)=BPARP(I);
            {  0  DELPOS(I,IM)=DELPOSP(I);
            {  0  ]
            {  0  DO I=1,6[
            {  0  DL1(I,IM)=DLP1(I);
            {  0  DL2(I,IM)=DLP2(I);
            {  0  DL3(I,IM)=DLP3(I);
            {  0  DL4(I,IM)=DLP4(I);
            {  0  DL5(I,IM)=DLP5(I);
            {  0  DL6(I,IM)=DLP6(I);
            {  0  ]
            {  0
            {  0
            {  0  "the following egsnrc quantities are all zeroed in the pegs4 generated data"
            {  0  "so they shall be zeroed here"
            {  0  MSGE(IM)=0;MSEKE(IM)=0;MLEKE(IM)=0;MCMFP(IM)=0;MRANGE(IM)=0;
            {  0
            {  0  "now, the non-zero quantities"
            {  0  MGE(IM)=$MXGE; "we do not use PWLF1 for photon quantities"
            {  0  "this setting is also done in init_user_photon"
            {  0  MEKE(IM)=NEL; "no. of electron energies as determed from PWLF1"
            {  0
            {  0  "now, set secondary egsnrc variables"
            {  0
            {  0  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
            {  0  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
            {  0
            {  0  "store results of pwlf in egsnrc variables"
            {  0  EKE0(IM)=BXE;
            {  0  EKE1(IM)=AXE;
            {  0
            {  0  "BFE and AFE were acquired with the call to"
            {  0  "PWLF1 above but we need to fill in the arrays"
            {  0  DO I=1,NEKE[
            {  0  ESIG0(I,IM)=BFE(I,1);
            {  0  ESIG1(I,IM)=AFE(I,1);
            {  0  PSIG0(I,IM)=BFE(I,2);
            {  0  PSIG1(I,IM)=AFE(I,2);
            {  0  EDEDX0(I,IM)=BFE(I,3);
            {  0  EDEDX1(I,IM)=AFE(I,3);
            {  0  PDEDX0(I,IM)=BFE(I,4);
            {  0  PDEDX1(I,IM)=AFE(I,4);
            {  0  EBR10(I,IM)=BFE(I,5);
            {  0  EBR11(I,IM)=AFE(I,5);
            {  0  PBR10(I,IM)=BFE(I,6);
            {  0  PBR11(I,IM)=AFE(I,6);
            {  0  PBR20(I,IM)=BFE(I,7);
            {  0  PBR21(I,IM)=AFE(I,7);
            {  0  TMXS0(I,IM)=BFE(I,8);
            {  0  TMXS1(I,IM)=AFE(I,8);
            {  0  ]
            {  0
            {  0  "below is for debugging to ensure that"
            {  0  "pegsless and pegs versions would give identical"
            {  0  "results if pegsless cross sections were to be"
            {  0  "read from a file a la pegs"
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0  ]
            {  0
            {  0  "put rescaling here in case we want to plot stopping powers via"
            {  0  "show_media_parameters below"
            {  0  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
            {  0  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
            {  0  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
            {  0  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
            {  0  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
            {  0  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
            {  0  DUNITR=DUNIT; "SAVE REQUESTED"
            {  0  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
            {  0  DUNIT=RLC(ID);]
            {  0  IF(DUNIT.NE.1.0) [
            {  0  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
            {  0  DUNITR,DUNIT,'(CM.)' );
            {  0  ]
            {  0  DO IM=1,NMED [
            {  0  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
            {  0  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
            {  0
            {  0  FOR I=1 TO MEKE(IM) [
            {  0  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
            {  0  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
            {  0  $SCALE TEFF0(IM) BY DFACT;
            {  0  $SCALE BLCC(IM) BY DFACTI;
            {  0  $SCALE XCC(IM) BY SQRT(DFACTI);
            {  0  RLDU(IM)=RLC(IM)/DUNIT;
            {  0  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
            {  0  ] "END IM DO"
            {  0
            {  0  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
            {  0  VACDST=VACDST*DUNITO/DUNIT;
            {  0  DUNITO=DUNIT; "SAVE OLD DUNIT"
            {  0
            {  0  call show_media_parameters(i_log);
            {  0
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {
            {  0  ;
            {  0  "***PHYSICAL AND MATHEMATICAL CONSTANTS                                "
            {  0  "     C        SPEED OF LIGHT(CM/SEC)                                  "
            {  0  "     RME      ELECTRON REST MASS(GRAMS)                               "
            {  0  "     HBAR     PLANCK'S CONSTANT/(2*PI)  (ERG SEC)                     "
            {  0  "     ECGS     ELECTRON CHARGE (ESU)                                   "
            {  0  "     EMKS     ELECTRON CHARGE (COULOMB)                               "
            {  0  "     AN       AVOGADRO'S NUMBER                                       "
            {  0  PIP=3.1415926536;
            {  0  C=2.997925E+10;
            {  0  HBAR=1.05450E-27;
            {  0  ECGS=4.80298E-10;
            {  0  EMKS=1.60210E-19;
            {  0  AN=6.02252E+23;
            {  0  "***DERIVED CONSTANTS                                                  "
            {  0  "     RADDEG   ONE RADIAN IN DEGREES                                   "
            {  0  "     FSC      FINE STRUCTURE CONSTANT                                 "
            {  0  "     ERGMEV   ONE MILLION ELECTRON VOLTS EXPRESSED IN ERGS            "
            {  0  "     R0       CLASSICAL ELECTRON RADIUS                               "
            {  0  "     RM       ELECTRON REST ENERGY IN MEV                             "
            {  0  RADDEG=180./PIP;
            {  0  FSC = ECGS**2/(HBAR*C);
            {  0  "     1.E+7 IS THE NUMBER OF ERGS PER JOULE                            "
            {  0  ERGMEV = (1.E+6)*(EMKS*1.E+7);
            {  0  RME = PRM/C**2*ERGMEV;
            {  0  "We are using RMP instead of PRM because single precision is required"
            {  0  RMP = PRM;
            {  0  R0 = (ECGS**2)/(RME*C**2);
            {  0  RMPSQ = RMP*RMP;
            {  0  A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV;
            {  0  A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13));
            {  0
            {  0  "DATA FOR COMMON BLOCK LSPION"
            {  0  DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/;
            {  0
            {  0  "DATA for COMMON BLOCK SPCOMM"
            {  0  DATA LMED/24/,NUMSTMED/$MXSTC/;
            {  0
            {  0  "DATA for COMMON BLOCK PWLFIN"
            {  0  DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/$MXEKE/;
            {  0
            {  0  "DATA for COMMON BLOCK MIMSD"
            {  0  DATA BMIN/4.5/;
            {  0
            {  0  "DATA for COMMON BLOCK RADLEN"
            {  0  DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/,
            {  0  A1440/1194.0/,A183/184.15/;
            {  0
            {  0  DATA MEDTB1/
            {  0  $S'H2-GAS',18*' ',$S'H2-LIQUID',15*' ',$S'HE-GAS',18*' ',$S'LI',22*' ',
            {  0  $S'BE',22*' ',$S'C-2.265 G/CM**3',9*' ',$S'C-1.70 G/CM**3',10*' ',
            {  0  $S'N2-GAS',18*' ',$S'O2-GAS',18*' ',$S'NE-GAS',18*' ',$S'NA',22*' ',
            {  0  $S'MG',22*' ',$S'AL',22*' ',$S'SI',22*' ',$S'AR-GAS',18*' ',
            {  0  $S'K',23*' ',$S'CA',22*' ',$S'TI',22*' ',$S'V',23*' ',$S'MN',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB2/
            {  0  $S'FE',22*' ',$S'CO',22*' ',$S'NI',22*' ',$S'CU',22*' ',$S'ZN',22*' ',
            {  0  $S'GE',22*' ',$S'SE',22*' ',$S'KR-GAS',18*' ',$S'RB',22*' ',
            {  0  $S'MO',22*' ',$S'AG',22*' ',$S'CD',22*' ',$S'IN',22*' ',$S'SN',22*' ',
            {  0  $S'XE-GAS',18*' ',$S'CS',22*' ',$S'GD',22*' ',$S'TA',22*' ',
            {  0  $S'W',23*' ',$S'PT',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB3/
            {  0  $S'AU',22*' ',$S'HG',22*' ',$S'PB',22*' ',$S'RN-GAS',18*' ',
            {  0  $S'U',23*' ',
            {  0  $S'AIR-GAS',17*' ',$S'CO2-GAS',17*' ',$S'POLYETHYLENE',12*' ',
            {  0  $S'POLYPROPYLENE',11*' ',$S'XYLENE',18*' ',$S'TOLUENE',17*' ',
            {  0  $S'NYLON',19*' ',$S'VINYLTOLUENE',12*' ',$S'A150-PLASTIC',12*' ',
            {  0  $S'STILBENE',16*' ',$S'POLYSTYRENE',13*' ',$S'ANTHRACENE',14*' ',
            {  0  $S'LEXAN',19*' ',$S'LUCITE',18*' ',$S'H2O',21*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB4/
            {  0  $S'MYLAR',19*' ',
            {  0  $S'KAPTON',18*' ',$S'LIF',21*' ',$S'POLYVINYL-CL',12*' ',
            {  0  $S'PYREX-GLASS',13*' ',$S'SIO2',20*' ',$S'CAF2',20*' ',
            {  0  $S'PHOTOEMULSION',11*' ',$S'AGCL',20*' ',$S'NAI',21*' ',
            {  0  $S'LII',21*' ',$S'AGBR',20*' ',$S'CSI',21*' '
            {  0  /;
            {  0
            {  0  DATA STDAT1/
            {  0  0.03535,6.790,1.864,3.5,19.2,9.584,
            {  0  0.09179,5.831,0.476,2.0,21.8,3.263,
            {  0  0.0114,7.625,2.202,4.0,41.8,11.139,
            {  0  0.3492,3.233,0.0966,2.0,40.0,3.122,
            {  0  0.3518,3.034,-0.0089,2.0,63.7,2.785,
            {  0  0.5848,2.360,-0.0089,2.0,78.0,2.868,
            {  0  0.7154,2.191,-0.0089,2.0,78.0,3.155,
            {  0  0.2120,3.041,1.738,4.0,82.0,10.540,
            {  0  0.2666,2.825,1.754,4.0,95.0,10.700,
            {  0  0.1202,3.357,2.073,4.5,137.0,11.904,
            {  0  0.2204,3.103,0.4515,2.8,149.0,5.053,
            {  0  0.1714,3.223,0.2386,2.8,156.0,4.530,
            {  0  0.3346,2.795,0.0966,2.5,166.0,4.239,
            {  0  0.3755,2.720,0.0966,2.5,173.0,4.435,
            {  0  0.1902,2.982,1.764,4.5,188.0,11.948,
            {  0  0.3041,2.674,0.2386,3.0,190.0,5.642,
            {  0  0.2177,2.874,0.1751,3.0,191.0,5.040,
            {  0  0.1782,2.946,0.0485,3.0,233.0,4.445,
            {  0  0.1737,2.935,-0.0089,3.0,245.0,4.266,
            {  0  0.1996,2.812,-0.0089,3.0,272.0,4.270
            {  0  /;
            {  0
            {  0  DATA STDAT2/
            {  0  0.2101,2.771,-0.0089,3.0,286.0,4.291,
            {  0  0.2229,2.713,-0.0089,3.0,297.0,4.260,
            {  0  0.2504,2.619,-0.0089,3.0,311.0,4.312,
            {  0  0.2557,2.613,-0.0089,3.0,322.0,4.419,
            {  0  0.3163,2.468,0.0485,3.0,330.0,4.691,
            {  0  0.2809,2.647,0.2386,3.0,350.0,5.141,
            {  0  0.2979,2.635,0.2386,3.0,348.0,5.321,
            {  0  0.1519,3.030,1.716,4.8,352.0,12.512,
            {  0  0.1450,3.078,0.4515,3.5,363.0,6.478,
            {  0  0.2228,2.824,0.1751,3.0,424.0,4.879,
            {  0  0.3091,2.563,-0.0089,3.0,470.0,5.063,
            {  0  0.1853,2.819,0.0485,3.3,469.0,5.273,
            {  0  0.2004,2.790,0.1751,3.3,487.0,5.517,
            {  0  0.1898,2.839,0.2386,3.3,488.0,5.534,
            {  0  0.1329,3.020,1.563,5.0,482.0,12.728,
            {  0  0.2214,2.784,0.4515,3.5,488.0,6.914,
            {  0  0.2068,2.686,0.0485,3.5,591.0,5.874,
            {  0  0.1663,2.805,0.1751,3.5,718.0,5.526,
            {  0  0.1499,2.870,0.1751,3.5,727.0,5.406,
            {  0  0.1465,2.903,0.0966,3.5,790.0,5.473
            {  0  /;
            {  0
            {  0  DATA STDAT3/
            {  0  0.1533,2.881,0.0966,3.5,790.0,5.575,
            {  0  0.1824,2.798,0.2386,3.5,800.0,5.961,
            {  0  0.1861,2.814,0.2386,3.5,823.0,6.202,
            {  0  0.1130,3.023,1.537,5.3,794.0,13.284,
            {  0  0.1362,3.034,0.2386,3.5,890.0,5.869,
            {  0  0.2466,2.879,1.742,4.0,85.7,10.595,
            {  0  0.1999,3.022,1.648,4.0,88.7,10.239,
            {  0  0.4875,2.544,0.1379,2.0,57.4,3.002,
            {  0  0.2493,2.975,0.1537,2.3,59.2,3.126,
            {  0  0.2755,2.911,0.1695,2.3,61.8,3.270,
            {  0  0.2830,2.890,0.1722,2.3,62.5,3.303,
            {  0  0.5345,2.439,0.1336,2.0,63.9,3.063,
            {  0  0.3495,2.749,0.1467,2.2,64.7,3.201,
            {  0  0.5462,2.435,0.1329,2.0,65.1,3.110,
            {  0  0.2989,2.851,0.1731,2.3,67.7,3.367,
            {  0  0.3670,2.724,0.1647,2.2,68.7,3.300,
            {  0  0.5858,2.364,0.1146,2.0,69.5,3.151,
            {  0  0.3865,2.664,0.1608,2.2,73.1,3.321,
            {  0  0.3996,2.606,0.1824,2.2,74.0,3.330,
            {  0  0.2065,3.007,0.2400,2.5,75.0,3.502
            {  0  /;
            {  0
            {  0  DATA STDAT4/
            {  0  0.3124,2.782,0.1561,2.3,78.7,3.326,
            {  0  0.4061,2.614,0.1492,2.2,79.3,3.342,
            {  0  0.1308,3.476,0.0171,2.5,94.0,3.167,
            {  0  0.1873,2.962,0.1558,2.8,108.2,4.053,
            {  0  0.2988,2.805,0.1479,2.5,134.0,3.971,
            {  0  0.1440,3.220,0.1385,2.8,139.2,4.003,
            {  0  0.3750,2.592,0.0676,2.5,166.0,4.065,
            {  0  0.3416,2.496,0.1009,3.0,331.0,5.332,
            {  0  0.1243,3.002,-0.0138,3.5,398.4,5.344,
            {  0  0.1560,2.926,0.1203,3.5,452.0,6.057,
            {  0  0.1785,2.845,0.0892,3.5,485.1,6.267,
            {  0  0.1351,2.976,0.0358,3.5,487.2,5.616,
            {  0  0.1796,2.840,0.0395,3.5,553.1,6.281
            {  0  /;
            {  0
            {  0  DATA NET/100/;
            {  0
            {  0  DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137.,
            {  0  149.,156.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245.,
            {  0  257.,272.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352.,
            {  0  363.,366.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488.,
            {  0  488.,487.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574.,
            {  0  580.,591.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736.,
            {  0  746.,757.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826.,
            {  0  841.,847.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./;
            {  0
            {  0  DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067,
            {  0  15.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738,
            {  0  32.064,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998,
            {  0  54.9380,55.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216,
            {  0  78.96,79.808,83.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0,
            {  0  101.07,102.905,106.4,107.87,112.4,114.82,118.69,121.75,127.60,
            {  0  126.9044,131.30,132.905,137.34,138.91,
            {  0  140.12,140.907,144.24,147.,150.35,151.98,157.25,158.924,162.50,
            {  0  164.930,167.26,168.934,173.04,174.97,178.49,180.948,183.85,
            {  0  186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,208.980,
            {  0  210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242.,
            {  0  243.,247.,247.,248.,254.,253./;
            {  0
            {  0  DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0,
            {  0  0.9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54,
            {  0  5.87,7.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80,
            {  0  4.2,3.4,1.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5,
            {  0  8.65,7.30,7.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769,
            {  0  7.007, 1.  ,7.54,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85,
            {  0  11.40,16.60,19.30,20.53,22.48,22.42,21.45,19.30,14.19,11.85,
            {  0  11.34,9.78,9.30, 1.  ,4., 1.  ,5.,  1. ,11.0,15.37,18.90,
            {  0  20.5,19.737,11.7,7.,1.   , 1.  , 1.  ,  1. /;
            {  0
            {  0  DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE',
            {  0  'NA','MG','AL','SI','P','S','CL','AR','K','CA','SC','TI',
            {  0  'V','CR','MN','FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR',
            {  0  'KR','RB','SR','Y','ZR','NB','MO','TC','RU','RH','PD','AG','CD',
            {  0  'IN','SN','SB','TE','I','XE','CS','BA','LA','CE','PR','ND',
            {  0  'PM','SM','EU','GD','TB','DY','HO','ER','TM','YB','LU','HF','TA',
            {  0  'W','RE','OS','IR','PT','AU','HG','TL','PB','BI','PO','AT','RN',
            {  0  'FR','RA','AC','TH','PA','U','NP','PU','AM','CM','BK','CF','ES',
            {  0  'FM'/;
            {  0
            {  0  "for COMMON BLOCK EPSTAR"
            {  0  DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/;
            {  0
            {  0  }
               0
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros to read and write phase space files                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1999                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros required to read from and write to phase space files. These macros  "
               0  "  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
               0  "  manipulations of phase space files that were hard-coded. Currently, these  "
               0  "  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
               0  "  configuration script looks for this file in the following directories, in  "
               0  "  this order                                                                 "
               0  "                                                                             "
               0  "  $HOME/egs4/BEAM_accelerator                                                "
               0  "  $HOME/egs4/beam                                                            "
               0  "  $OMEGA_HOME/beam                                                           "
               0  "                                                                             "
               0  "  All other configuration or compile scripts only use the version of this    "
               0  "  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
               0  "  that this file is concatenated before any codes that use the macros.       "
               0  "  Detailed description of what each macro does is provided at the top of     "
               0  "  the macro.                                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  ;
               0  REPLACE {;COMIN/RWPHSP/;} WITH {
            {  0  "RWPHSP must be included in the common block of main in any code that uses"
            {  0  "any of these phase space macros and also in the common block of"
            {  0  "any subroutine that uses any phase space macros.  Note that the macro"
            {  0  "$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
            {  0  "somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
            {  0  "DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
            {  0  "at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
            {  0  "variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
            {  0  "the top of any code that uses these macros.  If your compiler has trouble"
            {  0  "with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."
            {  0
            {  0  ;COMMON/RWPHSP/
            {  0  STRING_TEMP_ZLAST_OUT,
            {  0  "holds output phsp data for up to 1000 particles, with ZLAST"
            {  0  STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
            {  0  IHSTRY_PHSP, "history number (from primary non-phase space source) of"
            {  0  "particle being scored"
            {  0  iaea_dummy_long, "used to store INTEGER*8 values temporarily"
            {  0  NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
            {  0  "dosxyznrc source 20"
            {  0  ESHORT,    "single precision E read from/written to phsp"
            {  0  WEIGHTTMP, "modified version of WT to be written to phsp"
            {  0  WT_PHSP_SHORT, "single precision wt read from phsp"
            {  0  X_PHSP_SHORT, "single precision x read from phsp"
            {  0  Y_PHSP_SHORT, "single precision y read from phsp"
            {  0  Z_PHSP_SHORT, "single precision Z--for iaea format only"
            {  0  U_PHSP_SHORT, "single precision u read from phsp"
            {  0  V_PHSP_SHORT, "single precision v read from phsp"
            {  0  W_PHSP_SHORT, "single precision w--for iaea format only"
            {  0  ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
            {  0  MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
            {  0  EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
            {  0  EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
            {  0  NINC_PHSP_SHORT, "no. of particles from original primary source"
            {  0  dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
            {  0  iaea_extra_floats, "array of extra floats in IAEA phsp file"
            {  0  NUM_PHSP_TOT, "tot no of particles in phsp file"
            {  0  PHOT_PHSP_TOT,"no. of photons in phsp file"
            {  0  iaea_result,  "<0 if an error finding an available array index for IAEA"
            {  0  "phsp file"
            {  0  iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
            {  0  iaea_q_typ,    "array to convert from charge to IAEA type"
            {  0  iaea_typ_q,   "array to convert from IAEA type to charge"
            {  0  iaea_q_index, "array index"
            {  0  I_PHSP,    "loop counter"
            {  0  IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
            {  0  LATCHTMP,  "modified version of LATCH to be written to phsp"
            {  0  WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
            {  0  WRITE_PHSP_SOFAR, "how many particles written so far to file"
            {  0  PHSP_RESTART, "set to 1 if this is a restart"
            {  0  PHSP_RECL, "the record length"
            {  0  PHSP_RECL_OLD, "saves record length"
            {  0  iaea_extra_ints, "array in which LATCH will be stored for iaea format"
            {  0  iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
            {  0  "extra int and float variables in an IAEA phsp file"
            {  0  iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
            {  0  "IAEA phsp files read IN"
            {  0  iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
            {  0  iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
            {  0  i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
            {  0  "was used"
            {  0  iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
            {  0  " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
            {  0  " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
            {  0  MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"
            {  0
            {  0  CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
            {  0  CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
            {  0  $LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
            {  0  REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
            {  0  MUIDX_PHSP_SHORT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
            {  0  iaea_extra_floats(10);
            {  0  INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
            {  0  IERR_PHSP,LATCHTMP,
            {  0  WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
            {  0  PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
            {  0  iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
            {  0  iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
            {  0  i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
            {  0  iaea_i_muidx_out,dosxyz2beam_izscore;
            {  0  CHARACTER*5 MODE_RW;
            {  0
            {  0  "variables below are not part of the common block but are used locally"
            {  0  "by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"
            {  0
            {  0  INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
            {  0  REAL*4 REAL_TEMP_OUT(7);
            {  0  CHARACTER*32 REC_TEMP_OUT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
            {  0  "Must be placed after the variable declarations in any subroutine"
            {  0  "where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
            {  0  "it does not necessarily have to be put at the top of main, unless one or"
            {  0  "both of these macros are used in main."
            {  0  "It equivalences the character string REC_TEMP_OUT with the phase space data"
            {  0  "for 1 particle. REC_TEMP_OUT is then used to fill the character array"
            {  0  "STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
            {  0  "particles before writing."
            {  0
            {  0  EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
            {  0  EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
            {  0  EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
            {  0  EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
            {  0  EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
            {  0  EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
            {  0  EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
            {  0  EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
            {  0  }
               0  ;
               0
               0  REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
            {  0  "This macro initializes counters and flags that are used by the"
            {  0  "$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
            {  0  "used once and should be placed after the variable declarations in main."
            {  0
            {  0  DO I_PHSP=1,$MAX_SC_PLANES[
            {  0  WRITE_PHSP_COUNTER(I_PHSP)=0;
            {  0  WRITE_PHSP_SOFAR(I_PHSP)=0;
            {  0  IHSTRY_PHSP(I_PHSP)=0;
            {  0  ]
            {  0  PHSP_RESTART=0;
            {  0  PHSP_RECL_OLD=0;
            {  0
            {  0  iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
            {  0  iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;
            {  0
            {  0  iaea_n_extra_ints=0;iaea_n_extra_floats=0;
            {  0
            {  0  iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;
            {  0
            {  0  i_iaea_open_for_write=0;
            {  0
            {  0  iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;
            {  0
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
            {  0  "Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
            {  0  "by clearing the bits that store this information.  It also puts the"
            {  0  "single precision energy, ESHORT, read in into double precision form."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0
            {  0  {P4}=ESHORT;
            {  0
            {  0  IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
            {  0  ELSE [ {P1} = 0; ]
            {  0
            {  0  IF($BTEST({P3},30)) [
            {  0  {P2} = -1;
            {  0  {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [
            {  0  IF($BTEST({P3},29)) [
            {  0  {P2} = 1; {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [ {P2} = 0; ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
            {  0  "This macro calculates W, based on U and V and the sign of WT as read in from"
            {  0  "the phase space file.  Once the sign of WT is determined, WT is set equal"
            {  0  "to its absolute value, since there cannot be a negative particle weight."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=W"
            {  0  "{P2}=WT"
            {  0  "{P3}=X"
            {  0  "{P4}=Y"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0
            {  0  {P1} = min( 1., {P5}**2 + {P6}**2);
            {  0  {P1} = sqrt(1. - {P1});
            {  0  {P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"
            {  0
            {  0  {P2}=ABS({P2}); "WT is always positive"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
            {  0  "macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
            {  0  "read from phase space file into (potentially) double precision"
            {  0  "x, y, u, v passed to READ_PHSP_RECORD macro"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=X"
            {  0  "{P2}=Y"
            {  0  "{P3}=U"
            {  0  "{P4}=V"
            {  0
            {  0  {P1}=X_PHSP_SHORT;
            {  0  {P2}=Y_PHSP_SHORT;
            {  0  {P3}=U_PHSP_SHORT;
            {  0  {P4}=V_PHSP_SHORT;
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required  ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro actually reads the phase space data for a single particle."
            {  0  "It is called by $READ_PHSP, but can also be used as a stand-alone macro."
            {  0  "If the energy, E, is < 0.0, then this is the first particle scored"
            {  0  "from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
            {  0  "and E is set to ABS(E)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=NHSTRY"
            {  0  "{P5}=ZLAST"
            {  0  "{P6}=LATCH"
            {  0  "{P7}=E"
            {  0  "{P8}=WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
            {  0  ]
            {  0
            {  0  IF({P3}=76695869)[
            {  0  write(*,*)' x,y,u,v,wt,eshort,latch',
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
            {  0  WT_PHSP_SHORT,ESHORT,{P6};
            {  0  ]
            {  0
            {  0  "first particle from new primary history"
            {  0  IF(ESHORT<0.0)[
            {  0  {P4}={P4}+1;
            {  0  ESHORT=ABS(ESHORT);
            {  0  ]
            {  0
            {  0  {P7}=ESHORT;
            {  0  {P8}=WT_PHSP_SHORT;
            {  0  $PARSE_PHSP_RECORD({P9});
            {  0
            {  0  IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required            ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
            {  0  "the -E marker in the phase space file and does not advance NHSTRY"
            {  0  "It is only used in readphsp before byte swapping"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=ZLAST"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=E"
            {  0  "{P7}=WT"
            {  0  "{P8}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Note colon          ^  required between the first and second"
            {  0  "input parameters (third and fourth input variables)"
            {  0
            {  0  "This macro reads the phase space data for a single particle.  It finds"
            {  0  "the value of IQ and NPASS from the LATCH variable read in and then"
            {  0  "restores the LATCH variable.  It calculates W from U, V and the sign"
            {  0  "of WT and then restores WT to its absolute value.  And it puts the"
            {  0  "single-precision energy, ESHORT, read in into double-precision format."
            {  0  "If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
            {  0  "this as the first particle scored from a new primary history."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,record number reading from"
            {  0  "{P2}=NHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E"
            {  0  "{P9}=WT,X,Y,U,V"
            {  0
            {  0  $READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});
            {  0
            {  0  IF(IERR_PHSP=0)[
            {  0  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
            {  0  $GET_W_WT({P5},{P9});
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
            {  0  "This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
            {  0  "for a particle and is the form of LATCH written to the phase space file."
            {  0  "It puts double precision energy, E, into single precision format, ESHORT,"
            {  0  "for writing to the phase space file.  This macro is called from $READ_PHSP"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=W"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=E"
            {  0  "{P6}=WT"
            {  0
            {  0  LATCHTMP={P4};
            {  0
            {  0  IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
            {  0  ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]
            {  0
            {  0  IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
            {  0  ELSEIF({P2} = 0) [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBCLR(LATCHTMP,29);
            {  0  ]
            {  0  ELSE [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBSET(LATCHTMP,29);
            {  0  ]
            {  0
            {  0  ESHORT={P5};
            {  0
            {  0  WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
            {  0  "Macro to set E to -E if this is the first particle scored from a new"
            {  0  "primary (non-phsp source) history.  This macro is called from"
            {  0  "$WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters"
            {  0  "{P1}=phase space scoring plane no."
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=E"
            {  0  "{P4}=WT,X,Y,U,V"
            {  0
            {  0  IF({P2}~=IHSTRY_PHSP({P1}))[
            {  0  {P3}=-{P3};
            {  0  IHSTRY_PHSP({P1})={P2};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Macro to store the output phase space data for one particle in the"
            {  0  "variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
            {  0  "equivalenced to the string variable REC_TEMP_OUT, which stores the"
            {  0  "phase space for one particle in string form and which, in turn, is"
            {  0  "used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
            {  0  "which stores output phase space data for up to 1000 particles at a time."
            {  0  "This macro is called from $WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=ZLAST"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0  "{P5}=WT"
            {  0  "{P6}=X"
            {  0  "{P7}=Y"
            {  0  "{P8}=U"
            {  0  "{P9}=V"
            {  0
            {  0  LATCH_TEMP_OUT={P3};
            {  0  REAL_TEMP_OUT(1)={P4};
            {  0  REAL_TEMP_OUT(2)={P6};
            {  0  REAL_TEMP_OUT(3)={P7};
            {  0  REAL_TEMP_OUT(4)={P8};
            {  0  REAL_TEMP_OUT(5)={P9};
            {  0  REAL_TEMP_OUT(6)={P5};
            {  0  IF({P1}~=0) REAL_TEMP_OUT(7)={P2};
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
            {  0  "Note that a colon is required       ^  between the fifth and sixth"
            {  0  "input parameters"
            {  0
            {  0  "This macro is used to output phase space data 1000 particles at a time."
            {  0  "For every particle, the phase space data to be output is stored in"
            {  0  "the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
            {  0  "STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
            {  0  "space header info is considered to occupy the space of 1 particle in the"
            {  0  "first block of 1000 particles, however, it will be overwritten with nulls."
            {  0  "This is fine since the header info should be recalculated and rewritten at"
            {  0  "the top of the file after all data has been written out anyway."
            {  0  "Also note that restarting with this writing scheme requires that any"
            {  0  "blocks of N (N<1000) particles at the end of a phase space file from"
            {  0  "the previous run must immediately be read into the first N spaces of"
            {  0  "STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
            {  0  "for new particles.  Finally, after all phase space data has been output,"
            {  0  "there will probably be info for M (M<1000) particles still in"
            {  0  "STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
            {  0  "because the write counter did not reach 1000.  These are output using"
            {  0  "the $PHSP_BUFFER_FLUSH macro described below."
            {  0
            {  0  "Group writing reduces network traffic and saves a lot of time when the"
            {  0  "one of the main CPU-intensive activities is the writing of phase space data."
            {  0  "Group reading has also been considered, but preliminary studies have shown"
            {  0  "that it does not reduce CPU time significantly."
            {  0
            {  0  "Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
            {  0  "E to -E if this is the first particle scored from a new primary"
            {  0  "(non-phsp source) history."
            {  0
            {  0  "This macro is called by $WRITE_PHSP, but can also be used as a stand-"
            {  0  "alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
            {  0  "use of $PHSP_BUFFER_FLUSH (see below)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=name of phase space file"
            {  0  "{P4}=record number writing to"
            {  0  "{P5}=scoring plane number"
            {  0  "{P6}=IHSTRY"
            {  0  "{P7}=ZLAST"
            {  0  "{P8}=LATCH"
            {  0  "{P9}=E,WT,X,Y,U,V"
            {  0
            {  0  IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
            {  0  "we have a restart or its the start of a new batch"
            {  0  IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
            {  0  "make what was the buffer flush part of the first record of the restart"
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
            {  0  IF(WRITE_PHSP_SOFAR({P5})>0)[
            {  0  PHSP_RESTART=1;
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
            {  0  ]
            {  0  ELSE[
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
            {  0  ]
            {  0  ]
            {  0
            {  0  $SET_NEGATIVE_E({P5},{P6},{P9});
            {  0
            {  0  $PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});
            {  0
            {  0  IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
            {  0  32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
            {  0  28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  IF({P1}~=0)[
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
            {  0  32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
            {  0  28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0
            {  0  IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
            {  0  IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
            {  0  CLOSE({P2});
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  IF({P1}~=0)[
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
            {  0  ]
            {  0  IF(PHSP_RECL_OLD~=0)[
            {  0  "have to do this in case the output file=input file"
            {  0  PHSP_RECL=PHSP_RECL_OLD;
            {  0  CLOSE({P2});
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
            {  0  "This macro outputs the data for the M (M<1000) remaining particles still"
            {  0  "stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
            {  0  "The macro does not flush all of the data at once, but in blocks that"
            {  0  "divide exactly into the number of particles already in the phase space"
            {  0  "file.  For each block that is flushed, the phase space file is re-opened"
            {  0  "with a record length (RECL) equal to the size of the block.  Since RECL"
            {  0  "divides exactly into the number of particles already in the file, the"
            {  0  "block to be flushed can be appended onto the data that already exists in"
            {  0  "the file with no overwrites and/or blank space."
            {  0  "The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
            {  0  "a time, which is more time-consuming."
            {  0  "$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
            {  0  "$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
            {  0  "phase space data is output.  In the case of BEAM, it is placed at the end"
            {  0  "of each batch, so that, if the simulation crashes, phase space information"
            {  0  "from the last batch is not lost."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=file name"
            {  0  "{P4}=particle number +1"
            {  0  "{P5}=scoring plane number"
            {  0  TEMP_PHSP_COUNTER=0;
            {  0  NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
            {  0  IF(NUM_PHSP_TOFLUSH>0)[
            {  0  IF(WRITE_PHSP_SOFAR({P5})=0)[
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
            {  0  ]
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
            {  0  REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
            {  0  ]UNTIL(REM_PHSP=0);
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["write ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_ZLAST_OUT({P5})
            {  0  (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_OUT({P5})
            {  0  (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
            {  0  ] UNTIL(NUM_PHSP_TOFLUSH=0);
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=0;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
            {  0  "Note that colons     ^             ^  are required between the first and"
            {  0  "second input parameters (5th and 6th input variables) and the"
            {  0  "8th and 9th input parameters (13th and 14th input variables)"
            {  0
            {  0  "This outputs phase space data in blocks of 1000 particles at a time."
            {  0  "In preparation for output, LATCH is modified to hold NPASS and IQ,"
            {  0  "energy (E) is placed into a single precision variable, ESHORT, and"
            {  0  "weight (WT) is given the sign of W.  If this is the first particle"
            {  0  "scored from a new primary (non-phase space source) history, then"
            {  0  "ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,name of phase space file,"
            {  0  "     record number writing to, scoring plane number"
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E,WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  $GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});
            {  0
            {  0  $WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
            {  0  "This macro reads the info from the header of a phase space file."
            {  0  "It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
            {  0  "as a stand-alone macro."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=MODE0 or MODE2"
            {  0  "{P3}=total number of particles"
            {  0  "{P4}=no. of photons"
            {  0  "{P5}=max k.e. of particles"
            {  0  "{P6}=min. k.e. of electrons"
            {  0  "{P7}=no. of particles incident from original source"
            {  0
            {  0  READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  {P3}=NUM_PHSP_TOT;
            {  0  {P4}=PHOT_PHSP_TOT;
            {  0  {P5}=EKMAX_PHSP_SHORT;
            {  0  {P6}=EKMINE_PHSP_SHORT;
            {  0  {P7}=NINC_PHSP_SHORT;
            {  0
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
            {  0  STOP;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
            {  0  "Macro to open a phase space file in preparation for reading it."
            {  0  "The macro opens the file in one of 3 modes, as a file that is known"
            {  0  "to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
            {  0  "(IZLAST=0), or with no prior knowledge of whether the file has"
            {  0  "ZLAST or not (IZLAST<0)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  IF({P1}>0)["with ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  "error above on file opening when assumed it was MODE2"
            {  0  OUTPUT;(/' ***error opening file as MODE2 ****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE3')[
            {  0  OUTPUT;(//' That file does not start with MODE3,',
            {  0  ' as all old compressed files (with ZLAST) must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE3 file! '/
            {  0  ' Please convert it into a MODE2 file using [readphsp] ',
            {  0  ' and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}=0)["without ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
            {  0  "this factor is machine-dependent and stored in machine.mortran"
            {  0  "check file is MODE0 -ie standard compressed"
            {  0  IF(IERR_PHSP~=0)[
            {  0  "come here if error opening file assumed MODE0"
            {  0  OUTPUT;(/' ***ERROR opening file as MODE0****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE1')[
            {  0  OUTPUT;(//' That file does not start with MODE1,',
            {  0  ' as all old compressed files must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE1 file! '/
            {  0  ' Please convert it into a MODE0 file using [readphsp] ',
            {  0  'and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE0')[
            {  0  OUTPUT;
            {  0  (/' Does not start with MODE0 as files without ZLAST must'/
            {  0  '  Try again!'//);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
            {  0  OUTPUT;(/' First, try to open it as a MODE0 file');
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  {P1}=0;
            {  0  IF({P4}~='MODE0')[
            {  0  OUTPUT;(/' The file does not start with MODE0 as it supposed to');
            {  0  CLOSE({P2});
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
            {  0  "Puts max ke of particles, min ke of electrons, and no. of particles"
            {  0  "incident from original source--all of which may be double precision"
            {  0  "into real*4 variables"
            {  0  "{P1}=tot. no. of particles"
            {  0  "{P2}=no. of photons"
            {  0  "{P3}=max ke of particles"
            {  0  "{P4}=min ke of electrons"
            {  0  "{P5}=no. of particles incident from primary source"
            {  0  IF({P1}>2147483647)[
            {  0  write(*,*)' Warning while writing phase space file:';
            {  0  write(*,*)' No. of particles > 2^31-1.';
            {  0  write(*,*)' Total no. of particles (and photons) written';
            {  0  write(*,*)' to header may be nonsense.';
            {  0  ]
            {  0  NUM_PHSP_TOT={P1};
            {  0  PHOT_PHSP_TOT={P2};
            {  0  EKMAX_PHSP_SHORT={P3};
            {  0  EKMINE_PHSP_SHORT={P4};
            {  0  NINC_PHSP_SHORT={P5};
            {  0  }
               0
               0  REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
            {  0  "Macro to write the header information into a phase space file."
            {  0  "Files must be closed and re-opened with record length (RECL) for"
            {  0  "a single particle in order to prevent over-writing any particle data."
            {  0  "Once the header info is written, the file is closed again and re-opened"
            {  0  "with the RECL for 1000 particles."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $PARSE_PHSP_HEADER_FOR_WRITE({P5});
            {  0  WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
            {  0  EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
            {  0  "This macro opens a phase space file for writing.  The file is opened with"
            {  0  "a record length that will hold phase space data for 1000 particles in 1"
            {  0  "record.  This is to to enable writing phase space data for 1000 particles"
            {  0  "at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
            {  0  "$WRITE_PHSP_HEADER to output a dummy header to the file."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE_RW"
            {  0  IF({P1}~=0)["with ZLAST"
            {  0  {P4}='MODE2';
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  {P4}='MODE0';
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
            {  0  }
               0  ;
               0
               0  REPLACE {$CLOSE_PHSP(#);} WITH {;
            {  0  "Macro to close a phase space file."
            {  0
            {  0  "Input parameter:"
            {  0  "{P1}=the unit number of the phase space file"
            {  0
            {  0  CLOSE(UNIT={P1});
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  "AUNIT is a character variable"
            {  0  "construct phase space file name."
            {  0  "part of this--the part that determines the directory and"
            {  0  "file prefix--is done in beam"
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
            {  0  OUTPUT;
            {  0  (/' Restarting after previous run, will read old data & phase-space',
            {  0  ' files');
            {  0  DO I=1,NSC_PLANES [
            {  0  OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
            {  0  :OPEN_MODE0:;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0
            {  0  $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_WRITE_PHSP;} WITH {;
            {  0  IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
            {  0  ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]
            {  0
            {  0  "output directory and file prefix are defined in beam.mortran"
            {  0
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
            {  0  ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
            {  0  X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
            {  0  BEAM_MU_INDEX);
            {  0  ]
            {  0
            {  0  ELSE[
            {  0
            {  0  IF( i_parallel > 0 ) ["add an _w"
            {  0  phsp_fn=$cstring(phsp_fn)// '_w';
            {  0  call egs_itostring(phsp_fn,i_parallel,.false.);
            {  0  ]
            {  0  phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
            {  0  $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
            {  0  ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
            {  0  LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
            {  0  ]
            {  0  IF(IZLAST = 2)[
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
            {  0  JHSTRY=JHSTRY+1;
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
            {  0  XLAST(NP),YLAST(NP),ZLAST(NP),0;
            {  0  :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
            {  0  ]
            {  0  "Check only needed when actually writting to a phsp file"
            {  0  IF(NPPHSP(ISCORE)=phsp_upper_limit)[
            {  0  $egs_fatal('(//a,i19,4(a/))',
            {  0  ' *** WHILE WRITING PHASE SPACE FILE:',
            {  0  NPPHSP(ISCORE), ' particles in file.',
            {  0  ' Due to the fact that the counter for the number',
            {  0  ' of particles in the file cannot be larger than this,',
            {  0  ' no more particles will be written to the phsp file.'
            {  0  );
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
            {  0  IF(IO_OPT=4)["update no. of primary histories in header"
            {  0  DO I1=1,NSC_PLANES[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
            {  0  $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
            {  0  ]
            {  0  ]
            {  0  ELSE["standard BEAMnrc format"
            {  0  IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  DO I1=1,NSC_PLANES[
            {  0  NPPHSPSP=NPPHSP(I1);
            {  0  IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]
            {  0
            {  0  "output directory and file prefix defined in beam.mortran"
            {  0
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
            {  0  IF(NPPHSPSP=NPHOTPHSP(I1))[
            {  0  "no electrons"
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), 0.0, NINCPHSP);
            {  0  ]
            {  0  ELSE[
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
            {  0  ]
            {  0  ]
            {  0  "we store the total particle number in the 1st record of the ph-sp file"
            {  0  ]
            {  0  ]"end of standard BEAMnrc format"
            {  0  };
               0
               0  REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
            {  0  DO I=1,NSC_PLANES[
            {  0  OUTPUT I,NPPHSP(I);
            {  0  (//' PH-SP FILE',I4,': '/
            {  0  '               TOTAL NO. OF PARTICLES =',I12);
            {  0  IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
            {  0  "added phase space files before restarting"
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
            {  0  EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
            {  0  EKMINPHSPE(I)=99999.; "info unavailable"
            {  0  IF(IZLAST=0 & IZLAST1=1)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored with ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=0.  Restart with'/
            {  0  ' IZLAST=1.'//);
            {  0  STOP;
            {  0  ]
            {  0  ELSEIF(IZLAST=1 & IZLAST1=0)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored  without ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=1.  Restart with'/
            {  0  ' IZLAST=0.'//);
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
            {  0  NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  IF(NINCPHSP>
            {  0  NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
            {  0  "files have been added"
            {  0  OUTPUT I;(//' ***ERROR:'/
            {  0  ' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
            {  0  ' The code currently does not support this.  Please add phase space'/
            {  0  ' files only after all runs, including restarts, are complete.'//);
            {  0  "STOP;"
            {  0  ]
            {  0  ]
            {  0  IF(NPPHSP(I) > 0)[
            {  0  CALL DATETIME(1);
            {  0  OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
            {  0  "Read last particles to check whether it is right"
            {  0  IF(IO_OPT=4)[
            {  0  "just check that file size=checksum"
            {  0  $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
            {  0  NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
            {  0  "binary read"
            {  0  OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
            {  0  ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
            {  0  I12,' IN THIS FILE:'/' ',I12,6F12.5);
            {  0  "CALL TIME(TIMEN);"
            {  0  "OUTPUT TIMEN;"
            {  0  "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
            {  0  ]
            {  0  OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
            {  0  call egs_time(6); OUTPUT; (' ');
            {  0  ]
            {  0  ]"end of loop over planes"
            {  0  };
               0
               0  REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
            {  0  IF(n_parallel=0 | ~is_finished) [
            {  0  "do not close phsp files that have already been closed"
            {  0  "after individual parallel jobs have ended"
            {  0  IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
            {  0  "phase-space output"
            {  0  DO I=1,NSC_PLANES [
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  CLOSE(IOUTFLU(I));
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps."
            {  0  "Some mods by BW."
            {  0  IF(IRESTART=0) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,0,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  ELSEIF(IRESTART=1) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,1,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
            {  0  1,nhist,latch(np),iq(np),e(np),
            {  0  wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
            {  0  frMU_indx); "added MU index (JL 2013)"
            {  0  "zlast not used in dosxyz so this is a dummy variable"
            {  0
            {  0  };
               0
               0  REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
            {  0  ]
            {  0  ELSEIF(isource = 2 | isource = 8 )[
            {  0  ainflu=dble(IHSTRY+ncaseold+nsmiss+
            {  0  (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
            {  0  ]
            {  0  ELSEIF(isource=4)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss);
            {  0  ]
            {  0  ELSEIF(isource=6)[
            {  0  ainflu=dble(IHSTRY+ncaseold);
            {  0  ]
            {  0  ELSEIF(isource=9|isource=10|isource=21)[
            {  0  ainflu=dble(nhist);
            {  0  ]
            {  0  ELSEIF(isource=20)[
            {  0  ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
            {  0  ]
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
            {  0  $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
            {  0
            {  0  };
               0
               0  " The following are null macros that will be overwritten by the library "
               0  " version of BEAM "
               0  REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};
               0
               0  "End of phsp_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for IAEA phase space data format                             "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2007                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros for reading and writing phase space data in the official IAEA       "
               0  "  format.  See the online documentation at https://www-nds.iaea.org/phsp/    "
               0  "  for more about this format. These macros make use of the C++ IAEA phase    "
               0  "  space handling routines in directory $HEN_HOUSE/iaea_phsp/, which are      "
               0  "  provided for public use by the IAEA.                                       "
               0  "                                                                             "
               0  "  In order to use the routines, Fortran compilation must include the flags:  "
               0  "                                                                             "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_header.cpp                                       "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_phsp.cpp                                         "
               0  "  $HEN_HOUSE/iaea_phsp/iaea_record.cpp                                       "
               0  "  $HEN_HOUSE/iaea_phsp/utilities.cpp                                         "
               0  "  -lm -lstdc++                                                               "
               0  "                                                                             "
               0  "  In BEAMnrc, this is done by going into $HEN_HOUSE/specs/beamnrc.spec and   "
               0  "  setting `BEAM_OBJECTS =` the above flags.                                  "
               0  "                                                                             "
               0  "  These macros also make use of variables in COMIN/RWPHSP defined in         "
               0  "                                                                             "
               0  "  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
               0  "                                                                             "
               0  "  hence they must be included in the mortjob.mortran file AFTER              "
               0  "                                                                             "
               0  "  $HEN_HOUSE/utils/phsp_macros.mortran                                       "
               0  "                                                                             "
               0  "  These macros are defined as null in phsp_macros.mortran in case the IAEA   "
               0  "  C++ routines are unavailable and cannot be included in the code.           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=file name"
            {  0  "{P3}=IZLAST"
            {  0  "{P4}=IRESTART=0 for first run, 1 for restart"
            {  0  "{P5}=Z position of the scoring plane"
            {  0  "{P6}=IMUPHSP"
            {  0  "{P7}=IZSCORE, set to 1 to score Z for each particle"
            {  0  "note that if IRESTART=1, then nothing is done with {P3} and {P5}"
            {  0
            {  0  call iaea_new_source({P1},{P2},{P4}+2,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error opening IAEA phase space file for write.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  i_iaea_open_for_write=1;
            {  0  IF({P4}=0)[
            {  0  IF({P7}~=1) call iaea_set_constant_variable({P1},2,{P5});
            {  0  IF({P3}~=0)[
            {  0  IF({P6}~=0)[
            {  0  call iaea_set_extra_numbers({P1},2,1);
            {  0  "use generic user type for MU_INDEX"
            {  0  call iaea_set_type_extrafloat_variable({P1},1,0);
            {  0  iaea_i_muidx_out=2;
            {  0  ]
            {  0  ELSE [
            {  0  call iaea_set_extra_numbers({P1},1,1);
            {  0  ]
            {  0  call iaea_set_type_extrafloat_variable({P1},0,3);
            {  0  iaea_i_zlast_out=1;
            {  0  ]
            {  0  ELSEIF({P6}~=0)[
            {  0  call iaea_set_extra_numbers({P1},1,1);
            {  0  call iaea_set_type_extrafloat_variable({P1},0,0);
            {  0  iaea_i_muidx_out=1;
            {  0  ]
            {  0  ELSE[
            {  0  call iaea_set_extra_numbers({P1},0,1); "always store LATCH"
            {  0  ]
            {  0  call iaea_set_type_extralong_variable({P1},0,2);
            {  0  iaea_i_latch_out=1;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=file name"
            {  0
            {  0  call iaea_new_source({P1},{P2},1,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error opening IAEA phase space source.';
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_PARSE_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=WT"
            {  0  "{P2}=X"
            {  0  "{P3}=Y"
            {  0  "{P4}=Z"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0  "{P7}=W"
            {  0  "{P8}=ZLAST"
            {  0  "{P9}=BEAM_MU_INDEX"
            {  0
            {  0  WT_PHSP_SHORT={P1};
            {  0  X_PHSP_SHORT={P2};
            {  0  Y_PHSP_SHORT={P3};
            {  0  Z_PHSP_SHORT={P4};
            {  0  U_PHSP_SHORT={P5};
            {  0  V_PHSP_SHORT={P6};
            {  0  W_PHSP_SHORT={P7};
            {  0  ZLAST_PHSP_SHORT={P8};
            {  0  MUIDX_PHSP_SHORT={P9};
            {  0  }
               0
               0
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=NPASS"
            {  0  "{P3}=scoring plane no."
            {  0  "{P4}=NHSTRY (primary history no.)"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=IQ"
            {  0  "{P7}=E"
            {  0  "{P8}=WT,X,Y,Z,U,V,W,ZLAST,BEAM_MU_INDEX"
            {  0
            {  0  IF({P2}=0)["do not output if NPASS=1"
            {  0  ESHORT={P7}; "put energy into single precision"
            {  0  "calculate increment in primary history no. between this particle"
            {  0  "and last particle scored"
            {  0  iaea_n_stat={P4}-IHSTRY_PHSP({P3});
            {  0  IHSTRY_PHSP({P3})={P4}; "reset ihstry"
            {  0  "JWU: IAEA phsp uses kinetic energy!"
            {  0  IF( ({P6}=1) | ({P6}=-1) )[
            {  0  ESHORT = ESHORT - 0.5109989461;
            {  0  ]
            {  0  $IAEA_PARSE_FOR_WRITE({P8});
            {  0  IF(i_iaea_open_for_write=1)[
            {  0  iaea_extra_ints(iaea_i_latch_out)={P5};"store LATCH"
            {  0  IF(iaea_i_zlast_out>0) iaea_extra_floats(iaea_i_zlast_out)=ZLAST_PHSP_SHORT;
            {  0  IF(iaea_i_muidx_out>0) iaea_extra_floats(iaea_i_muidx_out)=MUIDX_PHSP_SHORT;
            {  0  ]
            {  0  ELSE[
            {  0  "use same array indices as input IAEA phsp file"
            {  0  "we only get here if the IAEA_OPEN_PHSP_FOR_WRITE macro"
            {  0  "has not been used"
            {  0  iaea_extra_ints(iaea_i_latch)={P5};"store LATCH"
            {  0  IF(iaea_i_zlast>0) iaea_extra_floats(iaea_i_zlast)=ZLAST_PHSP_SHORT;
            {  0  IF(iaea_i_muidx>0) iaea_extra_floats(iaea_i_muidx)=MUIDX_PHSP_SHORT;
            {  0  ]
            {  0  call iaea_write_particle({P1},iaea_n_stat,iaea_q_typ({P6}+2),ESHORT,
            {  0  WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
            {  0  V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=total no. of particles"
            {  0  "{P3}=total no. of photons"
            {  0  "{P4}=max, K.E. of all particles"
            {  0  "{P5}=no of incident primary histories"
            {  0  "{P6}=Z of scoring plane"
            {  0  "{P7}=IZLAST"
            {  0  "{P8}=IMUPHSP"
            {  0  "{P9}=IZSCORE"
            {  0
            {  0  call iaea_get_max_particles({P1},-1,iaea_dummy_long);
            {  0  {P2}=iaea_dummy_long;
            {  0  call iaea_get_max_particles({P1},1,iaea_dummy_long);
            {  0  {P3}=iaea_dummy_long;
            {  0  call iaea_get_total_original_particles({P1},iaea_dummy_long);
            {  0  {P5}=iaea_dummy_long;
            {  0  call iaea_get_maximum_energy({P1},EKMAX_PHSP_SHORT);
            {  0  {P4}=EKMAX_PHSP_SHORT;
            {  0  call iaea_get_constant_variable({P1},2,Z_PHSP_SHORT,iaea_result);
            {  0  IF(iaea_result=-3)[
            {  0  write(i_log,*)
            {  0  ' Z positions of each particle will be read from phase space data.';
            {  0  {P6}=999.;
            {  0  {P9}=1; "tell host code that Z is scored"
            {  0  ]
            {  0  ELSEIF(iaea_result<0)[
            {  0  write(i_log,*)' Error reading Z position where IAEA phsp was scored.';
            {  0  {P9}=0;
            {  0  ]
            {  0  ELSE[
            {  0  {P6}=Z_PHSP_SHORT;
            {  0  {P9}=0;
            {  0  ]
            {  0  call iaea_get_extra_numbers({P1},iaea_n_extra_floats,iaea_n_extra_ints);
            {  0  IF(iaea_n_extra_floats = -1 | iaea_n_extra_ints = -1)[
            {  0  write(i_log,*)' Error reading number of extra variables stored in IAEA phsp';
            {  0  ]
            {  0  call iaea_get_type_extra_variables({P1},iaea_result,iaea_extra_int_types,
            {  0  iaea_extra_float_types);
            {  0  IF(iaea_result=-1)[
            {  0  write(i_log,*)' Error getting types of extra variables stored in IAEA phsp';
            {  0  ]
            {  0  DO I_PHSP=1,iaea_n_extra_ints [
            {  0  IF(iaea_extra_int_types(I_PHSP)=2)[
            {  0  iaea_i_latch=I_PHSP;
            {  0  EXIT;
            {  0  ]
            {  0  ]
            {  0  IF(iaea_i_latch=-99)[
            {  0  write(i_log,*)' Warning: IAEA format phsp file does not store LATCH';
            {  0  ]
            {  0  DO I_PHSP=1,iaea_n_extra_floats [
            {  0  IF(iaea_extra_float_types(I_PHSP)=3)[
            {  0  iaea_i_zlast=I_PHSP;
            {  0  EXIT;
            {  0  ]
            {  0  ]
            {  0  IF(iaea_i_zlast=-99)[
            {  0  {P7}=0; "no zlast"
            {  0  ]
            {  0  ELSE[
            {  0  {P7}=1;
            {  0  ]
            {  0  "test to see if this file contains MU_INDEX"
            {  0  "we assume this is the first float after zlast, if zlast is scored,"
            {  0  "and has generic user type = 0"
            {  0  iaea_i_muidx=MAX(1,iaea_i_zlast+1);
            {  0  IF(iaea_i_muidx>iaea_n_extra_floats | iaea_extra_float_types(iaea_i_muidx)~=0) [
            {  0  iaea_i_muidx=-99;"reset this to no scoring"
            {  0  {P8}=0;
            {  0  ]
            {  0  ELSE[
            {  0  {P8}=1;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit no."
            {  0  "{P2}=record no. (particle no.) to go to"
            {  0
            {  0  iaea_dummy_long={P2};
            {  0  call iaea_set_record({P1},iaea_dummy_long,iaea_result);
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error going to record ',{P2},' in IAEA phsp file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_PARSE_FOR_READ(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=WT"
            {  0  "{P2}=X"
            {  0  "{P3}=Y"
            {  0  "{P4}=Z"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0  "{P7}=W"
            {  0  "{P8}=ZLAST"
            {  0  "{P9}=MU_INDEX"
            {  0
            {  0  {P1}=WT_PHSP_SHORT;
            {  0  {P2}=X_PHSP_SHORT;
            {  0  {P3}=Y_PHSP_SHORT;
            {  0  {P4}=Z_PHSP_SHORT;
            {  0  {P5}=U_PHSP_SHORT;
            {  0  {P6}=V_PHSP_SHORT;
            {  0  {P7}=W_PHSP_SHORT;
            {  0  {P8}=ZLAST_PHSP_SHORT;
            {  0  {P9}=MUIDX_PHSP_SHORT;
            {  0  }
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=NPASS"
            {  0  "{P3}=NHSTRY (no. of primary histories represented by particle read)"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=IQ"
            {  0  "{P6}=E"
            {  0  "{P7}=WT,X,Y,Z,U,V,W,ZLAST,MU_INDEX"
            {  0
            {  0  {P2}=0; "no multiple passers stored in IAEA format"
            {  0
            {  0  call iaea_get_particle({P1},iaea_n_stat,iaea_q_index,ESHORT,WT_PHSP_SHORT,
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,Z_PHSP_SHORT,U_PHSP_SHORT,
            {  0  V_PHSP_SHORT,W_PHSP_SHORT,iaea_extra_floats,iaea_extra_ints);
            {  0  IF(iaea_n_stat=-1)[
            {  0  WRITE(i_log,*)' Error getting particle data from IAEA phsp file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_n_stat=-2)[
            {  0  WRITE(i_log,*)' WARNING: Reached end of IAEA phsp file.  File restarted.';
            {  0  ]
            {  0  ELSEIF(iaea_n_stat>=0)[
            {  0  {P3}={P3}+iaea_n_stat;
            {  0  IF(iaea_i_latch=-99)[
            {  0  {P4}=0; "latch not stored here"
            {  0  ]
            {  0  ELSE [
            {  0  {P4}=iaea_extra_ints(iaea_i_latch);
            {  0  ]
            {  0  {P5}=iaea_typ_q(iaea_q_index);
            {  0  "JWU: IAEA phsp uses kinetic energy!"
            {  0  IF( ({P5}=1) | ({P5}=-1) )[
            {  0  ESHORT = ESHORT + 0.5109989461;
            {  0  ]
            {  0  {P6}=ESHORT;
            {  0  IF(iaea_i_zlast=-99)[
            {  0  ZLAST_PHSP_SHORT=0; "no zlast stored"
            {  0  ]
            {  0  ELSE [
            {  0  ZLAST_PHSP_SHORT= iaea_extra_floats(iaea_i_zlast);
            {  0  ]
            {  0  IF(iaea_i_muidx=-99)[
            {  0  MUIDX_PHSP_SHORT=0; "no mu_index stored"
            {  0  ]
            {  0  ELSE [
            {  0  MUIDX_PHSP_SHORT= iaea_extra_floats(iaea_i_muidx);
            {  0  ]
            {  0  $IAEA_PARSE_FOR_READ({P7});
            {  0  ]
            {  0  }
               0  ;
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_destroy_source({P1},iaea_result);
            {  0
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error closing IAEA phase space ID ',{P1};
            {  0  ]
            {  0  }
               0  ;
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0  "{P2}=no. of incident primary histories"
            {  0
            {  0  iaea_dummy_long={P2};
            {  0  call iaea_set_total_original_particles({P1},iaea_dummy_long);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_update_header({P1},iaea_result);
            {  0
            {  0  IF(iaea_result<0)[
            {  0  WRITE(i_log,*)' Error writing IAEA phase space header for ID ',{P1};
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;
            {  0  "input parameters"
            {  0  "{P1}=unit number"
            {  0
            {  0  call iaea_check_file_size_byte_order({P1},iaea_result);
            {  0
            {  0  IF(iaea_result=-3)[
            {  0  WRITE(i_log,*)' ERROR: Size of phase space file does not match';
            {  0  WRITE(i_log,*)' the value of checksum in the header.  Something may be';
            {  0  WRITE(i_log,*)' wrong.  Check your file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-4)[
            {  0  WRITE(i_log,*)' ERROR: Byte order in the phase space file does not';
            {  0  WRITE(i_log,*)' match the machine you are running on.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-5)[
            {  0  WRITE(i_log,*)' ERROR: Size of file does not match the value of checksum';
            {  0  WRITE(i_log,*)' in the header AND there is a byte order mismatch between';
            {  0  WRITE(i_log,*)' the file and the machine you are running on.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-1)[
            {  0  WRITE(i_log,*)' ERROR: Cannot open phase space header.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  ELSEIF(iaea_result=-2)[
            {  0  WRITE(i_log,*)' ERROR: Something is wrong with the phase space file.';
            {  0  $CALL_EXIT(1);
            {  0  ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosxzynrc application                                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Dave Rogers, 1986                                         "
               0  "                                                                             "
               0  "  Contributors:    Bruce Faddegon                                            "
               0  "                   George Ding                                               "
               0  "                   Charlie Ma                                                "
               0  "                   Alex Bielajew                                             "
               0  "                   Paul Reckwerdt                                            "
               0  "                   Blake Walters                                             "
               0  "                   Brian Geiser                                              "
               0  "                   Mark Holmes                                               "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Reid Townson                                              "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  A general purpose EGSnrc user code to do cartesian coordinate dose         "
               0  "  deposition studies. Every voxel (volume element) can have different        "
               0  "  materials and/or varying densities (for use with CT data).                 "
               0  "                                                                             "
               0  "  The geometry is a rectilinear volume in a right-handed coordinate system:  "
               0  "  the XY plane on the page, X axis to the right, Y down and Z into the page. "
               0  "  Voxel dimensions are variable in all three directions. For more detail on  "
               0  "  geometry see the subroutine HOWFAR.                                        "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  DOSXYZ started out as a demonstration code that Dave Rogers wrote to show  "
               0  "  Ralph Nelson that special purpose coding of rectilinear voxels was faster  "
               0  "  than using his more general macros. It then got used to estimate the time  "
               0  "  required to do a full Monte Carlo treatment planning calculation and the   "
               0  "  results published three years later in 1990 in a book chapter (Rogers and  "
               0  "  Bielajew). It then became the basis for a Monte Carlo timing benchmark;    "
               0  "  see Bielajew and Rogers, Med. Phys. 19, 303, (1992).                       "
               0  "                                                                             "
               0  "  The OMEGA project took this code over and added a variety ofdifferent      "
               0  "  source routines with coding contributions from BA Faddegon, CM Ma, GX      "
               0  "  Ding, AF Bielajew and P Reckwerdt. More recent mods have reduced the array "
               0  "  space used by the code, and added beam characterization inputs (CM Ma),    "
               0  "  btree inputs (Brian Geiser), correlated sampling hooks (Mark Holmes).      "
               0  "  Blake Walters and Mark Holmes added the CT reading ability. Dave Rogers    "
               0  "  cleaned up code (and added errors?) in 1997.                               "
               0  "                                                                             "
               0  "  DOSXYZnrc was created from DOSXYZ by Blake Walters in 2001                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80         "80 column mortran input"                                         ;
               0  !INDENT M 4; "Indent 4 spaces for each nesting level in mortran listing file"
               0  !INDENT F 4; "Indent 4 spaces for each nesting level in fortran output file"
               0  %Q1          "Automatically close quotes at end of the line"                   ;
               0
               0  "The next line is 80 characters long, use it to set up the screen width
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  ;
               0  "*******************************************************************************
               0  "
               0  "            *********************************************
               0  "            *                                           *
               0  "            * dosxyznrc.mortran                         *
               0  "            *                                           *
               0  "            *********************************************
               0  "
               0  "   A general purpose EGSnrc user code to do cartesian coordinate dose
               0  "   deposition studies. Every voxel (volume element) can have different
               0  "   materials and/or varying densities (for use with CT data).
               0  "
               0  "   The geometry is a rectilinear volume with a right-handed coordinate system:
               0  "   the X-Y plane on the page, X to the right, Y down and the
               0  "   Z-axis into the page. Voxel dimensions are completely variable in
               0  "   all three directions. For more detail on geometry see subroutine HOWFAR
               0
               0  "  Unit Assignments                                           ""toc:
               0  "  ================
               0  "
               0  "     Unit 1   Output summary and results
               0  "     Unit 2   .egsrns file for storing random numbers
               0  "     Unit 3   output .3ddose file containing dose arrays
               0  "     Unit 4   Raw data output file for restarts
               0  "     Unit 5   Input stream - file or terminal
               0  "     Unit 6   prompts for and echoes input
               0  "     Unit 8   echoes input cross-section data (usually assigned to a null file)
               0  "     Unit 17  geometry output file for EGS_Windows
               0  "     Unit 13  phase space output file for EGS_Windows
               0  "     Unit 12  Input cross section file from PEGS4
               0  "     Unit 15  Output of EGSnrc input error messages
               0  "     Unit 16  Output for .pardose when IPARALLEL > 1
               0  "     Unit 44  Full phase-space data set, such as output from BEAM
               0  "     $CTUnitNumber (normally 45)  CT data set input
               0  "
               0  "   DESCRIPTION OF INPUT FILE (on unit 5)                         ""toc:
               0  "   =========================
               0  "
               0  "  Record 1   TITLE     Up to 80 characters
               0  "
               0  "  Record 2   NMED      Number of media in problem - defaults to 1
               0  "             If (NMED=0) then create dosxyznrc phantom from binary CT data
               0  "
               0  "----------------------------------------------------------------------------
               0  "----------if NMED > 0  => non-CT data input---------------------------------
               0  "----------------------------------------------------------------------------
               0  "
               0  "  Record 3(NMED times) Media names, left justified. Note that
               0  "                       entire volume is initially set to medium 1
               0  "
               0  "  Record 4  ECUTIN,PCUTIN,ESTEPM(i,i=1,NMED),SMAX
               0  "                ECUTIN,PCUTIN: Electron (total) and photon global cutoff
               0  "                      energies in MeV.  If ECUTIN > ECUT input in EGSnrc
               0  "                      parameters (See below), then ECUTIN is used.  The
               0  "                      same is true if PCUTIN > PCUT input in EGSnrc parameters.
               0  "                      ECUT and PCUT default to AE and AP, respectively.
               0  "                ESTEPM(i,i=1,NMED): Dummy input (used to be estepe, max. energy
               0  "                      loss/electron step in each medium)
               0  "                SMAX: Dummy input (used to be max. step length)
               0  "
               0  "                ESTEPE and SMAX are now handled in EGSnrc inputs (See below),
               0  "                but the dummy inputs are retained for compatibility with
               0  "                EGS4/DOSXYZ input files.
               0  "
               0  "  Record 5   IMAX,JMAX,KMAX,IPHANT (4i10)
               0  "                IMAX,JMAX,KMAX: Number of voxels in the X,Y,Z directions
               0  "                       If < 0, it means that (-n) sets of equally spaced
               0  "                       boundaries will be input for that direction.
               0  "                IPHANT: set to 1 to output a .egsphant file for displaying
               0  "                       non-CT isodose contours using dosxyz_show
               0  "
               0  "  Record 6 et seq,     repeated for x, y and z directions separately
               0  "                       i.e. repeat the following replacing (i and x) by
               0  "                       (j and y) and (k and z) respectively
               0  "    if IMAX > 0
               0  "               input, one per record, the IMAX+1 x boundaries
               0  "
               0  "    if IMAX < 0
               0  "               input smallest x boundary, followed by  abs(IMAX) pairs
               0  "               one pair/record:
               0  "               voxel width, # voxels with this width
               0  "
               0  "    For example, starting at record 5:
               0  "              -1,-1,-1
               0  "              0.0
               0  "              1.0,16
               0  "              0.0
               0  "              1.0,16
               0  "              0.0
               0  "              1.0,16
               0  "       defines a 16x16x16 cm cube of 1cm**3 voxels with a total of 4097 regions
               0  "    Or:
               0  "              -1,-1,2
               0  "              0.0
               0  "              1.0,16
               0  "              0.0
               0  "              1.0,16
               0  "              0.0
               0  "              5.0
               0  "              10.0
               0  "       defines a 16x16x10 cm cube with 1x1x5 cm voxels stacked 2 deep
               0  "
               0  "   Record 7 et seq
               0  "             IL,IU, JL,JU, KL,KU, MEDIUM, DENSITY (7i10,f10.0)
               0  "             This record is repeated until a blank record is found.
               0  "             All regions default to medium 1 with its default density
               0  "             unless changed here.
               0  "             For all voxels with
               0  "                       IL <= i <= IU
               0  "                       JL <= j <= JU
               0  "                       KL <= k <= KU
               0  "             the medium and density are defined.
               0  "             If DENSITY=0.0, the default value for that
               0  "             MEDIUM is used (faster than entering default density here).
               0  "             If IU and IL are non-zero, the rest default to all j,k
               0  "
               0  "   Record 8 et seq
               0  "             IL,IU, JL,JU, KL,KU, ECUTL, PCUTL (6i10,2f10.0)
               0  "             This record is repeated until a blank record is found.
               0  "             As above but allowing a region by region local definition
               0  "             of ECUT and PCUT.
               0  "             All regions default to the global values defined in
               0  "             record 4 unless changed here.
               0  "             Note, this option disabled, but must enter blank record
               0  "             for compatibility. Note old code is in place.
               0  "
               0  "   Record 9 et seq
               0  "             IL,IU, JL,JU, KL,KU,IZSCAN,MAX20
               0  "             This record is repeated until a blank record is found.
               0  "             As above except these are the regions for which the
               0  "             dose will be printed in .egslst - beware of a paper explosion!
               0  "             The default is to print nothing unless asked for here.
               0  "             IZSCAN is non-zero to get a z-scan per page, otherwise
               0  "             output is an x-scan per page.  If the input parameter
               0  "             MAX20 is equal to 1 on any of these input lines, a
               0  "             summary of the 20 highest doses is included in the output.
               0  "
               0  ;
               0  "----------------------------------------------------------------------------
               0  "---------------if NMED = 0  input for a CT phantom ---------------------------
               0  "----------------------------------------------------------------------------
               0
               0  "   Record 3  PhantFileName (A256)  : The full name of the file containing
               0  "                                     the CT phantom as output by ctcreate
               0  "                                     (should be a .egsphant file).
               0  "
               0  "   Record 4  ECUTIN,PCUTIN,SMAX (3F15.0)
               0  "                ECUTIN,PCUTIN: Electron (total) and photon global cutoff
               0  "                       energies in MeV.  If ECUTIN > ECUT input in EGSnrc
               0  "                       parameters (See below), then ECUTIN is used as the
               0  "                       global ECUT.  The same is true if PCUTIN > PCUT input
               0  "                       in EGSnrc parameters.  ECUT and PCUT default to AE and
               0  "                       AP, respectively.
               0  "                SMAX: Dummy input (used to be max. step length)
               0  "
               0  "                SMAX is now handled in EGSnrc inputs (See below),
               0  "                but the dummy input is retained for compatibility with
               0  "                EGS4/DOSXYZ input files.
               0  "
               0  "   Record 5  zeroairdose,doseprint,MAX20 (3I5)
               0  "
               0  "             zeroairdose: = 1 to zero the dose in air (any
               0  "                            material with density < 0.044 g/cm^3)
               0  "                            in the .3ddose file
               0  "                          = 0(default) to not zero the dose in air
               0  "               doseprint: = 1 for output of all doses to
               0  "                            .egslst file
               0  "                          = 0(default) to suppress this output
               0  "                   MAX20: = 1 to print out summary of 20 highest
               0  "                            doses
               0  "                          = 0(default) no summary of these doses
               0  ;
               0  "----------------------------------------------------------------------------
               0  "---------------From here on the two formats are identical.------------------
               0  "----------------------------------------------------------------------------
               0  "
               0  "   Records 10--12 (6--8 if NMED=0) Refer to srcxyznrc.mortran
               0  "
               0  "   Record 13 (9 if NMED=0)
               0  "            NCASE, IWATCH, TIMMAX, INSEED1, INSEED2,
               0  "       BEAM_SIZE, ISMOOTH,IRESTART,IDAT,IREJECT,ESAVE_GLOBAL,NRCYCL,IPARALLEL,
               0  "       PARNUM,n_split,ihowfarless,i_phsp_out,i_bindos
               0  "
               0  "            NCASE     Number of histories
               0  "            IWATCH    0=>no tracking output, 1=>list every interaction
               0  "                      2=>list every electron step 4=>EGS_Windows output
               0  "                      IWATCH is for debugging/watching what is happening
               0  "                      It MUST be ZERO for production runs
               0  "            TIMMAX    Not used currently but prints warning: default 1 hour
               0  "            INSEED1&2 Starting random number seeds (0 is ok)
               0  "                      Note that, if using the RANLUX random no.
               0  "                      generator, INSEED1 is the luxury level and should
               0  "                      have a value >0 and <=4.  Otherwise, a default
               0  "                      luxury level of 1 will be used.
               0  "            BEAM_SIZE Beam size for a square field for the dose calculation
               0  "                      This parameter is only used by sources 2,3 and 4
               0  "                      (default to 100 cm for a 100x100 cm square field)
               0  "            ISMOOTH   =1 re-distribute particles when re-start a ph-sp file
               0  "                       and/or recycle an individual particle
               0  "                      =0 re-use the ph-sp data once run out (no redistribution)
               0  "            IRESTART  = 0 first run for this data set (the default)
               0  "                      = 1 restart of a previous run
               0  "                      = 2 just create the input file and exit
               0  "                      = 3 just read in the raw data and do the statistical
               0  "                          analysis
               0  "                      = 4 recombine .pardose files from parallel runs
               0  "            IDAT      = 0 output intermediate files for restarts
               0  "                      = 1 do not output intermediate data files at all
               0  "                      = 2 output the data file for restart at end only
               0  "            IREJECT   = 0 (default) do not perform charged particle range
               0  "                          rejection.
               0  "                      = 1 perform charged particle range rejection.  If
               0  "                          particle range to ECUTIN < distance to nearest voxel
               0  "                          boundary then terminate history if E <ESAVE_GLOBAL.
               0  "        ESAVE_GLOBAL  Energy (MeV) below which charged particle will be
               0  "                      considered for range rejection.
               0  "            NRCYCL    Number of times to recycle each particle in a phase space
               0  "                      source.  Each particle in the phase space
               0  "                      file is used a total of NRCYCL+1 times (provided the
               0  "                      particle has the correct charge and latch value) before
               0  "                      going on to the next particle.
               0  "                      If NRCYCL is set <=0 then NRCYCL is automatically
               0  "                      calculated to use the entire phase space file with no
               0  "                      restarts, unless the incident charge is +1 (positron) or
               0  "                      the user filters incident particles based on their LATCH
               0  "                      values (enflag=3), in which case NRCYCL is set to 0.
               0  "                      The calculated NRCYCL does not take into account
               0  "                      particles that are rejected because they miss the
               0  "                      geometry or because they are beyond the beam field
               0  "                      being considered (defined by BEAM_SIZE)
               0  "                      If NRCYCL is set > 0, then the user-input value is used.
               0  "                      If NCASE > no. of particles in the phase space file,
               0  "                      then use of NRCYCL is essential for accurate statistics.
               0  "                      If you are unsure of how many times to recycle, use
               0  "                      the automatically-calculated value of NRCYCL.  If this
               0  "                      still results in many restarts (because of many
               0  "                      particles missing the geometry or beyond beam field),
               0  "                      then re-run the simulation with NRCYCL set manually to:
               0  "           NCASE/(NPHSP - NSMISS/NRCYCL_prev - NOUTSIDE - NRJCT - NDBSRJCT)-1
               0  "                      where NPHSP is the no. of particles of interest in the
               0  "                      the ph-sp file (ie total no. of particle, no. of photons,
               0  "                      no. of electrons), NSMISS is the no. of particles that
               0  "                      missed the geometry in the previous run, NRCYCL_prev is
               0  "                      the value of NRCYCL used in the previous run,
               0  "                      NOUTSIDE is the no. of particles rejected because they
               0  "                      were beyond BEAM_SIZE in the previous run, NRJCT
               0  "                      is the no. of particles rejected because they were
               0  "                      multiple passers, and NDBSRJCT is the number of photons
               0  "                      rejected because they fall outside the directional
               0  "                      bremsstrahlung splitting (DBS) field radius at the SSD
               0  "                      (see inputs for source 2,8 for more info on rejecting
               0  "                      fat photons when DBS is used in BEAM to generate phase
               0  "                      space files). All of the aforementioned values are
               0  "                      available in the .egslst file.  Always round your
               0  "                      calculated value of NRCYCL up.
               0  "
               0  "   Note: the following 2 inputs are only relevant if you are manually
               0  "         creating/submitting your parallel jobs or if you are using the
               0  "         unix pprocess script.  In the case of the pprocess script, these
               0  "         inputs get set automatically.
               0  "
               0  "          IPARALLEL   set >1 if you are distributing the job among IPARALLEL
               0  "                      machines.  This will generate
               0  "                      a binary .pardose file for each job which will contain
               0  "                      the doses in all voxels WITHOUT UNCERTAINTIES.  IPARALLEL
               0  "                      defaults to 0.
               0  "            PARNUM    Only needs to be set if IPARALLEL>1 and you are using
               0  "                      a single phase space source.  The partition of the phase
               0  "                      space source that will be used for this one of the
               0  "                      series of parallel input files (for the same total
               0  "                      simulation) is given by:
               0  "                       (PARNUM-1)*(nshist/IPARALLEL)<nnphsp<=
               0  "                                                (PARNUM)*(nshist/IPARALLEL)
               0  "                      where nshist is the total number of particles in the
               0  "                      phase space file and nnphsp is the number of the
               0  "                      particle chosen for the simulation.  Thus, PARNUM
               0  "                      should cover the range 1<=PARNUM<=IPARALLEL.  If you
               0  "                      are using a separate phase space source for each
               0  "                      parallel job (ie the phase space source exists in
               0  "                      IPARALLEL pieces) and, thus, do not wish to partition
               0  "                      the phase space sources, PARNUM can be left at its
               0  "                      default value of 0.
               0  "
               0  "            n_split   If set > 1, then all photons will be split
               0  "                      n_split times.  This option increases the efficiency of
               0  "                      dose caluclations more than photon forcing.
               0  "                      A rule of thumb for good efficiency is
               0  "                         n_split >= No/(1-exp(-Lambda))
               0  "                      where Lambda is the approx. number of photon MFP
               0  "                      in the geometry of interest and No >= 5.
               0  "                      Note that if you use the above, there will
               0  "                      be on average approx. No primary interactions per
               0  "                      incident photon => reduce the number of
               0  "                      histories by this number.
               0  "
               0  "        The n_split algorithm works as follows:
               0  "         * dpmfp_i = -log(1 - (eta+i-1)/n_split)
               0  "           where dpmfp_i is MFP to the next interaction for the i-th sub-photon
               0  "           (i=1,2,...n_split)
               0  "           eta is a random number (the same for all n_split sub-photons)
               0  "         * Once at the interaction site, the i'th sub-photon produces
               0  "           electrons and/or scattered photons. Scattered photons are
               0  "           killed with probability 1/n_split, so that, if they survive,
               0  "           they have the weight of the original photon. Electrons have the
               0  "           weight of 1/n_split of original weight.
               0  "         * In any radiative events (brems, annih, annih at rest), photons
               0  "           are killed with probability 1/n_split => they have again the
               0  "           weight of the photon that initiated the history, if they survive
               0  "
               0  "        ihowfarless   Set to 1 to use the 'HOWFARLESS' algorithm for
               0  "                      transport in a homogeneous phantom.  When 'HOWFARLESS'
               0  "                      is used, subroutines HOWFAR and HOWNEAR only consider
               0  "                      the extreme outer boundaries of the phantom when
               0  "                      calculating the distance along the particle trajectory
               0  "                      or nearest perpendicular distance to a region boundary.
               0  "                      This removes the restriction that charged particle
               0  "                      steps must stop at all voxel boundaries and, thus,
               0  "                      speeds up the calculation considerably.  For the purpose
               0  "                      of dose deposition in the voxels, the total curved
               0  "                      charged particle step is approximated using 2 straight-
               0  "                      line steps joined at a hinge point.  See the DOSXYZnrc
               0  "                      manual for more details about the approximation.
               0  "                      Restrictions on charged particle step length then become
               0  "                      the EGSnrc input variables Smax (max. allowable charged
               0  "                      particle step length) and estepe (max. fractional energy
               0  "                      loss/step).  Leaving Smax set to its default value
               0  "                      of 5 cm should maximize efficiency of the 'HOWFARLESS'
               0  "                      algorithm at most beam energies.  Efficiency improvement
               0  "                      due to 'HOWFARLESS' depends on the incident beam type,
               0  "                      DOSXYZnrc voxel size and the boundary crossing algorithm
               0  "                      (BCA) used.  For incident photon beams from accelerators
               0  "                      simulated with BEAMnrc (phase space or BEAMnrc sim.
               0  "                      sources), the efficiency improves by ~30%
               0  "                      when the PRESTA-I BCA is used, and by factors of
               0  "                      2.5-3.5 when the more accurate (but slower) EXACT
               0  "                      BCA is used.  In monoenergetic electron beams,
               0  "                      'HOWFARLESS' improves efficiency by a factor of up to
               0  "                      ~4 with the PRESTA-I BCA and by a factor of up to
               0  "                      ~15 with the EXACT BCA.  Recommended for all homogeneous
               0  "                      phantom calculations, but it must NOT be used in
               0  "                      nonhomogeneous phantoms.
               0  "
               0  "         i_phsp_out   For outputting IAEA format phase space data on exit
               0  "                      from the phantom geometry.  If i_phsp_out=1, then data
               0  "                      is output in DOSXYZnrc coordinates.  If i_phsp_out=2
               0  "                      data is output in BEAMnrc coordinates.  This option is
               0  "                      only available for phase space or BEAM simulation
               0  "                      sources (which have a region surrounding the phantom).
               0  "                      The default is i_phsp_out=0--no phase space
               0  "                      output.  If you are using source 20 or source 21
               0  "                      (synchronized sources) then you also have the option of
               0  "                      storing frMU_indx in the file (see source inputs).
               0  "
               0  "          i_bindos    For outputting sparse binary dose data instead of the
               0  "                      dense ASCII .3ddose format. If i_bindos=0, then the
               0  "                      dose will be output in .3ddose format. Any other value
               0  "                      will output a .bindos file instead.
               0  "
               0  "----------------------------------------------------------------------------
               0  "----------------------------------------------------------------------------
               0  "                          EGSnrc INPUTS
               0  "                          *************
               0  "    (modified from the description in $HEN_HOUSE/get_inputs.mortran)
               0  "
               0  "  All input associated with selection of EGSnrc transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  Currently, the following options are available (case does not matter and
               0  "             the internal variables are shown in [ ] brackets):
               0  "
               0  "       Global ECUT=     Global (in all regions) electron transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        or is < ECUTIN from the main DOSXYZnrc inputs
               0  "                        (See above) then ECUTIN is used for global ECUT.
               0  "                        ECUT defaults to AE(medium).
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Global (in all regions) photon transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        or is < PCUTIN from the main DOSXYZnrc inputs
               0  "                        (See above) then PCUTIN is used for global PCUT.
               0  "                        PCUT defaults to AP(medium).
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        No SMAX restriction is necessary if the electron
               0  "                        step algorithm is PRESTA-II and the EXACT boundary
               0  "                        crossing algorithm is used.  In this case, SMAX
               0  "                        will default to 1e10.  However, if either
               0  "                         Electron-step algorithm= PRESTA-I
               0  "                         or
               0  "                         Boundary crossing algorithm= PRESTA-I (the default),
               0  "                        then a step-size restriction is necessary, and
               0  "                        SMAX will default to 5 cm.
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%).
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT and
               0  "                        PRESTA-I.  PRESTA-I means that boundaries will
               0  "                        be crossed a la PRESTA.  That is, with lateral
               0  "                        correlations turned off at a distance given by
               0  "                        `Skin depth for BCA' (see below) from the boundary
               0  "                        and MS forced at the boundary.  EXACT means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by `Skin depth for BCA' (see below).
               0  "                        Default is PRESTA-I for efficiency reasons. This
               0  "                        is known not to be exactly correct, and when charged
               0  "                        particle equilibrium does not hold or when there is
               0  "                        a large difference in size between dose voxels and
               0  "                        voxels making up the rest of the phantom, can result
               0  "                        in an overestimate of dose by up to 2.5%.  In such
               0  "                        cases, swich to EXACT BCA.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        If Boundary crossing algorithm= PRESTA-I (default)
               0  "                        then this is the distance from the boundary (in
               0  "                        elastic MFP) at which lateral correlations will be
               0  "                        switched off.  The default in this case is to
               0  "                        calculate a value based on the scattering power at
               0  "                        ECUT (same as PRESTA in EGS4).  If
               0  "                        Boundary crossing algorithm= EXACT then this is
               0  "                        the distance from the boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode and defaults to 3 mfp.
               0  "                        Note that if you choose EXACT boundary crossing and
               0  "                        set Skin depth for BCA to a very large number (e.g.
               0  "                        1e10), the entire calculation will be in SS mode.
               0  "                        If you choose PRESTA-I boundary crossing and make
               0  "                        Skin depth for BCA large, you will get default EGS4
               0  "                        behaviour (no PRESTA).
               0  "                        [ skindepth_for_bca ]
               0  "
               0  "            Note that the above defaults have been choosen as a compromise
               0  "            between accuracy (EXACT BCA) and efficiency (PRESTA-I BCA)
               0  "            since the PRESTA-I BCA algorithm has proven to generally
               0  "            produce satisfactory results.  Note that the new transport
               0  "            mechanics of EGSnrc are maintained away from boundaries and
               0  "            that one always has the option of verifying the accuracy
               0  "            by doing a long run with the EXACT BCA.
               0  "
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        difference even in `well conditioned' situations
               0  "                        (e.g. depth dose curves for RTP energy range
               0  "                        electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is Simple
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If KM, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low
               0  "                        energies, makes 2BS almost the same as 2BN at low
               0  "                        energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, NRC, default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but signifficant in the keV energy range.  If NRC is
               0  "                        selected, NIST data including corrections for
               0  "                        electron-electron brems will be used (typically only
               0  "                        significant for low values of the atomic number Z
               0  "                        and for k/T < 0.005).
               0  "       Bound Compton scattering=  On, Off or Norej (Default is On)
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impulse approximation.
               0  "                        Make sure to turn on for low energy applications,
               0  "                        not necessary above, say, 1 MeV.  Option Norej
               0  "                        uses full bound Compton cross section data
               0  "                        supplied in input below and does not reject
               0  "                        interactions.
               0  "                        [ IBCMP ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Radiative Compton corrections= On or Off (default). If on, then
               0  "                        include radiative corrections for Compton scattering.
               0  "                        Equations are based on original Brown & Feynman
               0  "                        equations (Phys. Rev. 85, p 231--1952).  Requires
               0  "                        a change to the user codes Makefile to include
               0  "                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
               0  "                        SOURCES (just before
               0  "                        $(EGS_SOURCEDIR)get_inputs.mortran).
               0  "                        [ radc_flag ]
               0  "       Pair angular sampling= Off, Simple or KM
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.
               0  "                        Default is Simple, make sure you always use
               0  "                        Simple or KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is Off
               0  "                        [ IPHTER ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turned on coherent (Rayleigh) scattering.
               0  "                        Default is Off. Should be turned on for low energy
               0  "                        applications. Not set to On by default because
               0  "                        On requires a special PEGS4 data set.  If set to
               0  "                        custom, then media for which custom form factors
               0  "                        are to be specified are listed in the input:
               0  "                        ff media names=
               0  "                        and the corresponding files containing custom data
               0  "                        are listed in:
               0  "                        ff file names=
               0  "                        [ IRAYLR ]
               0  "       Atomic relaxations= Off, On
               0  "                        Default is Off. The effect of using On is twofold:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the
               0  "                          appropriate cross seections
               0  "                        - Shell vacancies created in photo-absorption events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         Make sure to turn this option on for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "       Electron impact ionization= Off, On, Casnati, Kolbenstvedt, Gryzinski
               0  "                                   (Default is Off)
               0  "                         Determines which, if any, theory is used to model
               0  "                         electron impact ionization.  If set to 'On' then the
               0  "                         theory of Kawrakow is used.  Other settings use the
               0  "                         theory associated with the name given.  See future
               0  "                         editions of the EGSnrc Manual (PIRS-701) for more
               0  "                         details.  This is only of interest in keV X-Ray
               0  "                         simulations.  Otherwise, leave it Off.
               0  "                         [ eii_flag ]
               0  "       Photon cross sections= epdl, xcom, customized (Default is Storm-Israel
               0  "                         cross-sections from PEGS4)
               0  "                         The name of the cross-section data for photon
               0  "                         interactions.  This input line must be left out
               0  "                         to access the default Storm-Israel cross-sections
               0  "                         from PEGS4.  'edpl' uses cross-sections from the
               0  "                         evaluated photon data library (EPDL) from Lawrence
               0  "                         Livermore.  'xcom' will use the XCOM cross-sections
               0  "                         from Burger and Hubbell.  The user also has the
               0  "                         option of using their own customized cross-section
               0  "                         data.  See the BEAMnrc manual for more details.
               0  "                         [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "                         can also be turned On/Off on a region-by-region
               0  "                         basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  ;
               0
               0  "Step 1  User overrides and declarations                       ""toc:
               0  "=======================================
               0
               0  "There are macros defined in dosxyz_user_macros.mortran which user "
               0  "may wish to adjust"
               0
               0  "  Start of macro definitions                   ""toc:
               0
               0  "the following calculates BLCMIN on the fly if using PRESTA-I as the"
               0  "BCA--can save a lot of time, overrides macro of the same name in egsnrc.macros"
               0  "This macro commented out since it was found to cause real differences"
               0  "between dosxyznrc and dosxyz in e- depth-dose calculations.  We now default"
               0  "to use PRESTA-I BCA with fixed BLCMIN"
               0  "REPLACE {$SET-SKINDEPTH(#,#);} WITH {;"
               0
               0  "IF( exact_bca ) ["
               0  "      $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});"
               0  "      skindepth = skindepth_for_bca*ssmfp;"
               0  "]"
               0  "ELSE ["
               0  "      p2 = {P1}*({P1}+rmt2); beta2 = p2/(p2 + rmsq);"
               0  "      xccl = xcc(medium); blccl = blcc(medium); chia2 = xccl/(4*blccl*p2);"
               0  "      skindepth ="
               0  "         skindepth_for_bca*2*p2*beta2/xccl/(log(1+1./chia2)*(1+chia2)-1);"
               0  "      IF( skindepth > 5 ) skindepth = 5;"
               0  "]"
               0  "};"
               0
               0  "The following macros used to be in machine.mortran"
               0  REPLACE {$DECLARE_COMMON_TIMING_VARIABLES;} WITH {;
            {  0  character timen*8, daten*11, dntime*24;
            {  0  };
               0  REPLACE {$DATEN_FORMAT} WITH {A};
               0  REPLACE {$TIMEN_FORMAT} WITH {A};
               0
               0  "Macro to replace $SELECT-PHOTON-MFP in egsnrc.macros"
               0  "This is a modified version of this macro found in cavrznrc.mortran"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {;
            {  0
            {  0  IF( n_split > 1 ) [  "we use photon splitting"
            {  0
            {  0  :START-MFP-LOOP:;
            {  0
            {  0  $RANDOMSET RNNO35;
            {  0  rnno35 = rnno35/n_split;
            {  0  d_eta = 1./n_split;
            {  0  x_save = x(np); y_save = y(np); z_save = z(np);
            {  0  u_save = u(np); v_save = v(np); w_save = w(np);
            {  0  e_save = e(np); wt_save = wt(np)/n_split; ir_save = ir(np);
            {  0  latch_save = latch(np);
            {  0  np = np-1;
            {  0
            {  0  $RANDOMSET xxx; a_survive = xxx*n_split;
            {  0  i_survive_s = 1 + a_survive;
            {  0
            {  0  dpmfp_old = 0;
            {  0  eta_prime = 1 - rnno35 + d_eta;
            {  0  IF(IWATCH ~=0 & IWATCH~=4)["output a message about splitting"
            {  0  OUTPUT n_split,wt_save;
            {  0  (' Splitting photon into ',I4,' photons with weight ',1PE10.3);
            {  0  ]
            {  0  DO i_split = 1,n_split [
            {  0  eta_prime = eta_prime - d_eta;
            {  0  IF(eta_prime <= 0 ) goto :END-MFP-LOOP:;
            {  0  dpmfp = -log(eta_prime) - dpmfp_old;
            {  0  dpmfp_old = dpmfp_old + dpmfp;
            {  0  np = np+1;
            {  0  IF( np > $MXSTACK ) [
            {  0  write(6,*) ' Stack overflow in $SELECT-PHOTON-MFP ';
            {  0  stop;
            {  0  ]
            {  0  x(np) = x_save; y(np) = y_save; z(np) = z_save;
            {  0  u(np) = u_save; v(np) = v_save; w(np) = w_save;
            {  0  wt(np) = wt_save; e(np) = e_save; iq(np) = 0; ir(np) = ir_save;
            {  0  latch(np) = latch_save;
            {  0  irl = ir(np); irold = irl; medium = med(irl);
            {  0  LOOP [
            {  0  IF( medium ~= 0 ) [
            {  0  $SET INTERVAL GLE,GE;
            {  0  $EVALUATE GMFPR0 USING GMFP(GLE);
            {  0  $SET-RHOF;
            {  0  GMFP=GMFPR0/RHOF;
            {  0  $RAYLEIGH-CORRECTION;
            {  0  TSTEP=GMFP*DPMFP;
            {  0  ]
            {  0  ELSE [ TSTEP=VACDST; ]
            {  0  irnew = irl; idisc = 0; ustep = tstep; tustep = ustep;
            {  0  call howfar;
            {  0  VSTEP=USTEP;
            {  0  TVSTEP=VSTEP;
            {  0  EDEP=PZERO;
            {  0  IF (IWATCH>0) CALL WATCH($TRANAUSB,IWATCH);
            {  0  x(np) = x(np) + u(np)*ustep;
            {  0  y(np) = y(np) + v(np)*ustep;
            {  0  z(np) = z(np) + w(np)*ustep;
            {  0  IF( idisc > 0 ) [
            {  0  IF (IWATCH>0) CALL WATCH($USERDAUS,IWATCH);
            {  0  np = np-1;
            {  0  IF( np = 0 ) [
            {  0  ircode = 2; return;
            {  0  ]
            {  0  goto :END-MFP-LOOP:;
            {  0  ]
            {  0  IF( medium ~= 0 ) dpmfp = dpmfp - ustep/gmfp;
            {  0  IF( irnew ~= irold ) [
            {  0  ir(np) = irnew; irl = irnew;
            {  0  medium = med(irl);
            {  0  ]
            {  0  $AUSCALL($TRANAUSA);
            {  0  irold = ir(np);
            {  0  IF (IWATCH>0) CALL WATCH($TRANAUSA,IWATCH);
            {  0  ] UNTIL (medium ~= 0 & dpmfp < $EPSGMFP);
            {  0  x_save = x(np); y_save = y(np); z_save = z(np);
            {  0  ir_save = ir(np);
            {  0  IF(IRAYLR(IRL).EQ.1) [
            {  0  $RANDOMSET RNNO37;
            {  0  IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0  IF( i_split ~= i_survive_s ) [
            {  0  np = np-1; goto :JUST-RAYLEIGH-EVENT:;
            {  0  ]
            {  0  IF (IWATCH>0) CALL WATCH($RAYLAUSB,IWATCH);
            {  0  $AUSCALL($RAYLAUSB);"for howfarless version"
            {  0  wt(np) = wt(np)*n_split;
            {  0  :RAYLEIGH-SAMPLING-LOOP: LOOP [
            {  0  $RANDOMSET XXX;
            {  0  $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0  Q2=X2*RMSQ/(20.60744*20.60744);
            {  0  COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0  IF (ABS(COSTHE).GT.1.0) GO TO :RAYLEIGH-SAMPLING-LOOP:;
            {  0  CSQTHE=COSTHE*COSTHE;
            {  0  REJF=(1.0+CSQTHE)/2.0;
            {  0  $RANDOMSET RNNORJ;
            {  0  ] UNTIL (RNNORJ <= REJF);
            {  0  SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0  IF (IWATCH>0) CALL WATCH($RAYLAUSA,IWATCH);
            {  0  goto :JUST-RAYLEIGH-EVENT:;
            {  0  ]
            {  0  ]
            {  0  $RANDOMSET RNNO36;
            {  0  $EVALUATE GBR1 USING GBR1(GLE);
            {  0  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )[
            {  0  IF (IWATCH>0) CALL WATCH($PAIRAUSB,IWATCH);
            {  0  $AUSCALL($PAIRAUSB); "for howfarless option"
            {  0  call pair;
            {  0  IF (IWATCH>0) CALL WATCH($PAIRAUSA,IWATCH);
            {  0  ]
            {  0  ELSE [
            {  0  $EVALUATE GBR2 USING GBR2(GLE);
            {  0  IF (RNNO36.LT.GBR2) [
            {  0  IF (IWATCH>0) CALL WATCH($COMPAUSB,IWATCH);
            {  0  $AUSCALL($COMPAUSB); "for howfarless option"
            {  0  call compt;
            {  0  IF (IWATCH>0) CALL WATCH($COMPAUSA,IWATCH);
            {  0  ]
            {  0  ELSE [
            {  0  IF (IWATCH>0) CALL WATCH($PHOTOAUSB,IWATCH);
            {  0  $AUSCALL($PHOTOAUSB); "for howfarless option"
            {  0  call photo;
            {  0  IF (IWATCH>0) CALL WATCH($PHOTOAUSA,IWATCH);
            {  0  ]
            {  0  ]
            {  0
            {  0  "Kill scattered photons with probability 1/nsplit"
            {  0  "surviving photon carries the weight of the original photon"
            {  0  ip = NPold;
            {  0  LOOP [
            {  0  IF( iq(ip) = 0 ) [
            {  0  IF( i_split ~= i_survive_s ) [
            {  0  IF( ip < np ) [
            {  0  IF(IWATCH~=0 & IWATCH~=4)[
            {  0  OUTPUT ip,e(ip),iq(ip),ir(ip),x(ip),y(ip),
            {  0  z(ip),u(ip),v(ip),w(ip),latch(ip),wt(ip);
            {  0  (' Eliminating scattered photon',T36,':',
            {  0  I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            {  0  ]
            {  0  e(ip) = e(np); iq(ip) = iq(np);
            {  0  u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0  wt(ip) = wt(np); latch(ip) = latch(np);
            {  0  ]
            {  0  np = np-1;
            {  0  ]
            {  0  ELSE [
            {  0  wt(ip) = wt(ip)*n_split; ip = ip+1;
            {  0  ]
            {  0  ]
            {  0  ELSE [ "this is a charged particle, skip to the next particle"
            {  0  ip = ip+1;
            {  0  ]
            {  0  ] UNTIL (ip > np);
            {  0
            {  0  :JUST-RAYLEIGH-EVENT:
            {  0
            {  0  ]
            {  0  :END-MFP-LOOP:;
            {  0
            {  0  IF( np <= 0 ) [ ircode = 2; return; ]
            {  0  IF( iq(np) = 0 ) [
            {  0  "split it again if energy > PCUT"
            {  0  peig = e(np); eig = peig; irl = ir(np); medium = med(irl);
            {  0  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
            {  0  gle = log(eig);
            {  0  goto :START-MFP-LOOP:;
            {  0  ]
            {  0  return;
            {  0  ]
            {  0  ELSE[
            {  0  "just the regular $SELECT-PHOTON-MFP coding"
            {  0  $RANDOMSET RNNO35;
            {  0  IF(RNNO35 = 0.0)[RNNO35=1.E-30;]
            {  0  DPMFP=-LOG(RNNO35);
            {  0  ]
            {  0  }
               0
               0  " Range rejection macro:
               0  " **********************
               0  " DOSXYZnrc bypasses the EGSnrc built-in range rejection (implemented in
               0  " the $RANGE-DISCARD macro in EGSnrc) because EGSnrc range rejection
               0  " uses particle range to AE, while we want to use particle range to
               0  " ECUTIN.  In the macro below, DNEAR(NP) is the perpendicular distance from
               0  " the particle to the nearest region boundary, range is the particle range to
               0  " AE (calculated in EGSnrc) and RANGE_ECUTRR(MED(IRL)) is the range from ECUTIN
               0  " to AE in the medium in region IRL (calculated at the beginning of the
               0  " simulation).  Thus, range-RANGE_ECUTRR(MED(IRL)) is the particle range to
               0  " ECUTIN in region IRL, scaled for non-default density, and if
               0  " DNEAR is >= this, we can discard the particle.
               0  "
               0  " No range rejection is done in vacuum, if IREJECT=0, or if the particle energy
               0  " exceeds ESAVE_GLOBAL.
               0  "
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {
            {  0  "        ===================="
            {  0  ;
            {  0  IF( IREJECT = 1 & MED(IR(NP)) ~= 0 & E(NP) < ESAVE_GLOBAL &
            {  0  DNEAR(NP) >= range-RANGE_ECUTRR(MED(IR(NP)))*(RHO(MED(IR(NP)))/RHOR(IR(NP)))
            {  0  & (IR(NP)=irmax+1 | ~howfarless) )[
            {  0
            {  0  "Perform charged-particle range-rejection using ECUTIN"
            {  0  "range-RANGE_ECUTRR(MED(IR(NP)))*(RHO(MED(IR(NP)))/RHOR(IR(NP))) is the range"
            {  0  "to ECUTIN in region IR(NP), scaled for possible non-default densities"
            {  0
            {  0  IF(LELEC =  -1)[ IDISC=1;"electron" ] ELSE [IDISC=99;"positron"]
            {  0  GOTO :USER-ELECTRON-DISCARD:;
            {  0
            {  0  ]"end of perform range-rejection block"
            {  0  }
               0
               0  "macro below overrides that in egsnrc.macros.  It is identical with"
               0  "the exception of the check on (irl=irmax+1|~howfarless)"
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0  ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) & (irl=irmax+1|~howfarless))[
            {  0  IF(tperp >= range) ["particle cannot escape local region"
            {  0  idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0  go to :USER-ELECTRON-DISCARD: ;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  "macro below overrides that in egsnrc.macros.  It is identical with"
               0  "the exception of the return statement if IARG<0"
               0  REPLACE {$AUSCALL(#);} WITH
               0  {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]
            {  0  IF(IARG<0) RETURN;} ;
               0
               0  "the following change the defaults for the EGSnrc input parameters"
               0  "override the values in egsnrc.macros"
               0
               0  "Brems angular sampling= Simple"
               0  REPLACE {$IBRDST-DEFAULT} WITH {0}
               0  ;
               0
               0  "Rayleigh scattering= Off"
               0  REPLACE {$IRAYLR-DEFAULT} WITH {0}
               0  ;
               0
               0  "Bound Compton scattering= Off"
               0  REPLACE {$IBCMP-DEFAULT} WITH {0}
               0  ;
               0
               0  "Atomic relaxations= Off"
               0  REPLACE {$IEDGFL-DEFAULT} WITH {0}
               0  ;
               0
               0  "Photoelectron angular sampling= Off"
               0  REPLACE {$IPHTER-DEFAULT} WITH {0}
               0  ;
               0
               0  "Boundary crossing algorithm= PRESTA-I"
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {1}
               0  ;
               0
               0  "must agree with above"
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.false.}
               0  ;
               0
               0  "Macros to replace these large arrays to reduce static storage"
               0
               0  REPLACE {ECUT(#)}        WITH {ECUT} ;
               0  REPLACE {ecut(#)}        WITH {ECUT} ;
               0  REPLACE {ECUT/$MXREG}    WITH {ECUT/1} ;
               0  REPLACE {PCUT(#)}        WITH {PCUT} ;
               0  REPLACE {pcut(#)}        WITH {PCUT} ;
               0  REPLACE {PCUT/$MXREG}    WITH {PCUT/1} ;
               0  REPLACE {ESTEPR(#)}      WITH {ESTEPR} ;
               0  REPLACE {estepr(#)}      WITH {ESTEPR} ;
               0  REPLACE {ESTEPR/$MXREG}  WITH {ESTEPR/1};
               0  REPLACE {NOPLC(#)}       WITH {NOPLC} ;
               0  REPLACE {NOMSCT(#)}      WITH {NOMSCT} ;
               0  REPLACE {SMAXIR(#)}      WITH {SMAXIR} ;
               0  REPLACE {smaxir(#)}      WITH {SMAXIR} ;
               0  REPLACE {SMAXIR/$MXREG}  WITH {SMAXIR/1};
               0  REPLACE {ESAVE(#)}       WITH {ESAVE} ;
               0  REPLACE {IRAYLR(#)}      WITH {IRAYLR} ;
               0  REPLACE {iraylr(#)}      WITH {IRAYLR} ;
               0  REPLACE {IRAYLR/$MXREG}  WITH {IRAYLR/1} ;
               0  REPLACE {IEDGFL(#)}      WITH {IEDGFL} ;
               0  REPLACE {iedgfl(#)}      WITH {IEDGFL} ;
               0  REPLACE {IEDGFL/$MXREG}  WITH {IEDGFL/1} ;
               0  REPLACE {IPHTER(#)}      WITH {IPHTER} ;
               0  REPLACE {iphter(#)}      WITH {IPHTER} ;
               0  REPLACE {IPHTER/$MXREG} WITH {IPHTER /1} ;
               0  REPLACE {IBCMP(#)}      WITH {IBCMP} ;
               0  REPLACE {ibcmp(#)}      WITH {ibcmp} ;
               0  REPLACE {ibcmp/$MXREG} WITH {ibcmp /1} ;
               0  REPLACE {e_max_rr(#)} WITH {e_max_rr};
               0  REPLACE {e_max_rr/$MXREG} WITH {e_max_rr /1};
               0  REPLACE {i_do_rr(#)} WITH {i_do_rr};
               0  REPLACE {i_do_rr/$MXREG} WITH {i_do_rr /1};
               0
               0  "The geometry common is only system dependent when PRESTA is invoked
               0  REPLACE {;COMIN/GEOM/;} WITH {
            {  0  ; common/geom/
            {  0  xbound($IMAX+1),    "voxel x-boundaries                      "
            {  0  ybound($JMAX+1),    "voxel y-boundaries                      "
            {  0  zbound($KMAX+1),    "voxel z-boundaries                      "
            {  0  xbound_min,         "minimum x-boundary                      "
            {  0  xbound_max,         "maximum x-boundary                      "
            {  0  ybound_min,         "minimum y-boundary                      "
            {  0  ybound_max,         "maximum y-boundary                      "
            {  0  zbound_min,         "minimum z-boundary                      "
            {  0  zbound_max,         "maximum z-boundary                      "
            {  0  medsur,             "medium No for region outside the phantom "
            {  0  dsurround(4),       "medium thicknesses for region outside the phantom "
            {  0  IMAX,               "number of cells in x-direction          "
            {  0  JMAX,               "number of cells in y-direction          "
            {  0  KMAX,               "number of cells in z-direction          "
            {  0  ijmax,              "number of cells in x-y plane = IMAX*JMAX"
            {  0  irmax,              "number of regions = KMAX*ijmax + 1      "
            {  0  howfarless;         "set to .true. if DIST and DNEAR are only"
            {  0  "to use outer boundaries of the phantom."
            {  0  ".false. otherwise."
            {  0  "Type declarations"
            {  0  real*4  xbound, ybound, zbound, xbound_min, xbound_max, ybound_min,
            {  0  ybound_max, zbound_min, zbound_max,dsurround;
            {  0  integer medsur,IMAX, JMAX, KMAX, ijmax,irmax;
            {  0  logical howfarless;
            {  0  }
               0
               0  REPLACE {;COMIN/TIMEINFO/;} WITH {
            {  0  ; COMMON/TIMEINFO/
            {  0  TIMEN,      "stores current time"
            {  0  DATEN,      "stores current date"
            {  0  DNTIME;     "necessary for date and time routines"
            {  0  $DECLARE_COMMON_TIMING_VARIABLES;   "declared in machine.mortran"
            {  0  }
               0
               0  REPLACE {$CTUnitNumber} WITH {45} "assign a unit number for the CT data"
               0
               0  REPLACE {$MXDATA}       WITH {1}  "To get over nrccaux(p).mortran definition
               0  REPLACE {$NBATCH}       WITH {10} "Use 10 batches for restart features, etc.
               0  REPLACE {$MXDOS}        WITH {7}  "Max number of groups of regions to analyse
               0
               0  "Some macros for facilitating access to boundaries and regions
               0  "=============================================================
               0
               0  "Region number vs (i,j,k)
               0  REPLACE {$IR(#,#,#)} WITH {(1 + {P1} + ({P2}-1)*IMAX + ({P3}-1)*ijmax)}
               0
               0  "Dose region number vs (i,j,k)
               0  REPLACE {$IRD(#,#,#)} WITH {({P1} + ({P2}-1)*IMAX + ({P3}-1)*ijmax)}
               0
               0  "(i,j,k vs region number)
               0  REPLACE {;$DECODEIR(#,#,#,#);} WITH {
            {  0  "First parameter is input region, next 3 are decoded i,j,k"
            {  0  ;{P2}=mod({P1}-1,IMAX); IF({P2}=0) {P2}=IMAX;
            {  0  {P4} = 1 + ({P1}-1-{P2})/ijmax;
            {  0  {P3} = 1 + ( ({P1}-1-{P2}) - ({P4}-1)*ijmax)/IMAX;
            {  0  }
               0
               0  "Generalized output to units 6 and 1
               0  REPLACE {OUTPUT61#;#;} WITH {
            {  0  {SETR A =@LG}
            {  0  write(6,{COPY A}){P1};write(1,{COPY A}){P1};{COPY A}format{P2};
            {  0  }
               0  "Generalized output to unit 1
               0  REPLACE {OUTPUT1#;#;} WITH { {SETR A =@LG}
            {  0  write(1,{COPY A}){P1};{COPY A}format{P2};
            {  0  }
               0  "Generalized output to ioutgeom, used to be unit 17
               0  REPLACE {OUTPUT17#;#;} WITH { {SETR A =@LG}
            {  0  write(ioutgeom,{COPY A}){P1};{COPY A}format{P2};
            {  0  }
               0
               0  "replaces CALL-HOWNEAR with a call to the HOWNEAR subroutine"
               0  REPLACE {$CALL-HOWNEAR(#);} WITH {
            {  0  CALL HOWNEAR({P1},X(NP),Y(NP),Z(NP),IR(NP));
            {  0  }
               0
               0  REPLACE {;COMIN/SCORE/;} WITH {
            {  0  ;common/score/endep($MAXDOSE), endep2($MAXDOSE), temp2, planarefe,
            {  0  planarefp,planarfe,planarfp,
            {  0  nestep,
            {  0  endep_tmp($MAXDOSE),
            {  0  i_phsp_out,i_muidx_out,i_unit_out,IWATCH,mxnp,i_bindos,
            {  0  endep_last($MAXDOSE);
            {  0  REAL*8 endep, endep2, temp2,planarefe, planarefp, planarfe, planarfp;
            {  0  $LONG_INT nestep;
            {  0  real endep_tmp;
            {  0  integer i_phsp_out, "set to 1 or 2 to output phsp data to IAEA format"
            {  0  "phase space file"
            {  0  i_muidx_out, "set to 1 to include frMU_indx (fractional MU index)"
            {  0  "in phase space data (phsp or BEAM simulation source"
            {  0  "only)"
            {  0  i_unit_out, "unit no. for IAEA phsp output"
            {  0  i_bindos,   "set to 1 to output sparse binary file"
            {  0  IWATCH,mxnp;
            {  0  $SHORT_INT endep_last;
            {  0  }
               0  "V> endep(I) I=1,IMAX*JMAX*KMAX + 1,  +1 is for surrounding region
               0  "V>         note endep(I) is for geometric region I+1
               0
               0
               0  REPLACE {;COMIN/PHSPFILE/;} WITH {;
            {  0  COMMON/PHSPFILE/BEAM_SIZE,MODE_PHSP1,LATCH_OPT,
            {  0  NCASE_PHSP,LATBIT,NBIT1,NBIT2,I_BIT_FILTER,NofREPEAT,ISMOOTH,
            {  0  OUTCNT,NRCYCL,IPARALLEL,PARNUM,CYCLNUM;
            {  0  real BEAM_SIZE;
            {  0  INTEGER MODE_PHSP1,LATCH_OPT,NCASE_PHSP,LATBIT(20),NBIT1,NBIT2,
            {  0  I_BIT_FILTER,NofREPEAT,ISMOOTH,OUTCNT,NRCYCL,IPARALLEL,PARNUM,CYCLNUM;
            {  0  }
               0  ;
               0
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0  ;COMIN/USER-PHOTON-SPLITTING,USER-RANGE-REJECTION/;
            {  0  }
               0
               0  "V> COMMON/USER-PHOTON-SPLITTING/ Common used for photon splitting, included
               0  "V> ============================  in COMIN/USER/
               0  "V>
               0  "V>n_split = no. of times to split photons.  Splitting is only in effect
               0  "V>          if n_split > 1
               0
               0  REPLACE{;COMIN/USER-PHOTON-SPLITTING/;} WITH {
            {  0  ;COMMON/USERPS/n_split;
            {  0  $INTEGER n_split;
            {  0  }
               0
               0  "V> COMMON/USER-RANGE-REJECTION/ Common used for range rejection, included
               0  "V> ===========================  in COMIN/USER/
               0  "V>
               0  "V>IREJECT = 1 for range rejection, 0 otherwise
               0  "V>ESAVE_GLOBAL = global upper energy for range rejection
               0  "V>RANGE_ECUTRR(IMED) = range from ECUTIN to AE in medium IMED (not
               0  "V>                     scaled for non-default density)
               0
               0  REPLACE{;COMIN/USER-RANGE-REJECTION/;} WITH {
            {  0  ;COMMON/USERRR/ESAVE_GLOBAL,RANGE_ECUTRR($MXMED),IREJECT;
            {  0  $REAL ESAVE_GLOBAL,RANGE_ECUTRR;
            {  0  $INTEGER IREJECT;
            {  0  }
               0
               0  "Define variables used in the new version of $SELECT-PHOTON-MFP to"
               0  "allow the n_split option"
               0  APPEND
               0  {;
            {  0  $REAL    d_eta,eta_prime,dpmfp_old,
            {  0  x_save,y_save,z_save,u_save,v_save,w_save,
            {  0  e_save,wt_save,a_survive;
            {  0  $INTEGER ir_save,ip,i_split,latch_save,i_survive_s;
            {  0  ;} TO {$DEFINE-LOCAL-VARIABLES-PHOTON;}
               0  ;
               0
               0  APPEND {;COMIN/SCORE/;} TO {$COMIN-PHOTON;} "necessary for IWATCH"
               0  "output for n_split option"
               0
               0  APPEND {;COMIN/GEOM/;} TO {$COMIN-ELECTR;} "necessary to use range rejection"
               0  "with howfarless on"
               0
               0  $HAVE_C_COMPILER(#);
               0
               0  #ifdef HAVE_C_COMPILER;
               0  "append variables that allow us to keep track of min, max particle"
               0  "in a phase space source chunk, SOURCE common block is defined in"
               0  "srcxyznrc.macros"
               0  APPEND {;COMMON/SOURCE_FORPARALLEL/nnphsp_max, nnphsp_min;
            {  0  $LONG_INT nnphsp_max, nnphsp_min; } TO
               0  {;COMIN/SOURCE/;}
               0
               0  #endif;
               0
               0  "  start of coding                 ""toc:
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/ BOUNDS,BREMPR,ELECIN,GEOM,MEDIA,MISC,PHSPFILE,SCORE,SOURCE,
               0  STACK,THRESH,USEFUL,RANDOM,TIMEINFO,ET-Control,CH-Steps,USER,EPCONT,EGS-IO,
               0  RWPHSP/;
               0
               0  $LONG_INT NCASE,IHSTRY,tempdiv,jcase,compensated_NCASE;
               0  "compensated_NCASE for source 20 only"
               0  integer   idosl($MXDOS),idosu($MXDOS),jdosl($MXDOS),jdosu($MXDOS),
               0  kdosl($MXDOS),kdosu($MXDOS),IZSCAN($MXDOS),idgrp,n,j,i,
               0  maxx,maxy,maxz,maxbd,ngroup,igroup,nn,nnn,in,IL,IU,JL,JU,KL,KU,
               0  medtmp,k,irl,ieof,IOUT,lnblnk1,IXXIN,JXXIN;
               0  integer   IRSECT, "should be be part of common block--something with presta"
               0  ihist, "looping variable"
               0  idose, "loops over dose regions for analysis"
               0  nperpg, "number of sets of dose curves per page"
               0  ipage, "page counter"
               0  ios,   "1 if there is an error on opening ct phantom file"
               0  irin, "first region of source particle"
               0  temppar, "holds IPARALLEL when calculating NRCYCL"
               0  jj, "loop counter"
               0  idd,  "unit number for .3ddose file"
               0  iorstrt, "unit number for the .egsdat file"
               0  ioutgeom, "unit number for .egsgeom file"
               0  ioutgph,  "unit number for .egsgph file"
               0  ioutphant, "unit no. for output .egsphant file"
               0  egs_open_file,
               0  egs_open_datfile,
               0  ihowfarless, "set to 1 to calc. DIST, DNEAR against outer boundaries"
               0  "of phantom.  Set to 0 for normal transport."
               0  i_par_temp; "stores value of i_parallel"
               0  $REAL     xin,yin,zin, "x,y,z position of source particle"
               0  uin,vin,win, "u,v,w of source particle"
               0  weight,etotin,
               0  etot, "total energy, used in stat analysis at end of run"
               0  mindelX,mindelY,mindelZ; "min. width of X,Y,Z voxels, used to"
               0  "set min. step length when howfarless used"
               0  real      amass,tcpuold,ECUTIN,PCUTIN,ESTEPM($MXMED),width,
               0  rhotmp,ECUTL,PCUTL,TIMMAX,SMAX,
               0  timcpu, "keeps track of total CPU time"
               0  ainflu, "total number of incident particles"
               0  minrhor, "min density of CT phantom"
               0  maxrhor; "max density of CT phantom"
               0  character*256 PhantFileName, "name of file holding CT phantom data"
               0  parname, "name of .pardose file"
               0  phsp_out_fn;  "phsp file output name"
               0  REAL XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               0  XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX,
               0  XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX,
               0  XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN,
               0  XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               0  XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               0  XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               0  XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN; "used to output"
               0  "rep of source plane"
               0  "to .egsgeom file"
               0  INTEGER IRESTART,ibatch,ncaseold;
               0  character title(80);
               0  REAL   BATCHT,       "T>used by timing
               0  TIMEB,        "T>used by timing routines
               0  SECNDS;       "T>used by  $SET_ and $INITIALIZE_ELAPSED_TOTAL_TIME;
               0
               0  "Correlated sampling no longer supported with history by history statistics"
               0  "$Corr_Vars; mah 09/05/95 To declare CRFLAG ";
               0
               0  "CT Phantom Variable Declaration."
               0  Integer CTError;     " Declare error flag variable."
               0
               0  "variables for zeroing doses with >50% error and in air in the .3ddose file"
               0  INTEGER zerodose,    "set to $DOSEZERO from dosxyz_user_macros.mortran"
               0  zerocount,   "keeps track of how many doses zeroed"
               0  MAX20,       "set to 1 to print summary of max 20 doses"
               0  tempmax20,   "used in conjunction with MAX20"
               0  doseprint,   "set to 1 for full dose output to .egslst"
               0  "(CT data only)"
               0  IDAT,        "0 => store intermediate data"
               0  "1 => do not store data"
               0  "2 => store data but only at end of run"
               0  zeroairdose, "set to 1 to zero air dose in .3ddose file (CT data
               0  "only)"
               0  IPHANT;      "set to 1 to output a .egsphant file (non-CT data)"
               0
               0  "variables for recording total elapsed clock time"
               0  INTEGER NETADJ;      "keeps track of how many times elapsed time adjusted"
               0  REAL ETIMETOT;     "T>stores total elapsed time"
               0
               0  "variables for calculating range from ECUTIN to AE for range rejection"
               0  $INTEGER LELKE, lelktmp, lelec;
               0  $REAL EKEI,ELKEI,fedep,elktmp,dedxmid,aux;
               0
               0  "variables related to calculating dose statistics"
               0  REAL*8 temp;
               0  $LONG_INT nhist_old; "stores previous value of nhist"
               0
               0  $INTEGER n_repeat,i_repeat;
               0
               0  REAL z_score_tmp; "dummy variable passed to IAEA phsp file opening macro"
               0
               0  "New parallel processing implementation. Only used if there is a
               0  "    working C compiler.
               0
               0  external combine_results;
               0
               0  character medChar($IMAX);
               0  character encoding*62;
               0
               0  #ifdef HAVE_C_COMPILER;
               0  $REAL   part_dose, part2_dose, current_result, current_uncertainty;
               0  $LONG_INT n_run,n_tot,n_last,n_left,other_num_1,other_num_2,p_per_phsp_chunk;
               0  $INTEGER  n_job,n_run_chunk;
               0  $LOGICAL first_time;
               0  #endif;
               0
               0  $LOGICAL is_finished;
               0
               0  "  start of executable code            ""toc:
               0
               0  $DECLARE_TIMING_VARIABLES;
               0  "Above declares cput0, cput1,cput2"
               0  "cput0 is cpu time at start of execution"
               0  "cput1 is cputime at start of simulations"
               0  "cput2 is cputime when asked for so elapsed cpu is cput2-cput0 or -cput1"
               0
               0  "define the ascii encoding string for media in egsphant file"
               0  encoding = $ENCODING;
               0
               0  call egs_init; "initialize EGSnrc system"
               0
               0  $INITIALIZE_ELAPSED_TOTAL_TIME;
               0  $SET_ELAPSED_CPUTIME(cput0);
               0  "above initialized in machine.mortran"
               0
               0  "define unit numbers for output files"
               0  IOUT=1; "the unit number for the .egslst file
               0  idd=3; "unit number for .3ddose file
               0  iorstrt=4; "unit number for the .egsdat file
               0  ioutgeom=17; "unit number for .egsgeom file
               0  ioutgph=13; "unit number for .egsgph file
               0  ioutphant=18; "for output .egsphant file
               0
               0  i_unit_out=45; "does not matter what the IAEA phsp output unit is"
               0  "because this is actually just an array index for a C"
               0  "class"
               0  $INIT_PHSP_COUNTERS;
               0
               0  OUTPUT;(/' Begin execution with large arrays being zeroed'/
               0  ' This is only needed for Linux g77 compiler - comment'/
               0  ' this code near the top of dosxyznrc.mortran if you are'/
               0  ' not using a linux g77 compiler'/);
               0
               0  DO i = 1, $MXREG [MED(i) = 1;RHOR(i) =0.;]
               0  "above duplicates a statement in egsnrc.mortran BLOCK DATA"
               0  "It can be commented out for everything except g77 and fort77"
               0  "compilers which cannot handle such huge arrays."
               0  "The corresponding stmts in the BLOCKDATA are deleted via"
               0  "the dosxyznrc.configuration file when the fort77 or g77 compilers"
               0  "are being used."
               0
               0
               0  zeroairdose = 0; "can only be set to 1 in CT inputs"
               0  MAX20=0;
               0  IPHANT=0;
               0  doseprint=1; "assume we want to output doses to .egslst unless using CT"
               0  i_phsp_out=0; "default is to not output phsp"
               0  i_bindos=0;
               0
               0
               0  CALL DATETIME(1);
               0  OUTPUT61 TIMEN, DATEN; (' ',79('*')/
               0  ' NRCC/UW EGSnrc user-code DOSXYZnrc'/
               0  ' ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT / ' ',79('*')/
               0  ' **',T79,'**'/
               0  ' **',T38,'DOSXYZnrc',T79,'**'/
               0  ' **',T34,'Z pronounced zed',T79,'**'/ ' **',T79,'**'/
               0  ' **',T10,'Code developed at the National Research Council of Canada',
               0  ' and',T79,'**'/
               0  ' **',T15,'University of Wisconsin as part of the OMEGA project',
               0  T79,'**'/ ' **',T79,'**'/
               0  ' **',T15,
               0  T79,'**'/         ' **',T79,'**'/     1X ,79('*'));
               0  OUTPUT61
               0  $MXMED,$MXSTACK,$IMAX,$JMAX,$KMAX,$MAXDOSE,$DOSEZERO;
               0  (/'     The following parameters may be adjusted in dosxyz_user_macros.mortran'/
               0  ' $MXMED:    Max number of media:',I3,/
               0  ' $MXSTACK:  Max stack size:',I10/
               0  ' $IMAX,etc: Max dose scoring regions in x,y,z directions:', 3I5/
               0  ' $MAXDOSE:  Max dose scoring regions consistent with above:',I7/
               0  ' $DOSEZERO(=',I1,') 1=> all doses with uncert > 50% are zeroed',
               0  ' in .3ddose file'/);
               0  OUTPUT61 $INVDIM, $NENSRC;
               0  (/' The following parameters may be adjusted in srcxyz.macros'/
               0  ' $INVDIM:   number of elements in inverse CPD for input energy spectra =', I5/
               0  ' $NENSRC:   number of bins in input energy spectrum =', I5/);
               0
               0  OUTPUT61;(1x,79('=')/1x,79('-')//' Title: ',$);
               0  INPUT title;(80a1);
               0  OUTPUT61 Title;(' ',80a1/1x,79('-')/1x,79('=')//);
               0
               0  "Step 2   Pre-hatch call initialization                        ""toc:
               0  "======================================
               0
               0  OUTPUT61 $MXMED;(' Number of media (min = 1, max =',I4,', 0 => CT data): ',$);
               0  read(5,'(I10)') NMED;
               0  IF(NMED > $MXMED ) [ NMED= 1; "DEFAULTS TO 1 MEDIUM" ]
               0  OUTPUT61 NMED;(' ',t10,i7);
               0
               0  "----------------------------------------------------------------------------"
               0  IF(NMED = 0)[ "Input data from CT data file as processed by the code ctcreate"
               1      "----------------------------------------------------------------------------"
               1      OUTPUT61;
               1      (' Input the full name of the file containing the CT phantom created '/
               1      ' using ctcreate '/
               1      ' : ',$);
               1      read(5,'(A256)') PhantFileName;
               1      OUTPUT61 PhantFileName(:lnblnk1(PhantFileName));(A);
               1
               1      call replace_env(PhantFileName);
               1
               1      Open($CTUnitNumber,file=PhantFileName,status='old',access='sequential',
               1      iostat=ios);
               1      IF(ios~=0)[
               2          OUTPUT61;(/' The CT phantom file does not exist.'/
               2          ' Try again. ');
               2          STOP;
               2          ]
               1
               1      OUTPUT61;(/' CT Phantom summary: ');
               1
               1      "now start reading the info from the file"
               1      "read number of media"
               1      read($CTUnitNumber,'(i2)')NMED;
               1      OUTPUT61 NMED;(/' NMED = ',i2);
               1      "media names"
               1      OUTPUT61;(/' media:');
               1      DO n=1,NMED[
               2          read($CTUnitNumber,'(24a1)') (media(j,n),j=1,24);
               2          OUTPUT61 (media(j,n),j=1,24);(' ',24a1);
               2          ]
               1      "estepe and SMAX"
               1      read($CTUnitNumber,*) (ESTEPM(i),i=1,NMED);
               1      OUTPUT61 (ESTEPM(i),i=1,NMED);
               1      (/' Dummy values of (ESTEPM(i),i=1,NMED)'/
               1      ' : ',10f10.3);
               1      "IMAX,JMAX,KMAX"
               1      read($CTUnitNumber,*) IMAX,JMAX,KMAX;
               1      OUTPUT61 IMAX,JMAX,KMAX;
               1      (/' IMAX, JMAX, KMAX : ',3i4);
               1      IF (IMAX > $IMAX | JMAX > $JMAX | KMAX > $KMAX)[
               2          OUTPUT61; (/' ***ERROR:'/
               2          ' X, Y or Z dimension(s) of CT phantom > maximum allowed in DOSXYZnrc '/
               2          ' Change $IMAX, $JMAX, $KMAX in dosxyz_user_macros.mortran and recompile.');
               2          STOP;
               2          ]
               1
               1      " IJMAX and irmax needs to be set.           "
               1      ijmax = IMAX*JMAX;
               1      irmax =1 + IMAX*JMAX*KMAX;
               1
               1      "boundaries"
               1      read($CTUnitNumber,*) (xbound(i),i=1,IMAX+1);
               1      read($CTUnitNumber,*) (ybound(j),j=1,JMAX+1);
               1      read($CTUnitNumber,*) (zbound(k),k=1,KMAX+1);
               1      "calculate min and max boundaries"
               1      xbound_min = xbound(1); xbound_max = xbound(IMAX+1);
               1      ybound_min = ybound(1); ybound_max = ybound(JMAX+1);
               1      zbound_min = zbound(1); zbound_max = zbound(KMAX+1);
               1      OUTPUT61 xbound_min,xbound_max,ybound_min,ybound_max,
               1      zbound_min,zbound_max;
               1      (/' x range : ',F12.5,' - ',F12.5,' cm'/
               1      ' y range : ',F12.5,' - ',F12.5,' cm'/
               1      ' z range : ',F12.5,' - ',F12.5,' cm');
               1
               1      "input the media numbers"
               1      DO k=1,KMAX[
               2          DO j=1,JMAX[
               3              "Read in the characters that correspond to medium numbers"
               3              read($CTUnitNumber,:medformat:) (medChar(i),i=1,IMAX);
               3              "Convert from ASCII to a number"
               3              DO i=1,IMAX[
               4                  med($IR(i,j,k)) = index(encoding, medChar(i)) - 1;
               4                  ]
               3              ]
               2          read($CTUnitNumber,*);
               2          ]
               1      :medformat: FORMAT($IMAXa1);
               1
               1      "input the densities"
               1      maxrhor=0.;
               1      minrhor=999.;
               1      DO k=1,KMAX[
               2          DO j=1,JMAX[
               3              read($CTUnitNumber,*) (rhor($IR(i,j,k)),i=1,IMAX);
               3              DO i=1,IMAX[
               4                  IF(rhor($IR(i,j,k)) > maxrhor)[maxrhor=rhor($IR(i,j,k));]
               4                  IF(rhor($IR(i,j,k)) < minrhor)[minrhor=rhor($IR(i,j,k));]
               4                  ]
               3              ]
               2          read($CTUnitNumber,*);
               2          ]
               1      OUTPUT61 minrhor,maxrhor;
               1      (/' Densities range from ',F12.5,' - ',F12.5,' g/cc');
               1
               1      close($CTUnitNumber);
               1
               1      "now read in transport parameters"
               1      OUTPUT61;(/' ECUTIN,PCUTIN,(SMAX--DUMMY INPUT): ',$);
               1      read(5,'(3F15.0)') ECUTIN,PCUTIN,SMAX;
               1
               1      OUTPUT61 ECUTIN,PCUTIN,SMAX;(/t10,3f10.3);
               1
               1      "now some output parameters"
               1      OUTPUT61;
               1      (/' Input zeroairdose (1 to zero dose in air in .3ddose file; 0[default]'/
               1      ' to not zero this dose), doseprint (1 for full dose output in .egslst;'/
               1      ' 0[default] otherwise), MAX20 (1 to print out summary of 20 highest'/
               1      ' doses; 0[default] to not print this summary)'/
               1      ' : ',$);
               1      READ(5,'(3I5)')zeroairdose,doseprint,MAX20;
               1      IF(zeroairdose ~=1) zeroairdose=0;      "default value"
               1      IF(MAX20 ~= 1) MAX20=0;
               1      IF(doseprint ~= 1) doseprint=0;
               1      OUTPUT61 zeroairdose,doseprint,MAX20;(3I5);
               1
               1      idgrp=1;
               1      idosl(idgrp)=1; idosu(idgrp)=IMAX;
               1      jdosl(idgrp)=1; jdosu(idgrp)=JMAX;
               1      kdosl(idgrp)=1; kdosu(idgrp)=KMAX;
               1      IZSCAN(idgrp)=1;
               1      ]  "end of block reading in CT data
               0
               0
               0  ELSE [ " Read in geometric data as defined by user as opposed to CT data"
               1
               1      DO n=1,NMED [
               2          OUTPUT61 n;(' Medium',i3,':  ',$);
               2          INPUT (media(j,n),j=1,24);(24a1);
               2          OUTPUT61 (media(j,n),j=1,24);(' ',t20,24a1);
               2          ]
               1      med(1)=0;
               1      DO n=2,$MXREG [med(n)=1;] "ie Everything the first medium"
               1      "Can be changed below on a region by region basis"
               1
               1      OUTPUT61;(/' ECUTIN,PCUTIN,(ESTEPE,SMAX--DUMMY INPUTS): ',$);
               1      read(5,'(2F15.0,30F10.0,F15.0)') ECUTIN,PCUTIN,(ESTEPM(i),i=1,NMED),SMAX;
               1
               1      OUTPUT61 ECUTIN,PCUTIN,(ESTEPM(i),i=1,NMED),SMAX;(/t10,13f10.3);
               1
               1      "Step 3   Initialization for howfar                        ""toc:
               1      "==================================
               1
               1      "     Input x, y, z boundaries
               1
               1      "First define a macro which will be used for each axis in turn
               1      REPLACE {$GET-#-BOUNDARIES;} WITH {
            {  1      ;mindel{P1}=1.e20;
            {  1      IF(max{P1} > 0) [
            {  1      mindel{P1}=1.e20;
            {  1      IF(max{P1} > maxbd)[
            {  1      OUTPUT61 maxbd;
            {  1      (t15,'***ERROR:'/
            {  1      t15,'number of regions > max allowed (',i5,')');
            {  1      STOP;
            {  1      ]
            {  1      "Pick up boundaries one at a time"
            {  1      DO i=1,max{P1} [
            {  1      OUTPUT61 i;(' Small boundary for region(',i3,')  ',$);
            {  1      read(5,'(F15.0)') {P1}bound(i);
            {  1      IF( (i ~=1 ) & ( {P1}bound(i) <= {P1}bound(i-1) )) [
            {  1      OUTPUT61;(' *** Boundary out of order ***');
            {  1      ]
            {  1      OUTPUT61 {P1}bound(i);(' ',t10,f12.3);
            {  1      IF(i>=2 & {P1}bound(i)-{P1}bound(i-1)<mindel{P1})[
            {  1      mindel{P1}={P1}bound(i)-{P1}bound(i-1);
            {  1      ]
            {  1      ]
            {  1      OUTPUT61 max{P1};(' Outer boundary for region(',i3,')  ',$);
            {  1      read(5,'(F15.0)') {P1}bound(max{P1} + 1);
            {  1      OUTPUT61 {P1}bound(max{P1}+1);(' ',t10,f12.3);
            {  1      IF({P1}bound(max{P1}+1)-{P1}bound(max{P1})<mindel{P1})
            {  1      mindel{P1}={P1}bound(max{P1}+1)-{P1}bound(max{P1});
            {  1      ]
            {  1      ELSE [
            {  1      "max(P1) < 0, Input groups of regions"
            {  1      "Assume maxbd set to $IMAX, $JMAX or $KMAX"
            {  1      OUTPUT61;(' Initial boundary: ',$);
            {  1      read(5,'(F15.0)') {P1}bound(1);
            {  1      OUTPUT61 {P1}bound(1);(' ',f12.3);
            {  1      ngroup = - max{P1}; "Number of groups in this direction"
            {  1      max{P1} = 0;
            {  1      DO igroup = 1,ngroup [
            {  1      OUTPUT61;
            {  1      (' Width in this group, number of regions in group: ',$);
            {  1      read(5,'(F15.0,I10)') width,nn;
            {  1      IF(nn<=0) [nn=1;];
            {  1      IF(width<=0.0)[width=1.0;]
            {  1      IF(width<mindel{P1})mindel{P1}=width;
            {  1      OUTPUT61 width,nn;(' ',f12.3,i5);
            {  1      nnn = min(nn,maxbd-max{P1}); "Ensure do not add too many regions"
            {  1      IF(nnn ~= 0) [
            {  1      DO in = max{P1}+1,max{P1}+nnn [
            {  1      {P1}bound(in+1) = {P1}bound(in)+width;
            {  1      ]
            {  1      ]
            {  1      IF(nn ~= nnn)[
            {  1      OUTPUT61 maxbd;
            {  1      (t15,'***ERROR:'/
            {  1      t15,'number of regions > max allowed (',i5,')');
            {  1      STOP;
            {  1      ]
            {  1      max{P1} = max{P1}+nnn;
            {  1      ]
            {  1      "Must set IMAX etc after call to this macro"
            {  1      OUTPUT61 ({P1}bound(i),i=1,max{P1}+1);(' Boundaries'/(6f12.3));
            {  1      ]
            {  1      }
               1
               1      OUTPUT61 $IMAX,$JMAX,$KMAX;
               1      (/' # regions in x (max=',I4,'),y (max=',I4,'),z (max=',I4,') directions'/
               1      ' (if<0,implies # groups of reg), IPHANT (1 to output a .egsphant'/
               1      ' file for dosxyz_show, 0[default] to not output this file)'/
               1      '     : ',$);
               1      read(5,'(4I10)') maxx,maxy,maxz,IPHANT;
               1
               1      IF(maxx = 0) maxx=1; IF(maxx>$IMAX) maxx=$IMAX;
               1      IF(maxy = 0) maxy=1; IF(maxy>$JMAX) maxy=$JMAX;
               1      IF(maxz = 0) maxz=1; IF(maxz>$KMAX) maxz=$KMAX;
               1      OUTPUT61 maxx,maxy,maxz,IPHANT;(' ',4i6);
               1
               1      IF(IPHANT=1)[
               2          OUTPUT; (//' Will output a .egsphant file to display isodose contours'/
               2          ' with dosxyz_show.'//);
               2          ]
               1
               1      maxbd=$IMAX;
               1      OUTPUT61; ( / ' Input boundaries in the x-direction'/
               1      ' -----------------------------------');
               1      $GET-X-BOUNDARIES; IMAX=maxx;
               1      maxbd=$JMAX;
               1      OUTPUT61; ( / ' Input boundaries in the y-direction'/
               1      ' -----------------------------------');
               1      $GET-Y-BOUNDARIES; JMAX=maxy;
               1      maxbd=$KMAX;
               1      OUTPUT61; ( / ' Input boundaries in the z-direction'/
               1      ' -----------------------------------');
               1      $GET-Z-BOUNDARIES; KMAX=maxz;
               1
               1      "Determine boundary limits - to be used by the source routine
               1      xbound_min = xbound(1); xbound_max = xbound(IMAX+1);
               1      ybound_min = ybound(1); ybound_max = ybound(JMAX+1);
               1      zbound_min = zbound(1); zbound_max = zbound(KMAX+1);
               1
               1      ijmax = IMAX*JMAX;  irmax =1 + IMAX*JMAX*KMAX;
               1
               1      OUTPUT61 irmax;(/' Total # regions including exterior =',i10);
               1      IF(irmax > $MXREG) [
               2          OUTPUT61;(/' *** That is too many regions ***'//);
               2          stop ' *** Stopping because too many regions asked for ***';
               2          ]
               1
               1      "   Get density or material for each region
               1      "   rhor = 0.0 means use default density for the material in region
               1
               1      OUTPUT61;
               1      (/' Input groups of regions for which density and medium are not defaults');
               1      LOOP [
               2          OUTPUT61;(' Lower,upper i, j, k,  MEDIUM, DENSITY',$);
               2          read(5,'(7I10,F15.0)') IL,IU,JL,JU,KL,KU,MEDTMP,RHOTMP;
               2          IF( (IL = 0) & (IU = 0) )["Blank line, so quit"
               3              OUTPUT61;(/'    Found blank line => end of this input');
               3              EXIT;
               3              ]
               2          "Check IL etc are ok
               2          IF((IL <= 0)|(IL > IMAX)) IL = 1; IF((IU < IL)|(IU > IMAX)) IU = IMAX;
               2          IF((JL <= 0)|(JL > JMAX)) JL = 1; IF((JU < JL)|(JU > JMAX)) JU = JMAX;
               2          IF((KL <= 0)|(KL > KMAX)) KL = 1; IF((KU < KL)|(KU > KMAX)) KU = KMAX;
               2          IF((medtmp < 0)|(medtmp > NMED)) medtmp = 1;
               2
               2          OUTPUT61 IL,IU,JL,JU,KL,KU,MEDTMP,RHOTMP;
               2          (' ',3('(',i3,i4,')'), i4, f10.3);
               2          DO i=Il,IU [
               3              DO j=JL,JU [
               4                  DO k=KL,KU [
               5                      irl = $IR(i,j,k);
               5                      rhor(irl)=rhotmp;
               5                      med(irl)=medtmp;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1
               1      OUTPUT61;
               1      (//' Input groups of regions for which ECUT and PCUT are not defaults');
               1      OUTPUT61;(' NB This option is disabled, just input 8 zeros.');
               1      LOOP [
               2          OUTPUT61;(' Dummy values of lower,upper i, j, k,  ECUT, PCUT',$);
               2          read(5,'(6I10,2F15.0)') IL,IU,JL,JU,KL,KU,ECUTL,PCUTL;
               2          IF( IL = 0 & IU = 0)[
               3              OUTPUT61;(/'    Found blank line => end of this input');
               3              EXIT;"Blank line, so quit"
               3              ]
               2          OUTPUT61 IL,IU,JL,JU,KL,KU,ECUTL,PCUTL;
               2          (' ',3('(',i3,i4,')'),2(f10.3,1x));
               2          ]
               1
               1      "Step 4  Initialization for ausgab                        ""toc:
               1      "=================================
               1
               1      "Initially just ask for ranges of regions over which the dose to be output
               1      OUTPUT61; (//' Enter 8 numbers on one line'/
               1      '   3 pairs defining lower,upper x,y,z indicies of dose regions'/
               1      '                 for which results are to be output'/
               1      '   IZSCAN:       non-zero for z-scan/page'/
               1      '   MAX20:        if any one = 1, output summary of max 20 doses.'/
               1      '   end signaled by first pair both zero'/
               1      '   for no dose printed, MAX20 is still read from first line'/);
               1      idgrp=0;
               1      tempmax20=0;
               1      LOOP [
               2          idgrp=idgrp+1;
               2          read(5,'(8I10)') idosl(idgrp),idosu(idgrp),jdosl(idgrp),jdosu(idgrp),
               2          kdosl(idgrp),kdosu(idgrp),IZSCAN(idgrp),tempmax20;
               2          IF((idosl(idgrp) = 0)&(idosu(idgrp) = 0))["Quit when get blank line"
               3              OUTPUT61;('    Found blank line => end of this input');
               3              IF(idgrp = 1) ["was on first line of input"
               4                  IF(tempmax20 = 1 )[
               5                      MAX20 = 1;
               5                      OUTPUT61; ('   MAX20 =1 so will print largest 20 doses only');
               5                      ]
               4                  ELSE [
               5                      OUTPUT61;(' No doses will be output to egslst file');
               5                      ]
               4                  ]"end of block for defaults if no input"
               3              EXIT; "exit from loop - note can leave all blank=> no output"
               3              ]
               2          "The first two are not zero, so set defaults for all others"
               2          "to span whole range if not explicitly input"
               2          IF(idosl(idgrp)<=0) idosl(idgrp)=1;
               2          IF(idosu(idgrp)<=0 |idosu(idgrp)>=IMAX) idosu(idgrp)=IMAX;
               2          IF(jdosl(idgrp)<=0)jdosl(idgrp)=1;
               2          IF(jdosu(idgrp)<=0 |jdosu(idgrp)>=JMAX) jdosu(idgrp)=JMAX;
               2          IF(kdosl(idgrp)<=0)kdosl(idgrp)=1;
               2          IF(kdosu(idgrp)<=0 |kdosu(idgrp)>=KMAX) kdosu(idgrp)=KMAX;
               2          IF(tempmax20=1) MAX20=1;
               2          OUTPUT61 idosl(idgrp),idosu(idgrp),jdosl(idgrp),jdosu(idgrp),
               2          kdosl(idgrp),kdosu(idgrp),IZSCAN(idgrp),tempmax20;
               2          (t5,3(i6,i4),i6,i6);
               2          ]
               1      idgrp=idgrp-1;
               1
               1      ] "end of users input to directly specify phantom as opposed to CT input"
               0
               0  "Step 5 Determination of incident particle parameters        ""toc:
               0  "====================================================
               0
               0  dose_stat=0; "assume non phsp source or we can get nhist from phsp source"
               0
               0  "Define source
               0  call srcinput(ieof);
               0
               0  OUTPUT61;
               0  (//' NCASE,IWATCH,TIMMAX,INSEED1,INSEED2,BEAM_SIZE,ISMOOTH,IRESTART,IDAT,'/
               0  ' IREJECT,ESAVE_GLOBAL,NRCYCL,IPARALLEL,PARNUM,n_split,ihowfarless,i_phsp_out,'/
               0  ' i_bindos '/
               0  ' : ',$);
               0  read(5,'(2I16,F15.0,2I10,F15.0,4I10,F15.0,7I10)')
               0  NCASE,IWATCH,TIMMAX,IXXIN,JXXIN,BEAM_SIZE,ISMOOTH,IRESTART,IDAT,IREJECT,
               0  ESAVE_GLOBAL,NRCYCL,IPARALLEL,PARNUM,n_split,ihowfarless,i_phsp_out,i_bindos;
               0
               0  IF(n_split<=1 & e_split>1)[
               1      OUTPUT;
               1      (//' ***Warning: Electron splitting on with no photon splitting.'/
               1      '             Electron splitting will not be done.'//);
               1      ]
               0
               0
               0  IF(TIMMAX<=0.0)[TIMMAX = 0.99;"Default 1 hour"]
               0
               0  IF (IWATCH = 0 & NCASE < 100)[NCASE=100;]
               0  IF (NCASE/$NBATCH = 0)[
               1      NCASE=$NBATCH;
               1      ]
               0  jcase = NCASE/$NBATCH; NCASE = jcase*$NBATCH;
               0
               0  "Make sure the IXXIN and JXXIN values will not be overridden by defaults"
               0  " and warn user if they will in case they expect to start independent runs"
               0  IF((IXXIN <= 0) | (IXXIN > 31328)) [
               1      OUTPUT; (' First RN seed outside allowed range and default value set');
               1      IXXIN=1802;
               1      ]
               0  IF((JXXIN < = 0) | (JXXIN > 30081)) [
               1      OUTPUT; (' Second RN seed outside allowed range and default value set');
               1      JXXIN=9373; "sets Marsaglia default"
               1      ]
               0
               0  IF( i_parallel > 0 ) JXXIN = JXXIN - 1 + i_parallel;
               0
               0  IF(BEAM_SIZE <= 0.0) BEAM_SIZE=100.;
               0
               0  IF(IRESTART < 0 | IRESTART > 4)IRESTART=0;"SET UP THE DEFAULT VALUE"
               0
               0  IF(IPARALLEL<0) IPARALLEL=0;
               0  IF(PARNUM<0) PARNUM=0;
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF(IPARALLEL>1 & n_parallel>0)[
               1      OUTPUT IPARALLEL, n_parallel;
               1      (/' You have set IPARALLEL in the input file to ',I4,/
               1      ' But you are also running a C compiled code with n_parallel=',I4,/
               1      ' IPARALLEL will be reset to 1, and control of the parallel run '/
               1      ' will be from the code.'/);
               1      IPARALLEL=1;
               1      ]
               0  #endif;
               0
               0  IF(IPARALLEL>1 & PARNUM>IPARALLEL & (isource = 2 |  isource = 8 |
               0  isource = 20))[
               1      OUTPUT; (//' ****WARNING:'/
               1      ' PARNUM is > IPARALLEL '/
               1      ' It must be in the range 1<=PARNUM<=IPARALLEL if you'/
               1      ' want to partition a phase space source.'/
               1      ' PARNUM will be set to 0 for now, and the phase space'/
               1      ' source will not be partitioned.'//);
               1      PARNUM=0;
               1      ]
               0
               0  "necessary for calling srcinit with a BEAM simulation source if pprocess"
               0  "is being used"
               0  IF(IPARALLEL>1 & PARNUM>0)i_parallel=PARNUM;
               0
               0  IF(NRCYCL <= 0 & (isource=2 | isource=8))[
               1      "automatically calculate NRCYCL"
               1      IF(iqin=1 | enflag=3)["cannot determine nrcycl apriori"
               2          NRCYCL=0;
               2          ]
               1      ELSE[
               2          IF(iqin=0)[
               3              tempdiv=nphist;
               3              ]
               2          ELSEIF(iqin=-1)[
               3              tempdiv=nshist-nphist;
               3              ]
               2          ELSE["all particles"
               3              tempdiv=nshist;
               3              ]
               2          IF(IPARALLEL>1 & PARNUM>0)[
               3              temppar=IPARALLEL;
               3              ]
               2          ELSE[
               3              temppar=1;
               3              ]
               2          IF(NINT(dble(temppar*NCASE)/dble(tempdiv))<=1)[
               3              "prevents undersampling of ph-sp data in case NCASE is only"
               3              "slightly > tempdiv and also makes sure we do not recycle if"
               3              "NCASE<tempdiv"
               3              NRCYCL=0;
               3              ]
               2          ELSEIF(MOD(temppar*NCASE,tempdiv)=0)[
               3              "NCASE is an exact multiple of tempdiv"
               3              NRCYCL=(temppar*NCASE)/tempdiv-1;
               3              ]
               2          ELSE[
               3              NRCYCL=(temppar*NCASE)/tempdiv;
               3              ]
               2          ]
               1      ]
               0
               0  IF(ihowfarless<=0 | ihowfarless>1)[
               1      ihowfarless=0;
               1      howfarless=.false.;
               1      ]
               0  ELSE[
               1      howfarless=.true.;
               1      iausfl(6)=1;"call ausgab after particle transport"
               1      iausfl(16)=1;"before pair production"
               1      iausfl(18)=1;"before compton"
               1      iausfl(20)=1;"before photoelectric"
               1      iausfl(24)=1;"before rayleigh"
               1      ]
               0
               0  "set initial energy - used only for enflag=0 (mono-energetic source)"
               0  "                     reset for other sources elsewhere"
               0  IF(iqin = 0)[etotin = ein;] ELSE [etotin = ein + prm;]
               0
               0  OUTPUT61 NCASE,IWATCH,TIMMAX,IXXIN,JXXIN,BEAM_SIZE,ISMOOTH,IRESTART,IDAT,
               0  IREJECT,ESAVE_GLOBAL,NRCYCL,IPARALLEL,PARNUM,n_split,ihowfarless,i_phsp_out;
               0  (/i12,i4,f7.2,2i10,f7.2,i7,i5,i4,i4,F7.2,i4,i4,i4,i4,i4,i4/);
               0  IF(IRESTART=1)[
               1      OUTPUT61;(/' Above RNG seeds will be replaced by those from previous run.');
               1      ]
               0
               0  IF(i_phsp_out<0 | i_phsp_out>2) i_phsp_out=0;
               0  "phsp_out=2 meaningless if not phsp or BEAM simulation source"
               0  IF(i_phsp_out~=0 & (isource ~= 2 & isource ~= 8 & isource ~= 9 &
               0  isource ~= 10 & isource ~= 20 & isource ~= 21))[
               1      OUTPUT;(/' Warning: Phase space data can only be output for phase space '/
               1      ' or BEAM simulation sources.  Resetting i_phsp_out to 0 for '/
               1      ' now.'/);
               1      i_phsp_out=0;
               1      ]
               0  ELSEIF(i_phsp_out~=0)[
               1      IF(i_phsp_out=1)[
               2          OUTPUT;(/' Will output IAEA format phase space data in DOSXYZnrc '/
               2          ' coordinates.'/);
               2          ]
               1      ELSEIF(i_phsp_out=2)[
               2          OUTPUT;(/' Will output IAEA format phase space data in BEAMnrc '/
               2          ' coordinates.'/);
               2          ]
               1      IF(i_muidx_out=1)[
               2          OUTPUT;(/' Fractional MU index will be included in phase space data.'/);
               2          ]
               1      ]
               0
               0  IF(i_phsp_out=1 | i_phsp_out=2) iausfl(6)=1;
               0  "call ausgab after particle transport to score particles"
               0
               0  $INITIALIZE RNG USING IXXIN AND JXXIN;
               0
               0
               0  "=========================================================================="
               0  " Moved here by Ernesto Mainegra-Hing Dec 2011                             "
               0  " Opening same pegs4 file with two different units gives an error in gcc   "
               0  " 4.5.1 and 4.6.2. This occurs with a BEAM source when the pegs4 file is   "
               0  " the same as for the dosxyz simulation.                                   "
               0  "=========================================================================="
               0  "Step 6   Get EGSnrc transport parameters                      ""toc:
               0  "=========================================================================="
               0
               0  "set skin depth to 0 here.  If skindepth is omitted or not input properly"
               0  "this will get reset to BLCMIN if BCA=PRESTA-I, or 3 if BCA=EXACT by "
               0  "subroutine mscati.  If value is input properly, then it will take on that"
               0  "value.  If value is input properly, but out of range, then skindepth"
               0  "will be set to 3, regardless of the BCA"
               0  skindepth_for_bca=0;
               0
               0  call get_transport_parameter(-1);
               0
               0  IF((~exact_bca | transport_algorithm=$PRESTA--I) & SMAXIR=1e10)[
               1      "if we get to here with the default value of SMAX (1e10), then"
               1      "assume that this is because the SMAX input does not exist, the user"
               1      "did not input it properly or the value was out of range and we want to"
               1      "set it to the PRESTA-I default of 5"
               1      SMAXIR=5.;
               1      ]
               0
               0  "Just in case we need this, set it to the EGSnrc value"
               0  smax   = smaxir;
               0
               0  "Step 7   HATCH call                                   ""toc:
               0  "===================
               0
               0  OUTPUT; ( / / ' Call hatch'/ ' ----------'/);
               0  call hatch;
               0
               0  call show_transport_parameter(6); "output egsnrc parameters to the screen"
               0  call show_transport_parameter(iout); " print the transport parameter settings"
               0  " settings on unit IOUT"
               0  "=========================================================================="
               0  "End of block added by Ernesto Mainegra-Hing Dec 2011"
               0  "=========================================================================="
               0
               0  "now check to see if ECUTIN>ECUT or PCUTIN>PCUT"
               0  IF(ECUTIN > ECUT + 1e-10)[ "reset ecut in all regions to ecutin"
               1      OUTPUT ECUTIN,ECUT;
               1      (/' WARNING'/
               1      ' ECUTIN(=',F13.9,') > ECUT(=',F13.9,') input in EGSnrc parameters'/
               1      ' ECUT defaults to ECUTIN.'/);
               1      ECUT=ECUTIN;
               1      ]
               0  ELSE[ ECUTIN=ECUT; ]
               0
               0  IF(PCUTIN > PCUT + 1e-10)[ "reset pcut in all regions to pcutin"
               1      OUTPUT PCUTIN,PCUT;
               1      (/' WARNING'/
               1      ' PCUTIN(=',F13.9,') > PCUT(=',F13.9,') input in EGSnrc parameters'/
               1      ' PCUT defaults to PCUTIN.'/);
               1      PCUT=PCUTIN;
               1      ]
               0  ELSE[ PCUTIN=PCUT; ]
               0
               0  "call this here so that BEAM simulation source can get i_parallel if"
               0  "pprocess is used"
               0  call srcinit(weight);
               0
               0  IF(isource=20)[
               1      compensated_NCASE = (dble(NCASE)/dble(survival_ratio)+0.5);
               1      jcase = (NCASE+$NBATCH/2)/$NBATCH; NCASE = jcase*$NBATCH;
               1      " the factors of 1/2 are added to round up"
               1      IF(NRCYCL <= 0)[
               2          IF(iqin=1 | enflag=3)["cannot determine nrcycl apriori"
               3              NRCYCL=0;
               3              ]
               2          ELSE[
               3              IF(iqin=0)[
               4                  tempdiv=nphist;
               4                  ]
               3              ELSEIF(iqin=-1)[
               4                  tempdiv=nshist-nphist;
               4                  ]
               3              ELSE["all particles"
               4                  tempdiv=nshist;
               4                  ]
               3              IF(IPARALLEL>1 & PARNUM>0)[
               4                  temppar=IPARALLEL;
               4                  ]
               3              ELSE[
               4                  temppar=1;
               4                  ]
               3              IF(NINT(dble(temppar*compensated_NCASE)/dble(tempdiv))<=1)[
               4                  "prevents undersampling of ph-sp data in case NCASE is"
               4                  "only slightly > tempdiv and also makes sure we do not"
               4                  "recycle if NCASE<tempdiv"
               4                  NRCYCL=0;
               4                  ]
               3              ELSEIF(MOD(temppar*compensated_NCASE,tempdiv)=0)[
               4                  "NCASE is an exact multiple of tempdiv"
               4                  NRCYCL=dble(temppar*compensated_NCASE)/dble(tempdiv)-1;
               4                  ]
               3              ELSE[
               4                  NRCYCL=(temppar*compensated_NCASE)/dble(tempdiv);
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  IF( isource = 2 | isource = 8 | isource = 20)["phase space source"
               1      IF(NRCYCL>0)[
               2          OUTPUT NRCYCL;
               2          (' Will recyle each phase space particle ',I4,' times before going on '/
               2          ' to next particle.');
               2          ]
               1      IF( ISMOOTH = 1) [
               2          OUTPUT;(/' Will redistribute phase space particles if phase space file'/
               2          ' restarted and/or individual particles recycled');
               2          ]
               1      ELSE [OUTPUT;(' Restarted phase space files and recycled particles are not'/
               2          ' redistributed');
               2          ]
               1      ]
               0
               0  IF(IRESTART = 0) [OUTPUT;(/' Starting a new calculation');]
               0  ELSEIF(IRESTART = 1) [OUTPUT;(/' Restarting from a previous run');]
               0  ELSEIF(IRESTART = 2) [OUTPUT;(/' Just create input file and exit');]
               0  ELSEIF(IRESTART = 3) [OUTPUT;(/' Read in stored data and analyse');]
               0  ELSEIF(IRESTART = 4) [OUTPUT;(/' Recombining parallel runs');]
               0  ELSE [ IRESTART = 0; OUTPUT;(/' IRESTART set to 0, start new caln');]
               0
               0  IF(IDAT = 0) [OUTPUT;(/' Store intermediate files for each batch');]
               0  ELSEIF (IDAT = 1) [OUTPUT;(/' Do not store intermediate files at all');]
               0  ELSEIF (IDAT = 2) [OUTPUT;(/' Store data files at end of run only');]
               0  ELSE [IDAT = 0; OUTPUT;(/' Store intermediate files for each batch');]
               0
               0  IF(IPARALLEL>1)[
               1      OUTPUT;
               1      (/' Will output binary .pardose files.'/
               1      '   With this set, the egslst files do not contain dose listings either.');
               1      ]
               0
               0  "Output the cube to the egsgeom file if IWATCH=4"
               0  IF(IWATCH=4)[
               1      "open the .egsgeom file, .egsgph is opened by WATCH routine"
               1      ioutgeom=egs_open_file(ioutgeom,0,1,'.egsgeom');
               1      OUTPUT17 1,'QUAD', xbound_min,ybound_min,zbound_min,
               1      xbound_min,ybound_max,zbound_min, xbound_max,ybound_max,zbound_min,
               1      xbound_max,ybound_min,zbound_min; (' ',I1,A4,12(F7.2,','));
               1      OUTPUT17 1,'QUAD', xbound_min,ybound_min,zbound_max,
               1      xbound_min,ybound_max,zbound_max, xbound_max,ybound_max,zbound_max,
               1      xbound_max,ybound_min,zbound_max; (' ',I1,A4,12(F7.2,','));
               1      OUTPUT17 1,'QUAD', xbound_min,ybound_min,zbound_min,
               1      xbound_min,ybound_min,zbound_max, xbound_min,ybound_max,zbound_max,
               1      xbound_min,ybound_max,zbound_min; (' ',I1,A4,12(F7.2,','));
               1      OUTPUT17 1,'QUAD', xbound_max,ybound_min,zbound_min,
               1      xbound_max,ybound_min,zbound_max, xbound_max,ybound_max,zbound_max,
               1      xbound_max,ybound_max,zbound_min; (' ',I1,A4,12(F7.2,','));
               1      OUTPUT17 1,'QUAD', xbound_min,ybound_min,zbound_min,
               1      xbound_min,ybound_min,zbound_max, xbound_max,ybound_min,zbound_max,
               1      xbound_max,ybound_min,zbound_min; (' ',I1,A4,12(F7.2,','));
               1      OUTPUT17 1,'QUAD', xbound_min,ybound_max,zbound_min,
               1      xbound_min,ybound_max,zbound_max, xbound_max,ybound_max,zbound_max,
               1      xbound_max,ybound_max,zbound_min; (' ',I1,A4,12(F7.2,','));
               1
               1      IF(isource = 2 | isource = 8)["output representation of source plane"
               2          XMIN_YMIN_ZMIN = r_11(1)*(-BEAM_SIZE/2) + r_12(1)*(-BEAM_SIZE/2) +
               2          r_13(1)*(dsource+0.1) + xiso;
               2          YMIN_XMIN_ZMIN = r_21(1)*(-BEAM_SIZE/2) + r_22(1)*(-BEAM_SIZE/2) +
               2          r_23(1)*(dsource+0.1) + yiso;
               2          ZMIN_XMIN_YMIN = r_31(1)*(-BEAM_SIZE/2) + r_32(1)*(-BEAM_SIZE/2) +
               2          r_33(1)*(dsource+0.1) + ziso;
               2
               2          XMIN_YMAX_ZMIN = r_11(1)*(-BEAM_SIZE/2) + r_12(1)*(BEAM_SIZE/2) +
               2          r_13(1)*(dsource+0.1) + xiso;
               2          YMAX_XMIN_ZMIN = r_21(1)*(-BEAM_SIZE/2) + r_22(1)*(BEAM_SIZE/2) +
               2          r_23(1)*(dsource+0.1) + yiso;
               2          ZMIN_XMIN_YMAX = r_31(1)*(-BEAM_SIZE/2) + r_32(1)*(BEAM_SIZE/2) +
               2          r_33(1)*(dsource+0.1) + ziso;
               2
               2          XMAX_YMIN_ZMIN = r_11(1)*(BEAM_SIZE/2) + r_12(1)*(-BEAM_SIZE/2) +
               2          r_13(1)*(dsource+0.1) + xiso;
               2          YMIN_XMAX_ZMIN = r_21(1)*(BEAM_SIZE/2) + r_22(1)*(-BEAM_SIZE/2) +
               2          r_23(1)*(dsource+0.1) + yiso;
               2          ZMIN_XMAX_YMIN = r_31(1)*(BEAM_SIZE/2) + r_32(1)*(-BEAM_SIZE/2) +
               2          r_33(1)*(dsource+0.1) + ziso;
               2
               2          XMAX_YMAX_ZMIN = r_11(1)*(BEAM_SIZE/2) + r_12(1)*(BEAM_SIZE/2) +
               2          r_13(1)*(dsource+0.1) + xiso;
               2          YMAX_XMAX_ZMIN = r_21(1)*(BEAM_SIZE/2) + r_22(1)*(BEAM_SIZE/2) +
               2          r_23(1)*(dsource+0.1) + yiso;
               2          ZMIN_XMAX_YMAX = r_31(1)*(BEAM_SIZE/2) + r_32(1)*(BEAM_SIZE/2) +
               2          r_33(1)*(dsource+0.1) + ziso;
               2
               2          XMIN_YMIN_ZMAX = r_11(1)*(-BEAM_SIZE/2) + r_12(1)*(-BEAM_SIZE/2) +
               2          r_13(1)*(dsource-0.1) + xiso;
               2          YMIN_XMIN_ZMAX = r_21(1)*(-BEAM_SIZE/2) + r_22(1)*(-BEAM_SIZE/2) +
               2          r_23(1)*(dsource-0.1) + yiso;
               2          ZMAX_XMIN_YMIN = r_31(1)*(-BEAM_SIZE/2) + r_32(1)*(-BEAM_SIZE/2) +
               2          r_33(1)*(dsource-0.1) + ziso;
               2
               2          XMIN_YMAX_ZMAX = r_11(1)*(-BEAM_SIZE/2) + r_12(1)*(BEAM_SIZE/2) +
               2          r_13(1)*(dsource-0.1) + xiso;
               2          YMAX_XMIN_ZMAX = r_21(1)*(-BEAM_SIZE/2) + r_22(1)*(BEAM_SIZE/2) +
               2          r_23(1)*(dsource-0.1) + yiso;
               2          ZMAX_XMIN_YMAX = r_31(1)*(-BEAM_SIZE/2) + r_32(1)*(BEAM_SIZE/2) +
               2          r_33(1)*(dsource-0.1) + ziso;
               2
               2          XMAX_YMIN_ZMAX = r_11(1)*(BEAM_SIZE/2) + r_12(1)*(-BEAM_SIZE/2) +
               2          r_13(1)*(dsource-0.1) + xiso;
               2          YMIN_XMAX_ZMAX = r_21(1)*(BEAM_SIZE/2) + r_22(1)*(-BEAM_SIZE/2) +
               2          r_23(1)*(dsource-0.1) + yiso;
               2          ZMAX_XMAX_YMIN = r_31(1)*(BEAM_SIZE/2) + r_32(1)*(-BEAM_SIZE/2) +
               2          r_33(1)*(dsource-0.1) + ziso;
               2
               2          XMAX_YMAX_ZMAX = r_11(1)*(BEAM_SIZE/2) + r_12(1)*(BEAM_SIZE/2) +
               2          r_13(1)*(dsource-0.1) + xiso;
               2          YMAX_XMAX_ZMAX = r_21(1)*(BEAM_SIZE/2) + r_22(1)*(BEAM_SIZE/2) +
               2          r_23(1)*(dsource-0.1) + yiso;
               2          ZMAX_XMAX_YMAX = r_31(1)*(BEAM_SIZE/2) + r_32(1)*(BEAM_SIZE/2) +
               2          r_33(1)*(dsource-0.1) + ziso;
               2
               2          OUTPUT17 3,'QUAD',
               2          XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               2          XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX,
               2          XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX,
               2          XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN;
               2          (' ',I1,A4,12(F7.2,','));
               2          OUTPUT17 3,'QUAD',
               2          XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               2          XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               2          XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               2          XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN;
               2          (' ',I1,A4,12(F7.2,','));
               2          OUTPUT17 3,'QUAD',
               2          XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               2          XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               2          XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               2          XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX;
               2          (' ',I1,A4,12(F7.2,','));
               2          OUTPUT17 3,'QUAD',
               2          XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN,
               2          XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN,
               2          XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               2          XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX;
               2          (' ',I1,A4,12(F7.2,','));
               2          OUTPUT17 3,'QUAD',
               2          XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               2          XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               2          XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN,
               2          XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN;
               2          (' ',I1,A4,12(F7.2,','));
               2          OUTPUT17 3,'QUAD',
               2          XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX,
               2          XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               2          XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               2          XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX;
               2          (' ',I1,A4,12(F7.2,','));
               2
               2          IF(isource=8)[ "output the other positions of the source plane"
               3              DO I=2,numang[
               4                  XMIN_YMIN_ZMIN = r_11(I)*(-BEAM_SIZE/2) + r_12(I)*(-BEAM_SIZE/2) +
               4                  r_13(I)*(dsource+0.1) + xiso;
               4                  YMIN_XMIN_ZMIN = r_21(I)*(-BEAM_SIZE/2) + r_22(I)*(-BEAM_SIZE/2) +
               4                  r_23(I)*(dsource+0.1) + yiso;
               4                  ZMIN_XMIN_YMIN = r_31(I)*(-BEAM_SIZE/2) + r_32(I)*(-BEAM_SIZE/2) +
               4                  r_33(I)*(dsource+0.1) + ziso;
               4
               4                  XMIN_YMAX_ZMIN = r_11(I)*(-BEAM_SIZE/2) + r_12(I)*(BEAM_SIZE/2) +
               4                  r_13(I)*(dsource+0.1) + xiso;
               4                  YMAX_XMIN_ZMIN = r_21(I)*(-BEAM_SIZE/2) + r_22(I)*(BEAM_SIZE/2) +
               4                  r_23(I)*(dsource+0.1) + yiso;
               4                  ZMIN_XMIN_YMAX = r_31(I)*(-BEAM_SIZE/2) + r_32(I)*(BEAM_SIZE/2) +
               4                  r_33(I)*(dsource+0.1) + ziso;
               4
               4                  XMAX_YMIN_ZMIN = r_11(I)*(BEAM_SIZE/2) + r_12(I)*(-BEAM_SIZE/2) +
               4                  r_13(I)*(dsource+0.1) + xiso;
               4                  YMIN_XMAX_ZMIN = r_21(I)*(BEAM_SIZE/2) + r_22(I)*(-BEAM_SIZE/2) +
               4                  r_23(I)*(dsource+0.1) + yiso;
               4                  ZMIN_XMAX_YMIN = r_31(I)*(BEAM_SIZE/2) + r_32(I)*(-BEAM_SIZE/2) +
               4                  r_33(I)*(dsource+0.1) + ziso;
               4
               4                  XMAX_YMAX_ZMIN = r_11(I)*(BEAM_SIZE/2) + r_12(I)*(BEAM_SIZE/2) +
               4                  r_13(I)*(dsource+0.1) + xiso;
               4                  YMAX_XMAX_ZMIN = r_21(I)*(BEAM_SIZE/2) + r_22(I)*(BEAM_SIZE/2) +
               4                  r_23(I)*(dsource+0.1) + yiso;
               4                  ZMIN_XMAX_YMAX = r_31(I)*(BEAM_SIZE/2) + r_32(I)*(BEAM_SIZE/2) +
               4                  r_33(I)*(dsource+0.1) + ziso;
               4
               4                  XMIN_YMIN_ZMAX = r_11(I)*(-BEAM_SIZE/2) + r_12(I)*(-BEAM_SIZE/2) +
               4                  r_13(I)*(dsource-0.1) + xiso;
               4                  YMIN_XMIN_ZMAX = r_21(I)*(-BEAM_SIZE/2) + r_22(I)*(-BEAM_SIZE/2) +
               4                  r_23(I)*(dsource-0.1) + yiso;
               4                  ZMAX_XMIN_YMIN = r_31(I)*(-BEAM_SIZE/2) + r_32(I)*(-BEAM_SIZE/2) +
               4                  r_33(I)*(dsource-0.1) + ziso;
               4
               4                  XMIN_YMAX_ZMAX = r_11(I)*(-BEAM_SIZE/2) + r_12(I)*(BEAM_SIZE/2) +
               4                  r_13(I)*(dsource-0.1) + xiso;
               4                  YMAX_XMIN_ZMAX = r_21(I)*(-BEAM_SIZE/2) + r_22(I)*(BEAM_SIZE/2) +
               4                  r_23(I)*(dsource-0.1) + yiso;
               4                  ZMAX_XMIN_YMAX = r_31(I)*(-BEAM_SIZE/2) + r_32(I)*(BEAM_SIZE/2) +
               4                  r_33(I)*(dsource-0.1) + ziso;
               4
               4                  XMAX_YMIN_ZMAX = r_11(I)*(BEAM_SIZE/2) + r_12(I)*(-BEAM_SIZE/2) +
               4                  r_13(I)*(dsource-0.1) + xiso;
               4                  YMIN_XMAX_ZMAX = r_21(I)*(BEAM_SIZE/2) + r_22(I)*(-BEAM_SIZE/2) +
               4                  r_23(I)*(dsource-0.1) + yiso;
               4                  ZMAX_XMAX_YMIN = r_31(I)*(BEAM_SIZE/2) + r_32(I)*(-BEAM_SIZE/2) +
               4                  r_33(I)*(dsource-0.1) + ziso;
               4
               4                  XMAX_YMAX_ZMAX = r_11(I)*(BEAM_SIZE/2) + r_12(I)*(BEAM_SIZE/2) +
               4                  r_13(I)*(dsource-0.1) + xiso;
               4                  YMAX_XMAX_ZMAX = r_21(I)*(BEAM_SIZE/2) + r_22(I)*(BEAM_SIZE/2) +
               4                  r_23(I)*(dsource-0.1) + yiso;
               4                  ZMAX_XMAX_YMAX = r_31(I)*(BEAM_SIZE/2) + r_32(I)*(BEAM_SIZE/2) +
               4                  r_33(I)*(dsource-0.1) + ziso;
               4
               4                  OUTPUT17 3,'QUAD',
               4                  XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               4                  XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX,
               4                  XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX,
               4                  XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  OUTPUT17 3,'QUAD',
               4                  XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               4                  XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               4                  XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               4                  XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  OUTPUT17 3,'QUAD',
               4                  XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               4                  XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               4                  XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               4                  XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  OUTPUT17 3,'QUAD',
               4                  XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN,
               4                  XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN,
               4                  XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               4                  XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  OUTPUT17 3,'QUAD',
               4                  XMIN_YMIN_ZMIN,YMIN_XMIN_ZMIN,ZMIN_XMIN_YMIN,
               4                  XMIN_YMIN_ZMAX,YMIN_XMIN_ZMAX,ZMAX_XMIN_YMIN,
               4                  XMAX_YMIN_ZMAX,YMIN_XMAX_ZMAX,ZMAX_XMAX_YMIN,
               4                  XMAX_YMIN_ZMIN,YMIN_XMAX_ZMIN,ZMIN_XMAX_YMIN;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  OUTPUT17 3,'QUAD',
               4                  XMIN_YMAX_ZMIN,YMAX_XMIN_ZMIN,ZMIN_XMIN_YMAX,
               4                  XMIN_YMAX_ZMAX,YMAX_XMIN_ZMAX,ZMAX_XMIN_YMAX,
               4                  XMAX_YMAX_ZMAX,YMAX_XMAX_ZMAX,ZMAX_XMAX_YMAX,
               4                  XMAX_YMAX_ZMIN,YMAX_XMAX_ZMIN,ZMIN_XMAX_YMAX;
               4                  (' ',I1,A4,12(F7.2,','));
               4                  ]
               3              ]
               2          IF(isource=20 | isource=21)[ "supress output the other positions"
               3              " of the source planes"
               3              OUTPUT17;(/' Not displaying all 10000 source planes'/)
               3              ]
               2          ]
               1      ]
               0
               0  call srcout;
               0
               0  IF(howfarless) call modify_tmxs(MIN(mindelX,mindelY,mindelZ));
               0
               0  OUTPUT61;(/' Medium',t24,'AE',t34,'AP');
               0  DO n=1,NMED[OUTPUT61 (media(j,n),j=1,15),ae(n),ap(n);(1x,15a1,2f10.3);]
               0
               0  "RESTART FEATURES"
               0  "================"
               0  DO irl=1,irmax[endep_last(irl)=0;] "always zero this array"
               0
               0  IHSTRY=0; "always zero this as well"
               0
               0  IF(IRESTART = 0)["START A NEW RUN"
               1      nnread = 0;"initialize counter"
               1      nsmiss=0;       nmissm=0; ncaseold=0;
               1      nsrjct=0;       nsoutside=0; ndbsrjct=0;
               1      planarefe=0.;   planarefp=0.;
               1      planarfe=0.;    planarfp=0.;
               1      NofREPEAT = 0;  esrc=0.;      nestep=0;
               1      nhist=0; more_in_cont=0; "src10 and 11boolean"
               1      frMU_indx=-1.0; nsblocked=0;
               1      "-- no particles in container to start so read from the phase space"
               1
               1      IF(IPARALLEL>1 & PARNUM>0)[
               2          nnphsp=INT((PARNUM-1)*nshist/IPARALLEL)+1;
               2          ]
               1      ELSE[
               2          nnphsp=1;
               2          ]
               1      IF(i_iaea_in=1)[
               2          $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               2          ]
               1      "Zero the main scoring array
               1      DO irl=1,irmax[
               2          endep(irl)=0.0;
               2          endep2(irl)=0.0;
               2          endep_tmp(irl)=0.0;
               2          ]
               1      tcpuold=0.;
               1      ]
               0  ELSEIF(IRESTART = 1)["READ DATA FROM A PREVIOUS RUN"
               1      OUTPUT; (/' *** About to read dose data from previous run ***');
               1      i_par_temp=i_parallel;
               1      IF(IPARALLEL>0 & n_parallel=0) i_parallel=0;
               1      iorstrt=egs_open_datfile(iorstrt,0,1,'.egsdat');
               1      i_parallel=i_par_temp;
               1      DO irl=1,irmax[
               2          READ(iorstrt,*)endep(irl),endep2(irl);
               2          ]
               1      READ(iorstrt,*) ncaseold,nnread,nsmiss,nmissm,nnphsp,NofREPEAT,tcpuold,esrc,
               1      planarefe,planarefp,planarfe,planarfp,nestep,nsrjct,nsoutside,ndbsrjct,
               1      nhist,nsblocked;
               1      $RETRIEVE RNG STATE FROM UNIT iorstrt;
               1      CLOSE(iorstrt);
               1      OUTPUT61 ncaseold;     (/' Histories finshed in previous run',i12);
               1      IF(isource=2 | isource=8 | isource=9)[
               2          OUTPUT61 nhist; (/' Equivalent no. of primary histories',i12);
               2          ]
               1      OUTPUT61 tcpuold/3600.;(/' Total previou CPU time (hour)    ',f10.3);
               1      OUTPUT61;(/' Random number seeds for restart  ',$);
               1      $SHOW-RNG-STATE(6);
               1      $SHOW-RNG-STATE(1);
               1      OUTPUT;(/' ***Successfully read previous dose data file ***');
               1      ]
               0  ELSEIF(IRESTART = 2)["Just create the input file and then quit" GO TO :END:; ]
               0
               0  ELSEIF(IRESTART = 3)["Just do a data analysis"
               1      NCASE=0;
               1      OUTPUT; (/' *** About to read dose data from previous run ***');
               1      i_par_temp=i_parallel;
               1      IF(IPARALLEL>0 & n_parallel=0) i_parallel=0;
               1      iorstrt=egs_open_datfile(iorstrt,0,1,'.egsdat');
               1      i_parallel=i_par_temp;
               1      DO irl=1,irmax[
               2          READ(iorstrt,*)endep(irl),endep2(irl);
               2          ]
               1      READ(iorstrt,*) ncaseold,nnread,nsmiss,nmissm,nnphsp,NofREPEAT,tcpuold,esrc,
               1      planarefe,planarefp,planarfe,planarfp,nestep,nsrjct,nsoutside,ndbsrjct,
               1      nhist,nsblocked;
               1      $RETRIEVE RNG STATE FROM UNIT iorstrt;
               1      CLOSE(iorstrt);
               1      OUTPUT61 ncaseold;(/' Histories finished in previous run',i12);
               1      OUTPUT61 tcpuold/3600.;(/' Total CPU time (hour) by then    ',f10.3);
               1      timcpu=0;
               1      NCASE=0;
               1      OUTPUT;(/' ***Successfully read previous dose data file ***');
               1      GO TO :STAT-ANALYSIS:;
               1      ]
               0  ELSEIF(IRESTART=4)["just combine .pardose files"
               1      call egs_combine_runs(combine_results,'.pardose');
               1      ainflu=temp2; "need to define this because it is used to normalize dose"
               1      IF((isource = 0 | isource = 1 | isource = 3 | isource = 7) &
               1      beamarea>0.) ainflu=ainflu/beamarea;
               1      goto :ANALYZE-PARALLEL:;
               1      ]
               0
               0  "open phase space file for writing if requested"
               0  IF(i_phsp_out~=0)[
               1      phsp_out_fn=$DIRECTORY-FOR-PHSP // $file_sep //
               1      $cstring(output_file);
               1      IF( i_parallel > 0 ) ["add an _w"
               2          phsp_out_fn=$cstring(phsp_out_fn)// '_w';
               2          call egs_itostring(phsp_out_fn,i_parallel,.false.);
               2          ]
               1      "name must be null terminated"
               1      phsp_out_fn=$cstring(phsp_out_fn)//char(0);
               1      $DOSXYZ_OPEN_PHSP_FOR_WRITE;
               1      ]
               0
               0  "           Range rejection initialization                             ""toc:
               0  "           ******************************
               0
               0  IF (IREJECT = 1) ["do range rejection "
               1      OUTPUT61 ESAVE_GLOBAL;
               1      (/' Will perform charged-particle range rejection against voxel boundaries'/
               1      ' if particle energy is below ',F12.5,' MeV.');
               1      IF (ESAVE_GLOBAL <= ECUTIN) [
               2          OUTPUT61 ;(///' ******  NB ESAVE_GLOBAL <= ECUT  so NO Range Rejection',
               2          ' ***' //);
               2          IREJECT=0;
               2          ]
               1      ELSE[
               2          "calculate range from ECUTIN to AE for use in range rejection macro"
               2          "must do this for each medium"
               2          lelec=-1;
               2          DO MEDIUM=1,NMED[
               3              IF (ECUTIN = AE(MEDIUM))[
               4                  RANGE_ECUTRR(MEDIUM)=0.0;
               4                  ]
               3              ELSE[
               4                  EKE = ECUTIN- RM;
               4                  ELKE = LOG(EKE);
               4                  $SET INTERVAL ELKE, EKE;
               4                  EKEI = E_array(LELKE,MEDIUM);
               4                  ELKEI = (LELKE - eke0(MEDIUM))/eke1(MEDIUM);
               4                  $COMPUTE-DRANGE(EKE,EKEI,LELKE,ELKE,ELKEI,RANGE_ECUTRR(MEDIUM));
               4                  RANGE_ECUTRR(MEDIUM)=RANGE_ECUTRR(MEDIUM)+range_ep(0,LELKE,MEDIUM);
               4                  "note that this is not yet scaled for non-default density"
               4                  "scaling will be done on the fly"
               4                  ]
               3              ]
               2          ]
               1      ]
               0  ELSE["no range rejection"
               1      IREJECT=0; "set default"
               1      OUTPUT61; (/' No range rejection.');
               1      IF(ESAVE_GLOBAL > ECUTIN)[
               2          OUTPUT61;
               2          (T10,' Why is ESAVE_GLOBAL set when there is no range rejection?',
               2          /T15,'It is set to zero'/);
               2          ESAVE_GLOBAL = 0.0;
               2          ]
               1      ]
               0
               0
               0  IF(n_split > 1)[
               1      iausfl(8)  = 1; "After bremsstrahlung"
               1      iausfl(14) = 1; "A positron has annihilated in-flight"
               1      iausfl(15) = 1; "A positron has annihilated at rest"
               1      OUTPUT61 n_split; (/' Photons will be split ',I4,' times'/);
               1      ]
               0
               0  OUTPUT61;(//' ***************************************************************');
               0  IF(isource=20)[
               1      OUTPUT61 NCASE;
               1      (/ '  Histories to be simulated into the phantom for this run ',i12);
               1      OUTPUT61 compensated_NCASE;
               1      (  / '  Predicted histories required ',i12);
               1      ]
               0  ELSE[
               1      OUTPUT61 NCASE; (/ '  Histories to be simulated for this run ',i12);
               1      OUTPUT61 ncaseold+NCASE; (/ '  Histories to be analyzed after this run',i12);
               1      ]
               0  OUTPUT61;(/ ' ***************************************************************');
               0
               0  "Step 8   shower call                                   ""toc:
               0  "====================
               0
               0  "open the .egsdat file if called for"
               0  IF(IDAT=0 | IDAT=2)[
               1      i_par_temp=i_parallel;
               1      IF(IPARALLEL>0 & n_parallel=0) i_parallel=0;
               1      "avoids adding double _w extensions if"
               1      "parallel job controlled by script"
               1      iorstrt=egs_open_file(iorstrt,0,1,'.egsdat');
               1      i_parallel=i_par_temp;
               1      ]
               0
               0  IF(IWATCH ~= 0)[call watch(-99,IWATCH);] "Set up for watch routine if needed
               0
               0  $SET_ELAPSED_TOTAL_TIME(TIMEB);
               0  OUTPUT61 TIMEB;('   Elapsed wall clock time to this point=',f12.3,' s'/);
               0  $INITIALIZE_ELAPSED_TOTAL_TIME; "reset to get elapsed time during run only"
               0  ETIMETOT=0; "initialize total elapsed time"
               0  $SET_ELAPSED_CPUTIME(cput1);
               0  OUTPUT61 cput1 - cput0;
               0  (/'   CPU time so far for this run =',f12.3,' s'/);
               0
               0  NETADJ=0;  "initialize number of times elapsed time adjusted"
               0
               0  CYCLNUM=0; "initialize counter for number of times particles recycled"
               0
               0  nhist_last=0;
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  n_tot = ncaseold; first_time = .true.; is_finished = .false.;
               0  /part_dose,part2_dose/=0;
               0  "I'm not sure what is a good quantity to put into the job control file =>"
               0  "just use 0 for now"
               0
               0  :start_parallel_loop:;
               0
               0  IF(isource = 20 | isource = 21)["reset more_in_cont and MU index for every"
               1      "chunk"
               1      more_in_cont=0;
               1      frMU_indx=-1.0;
               1      ]
               0  IF( n_parallel > 0 ) [  "Job is part of a parallel run "
               1
               1      call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
               1      current_result, current_uncertainty);
               1      IF( n_run = 0 ) [
               2          write(6,'(//a,a//)') '****** No histories left in job control file',
               2          '       => end simulation';
               2          goto :STAT-ANALYSIS:;
               2          ]
               1      jcase = n_run/$NBATCH;
               1      IF( jcase < 1 ) [ jcase = 1; n_run = jcase*$NBATCH; ]
               1      IF( first_time ) [
               2          IF(isource=2|isource=8|isource=20)
               2          p_per_phsp_chunk=nshist/(n_parallel*$N_CHUNKS);
               2          first_time = .false.; n_last = n_run;
               2          write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
               2          ]
               1      ELSE [
               2          write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
               2          write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
               2          '      current result including previous runs and other parallel jobs: ',
               2          current_result, ' +/- ',current_uncertainty,' %',
               2          '      will run another ',n_run,' histories';
               2          ]
               1      IF(isource=2|isource=8|isource=20)[
               2          "    figure out where to start in the phase space file"
               2          "    if ncase/(n_parallel*$N_CHUNKS) has a remainder, then the last chunk"
               2          "    of the phase space file will be used twice.  This should not cause"
               2          "    too much underestimate of uncertainty"
               2          n_run_chunk=(ncase-n_left)*n_parallel*$N_CHUNKS/ncase;
               2          other_num_1=n_run_chunk*ncase;
               2          other_num_2=(ncase-n_left)*n_parallel*$N_CHUNKS;
               2          IF(other_num_1<other_num_2)[
               3              "ncase/(n_parallel*$N_CHUNKS) is not an integer"
               3              "and so n_run, no of histories in each chunk, has been rounded down"
               3              n_run_chunk=n_run_chunk+1;
               3              ]
               2          nnphsp_min=(n_run_chunk-1)*p_per_phsp_chunk+1;
               2          IF(n_left=0)["this is the last run just use up the rest of the"
               3              "phsp source"
               3              nnphsp_max=nshist;
               3              ]
               2          ELSE["calculate the max value of nnphsp"
               3              nnphsp_max=nnphsp_min+p_per_phsp_chunk-1;
               3              ]
               2          nnphsp=nnphsp_min;
               2          IF(i_iaea_in=1)[
               3              $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               3              ]
               2          CYCLNUM=0; "reset NRCYCL counter"
               2          write(6,'(/a/,a,i12,a,i12/,a//)')
               2          '      This simulation uses a phase space source.',
               2          '      This run will use from particle',nnphsp_min,' to particle ',
               2          nnphsp_max,
               2          '      in the source file.';
               2          ]
               1      ]
               0  #endif;
               0
               0  DO ibatch = 1,$NBATCH["Break into $NBATCH batches"
               1
               1      IF(ibatch =  1)[
               2          CALL DATETIME(1); "argument is a dummy"
               2          OUTPUT61 TIMEN;
               2          (/' BATCH #',2X,'TIME-ELAPSED',2X,'TOTAL CPUTIME',2X,'RATIO',2X,
               2          'TIME OF DAY',2X,'RNG pointers'//
               2          ' ',4X,'1',10X,'0.0',12X,'0.0',6X,'0.00',4X,$TIMEN_FORMAT,'  ',$);
               2          $SHOW-RNG-STATE(6);$SHOW-RNG-STATE(1);OUTPUT61;(' ');
               2          ]
               1      ELSE[
               2          $SET_ELAPSED_TOTAL_TIME(TIMEB);
               2          ETIMETOT=ETIMETOT+TIMEB;
               2          $SET_ELAPSED_CPUTIME(CPUT2);
               2          CALL DATETIME(1);
               2          TIMCPU=CPUT2-CPUT1;
               2          OUTPUT61 IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU,TIMEN;
               2          (4X,I2,5X,F8.1,7X,F8.1,2X,F8.2,4X,$TIMEN_FORMAT,'  ',$);
               2          $SHOW-RNG-STATE(6);$SHOW-RNG-STATE(1);OUTPUT61;(' ');
               2          "Check there is time left for another batch"
               2          BATCHT=TIMCPU/FLOAT(IBATCH-1);"Time per batch so far"
               2          IF(TIMCPU+1.1*BATCHT >  TIMMAX*3600.)[
               3              "Not enough time for another batch"
               3              "Print message and exit simulation loop"
               3              OUTPUT61;(' Not enough time for another batch within time limit');
               3              ]
               2
               2          ;$BEAMMODEL_DATA_OUTPUT;
               2          "analysis data for beam characterization models"
               2          ]
               1
               1      DO ihist = 1,jcase[
               2
               2          nhist_old=nhist;
               2
               2          IHSTRY=IHSTRY+1;
               2
               2          IF(isource=21 & more_in_cont=0)[
               3              frMU_indx = -1.0; "initialize frMU_indx to -1.0. It will either be"
               3              " changed in BEAM or in dosxyznrc after srchst"
               3              ]
               2
               2          call srchst(xin,yin,zin,uin,vin,win,irin,weight,latchi);
               2
               2          "srchst also returns in comin source esrc_sp, the sampled k.e."
               2          "       (enflag=1 cases) and einsrc, the total initial energy"
               2          "       for phase space inputs.  Also, if this is a new phase"
               2          "       space file, it returns nhist, the total no. of primary"
               2          "       histories used that scored particles in the phsp file."
               2
               2          "IF(((isource=20)|(isource=21 ))& weight=0)["
               2          "This check has been removed and the blocked particles are now counted"
               2          "as nsblocked in srcxyznrc.mortran (JL)"
               2          "this happens if a particle "
               2          "is blocked by shared library modules (only source 20 or 21)"
               2          " IHSTRY=IHSTRY-1;""do not count this particle as one"
               2          "that contributed"
               2          "]"
               2          "ELSE["
               2          "increment esrc, the kinetic+Q energy incident on the phantom"
               2          "-----------------------------------------------------------------"
               2          IF(enflag = 1)["Particle energy sampled from a spectrum"
               3              "-----------------------------------------------------------------"
               3              "esrc_sp is the kinetic energy"
               3              esrc = esrc + weight*esrc_sp;"we only count the kinetic E for the "
               3              "electrons and photons in the total incident E"
               3              IF(iqin =1)[ esrc = esrc +  weight*1.0220068;
               4                  "we include 2 0.511 MeV photons from e+ - e- annihilation"]
               3              IF(iqin ~= 0)[ etotin = esrc_sp + prm;"particle total E"]
               3              ELSE[etotin = esrc_sp;]
               3              ]
               2          "-----------------------------------------------------------------"
               2          ELSEIF(enflag = 2 | enflag = 3)["phase-space input or BEAM sim."
               3              "-----------------------------------------------------------------"
               3              etotin = einsrc;   "einsrc is the total energy of the particle"
               3              IF(iqin = -1)   [esrc = esrc + weight*(etotin - prm);
               4                  "remove e- rest mass"]
               3              ELSEIF(iqin = 0)[esrc = esrc + weight*etotin; ]
               3              ELSEIF(iqin = 1)[esrc = esrc + weight*(etotin + prm);
               4                  "add 0.511 for the positron but was - till June 97"
               4                  ]
               3              ]
               2          "-----------------------------------------------------------------"
               2          ELSEIF(enflag = 4)[ ;$BEAMMODEL-SOURCE4-ENERGY; ]
               2          "-----------------------------------------------------------------"
               2          ELSEIF(enflag > 5 )[ OUTPUT enflag;(' Wrong enflag:',I10); STOP; ]
               2          "-----------------------------------------------------------------"
               2
               2          IF(IWATCH > 0)[ WRITE(6,:INITIAL-SHOW-VALUE:)
               3              1,etotin,iqin,irin,xin,yin,zin,uin,vin,win,latchi,weight;
               3              :INITIAL-SHOW-VALUE: FORMAT(/' Initial shower values',
               3              t36,':',i3,f9.3,2i4,3f8.3,3f7.3,i10,1pe10.3);
               3              ]
               2
               2          "Determine on-axis planar and energy fluence in 1cm^2 area"
               2          IF(xin*xin+yin*yin<0.31831)[
               3              IF(iqin ~= 0)[
               4                  planarfe=planarfe+weight;
               4                  planarefe=planarefe+(etotin-prm)*weight;
               4                  ]
               3              ELSE["photons"
               4                  planarfp=planarfp+weight;
               4                  planarefp=planarefp+etotin*weight;
               4                  ]
               3              ]
               2
               2          IF((isource~=2 & isource~=8 & isource~=9 & isource~=20 & isource~=21 &
               2          isource~=10) |
               2          (dose_stat=1 & NRCYCL=0) |
               2          (dose_stat=1 & CYCLNUM=1) |
               2          ((isource=2 | isource=8 | isource=20) &
               2          (dose_stat=0 & ihist=1 & IBATCH=1 & nhist=nhist_old) &
               2          ((IPARALLEL>1 & PARNUM>0) | ( n_parallel>0)))) nhist=nhist+1;
               2          "we have a non-phsp, non-simulation source, we cannot get number of"
               2          "of primary histories from the phase space source AND we are not"
               2          "recycling or we are at the first particle in the cycle, or this"
               2          "particular partition of the phsp source (parallel run) does not"
               2          "start with the first particle from a new primary history."
               2
               2          IF(nhist~=nhist_old)["we have incremented nhist"
               3              nhist_last=nhist_last+1;
               3              IF(nhist_last=32700)[ "we are near the limit of nhist_last"
               4                  "reset nhist_last to 1 and endep_last to 0"
               4                  DO irl=1,irmax-1[
               5                      endep_last(irl)=0;
               5                      ]
               4                  nhist_last=1;
               4                  ]
               3              ]
               2
               2          IF( (iqin ~= 0 & e_split > 1 & n_split>1) &
               2          (isource = 2 | isource = 8 | isource = 9 | isource = 10 |
               2          isource = 20 | isource =21) ) [
               3              n_repeat = e_split;
               3              ] ELSE [ n_repeat = 1; ]
               2
               2          DO i_repeat = 1,n_repeat [
               3              "==========================================================="
               3              call shower(iqin,etotin,xin,yin,zin,uin,vin,win,irin,weight/n_repeat);
               3              "==========================================================="
               3              ]
               2
               2          IF(IWATCH ~= 0) call watch(-1,IWATCH);
               2          "]""end of source 20,21 else statement"
               2          ]"end of ihist loop"
               1
               1      $SET_ELAPSED_CPUTIME(cput2);"Final cpu for batch - only used for last"
               1      "batch, but set here so write to file"
               1      "not included"
               1      timcpu=cput2-cput1;
               1
               1      "FINISHED BATCH, SAVE DATA TO A FILE if REQUESTED"
               1
               1      IF(i_phsp_out>0)[
               2          $DOSXYZ_SET_OUT_PHSP_HEADER;
               2          ]
               1
               1      IF(IDAT = 0 | (IDAT = 2 & ibatch = $NBATCH) ) ["store data"
               2          rewind(iorstrt); "overwrite previous data"
               2          DO irl=1,irmax[
               3              "add unscored portions of endep_tmp before writing"
               3              endep(irl)=endep(irl)+endep_tmp(irl);
               3              endep2(irl)=endep2(irl)+endep_tmp(irl)*endep_tmp(irl);
               3              endep_tmp(irl)=0.;
               3              WRITE(iorstrt,*)endep(irl),endep2(irl);
               3              ]
               2          WRITE(iorstrt,*)
               2          IHSTRY+ncaseold, nnread, nsmiss, nmissm, nnphsp,
               2          NofREPEAT, tcpuold+timcpu, esrc, planarefe, planarefp, planarfe,
               2          planarfp, nestep, nsrjct,nsoutside,ndbsrjct,nhist,nsblocked;
               2          $PUT RNG STATE ON UNIT iorstrt;
               2          ]
               1      ]"END OF IBATCH LOOP"
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]
               0
               0  #endif;
               0
               0  "close any files that we opened"
               0  IF(IDAT=0 | IDAT=2) close(iorstrt);
               0  IF(IWATCH=4) [
               1      close(ioutgph);
               1      close(ioutgeom);
               1      ]
               0
               0  IF(i_phsp_out>0)[" close output phsp file (JL 2013)"
               1      $IAEA_DESTROY_PHSP_FILE(i_unit_out);
               1      ]
               0
               0  :STAT-ANALYSIS:;                 "toc:
               0  "=============="
               0
               0  IF (IRESTART ~= 3)[
               1      OUTPUT61 timcpu,timcpu/3600.,dble(IHSTRY)/(timcpu/3600.);
               1      (/' Total CPU time for run =',f8.1,' s =',f8.3,' hr =>',
               1      F12.0,' hist/hr'/T3,' On  '$MACHINE' ');
               1      ]
               0  IF (IRESTART = 1) ["Case of restarting"
               1      OUTPUT61 timcpu+tcpuold,(timcpu+tcpuold)/3600.,dble(IHSTRY+ncaseold)
               1      /((timcpu+tcpuold)/3600.);
               1      (/' CPU time for this+previous run =',f8.1,' s =',f8.3,' hr =>',
               1      F12.0,' hist/hr'/T3,' On  '$MACHINE' ');
               1      ]
               0  ELSEIF (IRESTART = 3)["just data analysis"
               1      OUTPUT61 timcpu+tcpuold,(timcpu+tcpuold)/3600.,float(ncaseold)
               1      /((timcpu+tcpuold)/3600.);
               1      (/' Total CPU time for old run =',f8.1,' s =',f8.3,' hr =>',
               1      F12.0,' hist/hr'/T3,' On  '$MACHINE' ');
               1      ]
               0
               0
               0  IF(isource = 2 | isource = 8 )[ "Full phase-space source"
               1      OUTPUT61 nnread,nhist,nsrjct,nsoutside,ndbsrjct,nsmiss,
               1      float((NRCYCL+1)*(nnread-nsrjct-nsoutside-ndbsrjct)-nsmiss)/float(nnread),
               1      NRCYCL,IHSTRY+ncaseold,OUTCNT;
               1      (/'  ********************************************************************'/
               1      /' # of particles read from ph-sp file (N_read)                   =',i12/
               1      ' # of primary (non ph-sp) histories read from ph-sp file        =',i12/
               1      ' # of particles discarded due to charge/LATCH/W/multiple passer =',i12/
               1      ' # of particles discarded because beyond BEAM_SIZE              =',i12/
               1      ' # of photons rejected because beyond DBS splitting radius      =',i12/
               1      ' # of particles that missed geometry                            =',i12/
               1      '                              N_used/N_read                     =',f12.3/
               1      ' # of times each particle in ph-sp file recycled                 '/
               1      '         (last particle may be recycled less than this)         =',i12/
               1      ' # of ph-sp particles simulated (N_used)                        =',i12/
               1      ' # of times ph-sp file restarted in this run                    =',i12/
               1      /'  ********************************************************************');
               1
               1      ]
               0  ELSEIF(isource=9 | isource =10)["BEAM sim. of treatment head"
               1      OUTPUT61 nnread,nhist,nsrjct,nsoutside,ndbsrjct,nsmiss,IHSTRY+ncaseold,
               1      dble(IHSTRY+ncaseold)/float(nnread);
               1      (/'  ********************************************************************'//
               1      ' # of particles read from BEAM simulation (N_read)              =',i12/
               1      ' # of primary particles incident in BEAM simulation             =',i12/
               1      ' # of particles discarded due to charge/LATCH/W/multiple passer =',i12/
               1      ' # of particles discarded because beyond BEAM_SIZE              =',i12/
               1      ' # of photons rejected because beyond DBS splitting radius      =',i12/
               1      ' # of particles that missed geometry                            =',i12/
               1      ' # of particles simulated in DOSXYZnrc (N_used)                 =',i12/
               1      '                        N_used/N_read                           =',f12.3/
               1      /'  ********************************************************************');
               1
               1      ]
               0  ELSEIF(isource=20)["VCU sim."
               1      OUTPUT61 NCASE,survival_ratio,compensated_NCASE,nnread,nsrjct,nsoutside,
               1      ndbsrjct, nsmiss, nsblocked,IHSTRY+ncaseold,
               1      dble(IHSTRY+ncaseold)/(float(nnread)*(NRCYCL+1)),OUTCNT;
               1      (/'  ********************************************************************'//
               1      ' # of particles originally requested (NCASE)                    =',i12/
               1      '   predicted survival ratio (based on shared library blockage)  =',f12.3/
               1      ' # calculated number to read from phsp (NCASE/survival_ratio)   =',i12/
               1      ' # of primary particles incident in the simulation (nnread)     =',i12/
               1      ' # of particles discarded due to charge/LATCH/W/multiple passer =',i12/
               1      ' # of particles discarded because beyond BEAM_SIZE              =',i12/
               1      ' # of photons rejected because beyond DBS splitting radius      =',i12/
               1      ' # of particles that missed geometry                            =',i12/
               1      ' # of particles that got blocked by shared library modules      =',i12/
               1      ' # of particles used in DOSXYZnrc (N_used)                      =',i12/
               1      '                N_used/(nnread x N_recycle)                     =',f12.3/
               1      ' # of times ph-sp file restarted in this run                    =',i12/
               1      /'  ********************************************************************');
               1      ]
               0  ELSEIF(isource=21)["BEAM simulation used as source, incident from any angle"
               1      "and through MLC"
               1      OUTPUT61 nnread,nhist,nsrjct,nsoutside,ndbsrjct,nsmiss,nsblocked,
               1      IHSTRY+ncaseold,dble(IHSTRY+ncaseold)/float(nnread);
               1      (/'  ********************************************************************'//
               1      ' # of particles read from BEAM simulation (N_read)              =',i12/
               1      ' # of primary particles incident in BEAM simulation             =',i12/
               1      ' # of particles discarded due to charge/LATCH/W/multiple passer =',i12/
               1      ' # of particles discarded because beyond BEAM_SIZE              =',i12/
               1      ' # of photons rejected because beyond DBS splitting radius      =',i12/
               1      ' # of particles that missed geometry                            =',i12/
               1      ' # of particles that got blocked by shared library modules      =',i12/
               1      ' # of particles simulated in DOSXYZnrc (N_used)                 =',i12/
               1      '                        N_used/N_read                           =',f12.3/
               1      /'  ********************************************************************');
               1
               1      ]
               0  ELSEIF(isource = 1)["parallel beam from any direction"
               1      OUTPUT61 nmissm;
               1      (/'  ********************************************************************'/
               1      /'  # of particles which missed the phantom with source 1       =',i12/
               1      /'  ********************************************************************');
               1      ]
               0
               0  ELSEIF(isource =4 )[ ;$BEAMMODEL-SOURCE4-SUMMARY; ]
               0
               0
               0  "Step 9 Analyse and output results                        ""toc:
               0  "=================================
               0
               0  etot=0.;
               0
               0  "Correlated sampling no longer supported with history by history statistics"
               0  "$Corr_Dump;mah 09/05/95 To store DOSEIS to file. ";
               0
               0  "sum energy deposition in phantom"
               0  "Note that dose is still really just an energy deposition"
               0  DO irl=1,irmax-1[etot=etot+endep(irl);]
               0
               0  IF (enflag = 0)[
               1      "Known Bug - this doesn't handle positrons correctly yet"
               1      OUTPUT61 etot/(dble(IHSTRY+ncaseold)*ein);
               1      (/' Fraction of incident energy deposited in the phantom =',f12.4/);
               1      ]
               0  ELSEIF((enflag=1)|(enflag=2)|(enflag=3)|(enflag=4))[ ;OUTPUT61 etot/esrc;
               1      (/' Fraction of incident energy deposited in the phantom =',f12.4/);
               1      IF ((enflag > 1))[ OUTPUT61 endep(irl)/esrc;
               2          (/' Fraction of incident energy deposited in the region surrounding'/
               2          ' the phantom when incident particles go through it   =',f12.4/);
               2          ]
               1      ]
               0
               0  "Calculate incident fluence
               0  IF(isource = 0 | isource = 1 | isource = 3 | isource = 7)[
               1      temp2=dble(IHSTRY+ncaseold+nsmiss+nmissm);
               1      IF(beamarea = 0)[ ainflu=dble(IHSTRY+ncaseold+nsmiss+nmissm);]
               1      ELSE[             ainflu=dble(IHSTRY+ncaseold+nsmiss+nmissm)/beamarea;]
               1      ]
               0  ELSEIF(isource = 2 | isource = 8 )[
               1      ainflu=dble(IHSTRY+ncaseold+nsmiss+
               1      (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
               1      "IHSTRY+ncaseold is the number of particles"
               1      "actually simulated from the phase space source"
               1      "We then add nsmiss+(NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct), an estimate of"
               1      "the total number of particles rejected based on charge, LATCH, W,"
               1      "being a multiple passer, being outside BEAM_SIZE, falling beyond the"
               1      "directional bremsstrahlung splitting (DBS) radius, or missing the geometry"
               1      "The result is an estimate of the total number of particles read from the"
               1      "phase space source.  This number is then divided by nshist, the total"
               1      "number of particles in the phase space source, to give the number"
               1      "of times that the phase space source has been used (this could be <1)"
               1      "Finally, we multiply this by NINCSRC, the number of particles"
               1      "incident from the original (non-phase space) source that were used to"
               1      "obtain the phase space source.  The result is an estimate of the number"
               1      "of particles incident from the original (non-phase space) source for"
               1      "this simulation."
               1      temp2=ainflu;
               1      ]
               0  ELSEIF(isource=4)[
               1      ainflu=dble(IHSTRY+ncaseold-nsmiss);
               1      temp2=ainflu;
               1      ]
               0  ELSEIF(isource=6)[
               1      ainflu=dble(IHSTRY+ncaseold);
               1      temp2=ainflu;
               1      ]
               0  ELSEIF(isource=9|isource=10|isource=21)[
               1      "full BEAM simulation, here we can just read nhist"
               1      "the no. of primary histories"
               1      ainflu=dble(nhist);
               1      temp2=ainflu;
               1      ]
               0  ELSEIF(isource=20)["full VCU simulation"
               1
               1      "ainflu=dble(IHSTRY+ncaseold+nsmiss+nsblocked+"
               1      "(NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;"
               1
               1      ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
               1
               1      temp2=ainflu;
               1      ]
               0  OUTPUT61 nestep,dble(nestep)/ainflu,count_pII_steps/dble(nestep);
               0  (/' Number of charged particle steps simulated,   N_step       =',I15/
               0  ' Number of charged particle steps/incident fluence          =',1PE15.5/
               0  ' No. of PRESTA-II steps/total no. of charged particle steps =',0PF15.5/);
               0
               0  "Now calculate dose uncertainties"
               0  IF(dose_stat=1)[
               1      OUTPUT61;(//' ***WARNING***'/
               1      ' Could not read no. of primary (non-phsp) histories from ph-sp file.'/
               1      ' Dose analyzed assuming each particle read from the ph-sp'/
               1      ' file is an independent history.  May result in an underestimate'/
               1      ' of the uncertainty.'//);
               1      ]
               0  ELSEIF(OUTCNT>0)[
               1      OUTPUT61;(//' ***WARNING***'/
               1      ' The ph-sp source was restarted at least once.  This may lead'/
               1      ' to an underestimate of uncertainty, especially if restarted'/
               1      ' many times.  If restarted many times, try re-running with'/
               1      ' NRCYCL recalculated as described at top of dosxyznrc.mortran'//);
               1      ]
               0  DO irl = 1,irmax-1 [
               1      IF(IDAT=1)[
               2          "add unscored portion of endep_tmp(irl) first"
               2          endep(irl)=endep(irl)+endep_tmp(irl);
               2          endep2(irl)=endep2(irl)+endep_tmp(irl)*endep_tmp(irl);
               2          ]
               1      "divide by rhor so that we do not have to store rhor in the .pardose"
               1      "file during parallel runs."
               1      endep(irl)=endep(irl)/rhor(irl+1);
               1      endep2(irl)=endep2(irl)/(rhor(irl+1)*rhor(irl+1));
               1      ]
               0
               0  #ifdef HAVE_C_COMPILER;
               0
               0  "store endep and endep2 before analysis for a parallel run"
               0  IF(IPARALLEL>1 | n_parallel>0)[
               1
               1      "now determine the full file name with the proper _w addition"
               1      "this file is written directly into the user code directory"
               1      parname=$cstring(egs_home) // $cstring(user_code) // $file_sep //
               1      $cstring(work_dir) // $cstring(output_file);
               1      IF(n_parallel>0)[
               2          "have to add _w[iparallel] if not controlled by script"
               2          parname=$cstring(parname)//'_w';
               2          call egs_itostring(parname,i_parallel,.false.);
               2          ]
               1      parname=$cstring(parname)//'.pardose';
               1      "name must be null terminated"
               1      parname(lnblnk1(parname)+1:lnblnk1(parname)+1)=char(0);
               1
               1      call write_pardose(temp2,IMAX,JMAX,KMAX,endep,endep2,parname);
               1      ]
               0
               0  #endif;
               0
               0  :ANALYZE-PARALLEL:;
               0
               0  "Now analyze uncertainty and convert
               0  "to dose per unit incident fluence gray-cm**2
               0  DO i=1,IMAX [
               1      DO j=1,JMAX [
               2          DO k=1,KMAX [
               3
               3              "first, estimate uncertainty"
               3              irl= $IRD(i,j,k);
               3              temp=endep(irl)/temp2;
               3              endep2(irl)=endep2(irl)/temp2;
               3              endep2(irl)=(endep2(irl)-temp*temp)/(temp2-1);
               3              IF(endep2(irl)>0) endep2(irl)=sqrt(endep2(irl));
               3              IF(endep(irl)~=0) endep2(irl)=endep2(irl)/(endep(irl)/temp2);
               3
               3              "amass used to store mass but now just stores volume"
               3              amass=
               3              (xbound(i+1)-xbound(i))*
               3              (ybound(j+1)-ybound(j))*
               3              (zbound(k+1)-zbound(k));
               3              IF (amass~=0.0) [
               4                  endep(irl) = endep(irl)*1.602e-10/(amass*ainflu);
               4                  ]
               3              ELSE[
               4                  endep(irl) = 0.0;
               4                  OUTPUT61 i,j,k;
               4                  ('AMASS is zero in  I= ',I4,'J= ',I4,' K= ',I4);
               4                  OUTPUT61;('So the dose has been set to zero.');
               4                  ];
               3              IF(endep(irl)=0.) endep2(irl)=0.9999999;
               3              ]
               2          ]
               1      ]
               0  "       Output results
               0  "       ==============
               0
               0  REPLACE {$PRINT-HEADER;} WITH {;
            {  0  IF((n_parallel>0 & is_finished)|IRESTART=4 )[
            {  0  "fluence meaningless in final analysis"
            {  0  OUTPUT1 title;
            {  0  (//,'1',80a1 //
            {  0  t10,
            {  0  'DOSXYZnrc Dose outputs (dose/F, Gy.cm**2)');
            {  0  ]
            {  0  ELSE[
            {  0  IF(((isource.EQ.0).OR.( isource.EQ.1).OR.( isource.EQ.3).OR.
            {  0  (isource.EQ.7)).AND.
            {  0  (beamarea ~= 0.))[
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,ainflu;
            {  0  ( '1',80a1 //
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Average planar fluence (number/beam area), F =',
            {  0  1pe11.3,'(1/cm**2)'//
            {  0  t10,
            {  0  'DOSXYZnrc Dose outputs (dose/F, Gy.cm**2)');
            {  0  ]
            {  0  ELSEIF(isource.EQ.2.OR.isource.EQ.8)[
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,
            {  0  IHSTRY+ncaseold;
            {  0  ( '1',80a1 /
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'No. of particles incident from phase space file =',1i13/);
            {  0  IF(OLDSRC.EQ.1)[
            {  0  OUTPUT1;
            {  0  (t10,'           DOSXYZnrc Dose outputs '/
            {  0  t10,'(Dose/incident particle from phase space file, Gy)');
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT1 ainflu;
            {  0  (t5,'No. of particles incident from original source  =',1f13.1//
            {  0  t10,'           DOSXYZnrc Dose outputs '/
            {  0  t10,'(Dose/incident particle from original source, Gy)');
            {  0  ]
            {  0  ]
            {  0  ELSEIF(((isource.EQ.4).OR.(isource.EQ.5)).OR.
            {  0  (((isource.EQ.0).OR.( isource.EQ.1).OR.( isource.EQ.3).OR.
            {  0  (isource.EQ.7)).AND.(beamarea.EQ.0.)))[
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,ainflu;
            {  0  ( '1',80a1 /
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Total number of incident particles =',1pe11.3//
            {  0  t10,'DOSXYZnrc',
            {  0  ' Dose outputs (Dose/incident particle, Gy)');
            {  0  ]
            {  0  ELSEIF(isource.EQ.6)[
            {  0  OUTPUT1 title,ainflu;
            {  0  ( '1',80a1 /
            {  0  t5,'Total number of incident particles =',1pe11.3//
            {  0  t10,'DOSXYZnrc',
            {  0  ' Dose outputs (Dose/incident particle, Gy)');
            {  0  ]
            {  0  ELSEIF((isource.EQ.9).OR.(isource.EQ.21))[
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,
            {  0  IHSTRY+ncaseold,nhist;
            {  0  ( '1',80a1 /
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'         No. of particles incident on DOSXYZ phantom =',1i13//
            {  0  t5,'No. of primary particles incident in BEAM simulation =',1i13//
            {  0  t10,'           DOSXYZnrc Dose outputs '/
            {  0  t10,'(Dose/incident particle from original source, Gy)');
            {  0  ]
            {  0  ELSEIF(isource.EQ.20)[
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,
            {  0  IHSTRY+ncaseold,nhist;
            {  0  ( '1',80a1 /
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'         No. of particles incident on DOSXYZ phantom =',1i13//
            {  0  t5,'No. of primary particles incident in VCU/BEAM simulation =',1i13//
            {  0  t10,'           DOSXYZnrc Dose outputs '/
            {  0  t10,'(Dose/incident particle from original source, Gy)');
            {  0  ]
            {  0  ELSE["currently we do not have any other sources"
            {  0  OUTPUT1 title,planarefe,planarefp,planarfe,planarfp,ainflu;
            {  0  ( '1',80a1 /
            {  0  t5,'Elec/positron planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar energy fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Elec/positron planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'Photon planar fluence scored in a 1cm**2 circle '/
            {  0  t5,'centered at z-axis on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t5,'on the phantom surface =',1pe11.3,'(1/cm**2)'//
            {  0  t10,'DOSXYZnrc Dose outputs',
            {  0  '   Gy.cm**2 (or Gy/incident particle)');
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0  IF(doseprint ~= 1)[
               1      $PRINT-HEADER;
               1      OUTPUT1;(/t5,'full dose output suppressed in this run');
               1      ]
               0  ELSE[
               1      DO idose=1,idgrp [
               2          "Loop over groups of regions to analyse
               2
               2          IF(IZSCAN(idose) = 1) [
               3              "Do output with one z scan per page
               3              k = (kdosu(idose) - kdosl(idose));
               3              k = k + k/5 + 7;
               3              nperpg = 60/k; "Number of sets of depths per page";
               3              IF(nperpg = 0)[
               4                  OUTPUT nperpg;(' Sets of depths per page = ',I2);
               4                  nperpg = 1;
               4                  OUTPUT nperpg;(' Set to  = ',I2);
               4                  ]
               3              $PRINT-HEADER;
               3              ipage=1; "Count how many zgroups printed on this page
               3              DO i=idosl(idose),idosu(idose) [
               4                  DO j = jdosl(idose),jdosu(idose),4 [
               5                      JL=j;JU=min(j+3,jdosu(idose));
               5                      OUTPUT1 xbound(i),xbound(i+1),i;
               5                      (//t15,'for x=',f10.3,' to',f10.3,5x,'i=',i3);
               5                      OUTPUT1 (ybound(jj),jj=JL,JU+1);
               5                      (/' ybounds:',f7.3,f12.3,3f17.3);
               5                      OUTPUT1 (jj,jj=JL ,JU );(t10,'j=',t17,5(i4,13x));
               5                      OUTPUT1 zbound(kdosl(idose));(' zbounds (',f10.3,')');
               5                      DO k = kdosl(idose),kdosu(idose) [
               6                          OUTPUT1 zbound(k+1),k, (endep($IRD(i,jj,k)),
               6                          min(99.9d0, 100d0*endep2($IRD(i,jj,k))),jj=JL,JU);
               6                          (f8.3,i4,4(1pe11.3,'-',0pf4.1,'%') );
               6                          IF(mod(k,5) = 0)[OUTPUT1;(' ');]
               6                          ]
               5                      IF( ( mod(ipage,nperpg) = 0) & ( ( JU ~= jdosu(idose) ) |
               5                      ( i ~= idosu(idose) ))) [
               6                          $PRINT-HEADER;
               6                          ipage=1;
               6                          ]
               5                      ELSE [ ipage = ipage+1; ]
               5                      ]"end DO j"
               4                  ]"end DO i"
               3              ]"end (IZSCAN(idose) ~= 0) block"
               2
               2          ELSEIF(IZSCAN(idose) = 0) [ "Output x scans each page
               3              i = (idosu(idose) - idosl(idose));
               3              i = i + i/5 + 7;
               3              nperpg = 60/i; "Number of sets of bins per page
               3              IF(nperpg = 0)[
               4                  OUTPUT nperpg;(' Sets of X scans per page = ',I2);
               4                  nperpg = 1;
               4                  OUTPUT nperpg;(' Set to  = ',I2);
               4                  ]
               3              $PRINT-HEADER;
               3              ipage=1;
               3              DO k=kdosl(idose),kdosu(idose) [
               4                  DO j = jdosl(idose),jdosu(idose),4 [
               5                      JL=J;JU=min(j+3,jdosu(idose));
               5                      OUTPUT1 zbound(k),zbound(k+1),k;
               5                      (//t15,'for z=',f10.3,' to',f10.3,5x,'k=',i3);
               5                      OUTPUT1 (ybound(jj),jj=JL,JU+1);
               5                      (/' ybounds:',f7.3,f12.3,3f17.3);
               5                      OUTPUT1 (jj,jj=JL ,JU );(t10,'j=',t17,5(i4,13x));
               5                      OUTPUT1 xbound(idosl(idose));(' xbounds (',f10.3,')');
               5                      DO i = idosl(idose),idosu(idose) [
               6                          OUTPUT1 xbound(i+1),i, (endep($IRD(i,jj,k)),
               6                          min(99.9d0, 100d0*endep2($IRD(i,jj,k))),jj=JL,JU);
               6                          (f8.3,i4,4(1pe11.3,'-',0pf4.1,'%') );
               6                          IF(mod(i,5) = 0)[OUTPUT1;(' ');]
               6                          ]
               5                      IF( ( mod(ipage,nperpg) = 0) & ( ( JU ~= jdosu(idose) ) |
               5                      ( k ~= kdosu(idose) ))) [
               6                          $PRINT-HEADER;
               6                          ipage=1;
               6                          ]
               5                      ELSE [ ipage = ipage+1; ]
               5                      ]
               4                  ]
               3              ]"end ELSE"
               2
               2          ELSE ["Output y scans each page
               3              j = (idosu(idose) - idosl(idose));
               3              j = j + j/5 + 7;
               3              nperpg = 60/j; "Number of sets of bins per page
               3              IF(nperpg = 0)[
               4                  OUTPUT nperpg;(' Sets of Y scans per page = ',I2);
               4                  nperpg = 1;
               4                  OUTPUT nperpg;(' Set to  = ',I2);
               4                  ]
               3              $PRINT-HEADER;
               3              ipage=1;
               3              DO k=kdosl(idose),kdosu(idose) [
               4                  DO i = idosl(idose),idosu(idose),4 [
               5                      JL=i;JU=min(i+3,idosu(idose));
               5                      OUTPUT1 zbound(k),zbound(k+1),k;
               5                      (//t15,'for z=',f10.3,' to',f10.3,5x,'k=',i3);
               5                      OUTPUT1 (xbound(jj),jj=JL,JU+1);
               5                      (/' xbounds:',f7.3,f12.3,3f17.3);
               5                      OUTPUT1 (jj,jj=JL ,JU );(t10,'i=',t17,5(i4,13x));
               5                      OUTPUT1 ybound(jdosl(idose));(' ybounds (',f10.3,')');
               5                      DO j = jdosl(idose),jdosu(idose) [
               6                          OUTPUT1 ybound(j+1),j, (endep($IRD(jj,j,k)),
               6                          min(99.9d0, 100d0*endep2($IRD(jj,j,k))),jj=JL,JU);
               6                          (f8.3,i4,4(1pe11.3,'-',0pf4.1,'%') );
               6                          IF(mod(j,5) = 0)[OUTPUT1;(' ');]
               6                          ]
               5                      IF( ( mod(ipage,nperpg) = 0) & ( ( JU ~= idosu(idose) ) |
               5                      ( k ~= kdosu(idose) ))) [
               6                          $PRINT-HEADER;
               6                          ipage=1;
               6                          ]
               5                      ELSE [ ipage = ipage+1; ]
               5                      ]
               4                  ]
               3
               3
               3              ]"end ELSE"
               2
               2          ]
               1
               1      WRITE(1,'(''1'')');  "page throw under fortran control"
               1      ]
               0
               0  "if IPHANT is set to 1, write out a .egsphant file"
               0  IF(IPHANT=1 & (n_parallel=0|(n_parallel>0 & is_finished)))[
               1      call write_phantom(ioutphant,nmed,media,estepm,IMAX,JMAX,KMAX,xbound,ybound,
               1      zbound,rhor,med);
               1      ]
               0
               0  "zero doses in air in the .3ddose file if requested"
               0  IF(zeroairdose = 1)[
               1      DO i=1,IMAX[
               2          DO j=1,JMAX[
               3              DO k=1,KMAX[
               4                  IF(rhor($IR(i,j,k)) <= 0.044)[
               5                      endep($IRD(i,j,k))=0.0;
               5                      endep2($IRD(i,j,k))=0.9999999;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  "Now zero doses with errors >50% in the .3ddose file if requested"
               0  zerodose=$DOSEZERO;
               0  zerocount=0;
               0  IF(zerodose = 1)[
               1      DO i=1,IMAX[
               2          DO j=1,JMAX[
               3              DO k=1,KMAX[
               4                  IF(endep2($IRD(i,j,k))>0.5 & endep($IRD(i,j,k)) > 0.0)[
               5                      endep($IRD(i,j,k))=0.0;
               5                      endep2($IRD(i,j,k))=0.9999999;
               5                      zerocount=zerocount+1;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0  IF(zerodose=1 & zerocount >0)[
               1      OUTPUT61 zerocount;
               1      (/' The dose values in ',I10,' voxels had error > 50% and have been'/
               1      ' zeroed in the .3ddose file.'/);
               1      ]
               0
               0  "subroutine call replaces a portion of code to write to .3ddose file"
               0  "do not call if we are doing a parallel run"
               0  IF((IPARALLEL <= 1 & n_parallel = 0) | (n_parallel > 0 & is_finished))[
               1      call write_dose(IMAX,JMAX,KMAX,xbound,ybound,zbound,endep,endep2,idd,MAX20
               1      ,i_bindos);
               1      ]
               0  ELSE [OUTPUT61;(//' No dose outputs since this is a parallel run '//);]
               0
               0
               0  $SET_ELAPSED_CPUTIME(cput2);
               0  timcpu=$CONVERSION_TO_SECONDS*(cput2-cput0);
               0  OUTPUT61 timcpu,timcpu/3600.;
               0  (/' Total CPU time for this run =',f8.1,' s =',f8.3,' hr');
               0  IF(IRESTART=4)[
               1      OUTPUT61;(/' CPU time is for combining .pardose files only.');
               1      ]
               0  ELSEIF(n_parallel>0 & is_finished)[
               1      OUTPUT61;(/' CPU time is for last run to finish only.');
               1      ]
               0  CALL DATETIME(1);
               0  OUTPUT61 DATEN, TIMEN; (/' END OF RUN          ',A11,1X,A8/);
               0
               0  :END:;
               0
               0  call egs_finish;     " Finish the simulation "
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 & ~is_finished ) [
               1      call egs_pjob_finish(n_job);
               1      IF( n_job = 0 ) [
               2          is_finished = .true.;
               2          call egs_combine_runs(combine_results,'.pardose');
               2          ainflu=temp2; "need to define this because it is used to normalize dose"
               2          IF((isource = 0 | isource = 1 | isource = 3 | isource = 7) &
               2          beamarea>0.) ainflu=ainflu/beamarea;
               2          call show_transport_parameter(iout);
               2          call srcout;
               2          goto :ANALYZE-PARALLEL:;
               2          ]
               1      ]
               0  #endif;
               0
               0  IF(isource=9 | isource=21 | (isource=20 &
               0  SHLflag=1 & MLCflag=0)) call finish_beamsource;
               0
               0  IF((isource=20 | isource = 21) & MLCflag=1) [call finish_vcusource;]
               0
               0  $CALL_EXIT(0);
               0
               0  stop 'Normal completion in main routine';
               0  end;
               0  "  end of main routine in dosxyznrc.mortran"
1              0  %E    "dosxyznrc.mortran - start of subroutine ausgab"
               0  "*******************************************************************************
               0  "
               0  "                         ausgab
               0  "                         ======
               0  "
               0  subroutine ausgab(iarg);
               0  "
               0  "*******************************************************************************
               0  ;
               0  $IMPLICIT-NONE;
               0  COMIN/EPCONT,SCORE,STACK,USER,RANDOM,SOURCE,GEOM,CH-Steps,MISC,MEDIA,
               0  USEFUL,RWPHSP/;
               0  "SCORE has IWATCH, MXNP,NESTEP,DOSEIS"
               0
               0  $INTEGER iarg, "argument from EGSnrc (see SLAC-265, section A2.6, p260)"
               0  ip;   "looping variable"
               0  $REAL XSI; "used to perform russian roulette on higher-order photons when"
               0  "n_split > 1"
               0
               0  "variables for howfarless option"
               0  $INTEGER irx,iry,irz,irold_loc,irnew_loc,outside,min_plane,iri,i,ii,jj,kk,
               0  ibsearch4,hwfl_rr,dirx,diry,dirz;
               0  $REAL dist_loc, dist_tot, edep_loc, tv,t(2),xi,yi,zi,ui(2),vi(2),wi(2),
               0  dist_tmp,x_tmp,y_tmp,z_tmp,edep_save,x_loc,y_loc,z_loc,
               0  xpln,ypln,zpln,dnear_loc,t_tot,t_rnd,dist_max,uii,vii,wii,
               0  distx,disty,distz,edep_frac,x_temp,y_temp,z_temp,u_temp,v_temp,w_temp,
               0  zlast_tmp;
               0  LOGICAL ir_defined;
               0  SAVE xi,yi,zi,ui,vi,wi,tv,iri,edep_save;
               0  DATA edep_save/0.0/;
               0
               0  IF(IWATCH ~=0) call watch(iarg,IWATCH); "IWATCH passed in comin score
               0
               0  mxnp=max(mxnp,np); "Keep track of how deep stack gets
               0  IF(np >= $MXSTACK) [ OUTPUT61 np, $MXSTACK;
               1      (//' In ausgab, np=',i3,' >= maximum stack allowed which is',i3/
               1      1X,79('*')//);
               1      IF(mxnp > $MXSTACK) [OUTPUT61 np, $MXSTACK;
               2          (//' In ausgab, np=',i3,' > maximum stack allowed which is',i3/
               2          1X,79('*')//'  Must stop - you must increase $MXSTACK in'/
               2          '   dosxyz_user_macros.mortran');
               2          stop '*** Stack overflow ***'; "Must increase $MXSTACK"
               2          ]
               1      ]
               0
               0  IF( n_split > 1 ) [
               1      IF( iarg = 7 | iarg = 13 | iarg = 14 ) ["perform russian roulette on higher"
               2          "order photons"
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [
               4                  $RANDOMSET XSI;
               4                  IF( xsi*n_split > 1) [ wt(ip) = 0; e(ip) = 0; ]
               4                  ELSE [ wt(ip) = wt(ip)*n_split; ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  IF(howfarless & (iarg=15 | iarg=17 | iarg=19 | iarg=23) & ir(np)<irmax+1)[
               1      "photon about to create an electron or Rayleigh scatter"
               1      "find current region"
               1
               1      IF(x(np)>xbound_max | x(np)<xbound_min |
               1      y(np)>ybound_max | y(np)<ybound_min |
               1      z(np)>zbound_max | z(np)<zbound_min )[
               2          IF(enflag>1)[
               3              ir(np)=irmax+1;
               3              ]
               2          ELSE[
               3              ir(np)=1;
               3              ]
               2          ]
               1      ELSE[
               2          irx=ibsearch4(x(np),imax+1,xbound);
               2          iry=ibsearch4(y(np),jmax+1,ybound);
               2          irz=ibsearch4(z(np),kmax+1,zbound);
               2          ir(np)=$IR(irx,iry,irz);
               2          ]
               1      irold=ir(np);
               1      ]
               0
               0  IF(iarg >5) RETURN;
               0
               0  IF(howfarless & iarg>0 & edep_save>0.0)[ "howfarless version"
               1      "Have energy to deposit along the path"
               1      "Can enter here with iarg=1,2,3,4,5.  If iarg=5, this is the end"
               1      "of a normal step and we want to deposit energy.  If iarg<5, then"
               1      "this is the case where the particle is in the same region at the"
               1      "beginning of the step as it was at the end of the step AND the"
               1      "particle energy fell below ECUT,PCUT,AE or AP during the step."
               1      "In this case, we want to deposit the energy from the step, which"
               1      "is stored in edep_save and then fall through to the normal"
               1      "energy deposition condition below where the remainder of the particle"
               1      "energy is deposited."
               1
               1      "estimate total curves step as two straight-line steps, t(1) and t(2)"
               1      "with a hinge point.  Direction after hinge is ui(2),vi(2),wi(2)"
               1
               1
               1      $DECODEIR(irold,irx,iry,irz);
               1      IF( x(np) > xbound(irx) & x(np) < xbound(irx+1) &
               1      y(np) > ybound(iry) & y(np) < ybound(iry+1) &
               1      z(np) > zbound(irz) & z(np) < zbound(irz+1) ) [
               2          "in case full step still leaves it within the voxel"
               2          IF(nhist_last = endep_last(irold-1))[
               3              "same shower that deposited energy last time in this region"
               3              endep_tmp(irold-1) = endep_tmp(irold-1) + edep_save*wt(np);
               3              ]
               2          ELSE["we have the next shower depositing energy into region ir(np)"
               3              " => put endep_tmp into the scoring arrays and set endep_last"
               3              endep(irold-1)=endep(irold-1)+endep_tmp(irold-1);
               3              endep2(irold-1)=endep2(irold-1) +
               3              endep_tmp(irold-1)*endep_tmp(irold-1);
               3              endep_tmp(irold-1) = edep_save*wt(np);
               3              endep_last(irold-1)=nhist_last;
               3              ]
               2          irnew = irold;
               2          ]
               1      ELSE ["step definitely takes it out of current voxel"
               2
               2          IF(~is_ch_step)["single scattering mode, set t1=tv"
               3              t(1)=tv;
               3              t(2)=0.;
               3              ]
               2          ELSE["may have random hinge in step"
               3              $RANDOMSET t_rnd;
               3              IF(t_rnd<0.5)["base hinge on initial direction"
               4                  t(1)=1-((x(np)-xi)*ui(1)+(y(np)-yi)*vi(1)+(z(np)-zi)*wi(1))/tv;
               4                  IF(t(1)<1e-3)["do not bother with hinge, set t1=straight line"
               5                      "dist and reset initial u,v,w accordingly"
               5                      t(1)=SQRT((x(np)-xi)**2+(y(np)-yi)**2+(z(np)-zi)**2);
               5                      ui(1)=(x(np)-xi)/t(1);
               5                      vi(1)=(y(np)-yi)/t(1);
               5                      wi(1)=(z(np)-zi)/t(1);
               5                      t(2)=0.;
               5                      ]
               4                  ELSE[
               5                      t(1)=(tv**2-(x(np)-xi)**2-(y(np)-yi)**2-(z(np)-zi)**2)/(2*tv*t(1));
               5                      t(2)=tv-t(1);
               5                      ui(2)=((x(np)-xi)-t(1)*ui(1))/(tv-t(1));
               5                      vi(2)=((y(np)-yi)-t(1)*vi(1))/(tv-t(1));
               5                      wi(2)=((z(np)-zi)-t(1)*wi(1))/(tv-t(1));
               5                      ]
               4                  ]
               3              ELSE["use final direction to calculate hinge"
               4                  ui(2)=u(np);
               4                  vi(2)=v(np);
               4                  wi(2)=w(np);
               4                  t(2)=1-((x(np)-xi)*ui(2)+(y(np)-yi)*vi(2)+(z(np)-zi)*wi(2))/tv;
               4                  IF(t(2)<1e-3)[
               5                      t(1)=SQRT((x(np)-xi)**2+(y(np)-yi)**2+(z(np)-zi)**2);
               5                      ui(1)=(x(np)-xi)/t(1);
               5                      vi(1)=(y(np)-yi)/t(1);
               5                      wi(1)=(z(np)-zi)/t(1);
               5                      t(2)=0.;
               5                      ]
               4                  ELSE[
               5                      t(2)=(tv**2-(x(np)-xi)**2-(y(np)-yi)**2-(z(np)-zi)**2)/(2*tv*t(2));
               5                      t(1)=tv-t(2);
               5                      ui(1)=((x(np)-xi)-t(2)*ui(2))/(tv-t(2));
               5                      vi(1)=((y(np)-yi)-t(2)*vi(2))/(tv-t(2));
               5                      wi(1)=((z(np)-zi)-t(2)*wi(2))/(tv-t(2));
               5                      ]
               4                  ]
               3              ]
               2
               2          t_tot=t(1)+t(2);
               2          irold_loc=irold;
               2          irnew_loc=irold_loc;
               2          edep_frac=edep_save/t_tot;
               2
               2          outside=0;
               2
               2          DO i=1,2["steps t1 and t2"
               3              IF(t(i)>0. & irold_loc>1)["do not take step if it is zero or"
               4                  "the particle is already outside the geom"
               4                  IF(i=2)[
               5                      xi=xi+ui(1)*t(1);
               5                      yi=yi+vi(1)*t(1);
               5                      zi=zi+wi(1)*t(1);
               5                      ]
               4                  IF(ui(i)>0)[
               5                      uii=1./abs(ui(i));
               5                      dirx=1; distx=(xbound(irx+1)-xi)*uii;
               5                      ]
               4                  ELSEIF(ui(i)<0)[
               5                      uii=1./abs(ui(i));
               5                      dirx=-1; distx=(xi-xbound(irx))*uii;
               5                      ]
               4                  ELSE[
               5                      dirx=0; uii=0; distx=1e20;
               5                      ]
               4                  IF(vi(i)>0)[
               5                      vii=1./abs(vi(i));
               5                      diry=1; disty=(ybound(iry+1)-yi)*vii;
               5                      ]
               4                  ELSEIF(vi(i)<0)[
               5                      vii=1./abs(vi(i));
               5                      diry=-1; disty=(yi-ybound(iry))*vii;
               5                      ]
               4                  ELSE[
               5                      diry=0; vii=0; disty=1e20;
               5                      ]
               4                  IF(wi(i)>0)[
               5                      wii=1./abs(wi(i));
               5                      dirz=1; distz=(zbound(irz+1)-zi)*wii;
               5                      ]
               4                  ELSEIF(wi(i)<0)[
               5                      wii=1./abs(wi(i));
               5                      dirz=-1; distz=(zi-zbound(irz))*wii;
               5                      ]
               4                  ELSE[
               5                      dirz=0; wii=0; distz=1e20;
               5                      ]
               4                  dist_tot=0.;
               4                  LOOP[
               5                      dist_max=t(i)-dist_tot;
               5                      IF(distx<disty & distx<distz & distx<dist_max)[
               6                          dist_loc=distx;
               6                          irx=irx+dirx;
               6                          IF(irx>0 & irx<=IMAX)[
               7                              disty=disty-distx;
               7                              distz=distz-distx;
               7                              irnew_loc=irold_loc+dirx;
               7                              distx=(xbound(irx+1)-xbound(irx))*uii;
               7                              ]
               6                          ELSE[outside=1;]
               6                          ]
               5                      ELSEIF(disty<distz & disty<dist_max)[
               6                          dist_loc=disty;
               6                          iry=iry+diry;
               6                          IF(iry>0 & iry<=JMAX)[
               7                              distx=distx-disty;
               7                              distz=distz-disty;
               7                              irnew_loc=irold_loc+diry*IMAX;
               7                              disty=(ybound(iry+1)-ybound(iry))*vii;
               7                              ]
               6                          ELSE[outside=1;]
               6                          ]
               5                      ELSEIF(distz<dist_max)[
               6                          dist_loc=distz;
               6                          irz=irz+dirz;
               6                          IF(irz>0 & irz<=KMAX)[
               7                              distx=distx-distz;
               7                              disty=disty-distz;
               7                              irnew_loc=irold_loc+dirz*ijmax;
               7                              distz=(zbound(irz+1)-zbound(irz))*wii;
               7                              ]
               6                          ELSE[outside=1;]
               6                          ]
               5                      ELSE[dist_loc=dist_max;]
               5
               5                      edep_loc=dist_loc*edep_frac;"fraction of total energy in step"
               5
               5                      IF(nhist_last = endep_last(irold_loc-1))[
               6                          "same shower that deposited energy last time in this region"
               6                          endep_tmp(irold_loc-1) = endep_tmp(irold_loc-1) + edep_loc*wt(np);
               6                          ]
               5                      ELSE["we have the next shower depositing energy into region ir(np)"
               6                          " => put endep_tmp into the scoring arrays and set endep_last"
               6                          endep(irold_loc-1)=endep(irold_loc-1)+endep_tmp(irold_loc-1);
               6                          endep2(irold_loc-1)=endep2(irold_loc-1) +
               6                          endep_tmp(irold_loc-1)*endep_tmp(irold_loc-1);
               6                          endep_tmp(irold_loc-1) = edep_loc*wt(np);
               6                          endep_last(irold_loc-1)=nhist_last;
               6                          ]
               5
               5                      IF(outside=1)["set it to outside region"
               6                          IF(enflag>1)[irnew_loc=irmax+1;]
               6                          ELSE[irnew_loc=1;]
               6                          ]
               5
               5                      irold_loc=irnew_loc;
               5                      dist_tot=dist_tot+dist_loc;
               5                      ]UNTIL(dist_tot>=t(i)|outside=1);
               4                  ]
               3              ]
               2          irnew=irnew_loc;"define irnew at end of charged particle step"
               2          IF(irnew~=irold)ir(np)=irnew;
               2          ]
               1      ]
               0
               0  IF(iarg = 0 & iq(np)~=0) nestep = nestep + 1;
               0  "count total number of charged particle steps"
               0
               0  IF(howfarless)[
               1      edep_save=0.0;
               1      hwfl_rr=0;
               1      ]
               0
               0  IF(iarg=5 & i_phsp_out~=0 & ir(np)=irmax+1 & irold<ir(np))[
               1      "particle exiting phantom geometry into surrounding region"
               1      "score phsp"
               1      IF(i_phsp_out=1)[
               2          $DOSXYZ_WRITE_PHSP;
               2          ] ELSE [ "convert back to BEAM coordinates "
               2          x_temp = (x(np)-xiso);
               2          y_temp = (y(np)-yiso);
               2          z_temp = (z(np)-ziso);
               2          u_temp = u(np);
               2          v_temp = v(np);
               2          w_temp = w(np);
               2
               2          IF(isource = 2 | isource=9 | isource=20 |isource=21 ) k_field=1;
               2          "these sources only use index 1 of the rotation matrix"
               2
               2          "for orthonormal matrices the inverse is the transpose"
               2          x(np)=r_11(k_field)*x_temp + r_21(k_field)*y_temp +
               2          r_31(k_field)*z_temp;
               2          y(np)=r_12(k_field)*x_temp + r_22(k_field)*y_temp +
               2          r_32(k_field)*z_temp;
               2          z(np)=r_13(k_field)*x_temp + r_23(k_field)*y_temp +
               2          r_33(k_field)*z_temp;
               2          u(np)=r_11(k_field)*u_temp + r_21(k_field)*v_temp +
               2          r_31(k_field)*w_temp;
               2          v(np)=r_12(k_field)*u_temp + r_22(k_field)*v_temp +
               2          r_32(k_field)*w_temp;
               2          w(np)=r_13(k_field)*u_temp + r_23(k_field)*v_temp +
               2          r_33(k_field)*w_temp;
               2
               2          IF(i_iaea_in=1)[
               3              "for IAEA phsp source we need to add SAD back to Z coordinate"
               3              z(np) = z(np) + iaea_SAD;
               3              ]
               2
               2          "Write the particle to a phsp"
               2          $DOSXYZ_WRITE_PHSP;
               2
               2          "convert particles properties back to orginal values in case"
               2          x(np)=x_temp + xiso;
               2          y(np)=y_temp + yiso;
               2          z(np)=z_temp + ziso;
               2          u(np)=u_temp;
               2          v(np)=v_temp;
               2          w(np)=w_temp;
               2          ]
               1      ]
               0
               0  IF(iarg=5)RETURN;
               0
               0  IF(ir(np)>1 & edep~=0.0)[
               1
               1      IF(iarg=0 & howfarless & ir(np)<irmax+1)[
               2
               2          $DECODEIR(ir(np),irx,iry,irz);
               2
               2          "calculate dnear to voxel boundary"
               2          dnear_loc=min(xbound(irx+1)-x(np),x(np)-xbound(irx),
               2          ybound(iry+1)-y(np),y(np)-ybound(iry),
               2          zbound(irz+1)-z(np),z(np)-zbound(irz));
               2          IF(IREJECT=1 & dnear_loc > e_range-RANGE_ECUTRR(MED(IR(NP)))*
               2          RHO(MED(IR(NP)))/RHOR(IR(NP)))[
               3              "charged particle range rejection"
               3              "dump energy in current voxel"
               3              edep=e(np)-prm;
               3              hwfl_rr=1;
               3              ]
               2          ELSEIF(dnear_loc < vstep)["step leaves voxel"
               3              "save particle initial position, direction, energy deposited"
               3              xi=x(np);yi=y(np);zi=z(np);
               3              ui(1)=u(np);vi(1)=v(np);wi(1)=w(np);
               3              edep_save=edep;
               3              "also, save total curved path step length"
               3              IF(~is_ch_step)[
               4                  "this is step to a boundary, no random hinge"
               4                  tv=vstep;
               4                  ]
               3              ELSE[
               4                  "condensed history step, set tv equal to total curved pathlength"
               4                  tv=tvstep;
               4                  ]
               3              RETURN; "do energy deposition after step"
               3              ]
               2          ]
               1
               1      "if it gets here it is one of: a) normal transport without using"
               1      "howfarless option  b) howfarless option with iarg=1,2,3,4"
               1      "(ECUT,PCUT discard) c) howfarless option with iarg=0 (step about"
               1      "to occur) and particle range rejected  d) howfarless option with"
               1      "iarg=0 and particle step does not take it outside the current voxel"
               1      "e) howfarless version with particle in region irmax+1 (dsurround)"
               1
               1      IF(nhist_last = endep_last(ir(np)-1))[
               2          "same shower that deposited energy last time in this region"
               2          endep_tmp(ir(np)-1) = endep_tmp(ir(np)-1) + edep*wt(np);
               2          ]
               1      ELSE["we have the next shower depositing energy into region ir(np)"
               2          " => put endep_tmp into  the scoring arrays and set endep_last"
               2          endep(ir(np)-1)=endep(ir(np)-1)+endep_tmp(ir(np)-1);
               2          endep2(ir(np)-1)=endep2(ir(np)-1) +
               2          endep_tmp(ir(np)-1)*endep_tmp(ir(np)-1);
               2          endep_tmp(ir(np)-1) = edep*wt(np);
               2          endep_last(ir(np)-1)=nhist_last;
               2          ]
               1      " note endep region # = region number - 1, i.e., endep(1) for region 2,etc"
               1
               1      IF(howfarless & hwfl_rr=1)[
               2          IF(iq(np)=-1)[
               3              np=np-1;
               3              ]
               2          ELSEIF(iq(np)=1)[
               3              call annih_at_rest;
               3              ]
               2          iarg=-1; "forces return from ELECTR or PHOTON"
               2          ]
               1      ]
               0
               0  return;end;
1              0  %E    "dosxyznrc.mortran - start of subroutine howfar"
               0  "*******************************************************************************
               0  "
               0  "                      howfar
               0  "                      ======
               0  "
               0  subroutine howfar;
               0
               0  "   howfar routine to use with a generalized cartesian coordinate system
               0  "
               0  "   Routine is optimized for speed - please suggest improvements
               0  "
               0  "   Geometrical information is passed in COMIN/GEOM,SOURCE/
               0  "
               0  "   xbound($IMAX),ybound($JMAX),zbound($KMAX),IMAX,JMAX,KMAX,ijmax,irmax
               0  "   xbound etc are the x, y and z boundaries defining the voxels
               0  "   $IMAX etc are the maximum number of elements in each direction
               0  "       as defined in the users main program
               0  "   IMAX etc are the actual number of elements in each direction for
               0  "       this particular calculation
               0  "   ijmax = IMAX*JMAX   a useful number
               0  "   irmax = 1 + ijmax*ikmax   the total number of regions in the
               0  "       current problem
               0  "   region 1 is the exterior region and signifies particle left geometry
               0  "   region irmax+1 is the surrounding air region if it exists.
               0  "
               0  "     Each voxel is defined by a triple of integers (i,j,k) (but called
               0  "           irx,iry and irz in this routine) such that:
               0  "
               0  "           xbound(i) <= x < xbound(i+1)     1 < i < IMAX
               0  "           ybound(j) <= y < ybound(j+1)     1 < j < JMAX
               0  "           zbound(k) <= z < zbound(k+1)     1 < k < KMAX
               0  "
               0  "  The x axis is to the right, y axis down the page and z into the page
               0  "
               0  "  The region number is defined as:
               0  "       ir = 1 + i + (j-1)*IMAX + (k-1)*ijmax
               0  "
               0  "  The routine sets dnear. Note that in problems where the typical
               0  "  step size is of the order of the region dimensions, then computing
               0  "  dnear can decrease efficiency. In this case the two lines containing
               0  "  dnear should be commented out
               0  "
               0  "  The routine assumes $DECODEIR(irl,i,j,k) is expanded to calculate
               0  "      i,j,k given irl, the current region
               0  "
               0  "  Equivalence statements are used to allow variable names to be used
               0  "           in the main macro for each direction
               0  "
               0  "  Version 1    April 1986  D.W.O.Rogers, NRCC
               0  "  Added coding for the surrounding air region April 1996 C.-M. Ma, NRCC
               0  "
               0  "*******************************************************************************
               0  ;
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EPCONT,GEOM,STACK,SOURCE/;
               0
               0  INTEGER ione, "set to 1"
               0  irl, "absolute region number"
               0  i,j,k, "loop counters"
               0  irx,iry,irz; "voxel x,y,z indices"
               0
               0  $REAL    dnearl, "perpendicular distance to boundary"
               0  dist, "distance to boundary along particle trajectory"
               0  xsrcp,ysrcp,zsrcp;
               0  "x,y,z positions where incident particle hits geometry"
               0
               0  data ione/1/;
               0
               0  irl = ir(np);
               0
               0  "now, find dnear"
               0  $CALL-HOWNEAR(dnearl);
               0  dnear(np)=dnearl;
               0
               0  IF(irl=1)[idisc = 1;return;"have left geometry"]
               0
               0  ELSEIF(irl = irmax + 1)["begin in region surrounding the phantom"
               1
               1      "introduce this check to deal with reflection right on the boundary
               1      "of the dsurround region.  This was found to be a problem as soon
               1      "as the use of multiple dsurrounds was introduced
               1      "      IF(z(np)>zbound_min & z(np)<zbound_max & x(np)>xbound_min &
               1      "         x(np)<xbound_max & y(np)>ybound_min & y(np)<ybound_max)[
               1      "        dist=0.;
               1      "        ustep=dist;
               1      "        IF(irold<irmax+1)[particle reflecting back into dsurround"
               1      "          irnew=irold;
               1      "          return;
               1      "        ]
               1      "        ELSE[put the particle in the right region within the phantom"
               1      "          OUTPUT61;
               1      "     (' ***Warning: irold=ir(np)=irmax+1 (ie the dsurround region) but'/
               1      "      '             particle is in the phantom.  Putting particle in '/
               1      "      '             correct region now.');
               1      "          irx=0;
               1      "          LOOP[irx=irx+1;]UNTIL(xbound(irx)<=x(np) & xbound(irx+1)>x(np));
               1      "          iry=0;
               1      "          LOOP[iry=iry+1;]UNTIL(ybound(iry)<=y(np) & ybound(iry+1)>y(np));
               1      "          irz=0;
               1      "          LOOP[irz=irz+1;]UNTIL(zbound(irz)<=z(np) & zbound(irz+1)>z(np));
               1      "          irnew=$IR(irx,iry,irz);
               1      "          return;
               1      "        ]
               1      "      ]
               1      IF(u(np) > 0.0) [
               2          "Going towards lower x-plane
               2          dist = (xbound_min - x(np))/u(np); "Distance to boundary
               2          IF(dist>0.)[
               3              ysrcp = y(np) + dist*v(np); "possible contact point..."
               3              zsrcp = z(np) + dist*w(np);
               3              IF ( (ysrcp >= ybound_min) & (ysrcp <= ybound_max) &
               3              (zsrcp >= zbound_min) & (zsrcp <= zbound_max)) [
               4                  "Hits the lower x-plane, search for the entrance region number
               4                  DO j=1,JMAX [
               5                      IF( (ybound(j) <= ysrcp) & (ysrcp <= ybound(j+1)) ) [
               6                          DO k=1,KMAX [
               7                              IF( (zbound(k) <= zsrcp) & (zsrcp <= zbound(k+1)) ) [
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = IMAX*j + klowx + ijmax*k;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]"end of do"
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on lower x-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(u(np) < 0.0) [ "Going towards upper x-plane
               2          dist = (xbound_max - x(np))/u(np); "Distance to boundary
               2          IF(dist>0.)[
               3              ysrcp = y(np) + dist*v(np); "possible contact point..."
               3              zsrcp = z(np) + dist*w(np);
               3              IF ( (ysrcp >= ybound_min) & (ysrcp <= ybound_max) &
               3              (zsrcp >= zbound_min) & (zsrcp <= zbound_max)) [
               4                  "Hits the upper x-plane, search for the entrance region number
               4                  DO j=1,JMAX [
               5                      IF( (ybound(j) <= ysrcp) & (ysrcp <= ybound(j+1)) )[
               6                          DO k=1,KMAX [
               7                              IF((zbound(k)<= zsrcp)&(zsrcp<= zbound(k+1)))[
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = IMAX*j + khix + ijmax*k;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on upper x-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1      IF(v(np) > 0.0) [
               2          "Going towards lower y-plane
               2          dist = (ybound_min - y(np))/v(np); "Distance to boundary
               2          IF(dist>0.)[
               3              xsrcp = x(np) + dist*u(np); "possible contact point"
               3              zsrcp = z(np) + dist*w(np);
               3              IF ( (xsrcp >= xbound_min) & (xsrcp <= xbound_max) &
               3              (zsrcp >= zbound_min) & (zsrcp <= zbound_max)) [
               4                  "Hits the lower y-plane, search for the entrance region number
               4                  DO i=1,IMAX [
               5                      IF( (xbound(i) <= xsrcp) & (xsrcp <= xbound(i+1)) ) [
               6                          DO k=1,KMAX [
               7                              IF( (zbound(k) <= zsrcp) & (zsrcp <= zbound(k+1)))[
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = i + klowy + ijmax*k;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on lower y-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(v(np) < 0.0) [ "Going towards upper y-plane
               2          dist = (ybound_max - y(np))/v(np); "Distance to boundary
               2          IF(dist>0.)[
               3              xsrcp = x(np) + dist*u(np); "possible contact point"
               3              zsrcp = z(np) + dist*w(np);
               3              IF ( (xsrcp >= xbound_min) & (xsrcp <= xbound_max) &
               3              (zsrcp >= zbound_min) & (zsrcp <= zbound_max)) [
               4                  "Hits the upper y-plane, search for the entrance region number
               4                  DO i=1,IMAX [
               5                      IF( (xbound(i) <= xsrcp) & (xsrcp <= xbound(i+1)) ) [
               6                          DO k=1,KMAX [
               7                              IF( (zbound(k) <= zsrcp) & (zsrcp <= zbound(k+1)) ) [
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = i + khiy + ijmax*k;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on upper y-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1      IF(w(np) > 0.0) [ "Going towards lower z-plane
               2          dist = (zbound_min - z(np))/w(np); "Distance to boundary
               2          IF(dist>0.)[
               3              xsrcp = x(np) + dist*u(np); "possible contact point"
               3              ysrcp = y(np) + dist*v(np);
               3              IF ( (xsrcp >= xbound_min) & (xsrcp <= xbound_max) &
               3              (ysrcp >= ybound_min) & (ysrcp <= ybound_max)) [
               4                  "Hits the lower z-plane, search for the entrance region number
               4                  DO i=1,IMAX [
               5                      IF( (xbound(i) <= xsrcp) & (xsrcp <= xbound(i+1)) ) [
               6                          DO j=1,JMAX [
               7                              IF( (ybound(j) <= ysrcp) & (ysrcp <= ybound(j+1)) ) [
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = i + klowz + IMAX*j;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on lower z-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(w(np) < 0.0) [ "Going towards upper z-plane
               2          dist = (zbound_max-z(np))/w(np); "Distance to boundary
               2          IF(dist>0.)[
               3              xsrcp = x(np) + dist*u(np); "possible contact point"
               3              ysrcp = y(np) + dist*v(np);
               3              IF ( (xsrcp >= xbound_min) & (xsrcp <= xbound_max) &
               3              (ysrcp >= ybound_min) & (ysrcp <= ybound_max)) [
               4                  "Hits the upper z-plane, search for the entrance region number
               4                  DO i=1,IMAX [
               5                      IF( (xbound(i) <= xsrcp) & (xsrcp <= xbound(i+1)) ) [
               6                          DO j=1,JMAX [
               7                              IF( (ybound(j) <= ysrcp) & (ysrcp <= ybound(j+1)) ) [
               8                                  IF(dist < ustep) [
               9                                      ustep = dist;
               9                                      irnew = i + khiz + IMAX*j;
               9                                      ]
               8                                  ELSE[irnew=ir(np);"still in the air region"]
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  stop ' * Stopped in howfar on upper z-plane. Cannot find irnew! *';
               4                  ]
               3              ]
               2          ]
               1
               1      "If gets here => still in air, discard it if far away from the phantom"
               1      IF(u(np)>0.)[xsrcp=(xbound_max+dsurround(1)-x(np))/u(np);]
               1      ELSEIF(u(np)<0.)[xsrcp=(xbound_min-dsurround(1)-x(np))/u(np);]
               1      ELSE[xsrcp=1.0E10;]
               1      IF(v(np)>0.)[ysrcp=(ybound_max+dsurround(2)-y(np))/v(np);]
               1      ELSEIF(v(np)<0.)[ysrcp=(ybound_min-dsurround(2)-y(np))/v(np);]
               1      ELSE[ysrcp=1.0E10;]
               1      IF(w(np)>0.)[zsrcp=(zbound_max+dsurround(3)-z(np))/w(np);]
               1      ELSEIF(w(np)<0.)[zsrcp=(zbound_min-dsurround(4)-z(np))/w(np);]
               1      ELSE[zsrcp=1.0E10;]
               1      dist=min(xsrcp,ysrcp,zsrcp);
               1      IF(dist< ustep)[
               2          ustep=dist;
               2          irnew=1;"the particle is going out of the air region"
               2          ]
               1      ELSE[irnew=ir(np);"still in the surrounding air region"]
               1
               1      ]"end of checking in the surrounding air"
               0  ELSEIF(howfarless)["just check against outer bounds of phantom"
               1
               1      dist=1e20;
               1
               1      IF(w(np) > 0.0) [
               2          "Going towards upper plane"
               2          dist = min(dist,(zbound_max-z(np))/w(np));"Distance to boundary"
               2          ]
               1      ELSEIF(w(np) < 0.0) [ "Going towards inner plane"
               2          dist = min(dist,-( z(np) - zbound_min)/w(np));
               2          ]
               1      IF(u(np) > 0.0) [
               2          "Going towards max plane"
               2          dist = min(dist,(xbound_max-x(np))/u(np));"Distance to boundary"
               2          ]
               1      ELSEIF(u(np) < 0.0) [ "Going towards inner plane"
               2          dist = min(dist,-( x(np) - xbound_min)/u(np));
               2          ]
               1      IF(v(np) > 0.0) [
               2          "Going towards max plane"
               2          dist = min(dist,(ybound_max-y(np))/v(np));"Distance to boundary"
               2          ]
               1      ELSEIF(v(np) < 0.0) [ "Going towards inner plane"
               2          dist = min(dist,-( y(np) - ybound_min)/v(np));
               2          ]
               1
               1      IF(dist < ustep)[
               2          ustep=dist;
               2          IF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               2          ELSE[irnew=1; "Leaving entire geometry" ]
               2          ]
               1      ELSE[
               2          irnew=irl; "irnew gets set properly in ausgab before step is taken"
               2          ]
               1      return;
               1      ]
               0  ELSE["full HOWFAR"
               1
               1      $DECODEIR(irl,irx,iry,irz);
               1
               1      "code below used to be in a macro called $CHECK-IN-#-DIRECTION"
               1      "macro was eliminated to get rid of equivalence statments in hopes"
               1      "of speeding up execution time"
               1
               1      IF(w(np) > 0.0) [
               2          "Going towards outer plane"
               2          dist = (zbound(irz+1)-z(np))/w(np);"Distance to boundary"
               2          IF(dist < ustep)[ustep=dist;
               3              IF(irz ~= KMAX) [ irnew=irl+ijmax; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew=1; "Leaving entire geometry" ]
               3              "Note this only assigns irnew correctly if no other boundaries are "
               3              "crossed first - but if they are, irnew will be set correctly there"
               3              ]
               2          ]
               1      ELSEIF(w(np) < 0.0) [ "Going towards inner plane"
               2          dist = -( z(np) - zbound(irz))/w(np);
               2          IF(dist < ustep) [
               3              ustep = dist;
               3              IF(irz ~= 1) [ irnew=irl-ijmax; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew = 1; "leaving geometry" ]
               3              ]
               2          ]
               1      IF(u(np) > 0.0) [
               2          "Going towards outer plane"
               2          dist = (xbound(irx+1)-x(np))/u(np);"Distance to boundary"
               2          IF(dist < ustep)[ustep=dist;
               3              IF(irx ~= IMAX) [ irnew=irl+ione; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew=1; "Leaving entire geometry" ]
               3              "Note this only assigns irnew correctly if no other boundaries are "
               3              "crossed first - but if they are, irnew will be set correctly there"
               3              ]
               2          ]
               1      ELSEIF(u(np) < 0.0) [ "Going towards inner plane"
               2          dist = -( x(np) - xbound(irx))/u(np);
               2          IF(dist < ustep) [
               3              ustep = dist;
               3              IF(irx ~= 1) [ irnew=irl-ione; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew = 1; "leaving geometry" ]
               3              ]
               2          ]
               1      IF(v(np) > 0.0) [
               2          "Going towards outer plane"
               2          dist = (ybound(iry+1)-y(np))/v(np);"Distance to boundary"
               2          IF(dist < ustep)[ustep=dist;
               3              IF(iry ~= JMAX) [ irnew=irl+IMAX; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew=1; "Leaving entire geometry" ]
               3              "Note this only assigns irnew correctly if no other boundaries are "
               3              "crossed first - but if they are, irnew will be set correctly there"
               3              ]
               2          ]
               1      ELSEIF(v(np) < 0.0) [ "Going towards inner plane"
               2          dist = -( y(np) - ybound(iry))/v(np);
               2          IF(dist < ustep) [
               3              ustep = dist;
               3              IF(iry ~= 1) [ irnew=irl-IMAX; ]
               3              ELSEIF(enflag > 1)[irnew=irmax+1;"entering dsurround territory"]
               3              ELSE [ irnew = 1; "leaving geometry" ]
               3              ]
               2          ]
               1      return;
               1      ]
               0  end;
1              0  %E    "dosxyznrc.mortran - start of subroutine hownear"
               0  "*******************************************************************************
               0  "
               0  "                      hownear
               0  "                      =======
               0  "
               0  SUBROUTINE HOWNEAR (TPERP,X,Y,Z,IRL);
               0
               0  "   hownear routine to use with a generalized cartesian coordinate system
               0  "
               0
               0  $IMPLICIT-NONE;
               0
               0  COMIN/GEOM/;
               0
               0  " subroutine parameters:
               0  $REAL TPERP, "the perpendicular distance to the nearest region boundary"
               0  X,     "the X position of the particle"
               0  Y,     "Y position"
               0  Z;     "Z position"
               0
               0  $INTEGER IRL; "absolute region number of particle"
               0
               0  "internal variables"
               0  $INTEGER IRX,IRY,IRZ; "indices of voxel that particle is in"
               0
               0  TPERP=1.e10;
               0  IF(IRL=1)[TPERP=0;] "exiting geometry"
               0  ELSEIF(IRL=irmax+1)["in dsurround region"
               1      IF((X>=xbound_min & X<=xbound_max & Y>=ybound_min &
               1      Y<=ybound_max) & (Z>=zbound_max | Z<=zbound_min))[
               2          TPERP=MIN(TPERP,ABS(Z-zbound_min),ABS(Z-zbound_max));
               2          ]
               1      ELSE[
               2          IF(Y>=ybound_min & Y<=ybound_max &
               2          (X<=xbound_min | X>=xbound_max))[
               3              TPERP=MIN(TPERP,ABS(X-xbound_min),ABS(X-xbound_max));
               3              ]
               2          ELSEIF(X>=xbound_min & X<=xbound_max &
               2          (Y<=ybound_min | Y>=ybound_max))[
               3              TPERP=MIN(TPERP,ABS(Y-ybound_min),ABS(Y-ybound_max));
               3              ]
               2          ELSEIF((X>=xbound_max | X<=xbound_min) &
               2          (Y>=ybound_max | Y<=ybound_min))[
               3              TPERP=MIN(TPERP**2,(X-xbound_max)**2+(Y-ybound_max)**2,
               3              (X-xbound_max)**2+(Y-ybound_min)**2,
               3              (X-xbound_min)**2+(Y-ybound_max)**2,
               3              (X-xbound_min)**2+(Y-ybound_min)**2);
               3              TPERP=SQRT(TPERP);
               3              ]
               2          ELSE[
               3              TPERP=0.;
               3              ]
               2          IF(Z<zbound_min)[
               3              TPERP=SQRT(TPERP**2+(Z-zbound_min)**2);
               3              ]
               2          ELSEIF(Z>zbound_max)[
               3              TPERP=SQRT(TPERP**2+(Z-zbound_max)**2);
               3              ]
               2          ]
               1      TPERP=MIN(TPERP,ABS(X-(xbound_min-dsurround(1))),
               1      ABS(X-(xbound_max+dsurround(1))),
               1      ABS(Y-(ybound_min-dsurround(2))),
               1      ABS(Y-(ybound_max+dsurround(2))),
               1      ABS(Z-(zbound_min-dsurround(4))),
               1      ABS(Z-(zbound_max+dsurround(3))));
               1      ]
               0  ELSEIF(howfarless)[
               1      TPERP=MIN(TPERP,X-xbound_min,xbound_max-X,
               1      Y-ybound_min,ybound_max-Y,
               1      Z-zbound_min,zbound_max-Z);
               1      ]
               0  ELSE["within phantom"
               1      ;$DECODEIR(IRL,IRX,IRY,IRZ);
               1      TPERP=min(TPERP,(xbound(irx+1)-X),(X-xbound(irx)));
               1      TPERP=min(TPERP,(ybound(iry+1)-Y),(Y-ybound(iry)));
               1      TPERP=min(TPERP,(zbound(irz+1)-Z),(Z-zbound(irz)));
               1      ]
               0  return;
               0  end;
               0  "******************************************************************************
               0  SUBROUTINE DATETIME(DUMMY);
               0
               0  "calls the macros CALL DATE and CALL TIME to assign the current date and time
               0  "to DATEN and TIMEN, respectively.  A subroutine is used to call the macros so
               0  "that machine-dependent date and time routines are all contained here.
               0  "******************************************************************************
               0  $IMPLICIT-NONE;
               0  ;COMIN/TIMEINFO/; INTEGER DUMMY; "just a dummy variable"
               0  "CALL DATE(DATEN); CALL TIME(TIMEN);"
               0  "IK: use the EGSnrc egs_fdate function instead. "
               0  call egs_get_fdate(DNTIME);
               0  daten(1:7)=dntime(5:11);
               0  daten(8:11)=dntime(21:24);
               0  timen(1:8)=dntime(12:19);
               0  RETURN; end;
1              0  %E    "dosxyznrc.mortran - start of subroutine write_dose"
               0  "******************************************************************************
               0
               0  subroutine write_dose(iimax,jjmax,kkmax,xbnd,ybnd,zbnd,dd,ddun,unitnum,
               0  writemax20,bindos);
               0
               0
               0  "Writes dose to file designated by unitnum.  Currently the subroutine writes
               0  "in the .3ddose format (unitnum=3) or the .bindos format and replaces a portion
               0  "of the main code.  However, this subroutine will eventually output the dose in
               0  "other formats as well.
               0
               0  "3 possible methods of specifying the array sizes for dd and ddun, the
               0  "dose and dose uncertainty arrays in this subroutine, were explored.  The
               0  "first method passed $MAXDOSE as a parameter to the subroutine.  The second
               0  "method, which ended up being the method used, calculated the required size
               0  "using iimax*jjmax*kkmax+1.  The third method specified dd and ddun as
               0  "dd(1) and ddun(1), which maps the start of these arrays onto their
               0  "counterparts in the main program (dose and doseun, respectively) and ensures
               0  "that they are as large as dose and doseun.  The following table summarizes
               0  "the size and resident in memory requirements (determined using top.new)
               0  "for compiling and a simple test run using each of the three array size
               0  "methods.  The version of dosxyz used for these tests had IMAX=512, JMAX=512,
               0  "KMAX=10.
               0  "
               0  "   method             compile                           run
               0  "   ------       max. size  max. res in mem.     max. size  max. res. in mem.
               0  "                --------    --------------      ---------  ----------------
               0  "
               0  " before write_dose
               0  "   added             90M          55M              95M          22M
               0  "
               0  " pass $MAXDOSE       90M          62M              95M          22M
               0  "iimax*jjmax*kkmax+1  90M          59M              95M          22M
               0  " dd(1),ddun(1)       90M          54M              95M          22M
               0  "
               0  "The test run case used 20x20x10 voxels to define a 20x20x10cm volume.
               0  "Incident beam was 10x0cm of 15MeV electrons.
               0  "
               0  "iimax*jjmax*kkmax+1 was favoured because it did not involve passing yet
               0  "another parameter (ie $MAXDOSE) and it would allow the user to run in
               0  "debug mode with error boundaries (which using DD(1),DDUN(1) would not).
               0  "******************************************************************************
               0  ;
               0  "Information which MUST be available to use this routine to plot dose:
               0  "1) number of voxels in the x,y,z directions (iimax,jjmax,kkmax)
               0  "2) 1-D array of real numbers containing voxel boundaries (in cm)
               0  "   in x,y,z directions (xbnd,ybnd,zbnd).  Data in these matrices is
               0  "   arranged so that xbnd(i+1) is the upper boundary of voxel i in the x
               0  "   direction, and xbnd(i) is the lower boundary of voxel i in the x
               0  "   direction.
               0  "3) 1-D array of real numbers containing dose/unit fluence (Gy/cm^2) in every
               0  "   voxel (dd).  3-D dose distribution must be collapsed into this 1-D
               0  "   array using the scheme:
               0  "      dose(i,j,k)=dd(i+(j-1)*iimax+(k-1)*iimax*jjmax)
               0  "      where dose(i,j,k) is the dose in voxel (i,j,k)
               0  "4) 1-D array of real numbers containing the dose uncertainty expressed
               0  "   as a fraction of dose in every voxel (ddun).
               0  "   3-D dose uncertainty distribution must be collapsed into the 1-D array
               0  "   in the same manner as in 3)
               0  "
               0  ;IMPLICIT NONE;
               0  INTEGER iimax,                     "max number of x cells"
               0  jjmax,                     "max number of y cells"
               0  kkmax,                     "max number of z cells"
               0  ijkmax,                    "iimax*jjmax*kkmax"
               0  irtmp,                     "tmp variable to hold ir"
               0  writemax20,                "1 for summary of max 20 doses"
               0  bindos,                    "1 for binary file"
               0  unitnum,                   "unit number in which to write data"
               0  ii,jj,kk,mm,nn,            "indices"
               0  NUMFRAC,                   "number of voxels for av. rel. uncertainty"
               0  MAXI(20),MAXJ(20),MAXK(20),"indices for max 20 doses"
               0  num_nonzero,               "number of nonzero voxels"
               0  num_blocks,                "number of voxel blocks"
               0  start_block,               "keep track of contiguous nonzero voxels"
               0  voxel_blocks($MAXDOSE),    "indices of nonzero voxels"
               0  egs_open_file;
               0  REAL    xbnd($IMAX+1),             "voxel x boundaries"
               0  ybnd($JMAX+1),             "voxel y boundaries"
               0  zbnd($KMAX+1),             "voxel z boundaries"
               0  dtemp,                     "float version of double dose"
               0  MAXDOS(20),                "maximum 20 doses"
               0  MAXDOSAVG,                 "average of max 20 doses"
               0  ERRMAXDOSAVG,              "average of error of max 20 doses"
               0  ERR50AVG,                  "average % error of doses > 50% of max dose"
               0  ERR50FRAC,                 "average error of doses > 50% of max"
               0  " dose as a fraction of max dose"
               0  DOSEFRAC,                  "fraction for calculating av. rel. uncertaint
               0  DOSEmin,                   "DOSEFRAC*MAXDOS(1)"
               0  ARUFRAC;                   "average relative uncertainty on all voxels"
               0  "with dose > DOSEFRAC*Dmax"
               0
               0  REAL*8  dd($MAXDOSE),              "linear array of doses"
               0  ddun($MAXDOSE);            "linear array of dose uncertainties"
               0
               0  REPLACE {$PLOTOUT#;} WITH {write(unitnum,*){P1};};
               0  REPLACE {$BINOUT#;} WITH {write(unitnum){P1};};
               0  REPLACE {$IRDWD(#,#,#)} WITH {({P1}+({P2}-1)*iimax+({P3}-1)*iimax*jjmax)};
               0
               0  num_nonzero = 0;
               0  num_blocks = 0;
               0  start_block = -1;
               0  ijkmax=iimax*jjmax*kkmax;
               0
               0  IF(bindos=0)[
               1      "open the .3ddose file for output"
               1      unitnum=egs_open_file(unitnum,0,1,'.3ddose');
               1      $PLOTOUT iimax,jjmax,kkmax;
               1      $PLOTOUT (xbnd(ii),ii=1,iimax+1);
               1      $PLOTOUT (ybnd(jj),jj=1,jjmax+1);
               1      $PLOTOUT (zbnd(kk),kk=1,kkmax+1);
               1      $PLOTOUT (((dd($IRDWD(ii,jj,kk)),ii=1,iimax),jj=1,jjmax),kk=1,kkmax);
               1      $PLOTOUT (((ddun($IRDWD(ii,jj,kk)),ii=1,iimax),jj=1,jjmax),kk=1,kkmax);
               1      ]
               0  ELSE[
               1      DO ii=1,ijkmax[
               2          IF(dd(ii)>0.0)[
               3              IF(start_block = -1) [
               4                  start_block = ii;
               4                  ]
               3              num_nonzero = num_nonzero + 1;
               3              ] ELSE [
               3              IF(start_block ~= -1) [
               4                  "First 0 dose voxel after a block of nonzero voxels"
               4                  num_blocks = num_blocks + 1;
               4                  voxel_blocks(2*num_blocks) = start_block;
               4                  voxel_blocks(2*num_blocks+1) = ii;
               4                  start_block = -1;
               4                  ]
               3              ]
               2          ]
               1      "Capture the final voxel block"
               1      IF(start_block ~= -1) [
               2          num_blocks = num_blocks + 1;
               2          voxel_blocks(2*num_blocks) = start_block;
               2          voxel_blocks(2*num_blocks+1) = ijkmax;
               2          ]
               1
               1      "open the .bindos file for output"
               1      unitnum=egs_open_file(unitnum,-1,1,'.bindos');
               1      $BINOUT iimax,jjmax,kkmax;
               1      $BINOUT (xbnd(ii),ii=1,iimax+1);
               1      $BINOUT (ybnd(jj),jj=1,jjmax+1);
               1      $BINOUT (zbnd(kk),kk=1,kkmax+1);
               1
               1      $BINOUT num_nonzero;
               1      $BINOUT num_blocks;
               1
               1      "Writing start/end indices of contiguous non-zero voxel doses, 0-indexed"
               1      "To be interpreted as [start, end)"
               1      DO ii=1,num_blocks [
               2          $BINOUT voxel_blocks(2*ii) - 1;
               2          $BINOUT voxel_blocks(2*ii+1) - 1;
               2          ]
               1
               1      DO ii=1,num_blocks [
               2          DO jj=voxel_blocks(2*ii),voxel_blocks(2*ii+1)-1 [
               3              dtemp = dd(jj);
               3              $BINOUT dtemp;
               3              ]
               2          ]
               1
               1      DO ii=1,num_blocks [
               2          DO jj=voxel_blocks(2*ii),voxel_blocks(2*ii+1)-1 [
               3              dtemp = ddun(jj);
               3              $BINOUT dtemp;
               3              ]
               2          ]
               1      ]
               0
               0  close(unitnum);
               0
               0  IF(writemax20=1)["print out maximum 20 doses"
               1      DO mm=1,20 [ MAXDOS(mm)=0.0; ]
               1      DO ii=1,iimax[
               2          DO jj=1,jjmax[
               3              DO kk=1,kkmax[
               4                  irtmp = $IRDWD(ii,jj,kk);
               4                  DO mm=1,min(20,ijkmax) [
               5                      IF(dd(irtmp)>=MAXDOS(mm))[
               6                          DO nn=min(20,ijkmax),mm+1,-1 [
               7                              MAXDOS(nn)=MAXDOS(nn-1);
               7                              MAXI(nn)=MAXI(nn-1);
               7                              MAXJ(nn)=MAXJ(nn-1);
               7                              MAXK(nn)=MAXK(nn-1);
               7                              ]
               6                          MAXDOS(mm)=dd(irtmp);
               6                          MAXI(mm)=ii;
               6                          MAXJ(mm)=jj;
               6                          MAXK(mm)=kk;
               6                          EXIT;
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1
               1      MAXDOSAVG=0.;
               1      ERRMAXDOSAVG=0.;
               1      DO mm=1,min(20,ijkmax) [
               2          MAXDOSAVG=MAXDOSAVG+MAXDOS(mm);
               2          ERRMAXDOSAVG=ERRMAXDOSAVG+ddun($IRDWD(MAXI(mm),MAXJ(mm),MAXK(mm)));
               2          ]
               1      MAXDOSAVG=MAXDOSAVG/float(min(20,ijkmax));
               1      ERRMAXDOSAVG=ERRMAXDOSAVG/float(min(20,ijkmax));
               1
               1      "now find average error of doses > DOSEFRAC*dose_maximum of max dose"
               1      "We calculate two ways, one taking straight average, the other"
               1      "summing the fractional variance and then taking the square root"
               1      "The later was added Dec 1999 after Iwan Kawrakow suggested that"
               1      "this parameter was independent of how many batches are used"
               1
               1      ERR50AVG=0.;
               1      ERR50FRAC=0.;
               1      DOSEFRAC=0.5;
               1      DOSEmin = DOSEFRAC*MAXDOS(1);
               1      ARUFRAC=0.;
               1      NUMFRAC=0;
               1      DO ii=1,iimax[
               2          DO jj=1,jjmax[
               3              DO kk=1,kkmax[
               4                  irtmp = $IRDWD(ii,jj,kk);
               4                  IF(dd(irtmp) > DOSEmin )[
               5                      ERR50AVG =ERR50AVG +ddun(irtmp);  "ave % uncertainty"
               5                      ERR50FRAC=ERR50FRAC+ddun(irtmp)*dd(irtmp); "ave abs.  uncertainty"
               5                      ARUFRAC  =ARUFRAC  +ddun(irtmp)**2;
               5                      "ave % uncertainty in quadrature"
               5                      NUMFRAC  =NUMFRAC+1;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1
               1      IF( (NUMFRAC ~= 0) & (MAXDOS(1) ~= 0.0)) [
               2          ERR50AVG=ERR50AVG/NUMFRAC;
               2          ERR50FRAC=ERR50FRAC/(NUMFRAC*MAXDOS(1));
               2          ARUFRAC=SQRT(ARUFRAC/NUMFRAC);
               2          ]
               1      ELSE[
               2          OUTPUT DOSEFRAC;
               2          (' Statistics really bad - analysis of average relatative uncertainty'/
               2          ' on voxels with dose > ',F12.5,'*Dmax is meaningless');
               2          ]
               1
               1
               1      OUTPUT61  min(20,ijkmax), MAXDOSAVG, min(20,ijkmax), ERRMAXDOSAVG*100.,
               1      DOSEFRAC, ERR50AVG*100., DOSEFRAC,
               1      ERR50FRAC*100, DOSEFRAC, ARUFRAC*100., NUMFRAC, DOSEFRAC,
               1      min(20,ijkmax);
               1      (/' average of ',I2,' highest doses = ',T62,E12.5,' Gy/particle'/
               1      ' average % error of ',I2,' highest doses = ',T60,F9.3,' %'/
               1      ' average % error of doses >',F7.3,' of max dose = ',T60,F9.3,' %'/
               1      ' (average error of doses >',F7.3,' of max dose)/(max dose) =',T60,F9.3,' %'/
               1      ' quadrature average % error of doses >',F7.3,' of max dose =',T60,F9.3,' %'/
               1      ' There are ',I11,' voxels with dose > ',F7.3,' of max dose ' //
               1      ' ',I2,' highest doses: '/
               1      ' '/
               1      '        dose (Gy/particle)                     (x,y,z) (cm)'/
               1      '        -----------------                      ------------'/);
               1
               1      DO mm=1,min(20,ijkmax) [
               2          OUTPUT61 MAXDOS(mm),ddun($IRDWD(MAXI(mm),MAXJ(mm),MAXK(mm)))*100,
               2          (xbnd(MAXI(mm)+1)+xbnd(MAXI(mm)))/2.,
               2          (ybnd(MAXJ(mm)+1)+ybnd(MAXJ(mm)))/2.,
               2          (zbnd(MAXK(mm)+1)+zbnd(MAXK(mm)))/2.;
               2          (' ',E12.5,' +/- ',F12.5,' %  ( ',F12.5,',',F12.5,',',F12.5,' )');
               2          ]
               1      ]
               0
               0  RETURN;
               0  end;
               0
1              0  %E    "dosxyznrc.mortran - start of subroutine write_phantom"
               0  "******************************************************************************
               0  "
               0  subroutine write_phantom(iunit,nmed,media,estepe,
               0  iimax,jjmax,kkmax,xbnd,ybnd,zbnd,
               0  rho,med);
               0  "
               0  "This subroutine writes out a .egsphant file so that dosxyz_show can be"
               0  "used to view dose contours when not using CT data"
               0  "It is a slightly modified form of write_phantom found in ctcreate.mortran"
               0  "******************************************************************************
               0  ;IMPLICIT NONE;
               0  Character*4  media(24,$MXMED);     "Media names"
               0  INTEGER iunit,                     "fort.iunit = .egsphant file"
               0  nmed,                      "number of media"
               0  iimax,                     "max number of x cells"
               0  jjmax,                     "max number of y cells"
               0  kkmax,                     "max number of z cells"
               0  ii,jj,kk,                  "indices"
               0  egs_open_file;
               0  $SHORT_INT med($MXREG);            "linear array of media numbers"
               0  REAL    xbnd($IMAX+1),             "voxel x boundaries"
               0  ybnd($JMAX+1),             "voxel y boundaries"
               0  zbnd($KMAX+1),             "voxel z boundaries"
               0  estepe($MXMED);            "linear array of estepe values"
               0  $REAL rho($MXREG);
               0
               0  character  encoding(62);
               0  encoding = $ENCODING;
               0
               0  REPLACE {$IRWP(#,#,#)} WITH {(1 + {P1} + ({P2}-1)*iimax + ({P3}-1)*iimax*jjmax)}
            {  0
               0  iunit=egs_open_file(iunit,0,1,'.egsphant');
               0
               0  WRITE(iunit,'(i2)') nmed;
               0  DO ii=1,nmed [
               1      Write(iunit,'(24a1)') (media(jj,ii),jj=1,24);
               1      ]
               0  WRITE(iunit,*) (estepe(ii),ii=1,nmed);
               0  WRITE(iunit,'(3i5)') iimax,jjmax,kkmax;
               0  WRITE(iunit,*) (xbnd(ii),ii=1,iimax+1);
               0  WRITE(iunit,*) (ybnd(jj),jj=1,jjmax+1);
               0  WRITE(iunit,*) (zbnd(kk),kk=1,kkmax+1);
               0  DO kk=1,kkmax[
               1      DO jj=1,jjmax[
               2          WRITE(iunit,1399)
               2          (encoding(med($IRWP(ii,jj,kk))+1:med($IRWP(ii,jj,kk))+1),ii=1,iimax);
               2          ]
               1      WRITE(iunit,*);
               1      ]
               0  1399 FORMAT($IMAXa1);
               0  DO kk=1,kkmax[
               1      DO jj=1,jjmax[
               2          WRITE(iunit,*) (rho($IRWP(ii,jj,kk)),ii=1,iimax);
               2          ]
               1      WRITE(iunit,*);
               1      ]
               0  close(iunit);
               0  RETURN;
               0  end;
               0
               0  "==========================================================================="
               0  subroutine combine_results(file_name);
               0  "==========================================================================="
               0  " Subroutine called at the end of all parallel runs to recombine the results"
               0  " This used to have to be done separately by the user.                      "
               0  "                                                                           "
               0  "==========================================================================="
               0  implicit none;
               0  COMIN/SCORE/;
               0  character*(*) file_name;
               0  $INTEGER I,IMAX,JMAX,KMAX,lnblnk1;
               0  REAL*4 TENDEP($MAXDOSE), TENDEP2($MAXDOSE);
               0  REAL*8 TTEMP2;
               0  $LOGICAL first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0  IF(first_time)[
               1      OUTPUT61 ;(/1X,'Summing the following .pardose files');
               1      OUTPUT61 ; (1X,'------------------------------------'/);
               1      ]
               0
               0  OUTPUT61 $cstring(file_name);(A);
               0
               0  "file name must be null terminated before passing to C routine"
               0  file_name=$cstring(file_name)//char(0);
               0
               0  call read_pardose(TTEMP2,IMAX,JMAX,KMAX,TENDEP,TENDEP2,file_name);
               0
               0  IF(first_time)[
               1      first_time = .false.;
               1      "zero arrays that we are going to be adding to"
               1      TEMP2=0.;
               1      DO I=1,IMAX*JMAX*KMAX[
               2          endep(I)=0.0;
               2          endep2(I)=0.0;
               2          ]
               1      ]
               0
               0  DO I=1,IMAX*JMAX*KMAX[
               1      endep(i)=endep(i)+tendep(i);
               1      endep2(i)=endep2(i)+ tendep2(i);
               1      ]
               0  TEMP2=TEMP2+TTEMP2;
               0  return;
               0  end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  integer function ibsearch4(a, nsh, b);
               0  real*4 b(*);
               0  $REAL a;
               0  integer min,max,help,nsh;
               0  real*4 x;
               0  min = 1;
               0  max = nsh;
               0  x = a;
               0  WHILE( min < max-1 )[
               1      help = (max+min) / 2;
               1      IF ( b(help)<=x)[
               2          min = help;
               2          ]
               1      ELSE[
               2          max = help;
               2          ]
               1      ]
               0  ibsearch4 = min;
               0  return;
               0  end;
               0
               0  subroutine modify_tmxs(mindel);
               0  implicit none;
               0  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL/;
               0  $REAL eil,ei,p2,beta2,chi_a2,elke,eke,dedx0,estepx,si,sip1,tmxs_orig,
               0  mindel;
               0  $INTEGER i,neke,leil,lelke;
               0
               0  DO medium = 1,nmed [
               1
               1      neke = meke(medium);
               1
               1      eil = (1 - eke0(medium))/eke1(medium); leil = 1;
               1      ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
               1      p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
               1      chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               1      $EVALUATE dedx0 USING ededx(eil);
               1      estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               1      estepx = estepx*ximax;
               1      IF( estepx > estepe ) [ estepx = estepe; ]
               1      si = estepx*ei/dedx0;
               1      IF( si < mindel/2. ) si = mindel/2.;
               1
               1      DO i = 1,neke - 1 [
               2
               2          elke = (i + 1 - eke0(medium))/eke1(medium); lelke = i;
               2          tmxs_orig=tmxs1(i,MEDIUM)*elke+tmxs0(i,MEDIUM);
               2          eke  = Exp(elke); lelke = i+1;
               2          p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
               2          chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               2          $EVALUATE dedx0 USING ededx(elke);
               2          estepx = 2*p2*beta2*dedx0/eke/
               2          Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               2          estepx = estepx*ximax;
               2          IF( estepx > estepe ) [ estepx = estepe; ]
               2          sip1 = estepx*eke/dedx0;
               2          IF( sip1 < mindel/2. ) sip1 = mindel/2.;
               2          tmxs1(i,medium) = (sip1 - si)*eke1(medium);
               2          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;
               2          si = sip1;
               2
               2          ]
               1
               1      tmxs0(neke,medium) = tmxs0(neke - 1,medium);
               1      tmxs1(neke,medium) = tmxs1(neke - 1,medium);
               1
               1      ]
               0
               0  return; end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parameter input functions                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Aaron Merovitz, 1998                                      "
               0  "                   Dave Rogers, 1998                                         "
               0  "                   Iwan Kawrakow, 1998                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
               0  "                                                                             "
               0  "  - Input values taken only if between specified delimiters (prior this      "
               0  "    change, the first VALUES_SOUGHT found was taken, even if it was not      "
               0  "    between the specified delimiters).                                       "
               0  "                                                                             "
               0  "  - Changed argument list to a common block GetInput defined in egs4.macros  "
               0  "    to avoid memory use explosion.                                           "
               0  "                                                                             "
               0  "  - Eliminated initial loop checking for presence of values sought as it is  "
               0  "    not necessary.                                                           "
               0  "                                                                             "
               0  "  - Introduced macros for handling strings (skipping blanks and comments,    "
               0  "    changing to upper case, etc.)                                            "
               0  "                                                                             "
               0  "  - Eliminated string input bug: strings were always converted to upper case "
               0  "                                                                             "
               0  "  - Changed definition of strings to character*$MACRO where $MACRO has a     "
               0  "    certain value that can be be defined in the user code if longer strings  "
               0  "    are required.                                                            "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
               0  "                                                                             "
               0  "  - Missing or misspelled end delimiter together with a missing value sought  "
               0  "    caused the routine to terminate. It now prints an error message and      "
               0  "    continues to look for additional input.                                  "
               0  "                                                                             "
               0  "  - Introduced an array ERROR_FLAGS where the input status of each of the    "
               0  "    attempted inputs is stored.                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT;
               0  "                                                                           "
               0  "                                                                           "
               0  " FUNCTION: Extracts the requested values_sought from input file and        "
               0  "           returns it to the caller.                                       "
               0  "                                                                           "
               0  " USAGE   :      Inputs must have the general form:                         "
               0  "              ***************************************                      "
               0  "              * Value_sought=  Value(s)             *                      "
               0  "              ***************************************                      "
               0  "         e.g.:        MEDNUM= 0, 1, 2                                      "
               0  "                      MEDIA= AIR700ICRU                                    "
               0  "                      RAYLEIGH SCATTERING= on                              "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "
               0  "   Inputs are all in the format: name of value_sought= value
               0  "   where the name of value_sought must match that expected by the
               0  "   program and the = sign must have no blanks between it and value_sought.
               0  "
               0  "   The value_sought must be the first thing on a line but blanks are
               0  "     allowed before it.
               0  "
               0  "   Various inputs are only sought between certain delimeter strings
               0  "     which are defined below (eg :start I/O control: :stop I/O control:)
               0  "     If not specified, the whole file is searched for a requested value_sought.
               0  "     Delimeter strings are enclosed by colons.
               0  "     Note that within delimeter strings, order of inputs does not matter.
               0  "
               0  "   If a requested quantity is not found, this is noted in $input.errors
               0  "     and this file is printed at the end of the log file.
               0  "
               0  "   A semi-colon implies the end of input for this quantity but is
               0  "     not mandatory.  However, this means they cannot be used in titles.
               0  "   A # sign indicated everything else on the line is a comment (and
               0  "     cannot be used in titles.
               0  "   Case is not important in the names of the quantites.
               0  "
               0  "   Commas separate multiple values for a given quantity and a comma
               0  "     at the end of a line implies there is more input on the next line.
               0  "   Values can extend over as many lines as needed. Use commas to imply
               0  "     there are more values on the next line.
               0  "
               0  "   Blank lines and blanks in general are ignored.
               0  "
               0  "   The maximum record length is 256 characters.
               0  "
               0  "
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  "                                                                           "
               0  "                                                                           "
               0  " FEATURES: If the amount of values needed for a particular values_sought   "
               0  "           is known and passed throught NVALUE(I), the subroutine will     "
               0  "           check that the number of inputs correspond.  Otherwise,         "
               0  "           NVALUE(I) will return the # of inputs found.                    "
               0  "                                                                           "
               0  "           For any integer or real (TYPE=0 or 1), get_inputs will check    "
               0  "           that the numerical value input is between VALUE_MIN and         "
               0  "           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
               0  "                                                                           "
               0  "           Writing in the input file can be upper case or lower case.      "
               0  "           However, all FORTRAN >MUST< be programmed in upper case.        "
               0  "              Changed the above: Can now be upper or lower case            "
               0  "                                 IK, Dec. 1998                             "
               0  "                                                                           "
               0  "           For clarity, inputs can be terminated with a semicolon(;).      "
               0  "           This is by no means necessary.                                  "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "                                                                           "
               0  "                   **** DECLARE YOUR INPUTS ****                           "
               0  "                                                                           "
               0  "    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
               0  "                                                                           "
               0  "  I=I+1;                              <--index counter                     "
               0  "  NUM_DRMIN=I;                        <--named pointer to the index num.   "
               0  "  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
               0  "  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
               0  "  TYPE(I)=0;                          <--Type (0-3)                        "
               0  "  VALUE_MIN(I)=0;                     <--Minimum value                     "
               0  "  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
               0  "  DEFAULT(I)=0;                       <--Default value                     "
               0  "                                                                           "
               0  "    CHARACTER INPUTS (TYPE 2)                                              "
               0  "                                                                           "
               0  "  I=I+1;
               0  "  NUM_TITLE=I;
               0  "  VALUES_SOUGHT(I)='TITLE';
               0  "  TYPE(I)=2;
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "
               0  "    ALLOWED INPTUS (TYPE 3)
               0  "
               0  "  I=I+1;
               0  "  NUM_IWATCH=I;
               0  "  VALUES_SOUGHT(I)='IWATCH';
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "  TYPE(I)=3;
               0  "  ALLOWED_INPUTS(I,0)='OFF';
               0  "  ALLOWED_INPUTS(I,1)='INTERACTIONS';
               0  "  ALLOWED_INPUTS(I,2)='STEPS';
               0  "  ALLOWED_INPUTS(I,3)='DEPOSITED';
               0  "  ALLOWED_INPUTS(I,4)='GRAPH';
               0  "                                                                           "
               0  "                      **** STATE THE DELIMETER ****                        "
               0  "                                                                           "
               0  "            DELIMETER='TRANSPORT CONTROL'                                  "
               0  "     OR     DELIMETER='NONE';                                              "
               0  "                                                                           "
               0  "  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
               0  "                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
               0  "                                                                           "
               0  "   The inputs are returned through CHAR_VALUE for character inputs         "
               0  "   or VALUE for integers, reals and allowed inputs                         "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0
               0
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING256 TEXTPIECE;  "Used to read a piece of TEXT                 "
               0  CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  UNITNUM=i_input; "inputfile.egs4inp"
               0  DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);   "Rewind the input file"
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIMETER = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIMETER~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A256)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  "the following is no longer used so comment it out"
               0  ":GI1002:
               0  "      WRITE (ERR,*) '***************ERROR***************';
               0  "      IF (CHECK=100) [
               0  "         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               0  "         WRITE (ERR,*) 'WAS NOT FOUND';
               0  "      ]
               0  "      ELSE [
               0  "         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               0  "                       '<<',' NOT FOUND';
               0  "      ]
               0  "      WRITE (ERR,*) 'END OF FILE REACHED';
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0
               0
1              0  %E   "get_inputs.mortran"
               0  "*****************************************************************************
               0  "
               0  subroutine get_transport_parameter(ounit);
               0  "
               0  " is provided for use with the EGSnrc system. It reads all physics
               0  " related parameters from the input file using the get_input routine.
               0  " For a description for the format/conventions used in get_input,
               0  " see the description at the beginning of this file.
               0  " In order to use this routine, include transportp.macros BEFORE
               0  " get_inputs.mortran via the configuration file.
               0  " If the routine is called with ounit > 0, the transport parameter
               0  " settings will be printid on unit ounit.
               0  "
               0  " Version 0.1           Iwan Kawrakow, January 1999
               0  "
               0  "******************************************************************************
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  You can change this by including the statement
               0  "
               0  "  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
               0  "
               0  "  in your input file.
               0  "
               0  "  Currently, the following options are available (case does not matter and
               0  "             the internal variables are shown in [ ] brackets):
               0  "
               0  "       Global ECUT=     Global (in all regions) electron transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Global (in all regions) photon transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions
               0  "                        will be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%).
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        difference even in `well conditioned' situations
               0  "                        (e.g. depth dose curves for RTP energy range
               0  "                        electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If KM, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, NRC default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but significant in the keV energy range. If NRC is
               0  "                        selected, the NRC brems cross-section data base will
               0  "                        be used, which is a version of the NIST data base
               0  "                        with corrected electron-electron brems contributions
               0  "                        (corrections to the NIST data is typically only
               0  "                        significant for low values of the atomic number Z
               0  "                        and for k/T < 0.005).
               0  "       Triplet production= On or Off (default).  Turns on/off simulation
               0  "                        of triplet production.  If On, then Borsellino's
               0  "                        first Born approximation is used to sample triplet
               0  "                        events based on the triplet cross-section data.
               0  "                        [ itriplet ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej (default)
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impulse approximation.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to use for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Radiative Compton corrections= On or Off (default). If on, then
               0  "                        include radiative corrections for Compton scattering.
               0  "                        Equations are based on original Brown & Feynman
               0  "                        equations (Phys. Rev. 85, p 231--1952).  Requires
               0  "                        a change to the user codes Makefile to include
               0  "                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
               0  "                        SOURCES (just before
               0  "                        $(EGS_SOURCEDIR)get_inputs.mortran).
               0  "                        [ radc_flag ]
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski, penelope.  If set to On or ik, then use
               0  "                        Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then
               0  "                        use the cross-sections of Casnati (contained in the
               0  "                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
               0  "                        kolbenstvedt, gryzinski and penelope. This is only of
               0  "                        interest in kV X-ray calculations.
               0  "                        Case-sensitive except for Off, On or ik options.
               0  "                        [ eii_flag ]
               0  "       Pair angular sampling= Off, Simple, KM.
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.  Uniform
               0  "                        Default is Simple, make sure you always use
               0  "                        Simple or KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel), epdl (Evaluated Photon Data
               0  "                        Library), xcom (the default), pegs4, mcdf-xcom and
               0  "                        mcdf-epdl:
               0  "                        Allows the use of photon cross-sections other than
               0  "                        from the PEGS4 file (unless the pegs4 option is
               0  "                        specified).  Options mcdf-xcom and mcdf-epdl use
               0  "                        Sabbatucci and Salvat's renormalized photoelectric
               0  "                        cross sections with either xcom or epdl for all other
               0  "                        cross sections.  These are more accurate but can
               0  "                        increase CPU time by up to 6 %.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turn on coherent (Rayleigh) scattering.
               0  "                        Default is On. Should be turned on for low energy
               0  "                        applications.
               0  "                        If custom, user must provide media names and form
               0  "                        factor files for each desired medium. For the rest
               0  "                        of the media, default atomic FF are used.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "Ali:photonuc, 2 blocks of comments"
               0  "       Photonuclear attenuation= Off (default) or On
               0  "                        If On, models the photonuclear effect. Current
               0  "                        implementation is crude. Available on a
               0  "                        region-by-region basis (see below)
               0  "                        [ IPHOTONUCR ]
               0  "       Photonuclear cross sections= Total photonuclear cross sections. User-
               0  "                        supplied total photonuclear cross-sections in
               0  "                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
               0  "                        where photonuc_xsections is the name supplied for
               0  "                        this input (case sensitive). In the absence of
               0  "                        any user-supplied data, or if photonuc_xsections
               0  "                        is set to 'default', the default file is
               0  "                        iaea_photonuc.data.
               0  "                        [ photonuc_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is On
               0  "                        [ IPHTER ]
               0  "       Atomic relaxations= Off, On, eadl, simple
               0  "                        Default is eadl.  On defaults to eadl.
               0  "                        When simulating atomic relaxations:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross sections
               0  "                        - Shell vacancies created in photoelectric,
               0  "                          compton and electron impact ionization events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         The eadl option features a more accurate treatment
               0  "                         of relaxation events and uses binding energies
               0  "                         consistent with those in of the photon cross sections
               0  "                         used in the simulation.  If using mcdf-xcom or
               0  "                         mcdf-epdl photon cross sections, you cannot use
               0  "                         the simple option and this will automatically get
               0  "                         reset to eadl.
               0  "                         Make sure to use eadl or simple for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "       and photonuclear effect(Ali:photonuc)
               0  "       can also be turned On/Off on a region-by-region
               0  "       basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "                or                  Ali:photonuc
               0  "       Photonuclear start region=
               0  "       Photonuclear stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0
               0  implicit none;  "Hard coded to catch possible user replacements of the "
               0  "following common blocks"
               0
               0  character*80 line;
               0  character*512 toUpper;
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0
               0  $INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
               0  num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
               0  num_ffmed,num_ffiles,
               0  num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
               0  num_pxsec,num_pxsec_out, num_cxsec,
               0  num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
               0  num_efield, num_bfield, num_emlmt,"EMH: EM fields"
               0  num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
               0  egs_open_file,lnblnk1;
               0
               0  $LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"
               0
               0  character*15 output_strings(14);"Ali:photonuc, increased by 1"
               0  save         output_strings,line;
               0  save         ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions,
               0  num_photonuc;"Ali:photonuc"
               0
               0
               0  DO k=1,80 [ line(k:k) = '='; ]
               0  delimeter = $THE_DELIMETER;
               0  ival = 0;
               0
               0  ;
               0  /ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,
               0  "Ali:photonuc, 1 line"
               0  photonuc_inregions/ = .false.;
               0
               0  "open a .errors file exclusively for output from this subroutine"
               0  i_errors=15;
               0  i_errors=egs_open_file(i_errors,0,1,'.errors');
               0
               0  write(i_errors,*)
               0  ' If you are not trying to reset transport parameters, ';
               0  write(i_errors,*)
               0  ' ignore all the output until the message ';
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  " ECUT "
               0  ival                = ival + 1;
               0  num_ecut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-ECUT;
               0
               0  " PCUT "
               0  ival                = ival + 1;
               0  num_pcut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-PCUT;
               0
               0  " SMAX "
               0  ival                = ival + 1;
               0  num_smax            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_SMAX;             "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $MAX-SMAX;
               0
               0  " Incoherent (Compton) scattering "
               0  ival                = ival + 1;
               0  num_incoh           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'Simple';
               0  allowed_inputs(ival,5) = 'norej';
               0
               0  " Radiative corrections for Compton scattering "
               0  ival                = ival + 1;
               0  num_radc            = ival;
               0  values_sought(ival) = $RADC_COMPTON;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Coherent (Rayleigh) scattering "
               0  ival                = ival + 1;
               0  num_coh             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'custom';
               0
               0  " Atomic Relaxations "
               0  ival                = ival + 1;
               0  num_relax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'eadl';
               0  allowed_inputs(ival,5) = 'simple';
               0
               0  " Photoelectron angular sampling "
               0  ival                = ival + 1;
               0  num_pe_ang          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Bremsstrahlung angular sampling "
               0  ival                = ival + 1;
               0  num_brems_ang       = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Simple';
               0  allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0
               0  " Bremsstrahlung cross sections "
               0  ival                = ival + 1;
               0  num_brems_cs        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
               0  allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"
               0
               0
               0  " Pair angular sampling "
               0  ival                = ival + 1;
               0  num_pair_ang        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
               0  allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0  allowed_inputs(ival,3) = 'Uniform';
               0  allowed_inputs(ival,4) = 'Blend';
               0
               0  " Pair cross sections "
               0  ival                = ival + 1;
               0  num_pair_cs         = ival;
               0  values_sought(ival) = $PAIR_CROSS_SECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NRC';
               0
               0  " Triplet production "
               0  ival                = ival + 1;
               0  num_triplet         = ival;
               0  values_sought(ival) = $TRIPLET_PRODUCTION;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Spin effects          "
               0  ival                = ival + 1;
               0  num_spin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SPIN_EFFECTS;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';                 "Only global on/off available"
               0
               0  " Electron impact ionization "
               0  ival                = ival + 1;
               0  num_eii             = ival;
               0  values_sought(ival) = $ELECTRON_IMPACT_IONI;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0  "type(ival)          = 3;"
               0  "allowed_inputs(ival,0) = 'Off';"
               0  "allowed_inputs(ival,1) = 'On';"
               0  "allowed_inputs(ival,2) = 'casnati';"
               0  "allowed_inputs(ival,3) = 'kolbenstvedt';"
               0  "allowed_inputs(ival,4) = 'gryzinski';"
               0
               0  " L-shell EII xsection scaling"
               0  ival                = ival + 1;
               0  num_eii_L= ival;                                "Set the variable pointer"
               0  values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0e+9;
               0  default(ival)       = 1.0;
               0
               0  " ESTEPE "
               0  ival                = ival + 1;
               0  num_estepe          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 1e-5;                     "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $MAX-ELOSS;
               0
               0  " XIMAX "
               0  ival                = ival + 1;
               0  num_ximax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $EXACT-BCA-XIMAX;
               0
               0  " BCA "
               0  ival                = ival + 1;
               0  num_bca             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Exact';
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Skindepth "
               0  ival                = ival + 1;
               0  num_skin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1;                       "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $SKIN-DEPTH-FOR-BCA;
               0
               0  " Electron-step algorithm "
               0  ival                = ival + 1;
               0  num_alg             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Photon cross sections "
               0  ival                = ival + 1;
               0  num_pxsec           = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " Photon cross sections output "
               0  ival                = ival + 1;
               0  num_pxsec_out       = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS_OUT;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Compton cross sections "
               0  ival                = ival + 1;
               0  num_cxsec           = ival;
               0  values_sought(ival) = $COMPTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " E-Field "
               0  ival                = ival + 1;
               0  num_efield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $E_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e15;                    "Define the allowed range"
               0  value_max(ival)     =  1e15;
               0  default(ival)       =  0;
               0
               0  " B-Field "
               0  ival                = ival + 1;
               0  num_bfield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $B_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e10;                    "Define the allowed range"
               0  value_max(ival)     =  1e10;
               0  default(ival)       =  0;
               0
               0  " EM-field step and eloss restriction "
               0  ival                = ival + 1;
               0  num_emlmt           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $EM_LMT;                 "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0;
               0  default(ival)       = 0.02;
               0
               0  "Ali:photonuc, 2 blocks"
               0  " Photonuclear "
               0  ival                = ival + 1;
               0  num_photonuc        = ival;           "set the variable pointer"
               0  values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
               0  nvalue(ival)        = 1;              "1 input"
               0  type(ival)          = 3;              "an `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Photonuclear cross sections "
               0  ival                = ival + 1;
               0  num_photonuc_xsec   = ival;
               0  values_sought(ival) = $PHOTONUC_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  "Ali:photonuc, 1 line"
               0  Nmin = num_ecut; Nmax = num_photonuc_xsec;
               0  "Nmin = num_ecut; Nmax = num_cxsec;"
               0
               0  CALL GET_INPUT;
               0
               0  IF( error_flags(num_ecut) = 0 ) [
               1      DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
               1      ]
               0  IF( error_flags(num_pcut) = 0 ) [
               1      DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
               1      ]
               0  IF( error_flags(num_smax) = 0 ) [
               1      DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
               1      ]
               0  IF( error_flags(num_brems_ang) = 0 ) [
               1      ibrdst = value(num_brems_ang,1);
               1      ]
               0  IF( error_flags(num_brems_cs) = 0 ) [
               1      ibr_nist = value(num_brems_cs,1);
               1      ]
               0  IF( error_flags(num_radc) = 0 ) [
               1      radc_flag = value(num_radc,1);
               1      ]
               0  IF( error_flags(num_pair_ang) = 0 ) [
               1      iprdst = value(num_pair_ang,1);
               1      ]
               0  IF( error_flags(num_pair_cs) = 0 ) [
               1      pair_nrc = value(num_pair_cs,1);
               1      ]
               0  IF( error_flags(num_triplet) = 0 ) [
               1      itriplet = value(num_triplet,1);
               1      ]
               0  IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
               0  IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
               0  IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
               0  IF( error_flags(num_bca) = 0 ) [
               1      bca_algorithm = value(num_bca,1);
               1      IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               1      ]
               0  IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
               0  IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
               0  IF( error_flags(num_spin) = 0 ) [
               1      itmp = value(num_spin,1);
               1      IF( itmp = 1 ) [ spin_effects = .true.; ]
               1      ELSE           [ spin_effects = .false.; ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_eii) = 0 ) [
               1      eii_xfile = char_value(num_eii,1);eii_flag=1;
               1      IF (toUpper($cstring(eii_xfile)).eq.'ON' |
               1      toUpper($cstring(eii_xfile)).eq.'IK' )[
               2          eii_xfile = 'ik';
               2          $egs_info(*,'==> Using default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
               2          eii_xfile='Off';eii_flag=0;
               2          ]
               1      ELSE["Using non-default EII data compilation"
               2          $egs_warning(*,'==> Using non-default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_pxsec) = 0 ) [
               1      photon_xsections = char_value(num_pxsec,1);
               1      IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
               2          ]
               1      ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
               2          ]
               1      ELSE[
               2          mcdf_pe_xsections = .false.;
               2          ]
               1      ]
               0
               0  IF( error_flags(num_pxsec_out) = 0 ) [
               1      xsec_out = value(num_pxsec_out,1);
               1      ]
               0  IF( error_flags(num_cxsec) = 0 ) [
               1      comp_xsections = char_value(num_cxsec,1);
               1      ]
               0  "Ali:photonuc, 3 lines"
               0  IF( error_flags(num_photonuc_xsec) = 0 ) [
               1      photonuc_xsections = char_value(num_photonuc_xsec,1);
               1      ]
               0
               0  IF( error_flags(num_efield) = 0 ) [
               1      ExIN = value(num_efield,1);
               1      EyIN = value(num_efield,2);
               1      EzIN = value(num_efield,3);
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented only for the C++ applications     "
               0  IF( error_flags(num_bfield) = 0 ) [
               1      BxIN = value(num_bfield,1);
               1      ByIN = value(num_bfield,2);
               1      BzIN = value(num_bfield,3);
               1      Bx=BxIN;By=ByIN;Bz=BzIN;
               1      Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_coh) = 0 ) [
               1      IF(value(num_coh,1) = 4)[
               2          write(*,'(/a/)') ' ===> custom ff requested!';
               2          ival                = ival + 1;
               2          num_ffmed           = ival;
               2          values_sought(ival) = 'ff media names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          ival                = ival + 1;
               2          num_ffiles          = ival;
               2          values_sought(ival) = 'ff file names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          Nmin = num_ffmed; Nmax = num_ffiles;
               2          CALL GET_INPUT;
               2          IF( error_flags(num_ffmed) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffmed));
               3              ]
               2          IF( error_flags(num_ffiles) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffiles));
               3              ]
               2          IF (nvalue(num_ffmed)>$MXMED)[
               3              $egs_fatal('(a,a,i3,a)',
               3              '***** Number of media with custom ff larger ',
               3              'than maximum number of media $MXMED = ',$MXMED,
               3              ' increase $MXMED and try again!!!');
               3              ]
               2          DO i=1,nvalue(num_ffmed) [
               3              iray_ff_media(i) = char_value(num_ffmed,i);
               3              iray_ff_file(i)  = char_value(num_ffiles,i);
               3              ]
               2          value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
               2          ]
               1      write(*,'(/)');
               1      ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $TURN-ON/OFF-IN-REGIONS(num_incoh,
               0  'Bound Compton start region',
               0  'Bound Compton stop region',
               0  ibcmp); incoh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_coh,
               0  'Rayleigh start region',
               0  'Rayleigh stop region',
               0  iraylr); coh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_relax,
               0  'Relaxations start region',
               0  'Relaxations stop region',
               0  iedgfl); relax_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_pe_ang,
               0  'PE sampling start region',
               0  'PE sampling stop region',
               0  iphter); pe_inregions = aux_inregions;
               0  "Ali:photonuc, 1 block"
               0  $TURN-ON/OFF-IN-REGIONS(num_photonuc,
               0  'Photonuclear start region',
               0  'Photonuclear stop region',
               0  iphotonucr); photonuc_inregions = aux_inregions;
               0  $SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
               0  'Set ECUT stop region');
               0  ecut_inregions = aux_inregions;
               0
               0  $SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
               0  'Set PCUT stop region');
               0  pcut_inregions = aux_inregions;
               0
               0  $SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
               0  'Set SMAX stop region');
               0  smax_inregions = aux_inregions;
               0
               0  write(i_errors,*);
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  "Check if EADL relaxation requested. Note that original relaxation"
               0  "algorithm using <M> and <N> is only turned ON for all regions."
               0  "Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
               0  "default case."
               0  IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
               1      eadl_relax = .true.;
               1      "Default relaxation is EADL"
               1      IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
               1      ]
               0  ELSE [
               1      IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
               2          eadl_relax = .true.; value(num_relax,1)=4;
               2          $egs_warning('(a/,a/,a/)',
               2          '    Simplified atomic relaxation not allowed',
               2          '    with shellwise PE cross sections. Resetting',
               2          '    to detailed EADL atomic relaxation!!!');
               2          ]
               1      ELSE [
               2          eadl_relax = .false.;
               2          ]
               1      ]
               0
               0  " we put the information stored in allowed_inputs into "
               0  " output_strings just in case the user over-rides it "
               0  " before printing out the settings "
               0
               0  output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
               0  itmp = value(num_incoh,1);
               0  output_strings(2) = allowed_inputs(num_incoh,itmp);
               0  $RADC_WARNING;
               0  output_strings(12) = allowed_inputs(num_radc,radc_flag);
               0  itmp = value(num_coh,1);
               0  output_strings(3) = allowed_inputs(num_coh,itmp);
               0  itmp = value(num_relax,1);
               0  output_strings(4) = allowed_inputs(num_relax,itmp);
               0  itmp = value(num_pe_ang,1);
               0  output_strings(5) = allowed_inputs(num_pe_ang,itmp);
               0  output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
               0  output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
               0  output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
               0  output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
               0  output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
               0  output_strings(11) = allowed_inputs(num_triplet,itriplet);
               0  "output_strings(13) = allowed_inputs(num_eii,eii_flag);"
               0  "Ali:photonuc, 2 lines"
               0  itmp = value(num_photonuc,1);
               0  output_strings(14) = allowed_inputs(num_photonuc,itmp);
               0
               0  entry show_transport_parameter(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0  write(ounit,'(a,/)')
               0  '                   Electron/Photon transport parameter';
               0  write(ounit,'(a,/)') line;
               0
               0
               0  IF (mcdf_pe_xsections)[
               1      write(ounit,'(a,38x,a,a)') ' Photon cross sections',
               1      'mcdf-',$cstring(photon_xsections);
               1      ]
               0  ELSE[
               1      write(ounit,'(a,38x,a)') ' Photon cross sections',
               1      $cstring(photon_xsections);
               1      ]
               0  write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);
               0
               0  write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
               0  IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
               1      ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
               1      ]
               0  write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
               0  write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
               0  write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
               0  write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
               0  write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
               0  write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
               0  write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
               0  write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
               0  "Ali:photonuc, 3 lines. EMH added IF statement"
               0  IF ( value(num_photonuc,1) > 0 )[
               1      write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
               1      write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
               1      $cstring(photonuc_xsections);
               1      ]
               0
               0  write(ounit,*);
               0
               0  write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
               0  IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
               1      ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
               1      ]
               0  write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
               0  write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
               0  IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
               0  ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
               0  write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
               0  IF (eii_L_factor ~= 1.0) [
               1      write(ounit,'(a,25x,f6.4)')
               1      ' L-shell EII xsections scaling factor',eii_L_factor;
               1      ]
               0  write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
               0  IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
               1      ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
               1      ]
               0  write(ounit,'(a,16x,f6.4)')
               0  ' Maximum fractional energy loss/step (ESTEPE)',estepe;
               0  write(ounit,'(a,21x,f6.4)')
               0  ' Maximum 1st elastic moment/step (XIMAX)',ximax;
               0  write(ounit,'(a,33x,a10)')
               0  ' Boundary crossing algorithm',output_strings(7);
               0  write(ounit,'(a,22x,g9.4)')
               0  ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
               0  write(ounit,'(a,37x,a10)')
               0  ' Electron-step algorithm',output_strings(8);
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
               1      write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
               1      ExIN,EyIN,EzIN;
               1      ]
               0  IF( Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
               1      Bx,By,Bz;
               1      ]
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
               0  Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
               1      ]
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0
               0  return;
               0  end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine set_elastic_parameter;
               0
               0  implicit none;
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0  ;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
               0  $INTEGER imed,ival,lnblnk1,nchanged;
               0  character*24 medname;
               0
               0  ounit = i_log;
               0  ounit = i_log;
               0  delimeter = $THE_DELIMETER;
               0  call get_input_set_error_level(0);
               0  ival = 0;
               0  DO imed=1,nmed [
               1      call egs_get_medium_name(imed,medname);
               1      ival                = ival + 1;
               1      values_sought(ival) = 'scale elastic scattering in '//
               1      medname(:lnblnk1(medname));
               1      nvalue(ival)        = 1;
               1      type(ival)          = 1;
               1      value_min(ival)     = 1e-3;
               1      value_max(ival)     = 1e3;
               1      default(ival)       = 1;
               1      ]
               0  Nmin = 1; Nmax = nmed;
               0  CALL GET_INPUT;
               0  nchanged = 0;
               0  DO imed=1,nmed [
               1      IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
               1      ]
               0  IF( nchanged > 0 ) [
               1      write(ounit,'(//a)')
               1      '================ Elastic scattering scaled as follows ==================';
               1      DO imed=1,nmed [
               2          IF( error_flags(imed) = 0 ) [
               3              call egs_get_medium_name(imed,medname);
               3              xcc(imed)  = xcc(imed)*value(imed,1);
               3              blcc(imed) = blcc(imed)*value(imed,1);
               3              write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
               3              value(imed,1);
               3              ]
               2          ]
               1      write(ounit,'(a//)')
               1      '========================================================================';
               1      ]
               0  return; end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc media input functions                                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END);
               0  "                                                                           "
               0  " A version of GET_INPUT that allows the user to specify a UNITNUM          "
               0  " other than the .egsinp file and different start and end delimiters.       "
               0  " Note that delimiters are interpreted literally.                           "
               0  " If NONE is supplied as DELIM_END, then EOF is taken as the stop           "
               0  " delimiter.                                                                "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING256 TEXTPIECE; "Used to read a piece of TEXT                  "
               0  CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING80  ENDSTRING;  "string at which to terminate search          "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG,end_string;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  DELIM_START=DELIM_START(:lnblnk1(DELIM_START));
               0  DELIM_END=DELIM_END(:lnblnk1(DELIM_END));
               0  $SKIP LEADING BLANKS IN DELIM_START;
               0  $SKIP LEADING BLANKS IN DELIM_END;
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0  $SKIP LEADING BLANKS IN ENDSTRING;
               0  IF(ENDSTRING=blank)[
               1      end_string=.false.;
               1      ]
               0  ELSE[
               1      $CONVERT ENDSTRING TO UPPER CASE;
               1      end_string=.false.;
               1      ]
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIM_START = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIM_END~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END;
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A256)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_plus_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0  "*****************************************************************************
               0  "
               0  subroutine get_media_inputs(ounit);
               0  "subroutine to take the media names in the input file and get the material
               0  "data, either from a user-specified material data file, from material data
               0  "specified explicitly in the input file, or from a user-specified density
               0  "correction file.  This subroutine is called in HATCH.  It assumes that
               0  "the subroutine get_transport_parameter has already been called and that
               0  "the media names in the simulation have already been read in.
               0
               0  implicit none;
               0
               0  REPLACE{$MAXPOINTS}WITH{300};
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0  COMIN/MEDINP,ELECIN,THRESH,ELEMTB,USEFUL/;
               0
               0  $INTEGER  ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_ap,ival_up,
               0  ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iaprim,ival_gasp,
               0  ival_pz,ival_sterncid,
               0  ival_densityfile,medfile_error,ival_outfile,
               0  egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_mederr,mindex,eindex,
               0  i_density,i01,length,i_outfile;
               0  $REAL ecut_min, pcut_min;
               0
               0  $LOGICAL  medfile_specified,densityfile_specified,elements_specified,
               0  outfile_specified($MXMED);
               0  $LOGICAL  iunrst_specified,stern_specified,iaprim_specified,
               0  gasp_specified,rho_specified,start_delim_found,end_delim_found,
               0  spec_by_pz,spec_by_rhoz,df_if_elem_mismatch($MXMED),
               0  df_if_rho_mismatch($MXMED);
               0  $LOGICAL  ex;
               0
               0  $INTEGER CURSOR,Kconvert;
               0
               0  "maybe we do not need to keep ZTBL REAL4, since it is only used here"
               0  $REAL4 ZTBL;
               0
               0  "variables for output of cross-section data to file for plotting"
               0  "some names end with O to avoid conflict with global variables"
               0  "in common blocks above"
               0  $REAL EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETAB(16),
               0  EIE,PLOTE($MAXPOINTS),PLOTEM($MAXPOINTS),PLOTEEN($MAXPOINTS),
               0  PLOTEMP($MAXPOINTS), PLOTEMS($MAXPOINTS);
               0  $INTEGER IPLOTE,IFLAG1,IFLAG2,LELKE;
               0  CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp,
               0  SUBTITLE,SERIES;
               0  DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9./;
               0
               0
               0  character*24 medium_name,med_tmp,sterncid_tmp;
               0  character*256 density_file,material_file,tmp_string,
               0  spoutput_file($MXMED);
               0  character*80 text_string, text_save, title;
               0  character*80 delim_start,delim_end;
               0  character*1 blank;
               0  character*512 toUpper;
               0
               0  "temporary variables for storing values before committing them"
               0  "to the media library"
               0  $INTEGER nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp;
               0  $REAL rho_tmp,rhoz_tmp($MXEL),z_tmp($MXEL),pz_tmp($MXEL),ae_tmp,ap_tmp,
               0  ue_tmp,up_tmp,gasp_tmp;
               0  $TYPE asym_tmp($MXEL);
               0
               0  "for stuff read from the density correction file"
               0  $INTEGER nepst_df,nne_df;
               0  $REAL iev_df,rho_df,z_df($MXEL),rhoz_df($MXEL),rhoz_tot;
               0  $TYPE asym_df($MXEL);
               0
               0  data blank/' '/;
               0
               0  save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho_mismatch,
               0  spoutput_file,outfile_specified;
               0
               0  REPLACE {$WRITE_MEDERR(#)} WITH {
            {  0  ;
            {  0  IF(n_parallel=0 | i_parallel=first_parallel)[
            {  0  write(i_mederr,*){P1};
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  call get_input_set_error_level(0);
               0  call get_input_plus_set_error_level(0);
               0
               0  "open a file for output from this routine"
               0  IF(n_parallel=0 | i_parallel=first_parallel)[
               1      i_mederr=17;
               1      i_mederr=egs_open_file(i_mederr,0,1,'.mederr');
               1      ]
               0
               0  "find min. ecut and pcut"
               0  ecut_min=999.;
               0  pcut_min=999.;
               0  DO i=1,$MXREG[
               1      IF(ecut(i)<ecut_min)ecut_min=ecut(i);
               1      IF(pcut(i)<pcut_min)pcut_min=pcut(i);
               1      ]
               0
               0  delimeter = 'MEDIA DEFINITION';
               0  ival = 0;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "full name of media data file"
               0  ival                = ival + 1;
               0  ival_medfile         = ival;
               0  values_sought(ival) = 'material data file';    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 2;
               0  Nmin = ival_medfile; Nmax = ival_medfile;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_medfile)=0)[
               1      material_file=char_value(ival_medfile,1);
               1      medfile_specified=.true.;
               1      "try opening it"
               1      i_medfile=17;
               1      i_medfile=egs_get_unit(i_medfile);
               1      IF(i_medfile < 1)[
               2          $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               2          ' medium data file.');
               2          ]
               1      open(i_medfile,file=material_file,status='old',err=:no_media_file:);
               1      medfile_specified=.true.;
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: material data file not supplied.');
               1      $WRITE_MEDERR(' Thus, you must define media explicitly in input file');
               1      $WRITE_MEDERR(' or via density correction file.');
               1      medfile_specified=.false.;
               1      ]
               0
               0  "get AE, UE, AP, UP, if specified"
               0  ival                = ival + 1;
               0  ival_ae = ival;
               0  values_sought(ival) = 'ae';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = ecut_min;
               0
               0  ival                = ival + 1;
               0  ival_ap = ival;
               0  values_sought(ival) = 'ap';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = pcut_min;
               0
               0  ival                = ival + 1;
               0  ival_ue = ival;
               0  values_sought(ival) = 'ue';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50 + prm;
               0
               0  ival                = ival + 1;
               0  ival_up = ival;
               0  values_sought(ival) = 'up';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50.0;
               0
               0  Nmin=ival_ae;Nmax=ival_up;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_ae)=0)[
               1      ae_tmp=value(ival_ae,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AE for media not supplied.  Will use min. ECUT.');
               1      ae_tmp=ecut_min;
               1      ]
               0  IF(error_flags(ival_ap)=0)[
               1      ap_tmp=value(ival_ap,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AP for media not supplied.  Will use min. PCUT.');
               1      ap_tmp=pcut_min;
               1      ]
               0  IF(error_flags(ival_ue)=0)[
               1      ue_tmp=value(ival_ue,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UE for media not supplied.  Will use
            '  1      50.5109989461 MeV');
               1      ue_tmp=50 + prm;
               1      ]
               0  IF(error_flags(ival_up)=0)[
               1      up_tmp=value(ival_up,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UP for media not supplied.  Will use 50.0 MeV');
               1      up_tmp=50.;
               1      ]
               0
               0  IF(ue_tmp<=ae_tmp)[
               1      $WRITE_MEDERR(' Error: UE <= AE.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UE <= AE.  Adjust value(s) and try again.');
               1      ]
               0  IF(up_tmp<=ap_tmp)[
               1      $WRITE_MEDERR(' Error: UP <= AP.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UP <= AP.  Adjust value(s) and try again.');
               1      ]
               0
               0  "now check for individual media inputs in file"
               0  "if not there, get data from material data file"
               0
               0  DO i=1,NMED[
               1
               1      "convert medium name to string for ease of"
               1      "implementation"
               1      DO j=1,24[medium_name(j:j)=media(j,i);]
               1
               1      "set up defaults"
               1      elements_specified=.false.;
               1      rho_specified=.false.;
               1      densityfile_specified=.false.;
               1      stern_specified=.false.;
               1      iunrst_specified=.false.;
               1      iaprim_specified=.false.;
               1      gasp_specified=.false.;
               1      spec_by_rhoz=.false.;
               1      spec_by_pz=.false.;
               1      df_if_elem_mismatch(i)=.false.;
               1      df_if_rho_mismatch(i)=.false.;
               1
               1      sterncid_tmp=medium_name;
               1      gasp_tmp=0.0;
               1      iunrst_tmp=0;
               1      iaprim_tmp=0;
               1      epstfl_tmp=0;
               1      density_file=' ';
               1
               1      $WRITE_MEDERR(' ');
               1
               1      $WRITE_MEDERR(' For medium: ',medium_name);
               1
               1      delimeter=$cstring(medium_name);
               1
               1      ival=0;
               1
               1      "see if composition is specified explicitly"
               1      ival=ival+1;
               1      ival_elements=ival;
               1      values_sought(ival) = 'elements';
               1      type(ival)          = 2;  "i.e.  character input"
               1      nvalue(ival)        = 0;
               1      nmin=ival_elements;nmax=ival_elements;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_elements)=0)[
               2          DO j=1,nvalue(ival_elements)[
               3              $CONVERT char_value(ival_elements,j) TO UPPER CASE;
               3              ]
               2          "now get fraction of each element"
               2          ival=ival+1;
               2          ival_pz=ival;
               2          nne_tmp=nvalue(ival_elements);
               2          values_sought(ival)='number of atoms';
               2          type(ival)=0;
               2          nvalue(ival)=nne_tmp;
               2          nmin=ival_pz;nmax=ival_pz;
               2          CALL GET_INPUT;
               2          IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               3              "got em.  Use em.  But not if this is an element"
               3              DO j=1,nne_tmp[
               4                  asym_tmp(j)=char_value(ival_elements,j);
               4                  pz_tmp(j)=value(ival_pz,j);
               4                  ]
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          ELSE[
               3              "check to see if fractional wts specified"
               3              ival=ival+1;
               3              ival_rhoz=ival;
               3              values_sought(ival)='mass fractions';
               3              type(ival)=1;
               3              nvalue(ival)=nne_tmp;
               3              nmin=ival_rhoz;nmax=ival_rhoz;
               3              IF(nne_tmp=1)[
               4                  "set max, min and default values"
               4                  value_min(ival)=0.0;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=1.;
               4                  ]
               3              CALL GET_INPUT;
               3              IF(error_flags(ival_rhoz)=0)[
               4                  "got em.  Use em."
               4                  DO j=1,nne_tmp[
               5                      asym_tmp(j)=char_value(ival_elements,j);
               5                      rhoz_tmp(j)=value(ival_rhoz,j);
               5                      ]
               4                  elements_specified=.true.;
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          IF(nne_tmp=1 & ~elements_specified)[
               3              "an element: set pz to 1 and use default atomic weight"
               3              asym_tmp(1)=char_value(ival_elements,1);
               3              pz_tmp(1)=1;
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          IF(elements_specified)[
               3              $WRITE_MEDERR(' Composition specified in .egsinp file.');
               3              ]
               2          ]
               1
               1      "see what else is there"
               1      ival=ival+1;
               1      ival_rho=ival;
               1      values_sought(ival) = 'rho';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=1.0;
               1      nmin=ival_rho;nmax=ival_rho;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_rho)=0)[
               2          rho_tmp=value(ival_rho,1);
               2          rho_specified=.true.;
               2          $WRITE_MEDERR(' Rho specified in .egsinp file.');
               2          ]
               1
               1      "now see what else is specified in the .egsinp file"
               1      ival=ival+1;
               1      ival_sterncid=ival;
               1      values_sought(ival)='sterncid';
               1      type(ival)=2;
               1      nvalue(ival)=1;
               1      nmin=ival_sterncid;nmax=ival_sterncid;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_sterncid)=0)[
               2          sterncid_tmp=char_value(ival_sterncid,1);
               2          stern_specified=.true.;
               2          $WRITE_MEDERR(' STERNCID specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iunrst=ival;
               1      values_sought(ival)='stopping powers';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='restricted total';
               1      allowed_inputs(ival,1)='unrestricted collision';
               1      allowed_inputs(ival,2)='unrestricted collision and radiative';
               1      allowed_inputs(ival,3)='unrestricted collision and restricted radiative';
               1      allowed_inputs(ival,4)='restricted collision and unrestricted radiative';
               1      allowed_inputs(ival,5)='unrestricted radiative';
               1      nmin=ival_iunrst;nmax=ival_iunrst;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iunrst)=0)[
               2          iunrst_tmp=value(ival_iunrst,1);
               2          iunrst_specified=.true.;
               2          $WRITE_MEDERR(' IUNRST specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iaprim=ival;
               1      values_sought(ival)='bremsstrahlung correction';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='KM';
               1      allowed_inputs(ival,1)='NRC';
               1      allowed_inputs(ival,2)='none';
               1      nmin=ival_iaprim;nmax=ival_iaprim;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iaprim)=0)[
               2          iaprim_tmp=value(ival_iaprim,1);
               2          iaprim_specified=.true.;
               2          $WRITE_MEDERR(' IAPRIM specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_gasp=ival;
               1      values_sought(ival)='gas pressure';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=0.0;
               1      nmin=ival_gasp;nmax=ival_gasp;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_gasp)=0)[
               2          gasp_tmp=value(ival_gasp,1);
               2          gasp_specified=.true.;
               2          $WRITE_MEDERR(' GASP specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_densityfile=ival;
               1      values_sought(ival)='density correction file';
               1      type(ival)          = 2;
               1      nvalue(ival)=1;
               1      nmin=ival_densityfile;nmax=ival_densityfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_densityfile)=0)[
               2          density_file=char_value(ival_densityfile,1);
               2          densityfile_specified=.true.;
               2          "may get changed to false later if it cannot be opened"
               2          $WRITE_MEDERR(' Density correction file specified in .egsinp file.');
               2          ]
               1
               1      "check if the user has specified an output file for plotting"
               1      "e- data."
               1      ival = ival+1;
               1      ival_outfile = ival;
               1      values_sought(ival) = 'e- stopping power output file';
               1      type(ival) = 2;
               1      nvalue(ival) =1;
               1      nmin=ival_outfile;nmax=ival_outfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_outfile)=0)[
               2          spoutput_file(i)=char_value(ival_outfile,1);
               2          outfile_specified(i)=.true.;
               2          $WRITE_MEDERR(' e- stopping powers will be output to ',
               2          spoutput_file(i));
               2          ]
               1      ELSE [
               2          outfile_specified(i)=.false.;
               2          ]
               1
               1      "done reading the .egsinp file for this medium"
               1      "see if we need anything from the material data file"
               1      IF(medfile_specified & (~elements_specified | ~rho_specified |
               1      ~iunrst_specified | ~iaprim_specified | ~gasp_specified |
               1      ~stern_specified | ~densityfile_specified))[
               2          "we assume at this point that the media file has been opened"
               2          "let us find the delimeters for this medium"
               2          rewind(i_medfile);
               2          start_delim_found=.false.;
               2          end_delim_found=.false.;
               2          WHILE(~start_delim_found | ~end_delim_found)[
               3              read(i_medfile,'(a)',end=:stop_medfile_read:)text_string;
               3              text_save=text_string;
               3              text_string=toUpper($cstring(text_string));
               3              mindex=index(text_string,'MEDIUM');
               3              eindex=index(text_string,'=');
               3              IF(mindex>0 & eindex>mindex)[
               4                  "remove everything up to ="
               4                  text_string=text_save(eindex+1:);
               4                  text_string=$cstring(text_string);
               4                  $SKIP LEADING BLANKS IN text_string;
               4                  IF(text_string=medium_name)[
               5                      delim_start=text_save;
               5                      start_delim_found=.true.;
               5                      ]
               4                  ELSEIF(start_delim_found)[
               5                      delim_end=text_save;
               5                      end_delim_found=.true.;
               5                      ]
               4
               4                  ]
               3              ]
               2          :stop_medfile_read:
               2          IF(~start_delim_found)[
               3              $WRITE_MEDERR(' Warning: Data for ',medium_name,' not found');
               3              $WRITE_MEDERR(' in material data file.');
               3              ]
               2          ELSE[
               3              IF(~end_delim_found)[
               4                  "eof is end delimiter"
               4                  delim_end='NONE';
               4                  ]
               3
               3              ival=0;
               3              "now go through and get what is required"
               3              IF(~elements_specified)[
               4                  ival=ival+1;
               4                  ival_elements=ival;
               4                  values_sought(ival) = 'elements';
               4                  type(ival)          = 2;  "i.e.  character input"
               4                  nvalue(ival)        = 0;
               4                  nmin=ival_elements;nmax=ival_elements;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_elements)=0)[
               5                      "now get fraction of each element"
               5                      ival=ival+1;
               5                      ival_pz=ival;
               5                      nne_tmp=nvalue(ival_elements);
               5                      values_sought(ival)='number of atoms';
               5                      type(ival)=0;
               5                      nvalue(ival)=nne_tmp;
               5                      nmin=ival_pz;nmax=ival_pz;
               5                      CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               5                      IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               6                          "got em.  Use em.  If its not an element"
               6                          DO j=1,nne_tmp[
               7                              asym_tmp(j)=char_value(ival_elements,j);
               7                              pz_tmp(j)=value(ival_pz,j);
               7                              ]
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      ELSE[
               6                          "check to see if fractional wts specified"
               6                          ival=ival+1;
               6                          ival_rhoz=ival;
               6                          values_sought(ival)='mass fractions';
               6                          type(ival)=1;
               6                          nvalue(ival)=nne_tmp;
               6                          nmin=ival_rhoz;nmax=ival_rhoz;
               6                          IF(nne_tmp=1)[
               7                              "set max, min and default values"
               7                              value_min(ival)=0.0;
               7                              value_max(ival)=1.e15;
               7                              default(ival)=1.;
               7                              ]
               6                          CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               6                          IF(error_flags(ival_rhoz)=0)[
               7                              "got em.  Use em."
               7                              DO j=1,nne_tmp[
               8                                  asym_tmp(j)=char_value(ival_elements,j);
               8                                  rhoz_tmp(j)=value(ival_rhoz,j);
               8                                  ]
               7                              elements_specified=.true.;
               7                              spec_by_rhoz=.true.;
               7                              ]
               6                          ]
               5                      IF(nne_tmp=1 & ~elements_specified)[
               6                          asym_tmp(1)=char_value(ival_elements,1);
               6                          pz_tmp(1)=1;
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      IF(elements_specified)[
               6                          $WRITE_MEDERR(' Composition specified in material data file');
               6                          ]
               5                      ]
               4                  ]
               3
               3              IF(~rho_specified)[
               4                  ival=ival+1;
               4                  ival_rho=ival;
               4                  values_sought(ival) = 'rho';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1e15;
               4                  default(ival)=1.0;
               4                  nmin=ival_rho;nmax=ival_rho;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_rho)=0)[
               5                      rho_tmp=value(ival_rho,1);
               5                      rho_specified=.true.;
               5                      $WRITE_MEDERR(' Rho specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~stern_specified)[
               4                  ival=ival+1;
               4                  ival_sterncid=ival;
               4                  values_sought(ival)='sterncid';
               4                  type(ival)=2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_sterncid;nmax=ival_sterncid;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_sterncid)=0)[
               5                      sterncid_tmp=char_value(ival_sterncid,1);
               5                      stern_specified=.true.;
               5                      $WRITE_MEDERR(' STERNCID specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iunrst_specified)[
               4                  ival=ival+1;
               4                  ival_iunrst=ival;
               4                  values_sought(ival)='stopping powers';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='restricted total';
               4                  allowed_inputs(ival,1)='unrestricted collision';
               4                  allowed_inputs(ival,2)='unrestricted collision and radiative';
               4                  allowed_inputs(ival,3)=
               4                  'unrestricted collision and restricted radiative';
               4                  allowed_inputs(ival,4)=
               4                  'restricted collision and unrestricted radiative';
               4                  allowed_inputs(ival,5)='unrestricted radiative';
               4                  nmin=ival_iunrst;nmax=ival_iunrst;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iunrst)=0)[
               5                      iunrst_tmp=value(ival_iunrst,1);
               5                      iunrst_specified=.true.;
               5                      $WRITE_MEDERR(' IUNRST specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iaprim_specified)[
               4                  ival=ival+1;
               4                  ival_iaprim=ival;
               4                  values_sought(ival)='bremsstrahlung correction';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='KM';
               4                  allowed_inputs(ival,1)='NRC';
               4                  allowed_inputs(ival,2)='none';
               4                  nmin=ival_iaprim;nmax=ival_iaprim;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iaprim)=0)[
               5                      iaprim_tmp=value(ival_iaprim,1);
               5                      iaprim_specified=.true.;
               5                      $WRITE_MEDERR(' IAPRIM specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~gasp_specified)[
               4                  ival=ival+1;
               4                  ival_gasp=ival;
               4                  values_sought(ival)='gas pressure';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=0.;
               4                  nmin=ival_gasp;nmax=ival_gasp;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_gasp)=0)[
               5                      gasp_tmp=value(ival_gasp,1);
               5                      gasp_specified=.true.;
               5                      $WRITE_MEDERR(' GASP specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~densityfile_specified)[
               4                  ival=ival+1;
               4                  ival_densityfile=ival;
               4                  values_sought(ival)='density correction file';
               4                  type(ival)          = 2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_densityfile;nmax=ival_densityfile;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_densityfile)=0)[
               5                      density_file=char_value(ival_densityfile,1);
               5                      densityfile_specified=.true.;
               5                      "may get changed to false later if it cannot be opened"
               5                      $WRITE_MEDERR(
               5                      ' Density correction file specified in material data file.');
               5                      ]
               4                  ]
               3              ]
               2
               2          ]
               1
               1      "now, try to open the density correction file, if specified"
               1      IF(densityfile_specified)[
               2          "if a file separator is specified in the name, assume the full path + name"
               2          "of the file is specified"
               2          write(*,*)' density_file ',density_file;
               2          IF(index(density_file,$file_sep)>0) [
               3              tmp_string=$cstring(density_file);
               3              inquire(file=tmp_string,exist=ex);
               3              IF(~ex)[
               4                  $WRITE_MEDERR(' Error: Density correction file ',tmp_string);
               4                  $WRITE_MEDERR(' cannot be found.');
               4                  ]
               3              ]
               2          ELSE [
               3              density_file=$cstring(density_file)//'.density';
               3              "first look in $EGS_HOME/pegs4/density_corrections"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look in $EGS_HOME/pegs4/density in case directory still there"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look through $HEN_HOUSE/pegs4/density_corrections"
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              $WRITE_MEDERR(' Error: Density correction file',
               3              density_file);
               3              $WRITE_MEDERR(' does not exist in');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/elements, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/compounds, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density, ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/elements or ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/compounds.');
               3              :density_file_found:
               3              ]
               2          ]
               1
               1      IF(densityfile_specified)[
               2          "now try to open it"
               2          i_density=19;
               2          i_density=egs_get_unit(i_density);
               2          IF(i_density < 1)[
               3              $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               3              ' density correction file.');
               3              ]
               2          open(i_density,file=tmp_string,status='old',err=:no_density_file:);
               2          density_file=tmp_string;
               2          densityfile_specified=.true.;
               2          epstfl_tmp=1;
               2
               2          "the density file is open at this point so just read the data"
               2
               2          read(i_density,'(a)')title;
               2          read(i_density,*)nepst_df,iev_df,rho_df,nne_df;
               2          read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df);
               2
               2          "get atomic symbols and pz based on df header"
               2          DO j=1,nne_df[
               3              i01=z_df(j);
               3              asym_df(j)=ASYMT(i01);
               3              ]
               2
               2          "check to see if data read from density file matches"
               2          "composition and rho already input"
               2          IF(elements_specified)[
               3              IF(nne_tmp~=nne_df)[
               4                  df_if_elem_mismatch(i)=.true.;
               4                  ]
               3              ELSE[
               4                  rhoz_tot=0.;
               4                  DO j=1,nne_tmp["normalize rhoz as it is in dcf"
               5                      IF(spec_by_pz)[
               6                          i01=ZTBL(asym_tmp(j));
               6                          rhoz_tmp(j)=pz_tmp(j)*WATBL(i01);
               6                          ]
               5                      rhoz_tot=rhoz_tot+rhoz_tmp(j);
               5                      ]
               4                  DO j=1,nne_df[
               5                      DO k=1,nne_tmp[ "at this point nne_df=nne_tmp"
               6                          IF(asym_df(j)=asym_tmp(k))[
               7                              IF(rhoz_df(j)>(1+0.01)*rhoz_tmp(k)/rhoz_tot |
               7                              rhoz_df(j)<(1-0.01)*rhoz_tmp(k)/rhoz_tot)[
               8                                  df_if_elem_mismatch(i)=.true.;
               8                                  ]
               7                              exit;
               7                              ]
               6                          ]
               5                      IF(k>nne_tmp) df_if_elem_mismatch(i)=.true.;
               5                      "never found the element"
               5                      IF(df_if_elem_mismatch(i)) [exit;];
               5                      ]
               4                  ]
               3              IF(df_if_elem_mismatch(i))[
               4                  $WRITE_MEDERR(' Warning: composition specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use the composition specified in the density correction file.');
               4                  nne_tmp=nne_df;
               4                  DO j=1,nne_tmp[
               5                      z_tmp(j)=z_df(j);
               5                      rhoz_tmp(j)=rhoz_df(j);
               5                      asym_tmp(j)=asym_df(j);
               5                      ]
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              $WRITE_MEDERR(' Composition specified in density correction file');
               3              nne_tmp=nne_df;
               3              DO j=1,nne_tmp[
               4                  z_tmp(j)=z_df(j);
               4                  rhoz_tmp(j)=rhoz_df(j);
               4                  asym_tmp(j)=asym_df(j);
               4                  ]
               3              spec_by_rhoz=.true.;
               3              elements_specified=.true.;
               3              ]
               2
               2          IF(rho_specified)[
               3              "check to see if rho read from density correction file matches"
               3              "that already input"
               3              IF(rho_df>(1+0.01)*rho_tmp | rho_df<(1-0.01)*rho_tmp)[
               4                  $WRITE_MEDERR(' Warning: rho specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use rho as specified in the density correction file.');
               4                  rho_tmp=rho_df;
               4                  df_if_rho_mismatch(i)=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              rho_tmp=rho_df;
               3              rho_specified=.true.;
               3              $WRITE_MEDERR(' Rho specified in density correction file');
               3              ]
               2
               2          IF(gasp_specified)[
               3              "any value of gasp other than 1 atm is incompatible with"
               3              "use of dcf and, since gasp is only used to scale rho when"
               3              "dcf is used, this input is now unecessary at best"
               3              $WRITE_MEDERR(' Warning: gas pressure input not required',
               3              ' when using density correction file.  Will set GASP=0.');
               3              gasp_specified=.false.;
               3              gasp_tmp=0.;
               3              ]
               2
               2          "close the density file"
               2          close(i_density);
               2          ]
               1
               1      "okay, now commit this to the media library"
               1      IF(elements_specified & rho_specified)[
               2
               2          ae(i)=ae_tmp;
               2          ue(i)=ue_tmp;
               2          ap(i)=ap_tmp;
               2          up(i)=up_tmp;
               2
               2          DO j=1,24[
               3              inpstrn(j,i) = sterncid_tmp(j:j);
               3              ]
               2
               2          nne(i)=nne_tmp;
               2          rho(i)=rho_tmp;
               2
               2          DO j=1,nne_tmp[
               3              inpasym(i,j)=asym_tmp(j);
               3              "assume we are getting z from asym"
               3              "redundant in the case where medium defined using"
               3              "density correction file"
               3              "ZTBL is a function defined in pegs4_routines.mortran"
               3              zelem(i,j)=ZTBL(asym_tmp(j));
               3              i01=zelem(i,j);
               3              "WATBL defined in pegs4_macros.mortran"
               3              wa(i,j)=WATBL(i01);
               3              wa4(i,j)=WATBL(i01);
               3              "also do $REAL4 math so we can check against cross-sections"
               3              "calculated by pegs4.mortran"
               3              IF(spec_by_rhoz)[
               4                  rhoz(i,j)=rhoz_tmp(j);
               4                  rhoz4(i,j)=rhoz_tmp(j);
               4                  pz(i,j)=rhoz(i,j)/wa(i,j);
               4                  pz4(i,j)=rhoz4(i,j)/wa4(i,j);
               4
               4                  ]
               3              ELSEIF(spec_by_pz)[
               4                  pz(i,j)=pz_tmp(j);
               4                  pz4(i,j)=pz_tmp(j);
               4                  rhoz(i,j)=pz(i,j)*wa(i,j);
               4                  rhoz4(i,j)=pz4(i,j)*wa4(i,j);
               4                  ]
               3              ]
               2
               2          iunrst(i)=iunrst_tmp;
               2          iaprim(i)=iaprim_tmp;
               2          epstfl(i)=epstfl_tmp;
               2          inpgasp(i)=gasp_tmp;
               2          inpdensity_file(i)=density_file;
               2
               2          ]
               1      ELSE[
               2          $WRITE_MEDERR(' Error: Medium ',medium_name,' not correctly defined.');
               2          ]
               1      ]
               0
               0  IF(medfile_specified) close(i_medfile);
               0
               0  IF(n_parallel=0 | i_parallel=first_parallel) close(i_mederr);
               0
               0
               0  entry show_media_parameters(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  IF(is_pegsless)[
               1
               1      "show common data"
               1
               1      write(ounit,*);
               1      write(ounit,*)' Medium data: ';
               1      write(ounit,*);
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE = ',ue(1),' MeV';
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP = ',up(1),' MeV';
               1      write(ounit,*);
               1      IF(medfile_specified)[
               2          write(ounit,*)' Material data file: ',material_file;
               2          ]
               1      ELSE[
               2          write(ounit,*)' No material data file supplied.  Material data obtained from';
               2          write(ounit,*)' .egsinp file or density correction file.';
               2          ]
               1      write(ounit,*);
               1
               1      "now list data for individual media that were successfully read in"
               1
               1      DO i=1,nmed[
               2
               2          write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24);
               2          write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24);
               2          write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3';
               2          write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i));
               2          write(ounit,'(a,i5)')'  iunrst: ',iunrst(i);
               2          write(ounit,'(a,i5)')'  iaprim: ',iaprim(i);
               2          write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.';
               2          IF(epstfl(i)=1)[
               3              write(ounit,*)' density correction file: ',
               3              $cstring(inpdensity_file(i));
               3              IF(df_if_elem_mismatch(i))[
               4                  write(ounit,*)' ****Warning: composition specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use the composition specified in the density correction file.';
               4                  ]
               3              IF(df_if_rho_mismatch(i))[
               4                  write(ounit,*)' ****Warning: rho specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use rho as specified in the density correction file.';
               4                  ]
               3              ]
               2          write(ounit,*);
               2
               2          "output stopping powers to file for plotting if requested"
               2          IF(outfile_specified(i) & (n_parallel=0 | i_parallel=first_parallel)) [
               3              inquire(file=spoutput_file(i),exist=ex);
               3              IF(ex) [
               4                  $egs_warning('(a)','Warning: stopping power output file ',
               4                  spoutput_file(i),'already exists.  Will overwrite.');
               4                  ]
               3              i_outfile=20;
               3              i_outfile=egs_get_unit(i_outfile);
               3              IF(i_outfile < 1)[
               4                  $egs_warning('(a)','Warning: Failed to get available fortran unit for',
               4                  ' stopping power output file.');
               4                  ]
               3              open(i_outfile,file=spoutput_file(i),status='unknown',err=:no_output_file:);
               3              goto :got_outfile:;
               3              :no_output_file:
               3              $egs_warning('(a)','Warning: Failed to open stopping power output file ',
               3              spoutput_file(i));
               3              goto :end_outfile:;
               3              :got_outfile:
               3              IFLAG1=0;IFLAG2=0;IPLOTE=0;MEDIUM=i;
               3              XAXIS = 'kinetic energy / MeV';
               3              YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N';
               3              YAXISEmfp = 'mean free path / cm';
               3              YAXISPmfp = 'mean free path / cm';
               3              write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24);
               3              SUBTITLE = 'Electron data';
               3              DO j=1,8[
               4                  DO k=1,16[
               5                      EKE=ETAB(k)*10.**(j-4);
               5                      IF(EKE <= AE(1)-PRM) [
               6                          IF(IFLAG1 = 0) [
               7                              IFLAG1=1; EKE=AE(1)-PRM;
               7                              ] ELSE [ EKE=0.0; ]
               6                          ]
               5
               5                      IF(EKE > UE(1)-PRM) [
               6                          IF(IFLAG2 = 0) [
               7                              IFLAG2=1; EKE=UE(1)-PRM;
               7                              ] ELSE [ EKE=1.E30; ]
               6                          ]
               5                      EIE=EKE+PRM;       TMXSO=0.0;        DEDXE=0.0;
               5                      DEDXP=0.0;           EFRACT=0.0;
               5                      IF(EIE >= AE(1)-0.0001 & EIE <= UE(1)+0.001) [
               6                          ELKE=LOG(EKE);
               6                          $SET INTERVAL ELKE,EKE;
               6                          $EVALUATE DEDXE USING EDEDX(ELKE);"RESTRICTED STOPPING POWERS"
               6
               6                          "enable below to plot other quantities"
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6                          IPLOTE=IPLOTE+1;   "keep track of how many entries"
               6                          PLOTEEN(IPLOTE)=EKE;
               6                          PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM);
               6                          "enable below to plot other quantities
               6
               6
               6
               6
               6
               6
               6
               6
               6                          ]
               5                      ]
               4                  ]
               3              IF(IPLOTE>0)[
               4                  "currently only plots stopping powers"
               4                  IF(iunrst(i)=0) [
               5                      SERIES='restricted total stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=1) [
               5                      SERIES='unrestricted collision stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=2) [
               5                      SERIES='unrestricted collision + radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=3) [
               5                      SERIES='unrestricted collision + restricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=4) [
               5                      SERIES='restricted collision + unrestricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=5) [
               5                      SERIES='unrestricted radiative stopping power';
               5                      ]
               4                  CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES,
               4                  XAXIS,YAXISE,GRAPHTITLE,SUBTITLE,i_outfile,2);
               4                  ]
               3              close(i_outfile);
               3              :end_outfile:
               3              ]
               2          ]
               1      ]
               0
               0  return;
               0  :no_media_file:
               0  $egs_fatal('(a)','Error: Cannot open material data file',material_file);
               0  return;
               0  :no_density_file:
               0  $egs_fatal('(a)','Error: Cannot open density correction file: ',
               0  $cstring(density_file));
               0  return;
               0  end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0
               0  SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, AXISTYPE);
               0  "a version of XVGRPLOT specifically for plotting stopping powers and"
               0  "associated data.  Note that this is required because xvgrplot.mortran"
               0  "is not included at compile time for all user codes."
               0  IMPLICIT NONE;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER MAX;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY;
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  $LOGICAL TESTFILE, ALLPOS;
               0
               0  FUDGE = 1.e-10;
               0
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0
               0  "---Initialize LOGX, LOGY, to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;
               0
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          ]
               1      ]
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Data set is of type XY---"
               0  WRITE(UNITNUM,:200:);
               0  :200: FORMAT ('@TYPE xy');
               0  IF (CURVENUM < 10) [
               1      WRITE(UNITNUM,:151:) CURVENUM;
               1      IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               1      ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,:152:) CURVENUM;
               1      WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               1      ]
               0  :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               0  :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               0  :197: FORMAT ('@    s',I1,' symbol color ',I2);
               0  :198: FORMAT ('@    s',I1,' symbol color ',I1);
               0  :199: FORMAT ('@    s',I2,' symbol color ',I2);
               0
               0  "---Then write the data to the file.---"
               0  DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               0  :250: FORMAT (1PE15.4,1PE15.4);
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END;
               0  ;
               0  "---End of subroutine.---"
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosxzynrc application source routines                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Dave Rogers, 1986                                         "
               0  "                                                                             "
               0  "  Contributors:    Alex Bielajew                                             "
               0  "                   Bruce Faddegon                                            "
               0  "                   George Ding                                               "
               0  "                   Charlie Ma                                                "
               0  "                   Mark Holmes                                               "
               0  "                   Blake Walters                                             "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc dosxyznrc application routines to input various sources, including  "
               0  "  phase space files and beam characterization.                               "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80         "80 column mortran input"                                         ;
               0  !INDENT M 4; "Indent 4 spaces for each nesting level in mortran listing file"
               0  !INDENT F 4; "Indent 4 spaces for each nesting level in fortran output file"
               0  %Q1          "Automatically close quotes at end of the line"                   ;
               0  ;
               0  "*******************************************************************************
               0
               0  "
               0  "                         ***************************
               0  "                         *                         *
               0  "                         * srcxyznrc.mortran       *
               0  "                         *                         *
               0  "                         ***************************
               0  "
               0  "    Routines to be used with dosxyz to input various sources including
               0  "    phase space files, and beam characterization.
               0  "
               0  "    1) srcinput: Parameter input
               0  "    2) srcinit : Calculate 'one time only constants'
               0  "    3) srchst  : Calculate input phase space for each history
               0  "    4) srcout  : Print summary of source-related input data
               0  "
               0  "    Maintained under sccs control at NRCC
               0  "
               0  "
1              0  %E    "srcxyznrc.mortran start of input description
               0  "*******************************************************************************
               0  "
               0  "                Input source parameters read by srcxyznrc.mortran
               0  "                ==============================================
               0  "              (see section 4 of DOSXYZnrc User's Manual for details)
               0  "
               0  "*******************************************************************************
               0  "
               0  "Record SC1-0  Parallel beam incident on the front with rectangular collimation
               0  "                                        (front is the zbound(1) plane)
               0  "
               0  "       iqin,isource,xinl,xinu,yinl,yinu,thetax,thetay,thetaz
               0  "
               0  "               iqin       Charge of the incident beam (defaults to 0)
               0  "               isource    = 0
               0  "               xinl,xinu  Lower and upper x-bounds on source (in cm)
               0  "               yinl,yinu  Lower and upper y-bounds on source (in cm)
               0  "               thetax     Angle of the beam relative to the X-axis (degrees)
               0  "               thetay     Angle of the beam relative to the Y-axis (degrees)
               0  "               thetaz     Angle of the beam relative to the Z-axis (degrees)
               0  "                          (incident angles default to 90,90,0)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-1  Parallel beam incident from any direction with rectangular
               0  "            collimation
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,theta,phi,xcol,ycol,phicol
               0  "
               0  "               iqin        Charge of the incident beam (defaults to 0)
               0  "               isource     = 1
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter
               0  "               theta       angle between the +z direction and a line joining
               0  "                           the center of the beam to the isocenter
               0  "               phi         angle  between the +x direction and the
               0  "                           projection of the line joining the center of the
               0  "                           beam to the isocenter on the xy plane
               0  "               x|y|col     total x- and y- widths of the beam on the plane
               0  "                           perpendicular to the beam direction, defined
               0  "                           by the center of the beam and the isocenter
               0  "               phicol      angle by which the collimator is rotated in the
               0  "                           collimator plane perpendicular to the beam direction
               0  "                           Phicol is determined for theta=0 or 180 and phi=0.
               0  "                           The positive sense of rotation is counterclockwise
               0  "                           as one sights down the beam direction.
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-2  Full phase-space source file, particles incident on front face
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,theta,phi,dsource,phicol,i_dbs,r_dbs,
               0  "                                         ssd_dbs,z_dbs,e_split
               0  "
               0  "               iqin(iqphsp)= 0 only photons from ph-sp file will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqphsp
               0  "               isource     =  2
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter
               0  "               theta       angle between the +z direction and a line joining
               0  "                           the origin in the phase space plane to the
               0  "                           isocenter.  theta=180 degrees for a beam down
               0  "                           from the top.
               0  "               phi         angle  between the +x direction and the
               0  "                           projection of the line joining the origin in the
               0  "                           phase space plane to the isocenter on the xy plane
               0  "               dsource     For a BEAMnrc format phase space source: absolute
               0  "                           distance from the isocenter to the
               0  "                           source center, which is, by definition, the
               0  "                           origin in the phase space plane.  For an IAEA
               0  "                           format phase space source: the primary source to
               0  "                           isocentre distance (SAD).
               0  "               phicol      angle by which the collimator is rotated in the
               0  "                           collimator plane perpendicular to beam direction.
               0  "                           Phicol is determined for theta=0 or 180 and phi=0.
               0  "                           The positive sense of rotation is counterclockwise
               0  "                           as one sights down from the origin in the
               0  "                           phase space plane.
               0  "                           phicol = 180 to retain same x,y positions passing
               0  "                           from BEAM to DOSXYZ  (because of coordinate
               0  "                           transformation used).
               0  "               i_dbs       set to 1 if you used directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation used to
               0  "                           generate this phase space source AND you wish to
               0  "                           reject fat photons not aimed into the splitting
               0  "                           field.  These fat photons may compromise dose
               0  "                           statistics.  Set to 0 otherwise.
               0  "               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
               0  "                           Set to 0 to disable this option.  Only needed if
               0  "                           i_dbs=1.
               0  "             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
               0  "                           Only needed if i_dbs=1.
               0  "               z_dbs       Z in the BEAMnrc run where the phase space source
               0  "                           was scored (in cm).  Only needed if i_dbs=1.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "
               0  "      For i_dbs=1, photons are projected from z_dbs to ssd_dbs and if they will
               0  "      fall outside of r_dbs (based on their Z direction cosine) then they will
               0  "      be rejected.  This prevents fat photons from compromising dose
               0  "      statistics.
               0  "
               0  "     Note: as currently set, multiple passers and all particles going
               0  "           backwards in the phase space file are NOT used.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-3  Point source incident from the front (along the +ve z-axis)
               0  "            employing rectangular collimation
               0  "
               0  "       iqin,isource,xinl,xinu,yinl,yinu,ssd
               0  "
               0  "               iqin       Charge of the incident beam (defaults to 0)
               0  "               isource    = 3
               0  "               xinl,xinu  Lower and upper x-bounds on source
               0  "               yinl,yinu  Lower and upper y-bounds on source
               0  "               ssd        Source-surface distance (ssd >0)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-4  Beam characterization model, particles incident on front face
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,thetax,thetay,thetaz,phicol
               0  "
               0  "               iqin        = 0 only photons from ph-sp file will be simulated
               0  "                           = 1 only positrons will be simulated
               0  "                           =-1 only electrons will be simulated
               0  "                           = 2 all the particles will be simulated
               0  "               isource     =  4
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter
               0  "               theta       angle between the +z direction and a line joining
               0  "                           the origin in the phase space plane to the isocenter
               0  "               phi         angle  between the +x direction and the
               0  "                           projection of the line joining the origin in the
               0  "                           phase space plane to the isocenter on the xy plane
               0  "               dsource     absolute distance from the isocenter to the
               0  "                           source center, which is, by definition, the
               0  "                           origin in the phase space plane
               0  "               phicol      angle by which the collimator is rotated in the
               0  "                           collimator plane perpendicular to the beam direction
               0  "                           Phicol is determined for theta=0 or 180 and phi=0.
               0  "                           The positive sense of rotation is counterclockwise
               0  "                           as one sights down from the origin in the
               0  "                           phase space plane.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-6  Uniform isotropically radiating parallelepiped within DOSXYZ
               0  "              phantom
               0  "
               0  "     iqin,isource,xinl,xinu,yinl,yinu,zinl,zinu
               0  "               iqin        charge of particles from source (defaults to 0)
               0  "               isource     = 6
               0  "               xinl        min x of active volume (cm)
               0  "               xinu        max x of active volume (cm)
               0  "               yinl        min y of active volume (cm)
               0  "               yinu        max y of active volume (cm)
               0  "               zinl        min z of active volume (cm)
               0  "               zinu        max z of active volume (cm)
               0  "
               0  "NOTE: The active volume must be completely contained within the phantom.
               0  ;
               0  "------------------------------------------------------------------------------"
               0  "Record SC1-7  Parallel beam incident from multiple, user-selected angles.
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,nang,xcol,ycol,phicol
               0  "
               0  "               iqin        Charge of the incident beam (defaults to 0)
               0  "               isource     = 7
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter
               0  "               nang        number of incident theta-phi pairs or, if -ve,
               0  "                           absolute value is the number of groups of theta-
               0  "                           phi pairs.  Within a group:
               0  "                              1. only theta or phi, but not both, can vary
               0  "                              2. varying theta's or phi's are evenly
               0  "                                 distributed
               0  "                              3. theta-phi pairs have equal probability
               0  "               x|y|col     total x- and y- widths of the beam on the plane
               0  "                           perpendicular to the beam direction, defined
               0  "                           by the center of the beam and the isocenter
               0  "               phicol      angle by which the collimator is rotated in the
               0  "                           collimator plane perpendicular to the beam direction
               0  "                           Phicol is determined for theta=0 or 180 and phi=0.
               0  "                           The positive sense of rotation is counterclockwise
               0  "                           as one sights down the beam direction.
               0  "
               0  "  Note that, similar to source 1, theta is defined as the angle between the +z
               0  "  direction and a line joining the center of the beam to the isocenter, and
               0  "  phi is defined as the angle between the +x direction and the projection of
               0  "  the line joining the center of the beam to the isocenter on the xy plane.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "Record SC1-8  Full phase-space source, particles incident from multiple,
               0  "              user-selected angles.
               0  "
               0  "    iqin,isource,xiso,yiso,ziso,nang,dsource,phicol,i_dbs,r_dbs,ssd_dbs,
               0  "             z_dbs,e_split
               0  "
               0  "               iqin(iqphsp)= 0 only photons from ph-sp file will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqphsp
               0  "               isource     =  8
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter
               0  "               nang        number of incident theta-phi pairs or, if -ve,
               0  "                           absolute value is the number of groups of theta-
               0  "                           phi pairs.  Within a group:
               0  "                              1. only theta or phi, but not both, can vary
               0  "                              2. varying theta's or phi's are evenly
               0  "                                 distributed
               0  "                              3. theta-phi pairs have equal probability
               0  "               dsource     For an BEAMnrc format phase space source: the
               0  "                           absolute distance from the isocenter to the
               0  "                           source center, which is, by definition, the
               0  "                           origin in the phase space plane.  For an IAEA
               0  "                           format source: the primary source-to-isocentre
               0  "                           distance (SAD).
               0  "               phicol      angle by which the collimator is rotated in the
               0  "                           collimator plane perpendicular to beam direction.
               0  "                           Phicol is determined for theta=0 or 180 and phi=0.
               0  "                           The positive sense of rotation is counterclockwise
               0  "                           as one sights down from the origin in the
               0  "                           phase space plane.
               0  "                           phicol = 180 to retain same x,y positions passing
               0  "                           from BEAM to DOSXYZ  (because of coordinate
               0  "                           transformation used).
               0  "               i_dbs       set to 1 if you used directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation used to
               0  "                           generate this phase space source AND you wish to
               0  "                           reject fat photons not aimed into the splitting
               0  "                           field.  These fat photons may compromise dose
               0  "                           statistics.  Set to 0 otherwise.
               0  "               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
               0  "                           Set to 0 to disable this option.  Only needed if
               0  "                           i_dbs=1.
               0  "             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
               0  "                           Only needed if i_dbs=1.
               0  "               z_dbs       Z in the BEAMnrc run where the phase space source
               0  "                           was scored (in cm).  Only needed if i_dbs=1.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "
               0  "      For i_dbs=1, photons are projected from z_dbs to ssd_dbs and if they will
               0  "      fall outside of r_dbs (based on their Z direction cosine) then they will
               0  "      be rejected.  This prevents fat photons from compromising dose
               0  "      statistics.
               0  "
               0  "     Note: as currently set, multiple passers and all particles going
               0  "           backwards in the phase space file are NOT used.
               0  "     Also note that, similar to source 2, theta is the angle between the +z
               0  "     direction and a line joining the origin of the phase space plane to the
               0  "     isocenter, and phi is the angle between the +x direction and the
               0  "     projection of the line joining the origin of the phase space plane to
               0  "     the isocenter in the xy plane.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-9 BEAM treatment head simulation used as source, incident from
               0  "             any angle
               0  "
               0  "  This source requires unix/Linux systems to have a working C/C++ compiler
               0  "  and requires the BEAM code, BEAM_accelname, to have been compiled as a
               0  "  shared library (libBEAM_accelname.so or BEAM_accelname.dll) that exists in
               0  "  your EGS_HOME/bin/config directory.  See the DOSXYZnrc Manual for more
               0  "  details.
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,theta,phi,dsource,phicol,i_dbs,e_split
               0  "
               0  "               iqin(iqinc)= 0 only photons from BEAM simulation will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqinc
               0  "               isource     = 9
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter.
               0  "               theta       angle between the +z direction and a vector
               0  "                           joining the isocentre to the origin of the source
               0  "                           plane (the plane where the particles are sampled
               0  "                           from the BEAM simulation--which is the
               0  "                           scoring plane in a standard BEAM simulation).
               0  "                           theta=180 degrees for a beam down from the top.
               0  "               phi         angle between the +x direction and the
               0  "                           projection of the vector joining the isocenter to
               0  "                           the origin of the source plane.
               0  "               dsource     absolute distance from the isocenter to the
               0  "                           origin of the source plane.
               0  "               phicol      angle by which the source plane is rotated about
               0  "                           the BEAM central axis.  Rotation is counter-
               0  "                           clockwise for theta=0.  Set phicol=180 degrees
               0  "                           to retain same x,y, positions passing
               0  "                           from BEAM to DOSXYZ when theta=180 (beam coming
               0  "                           down from top).
               0  "               i_dbs       set to 1 if you are using directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation
               0  "                           AND you wish to reject fat photons not aimed into
               0  "                           the splitting field.  These fat photons may
               0  "                           compromise dose statistics.  Set to 0 otherwise.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-10 BEAM treatment head simulation used as source, incident from
               0  "              multiple, user-defined angles.
               0  "
               0  "  This source requires unix/Linux systems to have a working C/C++ compiler
               0  "  and requires the BEAM code, BEAM_accelname, to have been compiled as a
               0  "  shared library (libBEAM_accelname.so or BEAM_accelname.dll) that exists in
               0  "  your EGS_HOME/bin/config directory.  See the DOSXYZnrc Manual for more
               0  "  details.
               0  "
               0  "       iqin,isource,xiso,yiso,ziso,nang,dsource,phicol,i_dbs,e_split
               0  "
               0  "               iqin(iqinc)= 0 only photons from BEAM simulation will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqinc
               0  "               isource     = 10
               0  "               x|y|z|iso   x|y|z|-coordinates of the isocenter.
               0  "               nang        number of incident theta-phi pairs or, if -ve,
               0  "                           absolute value is the number of groups of theta-
               0  "                           phi pairs.  Within a group:
               0  "                              1. only theta or phi, but not both, can vary
               0  "                              2. varying theta's or phi's are evenly
               0  "                                 distributed
               0  "                              3. theta-phi pairs have equal probability
               0  "               dsource     absolute distance from the isocenter to the
               0  "                           origin of the source plane.
               0  "               phicol      angle by which the source plane is rotated about
               0  "                           the BEAM central axis.  Rotation is counter-
               0  "                           clockwise for theta=0.  Set phicol=180 degrees
               0  "                           to retain same x,y, positions passing
               0  "                           from BEAM to DOSXYZ when theta=180 (beam coming
               0  "                           down from top).
               0  "               i_dbs       set to 1 if you are using directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation
               0  "                           AND you wish to reject fat photons not aimed into
               0  "                           the splitting field.  These fat photons may
               0  "                           compromise dose statistics.  Set to 0 otherwise.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "
               0  "      Note that this source requires Record SC1-10a, described below.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "Record SC1-20 Synchronized phase space source simulating continuous motion of
               0  "              the source plane between user-defined control points.  Option
               0  "              to run the source through a geometry (usually MLC) defined using
               0  "              BEAM or a non-EGSnrc code compiled as a shared library
               0  "        - added by Tony Popescu and Julio Lobo
               0  "
               0  "  This source requires unix/Linux systems to have a working C/C++ compiler
               0  "  and requires the BEAM code or non-EGSnrc code (e.g particleDmlc) to have
               0  "  been compiled as a shared library (libparticleDmlc.so) that exists in
               0  "  your EGS_HOME/bin/config directory.
               0  "
               0  "
               0  "       iqin,isource,nset,i_dbs,r_dbs,ssd_dbs,z_dbs,e_split,i_muidx_out, calflag
               0  "
               0  "               iqin(iqinc) = 0 only photons from BEAM simulation will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqinc
               0  "               isource     = 20
               0  "               nset        number of settings (control points) (>=2)
               0  "               i_dbs       set to 1 if you are using directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation
               0  "                           AND you wish to reject fat photons not aimed into
               0  "                           the splitting field.  These fat photons may
               0  "                           compromise dose statistics.  Set to 0 otherwise.
               0  "               r_dbs       DBS splitting radius used in BEAMnrc simulation(cm).
               0  "                           Set to 0 to disable this option.  Only needed if
               0  "                           i_dbs=1.
               0  "             ssd_dbs       SSD at which r_dbs is defined in the BEAM sim. (cm).
               0  "                           Only needed if i_dbs=1.
               0  "               z_dbs       Z in the BEAMnrc run where the phase space source
               0  "                           was scored (in cm).  Only needed if i_dbs=1.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "            i_muidx_out    Set to 1 to include frMU_indx (the fractional
               0  "                           monitor unit index) in phase space output if
               0  "                           i_phsp_out=1 or 2.
               0  "               calflag     set to 1 to skip the calibration run performed to
               0  "                           refine the estimate of NRCYCL needed to avoid
               0  "                           rewinding the phsp. Only do this if certain that
               0  "                           your phsp has enough particles compared to the no.
               0  "                           of histories you are running.
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  "Record SC1-21 Synchronized BEAM treatment head simulation used as source
               0  "              with continuous motion of the source plane between user-defined
               0  "              control points.  Option to run the source through a geometry
               0  "              (usually MLC) defined using a non-EGSnrc code compiled as a
               0  "              shared library.
               0  "        - added by Tony Popescu and Julio Lobo
               0  "
               0  "  This source requires unix/Linux systems to have a working C/C++ compiler
               0  "  and requires the BEAM code being used as the source, BEAM_accelname, to have
               0  "  been compiled as a shared library (libBEAM_accelname.so or
               0  "  BEAM_accelname.dll) that exists in your $EGS_HOME/bin/config directory.  See
               0  "  the DOSXYZnrc Manual for more details.
               0  "
               0  "       iqin,isource,nset,i_dbs,e_split,i_muidx_out
               0  "
               0  "               iqin(iqinc) = 0 only photons from BEAM simulation will be used
               0  "                           = 1 only positrons will be used
               0  "                           =-1 only electrons will be used
               0  "                           = 2 all the particles will be used
               0  "                           internally renamed as iqinc
               0  "               isource     = 21
               0  "               nset        number of settings (control points) (>=2)
               0  "               i_dbs       set to 1 if you are using directional bremsstrahlung
               0  "                           splitting (DBS) in the BEAM simulation
               0  "                           AND you wish to reject fat photons not aimed into
               0  "                           the splitting field.  These fat photons may
               0  "                           compromise dose statistics.  Set to 0 otherwise.
               0  "             e_split       No. of times to split charged particles as soon
               0  "                           as they enter the DOSXYZnrc geometry.  Used in
               0  "                           conjunction with photon splitting (n_split) to
               0  "                           prevent higher-weight charged particles from
               0  "                           compromising dose statistics.  Recommended setting
               0  "                           is e_split=n_split for optimum efficiency.  Not
               0  "                           used if n_split<=1.
               0  "            i_muidx_out    Set to 1 to include frMU_indx (the fractional
               0  "                           monitor unit index) in phase space output if
               0  "                           i_phsp_out=1 or 2.
               0  ;
               0  "------------------------------------------------------------------------------
               0  "Record SC1-7a, SC1-8a and SC1-10a (required for sources 7, 8 and 10 only)
               0  "        if nang>0:
               0  "         (theta(i),phi(i),pang(i),i=1,nang)
               0  "
               0  "               theta(i)    incident theta i
               0  "               phi(i)      incident phi i.
               0  "               pang(i)     probability of a particle being incident at
               0  "                           theta(i)-phi(i) (probabilities are automatically
               0  "                           normalized to 1).
               0  "
               0  "        if nang<0:
               0  "         (ivary(i),angfixed(i),angmin(i),angmax(i),ngang(i),pgang(i),i=1,-nang)
               0  "
               0  "               ivary(i)    =0 to vary phi in group i, 1 to vary theta in
               0  "                           group i
               0  "               angfixed(i) =fixed theta (ivary=0) or phi (ivary=1) for group i
               0  "               angmin(i)   min. value of varying phi (ivary=0) or theta
               0  "                           (ivary=1) in group i
               0  "               angmax(i)   max. value of varying phi or theta in group i
               0  "               ngang(i)    number of equally-spaced phi's or theta's
               0  "                           including angmin(i) and angmax(i) (Note: this
               0  "                           means ngang(i) must be at least 2).
               0  "               pgang(i)    probability of a particle being incident in
               0  "                           group i (probabilities are automatically normalized
               0  "                           to 1).
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "Record SC1-20a and SC1-21a (required for sources 20 and 21)
               0  "
               0  "  (|x|y|ziso(i),theta(i),phi(i),phicol(i),dsource(i),muIndex(i),i=1,nset)
               0  "
               0  "           |x|y|ziso(i)    x,y,z of isocentre for control point i
               0  "               theta(i)    incident theta for control point i
               0  "               phi(i)      incident phi for control point i
               0  "               phicol(i)   incident phicol for control point i
               0  "               dsource(i)  distance from isocentre to origin of BEAM
               0  "                           scoring plane for control point i.  For source
               0  "                           21 using an IAEA phase space file, this is
               0  "                           the primary source to isocentre distance (SAD).
               0  "               muIndex(i)  fractional monitor unit index for control point
               0  "                           i.  Restrictions: muIndex(i) is on [0,1],
               0  "                           muIndex(i-1)<=muIndex(i), muIndex(1)=0.0,
               0  "                           muIndex(nset)=1.0
               0  "
               0  "   Note: theta, phi, phicol, and dsource have the same meaning as for
               0  "   Source 2 (see above).
               0  ;
               0  "-------------------------------------------------------------------------------
               0  "
               0  " Record SC2
               0  "       enflag,mode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
               0  "                                                              dsurround(4)
               0  "
               0  "            enflag    = 0 for monoenergetic beams
               0  "                      = 1 for beams with an energy spectrum
               0  "                      = 2 for ph-sp beam input or full BEAM sim.
               0  "                      = 3 for ph-sp beam input or full BEAM sim. + dose
               0  "                          components calculations (use of LATCH filters)
               0  "                      = 4 for ph-sp beam modelled with multiple-source
               0  "                          (use of LATCH filters)
               0  "            mode      = 0 default file format for ph-sp data (enflag=2)
               0  "                          (7 variables/record)
               0  "                      = 2 special file format for ph-sp data with ZLAST
               0  "                          (8 variables/record)
               0  "           medsur   :     medium number for the region outside the phantom
               0  "                          (default = vacuum if medsur = 0) for enflag > 1
               0  "           dsurround(1):  if dflag=0, the thickness of the region surrounding
               0  "                          the phantom on all sides (default=50cm)
               0  "                          OR
               0  "                          if dflag=1, the thickness of the region surrounding
               0  "                          the phantom in the x direction (default=0cm)
               0  "             dflag    = 0 dsurround(1) applies to all sides of phantom
               0  "                      = 1 dsurround(1) applies to x direction; must input
               0  "                          dsurround(2) for y direction, dsurround(3) for +z
               0  "                          direction (down), dsurround(4) for -z direction (up)
               0  "          dsurround(2):   (only required if dflag=1) thickness of region
               0  "                           surrounding phantom in y direction (default=0cm)
               0  "          dsurround(3):   (only required if dflag=1) thickness of region
               0  "                           surrounding phantom in +z direction (default=0cm)
               0  "          dsurround(4):   (only required if dflag=1) thickness of region
               0  "                           surrounding phantom in -z direction (default=0cm)
               0  "
               0  "      Note:  Currently, medsur, dflag and dsurround(1...4) are only input
               0  "             if enflag > 1.
               0  ;
               0  "------------------------------------------------------------------------------
               0  " Record SC3a   (if enflag = 0)
               0  "            ein
               0  "            ein       kinetic energy of the incident particles in MeV
               0  "
               0  "------------------------------------------------------------------------------
               0  " Record SC3b   (if enflag = 1, 2, 3, or 4, each with different inputs)
               0  "             FILNAM  or
               0  "             the_beam_code, the_input_file, the_pegs_file or
               0  "             the_shared_code,the_phsp_file,the_input_file (isource 20) or
               0  "   the_beam_code,the_input_file,the_pegs_file,the_vcu_code,the_vcu_input_file
               0  "                                                           (isource = 21)
               0  "            FILNAM  Name of file containing energy spectrum   (enflag =1)
               0  "
               0  "                    name of file containing phase-space data  (enflag = 2,3
               0  "                                                        and isource=2,8)
               0  "
               0  "                    name of file containing source parameters (enflag = 4)
               0  "
               0  "             or for isource = 9,10
               0  "
               0  "          the_beam_code    The name of the BEAM code you are running as a
               0  "                           source (ie BEAM_accelname).  This must have been
               0  "                           compiled as a shared library (libBEAM_accelname.so
               0  "                           or BEAM_accelname.dll) and exist in
               0  "                           EGS_HOME/bin/config.
               0  "          the_input_file   The input file used to run the BEAM simulation
               0  "                           (no .egsinp extension).  This must exist in your
               0  "                           EGS_HOME/BEAM_accelname directory.  It must be
               0  "                           a working input file and must be set up to write
               0  "                           a phase space file at a single scoring plane.
               0  "                           This plane becomes where particles are sampled from
               0  "                           for the DOSXYZ simulation (no phase space file
               0  "                           is scored, however).
               0  "          the_pegs_file    The pegs data set used by the BEAM simulation
               0  "                           (no .pegs4dat extension).  This must be in
               0  "                           HEN_HOUSE/pegs4/data or EGS_HOME/pegs4/data.
               0  "
               0  "            or for isource = 20
               0  "
               0  "          the_shared_code  BEAM or non-EGSnrc code used to simulate a geometry
               0  "                           interposed between phase space source and
               0  "                           the phantom.  Must have been compiled as a shared
               0  "                           library and exist in $EGS_HOME/bin/config
               0  "                           (isource = 20)
               0  "          the_phsp_file    Name of file containing phase space data
               0  "                           (isource = 20)
               0  "          the_input_file   Input file for the BEAM or non-EGSnrc code used
               0  "                           to simulate a geometry interposed between the
               0  "                           phase space source and the phantom.  In the
               0  "                           case where you are using a BEAM accelerator, this
               0  "                           must exist in the $EGS_HOME/BEAM_accelname
               0  "                           directory and must specify a scoring plane at
               0  "                           the bottom of the accelerator. (isource = 20)
               0  "
               0  "           or for isource = 21
               0  "
               0  "          the_beam_code    Same as for isource=9, 10
               0  "          the_input_file   Same as for isource=9, 10
               0  "          the_pegs_file    Same as for isource=9, 10
               0  "          the_vcu_code     (optional) Name of non-EGSnrc code used to simulate
               0  "                           a geometry (usually MLC) interposed between the
               0  "                           treatment head source and the phantom.  Must have
               0  "                           been compiled as a shared library and exist in
               0  "                           $EGS_HOME/bin/config.
               0  "  the_vcu_input_file (optional) The full path to the input file for
               0  "                           the_vcu_code
               0  "------------------------------------------------------------------------------
               0  " Record SC3c   (if enflag = 3)
               0  "       I_BIT_FILTER, NBIT1, NBIT2
               0  "
               0  "            I_BIT_FILTER = 0 INclusive/EXclusive for bits: if any of the 1st
               0  "                             set of NBIT1 bits are set and none of the 2nd set
               0  "                             of NBIT2 bits are set, the particle is used.
               0  "                         = 1 EXclusive for bits: if any of the set of NBIT1
               0  "                             bits are set, the particle is not used.
               0  "                         = 2 INclusive for regions: use secondary particles
               0  "                             that originated in any of the specified NBIT1
               0  "                             regions.
               0  "                         = 3 EXclusive for regions: do not use secondary
               0  "                             particles that originated in any of the NBIT1
               0  "                             specified regions.
               0  "
               0  "                             Note: For I_BIT_FILTER=0,1 the actual bits
               0  "                             specified below by LATBIT(i) are checked.
               0  "                             For I_BIT_FILTER=2,3 the regions of origin
               0  "                             (stored in bits 24 to 28 and specified by
               0  "                             IREGION_TO_BIT) are checked against LATBIT(i)
               0  "                             values.
               0  "
               0  "                      NBIT1: the number of bits or regions of origin to
               0  "                             include (I_BIT_FILTER=0,2) or exclude
               0  "                             (I_BIT_FILTER=1,3).
               0  "                      NBIT2: the number of bits to exclude.  Only has meaning
               0  "                             for I_BIT_FILTER=0, otherwise, it is
               0  "                             automatically set to 0.
               0  "
               0  "              Restrictions: for I_BIT_FILTER=0:    0<=NBIT1+NBIT2<=29
               0  "                            for I_BIT_FILTER=1:    0<=NBIT1<=29
               0  "                            for I_BIT_FILTER=2,3:  0<=NBIT1<=24
               0  ;
               0  "
               0  "       (LATBIT(i),i=1,NBIT1)
               0  "            (LATBIT(i),i=1,NBIT1): bits/IREGION_TO_BITs to
               0  "                                   include (I_BIT_FILTER=0,2) or
               0  "                                   exclude (I_BIT_FILTER=1,3) from the source.
               0  "
               0  "       Next line required only if I_BIT_FILTER=0 and NBIT2>0.
               0  "
               0  "       (LATBIT(i),i=NBIT1+1,NBIT1+NBIT2)
               0  "         (LATBIT(i),i=NBIT1+1,NBIT1+NBIT2): bits to exclude (I_BIT_FILTER=0).
               0  "
               0  "              Restrictions: bits should be >=0 and <=28
               0  "                            IREGION_TO_BITs should be >=0 and <=23.
               0  "
               0  "       Note: The check on particle charge is done independently before
               0  "             these bit filters are applied.
               0  ;
               0  "  end of inputs read by srcxyznrc.mortran
               0  "------------------------------------------------------------------------------
1              0  %E "srcxyznrc.mortran start of subroutine srcinput "
               0  "**************************************************************************"
               0  "
               0  subroutine srcinput(ieof);
               0
               0  implicit none;
               0
               0  "This subroutine is used for source parameter input
               0  "
               0  "Energy parameters:
               0  "   enflag = 0, monoenergetic source sets ein to k.e. and this is used to
               0  "               set etotin in main.
               0  "   enflag = 1, energy spectrum, ein is set to maximum k.e. in spectrum
               0  "               and this value is used by PRESTA
               0  "   phase space inputs: ein is max k.e. of particles in phase space file
               0  "               read from first line.
               0  "
               0  "**************************************************************************"
               0  REPLACE {$NTEMP} WITH {12} "Dimension of temporary input buffer
               0  $REAL temp,fnorm,binsok,gridsz,ak;
               0  $INTEGER i,k,j,ib,ieof;
               0  dimension temp($NTEMP);
               0  CHARACTER*256 FILNAM;
               0  CHARACTER*80 SPEC_TITLE;
               0  CHARACTER*5  MODE;
               0  $INTEGER lnblnk1,ilen;
               0  $INTEGER latchm,nhistm; "temp. variables used for source 2,8"
               0  $REAL einm,xinm,yinm,uinm,vinm,wtm,zlastm,Z_SOURCE;
               0  "temp. variables used for source 2,8"
               0  ;COMIN/ENERGYSRC,GEOM,PHSPFILE,SCORE,SOURCE,SSMDIS,MEDIA,MISC,BOUNDS,RWPHSP,
               0  EGS-IO/;
               0
               0  enflag = 0; "Default flag: Source energy same for each source particle
               0  i_muidx_out = 0; "default not to output frMU_indx if writing phsp data"
               0  calflag = 0; "default to running the calibration run (isource = 20)"
               0
               0  OUTPUT; ( / / ' Source configuration'/);
               0  OUTPUT; (
               0  '      (0) Parallel, rectangular beam incident from the front' /
               0  '          Requires 9 inputs:'                                 /
               0  '          charge (-1,0,1),'                                   /
               0  '          0 (mandatory, to identify source type),'            /
               0  '          lower x-coordinate of the beam (cm),'               /
               0  '          upper x-coordinate of the beam (cm),'               /
               0  '          lower y-coordinate of the beam (cm),'               /
               0  '          upper y-coordinate of the beam (cm),'               /
               0  '          angle of beam with respect to the positive x-axis (degrees),'/
               0  '          angle of beam with respect to the positive y-axis (degrees),'/
               0  '          angle of beam with respect to the negative z-axis (degrees) '/
               0  '            (angles default to 90,90,0--incident on front of phantom)'/);
               0  OUTPUT; (
               0  '   or (1) Parallel, rectangular beam incident from any direction'/
               0  '          Requires 10 inputs:'                                   /
               0  '          charge (-1,0,1),'                                      /
               0  '          1 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          angle between +z direction and the line joining the   '/
               0  '             center of the beam (collimator) to the isocenter'   /
               0  '             --called the polar angle(degrees),'                 /
               0  '          angle between +x direction and the projection of the'  /
               0  '             line joining the center of the beam (collimator)'   /
               0  '             to the isocenter on the xy plane--called the azimuthal'/
               0  '             angle (degrees),'/
               0  '          total x-width of the beam in the plane perpendicular'  /
               0  '             to the beam direction (cm),'                        /
               0  '          total y-width of the beam in the plane perpendicular'  /
               0  '             to the beam direction (cm),'                        /
               0  '          angle by which the collimator is rotated in the'       /
               0  '             collimator plane perpendicular to the beam'         /
               0  '             direction (degrees),                     '          /
               0  '             (+ve rotation is counterclockwise looking along'    /
               0  '              the beam direction'                                /);
               0  OUTPUT; (
               0  '  or  (2) Full phase-space of each particle'                     /
               0  '          Requires 9 inputs plus data stored in units 43 and 44:'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          2 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          angle between +z direction and the line joining the   '/
               0  '             origin in the phase space plane to the isocenter'   /
               0  '             --called the polar angle(degrees),'                 /
               0  '          angle between +x direction and the projection of the'  /
               0  '             line joining the origin in the phase space plane'   /
               0  '             to the isocenter on the xy plane--called the azimuthal'/
               0  '             angle (degrees),'                                   /
               0  '          absolute distance from the isocenter to the origin'    /
               0  '             in the phase space plane                      '     /
               0  '          angle by which the source is rotated in the'           /
               0  '             phase space plane perpendicular to the beam'        /
               0  '             direction (degrees),                     '          /
               0  '             (+ve rotation is counterclockwise looking down'     /
               0  '              from the origin in the phase space plane),'          /
               0  '          i_dbs--set to 1 if DBS was used in BEAM simulation used' /
               0  '             to generate the phsp source and you want to reject fat' /
               0  '             photons, 0 otherwise,'/
               0  '          DBS splitting radius (cm),'/
               0  '          SSD at which splitting radius defined (cm),'/
               0  '          Z at which phsp source collected (cm),'/
               0  '          No. of times to split charged particles.'/);
               0  OUTPUT; (
               0  '   or (3) Point, rectangular beam incident from the front' /
               0  '          Requires 7 inputs:'                                 /
               0  '          charge (-1,0,1),'                                   /
               0  '          3 (mandatory, to identify source type),'            /
               0  '          lower x-coordinate of the beam (cm),'               /
               0  '          upper x-coordinate of the beam (cm),'               /
               0  '          lower y-coordinate of the beam (cm),'               /
               0  '          upper y-coordinate of the beam (cm),'               /
               0  '          distance to the plane (cm),'/
               0  );
               0  OUTPUT; (
               0  '  or  (6) Uniform isotropically radiating parallelepiped within'/
               0  '          the phantom'/
               0  '          Requires 8 inputs:'/
               0  '          charge (-1,0,1),'      /
               0  '          6 (mandatory, to identify source type),'               /
               0  '          lower x-coordinate of active volume (cm)'/
               0  '          upper x-coordinate of active volume (cm),'            /
               0  '          lower y-coordinate of active volume (cm) '/
               0  '          upper y-coordinate of active volume (cm),'            /
               0  '          lower z-coordinate of active volume (cm)  ' /
               0  '          upper z-coordinate of active volume (cm) '/);
               0  OUTPUT; (
               0  '  or  (7) Parallel beam incident from multiple, user-selected angles'/
               0  '          Requires 9 inputs on this line:'/
               0  '          charge (-1,0,1),'      /
               0  '          7 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          number of incident theta-phi pairs or -ve number of',  /
               0  '             groups of incident theta-phi pairs where, within a group', /
               0  '             only theta or phi can vary, the varying angles are' /
               0  '             evenly distributed and have equal probability,'     /
               0  '          total x-width of the beam in the plane perpendicular'  /
               0  '             to the beam direction (cm),'                        /
               0  '          total y-width of the beam in the plane perpendicular'  /
               0  '             to the beam direction (cm),'                        /
               0  '          angle by which the collimator is rotated in the'       /
               0  '             collimator plane perpendicular to the beam'         /
               0  '             direction (degrees),                     '          /
               0  '             (+ve rotation is counterclockwise looking along'    /
               0  '              the beam direction'                                /);
               0  OUTPUT; (
               0  '  or  (8) Full phase-space incident from multiple angles'        /
               0  '          Requires 8 inputs on this line and data stored in units 43,44:'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          2 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          number of incident theta-phi pairs or -ve number of',  /
               0  '             groups of incident theta-phi pairs where, within a group', /
               0  '             only theta or phi can vary, the varying angles are' /
               0  '             evenly distributed and have equal probability,'     /
               0  '          absolute distance from the isocenter to the origin'    /
               0  '             in the phase space plane                      '     /
               0  '          angle by which the source is rotated in the'           /
               0  '             phase space plane perpendicular to the beam'        /
               0  '             direction (degrees),                     '          /
               0  '             (+ve rotation is counterclockwise looking down'     /
               0  '              from the origin in the phase space plane),'         /
               0  '          i_dbs--set to 1 if DBS was used in BEAM simulation used' /
               0  '             to generate the phsp source and you want to reject fat' /
               0  '             photons, 0 otherwise,'/
               0  '          DBS splitting radius (cm),'/
               0  '          SSD at which splitting radius defined (cm),'/
               0  '          Z at which phsp source collected (cm)',/
               0  '          No. of times to split charged particles.'/);
               0  OUTPUT; (
               0  '  or  (9) BEAM simulation of treatment head'                     /
               0  '          Requires 11 inputs plus name of accelerator simulation,'/
               0  '          input file used in accelerator simulation, and pegs4'/
               0  '          data used in accelerator simulation:'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          9 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          angle between beam central axis and +z axis in DOSXYZ'/
               0  '             geometry--called the polar angle(degrees),'         /
               0  '          angle between +x direction in DOSXYZ geometry and'  /
               0  '             beam central axis projected on the DOSXYZ xy plane'   /
               0  '             --called the azimuthal angle (degrees),'            /
               0  '          absolute distance from the isocenter to centre of'    /
               0  '             scoring plane in BEAM simulation,'     /
               0  '          angle to rotate BEAM simulation about its central'     /
               0  '             axis (degrees) (+ve rotation is counterclockwise'/
               0  '             looking down the axis),'          /
               0  '          i_dbs--set to 1 if DBS is being used in BEAM simulation' /
               0  '             and you want to reject fat photons, 0 otherwise,'/
               0  '          No. of times to split charged particles.'/);
               0  OUTPUT; (
               0  '  or  (10) BEAM simulation source incident from multiple angles' /
               0  '          Requires 10 inputs plus name of accelerator simulation,'/
               0  '          input file used in accelerator simulation, and pegs4'/
               0  '          data used in accelerator simulation:'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          9 (mandatory, to identify source type),'               /
               0  '          x-coordinate of the isocenter (cm),'                   /
               0  '          y-coordinate of the isocenter (cm),'                   /
               0  '          z-coordinate of the isocenter (cm),'                   /
               0  '          number of incident theta-phi pairs or -ve number of',  /
               0  '             groups of incident theta-phi pairs where, within a group', /
               0  '             only theta or phi can vary, the varying angles are' /
               0  '             evenly distributed and have equal probability,'     /
               0  '          absolute distance from the isocenter to centre of'    /
               0  '             scoring plane in BEAM simulation,'     /
               0  '          angle to rotate BEAM simulation about its central'     /
               0  '             axis (degrees) (+ve rotation is counterclockwise'/
               0  '             looking down the axis),'          /
               0  '          i_dbs--set to 1 if DBS is being used in BEAM simulation' /
               0  '             and you want to reject fat photons, 0 otherwise,'/
               0  '          No. of times to split charged particles.'/);
               0  OUTPUT; (
               0  '  or  (20) Phase Space Incident from multiple settings '/
               0  '  optionally through an MLC or through a BEAM accel.'/
               0  '          Requires 6 inputs plus name of the input file used'/
               0  '       for BEAM/vcu SIM. and the BEAM/VCU code if used'/
               0  '          data used in simulation:'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          20 (mandatory, to identify source type),'               /
               0  '          number of control points, ',  /
               0  '          i_dbs: set to 1 if DBS is being used in simulation' /
               0  '             and you want to reject fat photons, 0 otherwise,'/
               0  '          r_dbs: radius of DBS splitting field in original'/
               0  '             BEAM simulation,'/
               0  '          ssd_dbs: SSD of DBS splitting field, '/
               0  '          z_dbs: Z position where phase space was scored '/
               0  '             in original BEAM simulation, '/
               0  '          No. of times to split charged particles,'/
               0  '          i_muidx_out: Set to 1 to include fractional MU index'/
               0  '             in output phase space (i_phsp_out=1 or 2)'/
               0  '          calflag: Set to 1 to skip the calibration run performed'/
               0  '             to refine the estimate of NRCYCL.'/);
               0  OUTPUT; (
               0  '  or  (21) BEAM simulation of treatment head will multiple settings' /
               0  '  optionally through a MLC'/
               0  '          Requires  name of accelerator simulation,'/
               0  '          input file used in accelerator simulation, and pegs4'/
               0  '          data used in accelerator simulation, name of input file'/
               0  '       for vcu SIM. and the VCU code (particleDmlc) if using MLC'/
               0  '          charge (-1 electron,0 photon,1 positron, 2 all),'      /
               0  '          21 (mandatory, to identify source type),'               /
               0  '          number of control points ',  /
               0  '          i_dbs: set to 1 if DBS is being used in BEAM simulation' /
               0  '             and you want to reject fat photons, 0 otherwise,'/
               0  '          No. of times to split charged particles.'/
               0  '          i_muidx_out: Set to 1 to include fractional MU index'/
               0  '             in output phase space (i_phsp_out=1 or 2)'/);
               0
               0  OUTPUT;(' All inputs on one line:',$);
               0
               0  INPUT iqin,isource,(temp(i),i=1,$NTEMP); (2i12,$NTEMPf15.0);
               0
               0  IF( (iqin < -1) | (iqin > 1 & isource ~= 2 & isource < 8) | (iqin > 2) )[
               1      iqin=0;
               1      ]
               0
               0  "------------------------------------------------------------------------"
               0  IF(isource = 0) [ "Frontal parallel beam directed along z-axis"
               1      "------------------------------------------------------------------------"
               1      xinl   = temp(1);     xinu   = temp(2);     yinl   = temp(3);
               1      yinu   = temp(4);     thetax = temp(5);     thetay = temp(6);
               1      thetaz = temp(7);
               1      OUTPUT iqin,xinl,xinu,yinl,yinu,thetax,thetay,thetaz;
               1      ( / ' Parallel beam incident from the front(+ve z-axis)'/
               1      ' Electric charge of the source:',t40,i12           /
               1      ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' Angle relative to +x:',t40,f10.4                   /
               1      ' Angle relative to +y:',t40,f10.4                   /
               1      ' Angle relative to -z:',t40,f10.4                   //);
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 1) [ "Parallel beam directed in any direction"
               1      "------------------------------------------------------------------------"
               1      xiso   = temp(1);     yiso   = temp(2);     ziso   = temp(3);
               1      theta(1)  = temp(4);     phi(1)  = temp(5);     xcol   = temp(6);
               1      ycol   = temp(7);     phicol = temp(8);
               1      OUTPUT iqin,xiso,yiso,ziso,theta(1),phi(1),xcol,ycol,phicol;
               1      ( / ' Parallel beam incident from an arbitrary direction'/
               1      ' Electric charge of the source:'       ,t40,i12     /
               1      ' x-coordinate of the isocenter:'       ,t40,f10.4   /
               1      ' y-coordinate of the isocenter:'       ,t40,f10.4   /
               1      ' z-coordinate of the isocenter:'       ,t40,f10.4   /
               1      ' Polar angle of collimator center:'    ,t40,f10.4   /
               1      ' Azimuthal angle of collimator center:',t40,f10.4   /
               1      ' Total x-collimator width:'            ,t40,f10.4   /
               1      ' Total y-collimator width:'            ,t40,f10.4   /
               1      ' Collimator rotation angle:'           ,t40,f10.4   //);
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 2)[ "Full phase space for each particle"
               1      "------------------------------------------------------------------------"
               1      xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
               1      theta(1)   = temp(4);     phi(1)     = temp(5);     dsource = temp(6);
               1      phicol  = temp(7);     iqphsp=iqin;
               1      i_dbs=temp(8); r_dbs=temp(9); ssd_dbs=temp(10); z_dbs=temp(11);
               1      e_split=temp(12);
               1      OUTPUT xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,e_split;
               1      ( / ' Full phase space from an arbitrary direction'/
               1      ' x-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' y-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' z-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' Polar angle of origin in source plane:',t55,f10.4/
               1      ' Azimuthal angle of origin in source plane:' ,t55,f10.4/
               1      ' Distance from isocenter to origin in source plane:',t55,f10.4/
               1      ' Source rotation angle:'            ,t55,f10.4/
               1      ' No. of times to split e+/e-:'    ,t55,i10/);
               1      IF(i_dbs=1)[
               2          OUTPUT r_dbs,ssd_dbs,z_dbs;
               2          (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
               2          ' in BEAM simulation to generate phase space source with:'/
               2          '    DBS splitting radius:',t55,f10.4/
               2          '    SSD where radius defined:',t55,f10.4/
               2          '    Z where source scored:',t55,f10.4/
               2          ' Photons whose trajectory takes them outside the DBS splitting'/
               2          ' radius at the SSD will be rejected.'/);
               2          IF(ssd_dbs<z_dbs)[
               3              OUTPUT;(//' ***WARNING:'/
               3              ' SSD where DBS splitting radius is defined < the Z'/
               3              ' value of scoring plane for this source.'/
               3              ' Particle rejection will be turned off.'//);
               3              i_dbs=0;
               3              ]
               2          ]
               1      ELSE[
               2          i_dbs=0;
               2          ]
               1      IF(iqphsp=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
               2          ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 3)[ "Frontal point source beam
               1      "------------------------------------------------------------------------"
               1      xinl   = temp(1);     xinu   = temp(2);     yinl   = temp(3);
               1      yinu   = temp(4);     ssd    = temp(5);
               1      OUTPUT iqin,xinl,xinu,yinl,yinu,ssd;
               1      ( / ' Point source incident from the front(+ve z-axis)'/
               1      ' Electric charge of the source:',t40,i12           /
               1      ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' SSD                     :',t40,f10.4             /);
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 4)[ ;$BEAMMODEL-SOURCE4-INPUT; ]
               0  "------------------------------------------------------------------------"
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 6)[ "isotropically radiating source
               1      "------------------------------------------------------------------------"
               1      xinl = temp(1);     xinu   = temp(2);     yinl   = temp(3);
               1      yinu   = temp(4);   zinl   = temp(5);     zinu   = temp(6);
               1      OUTPUT iqin,xinl,xinu,yinl,yinu,zinl,zinu;
               1      ( / ' Uniform isotropically radiating parallelepiped:'/
               1      ' Electric charge of the source:',t40,i12           /
               1      ' x-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' y-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /
               1      ' z-boundaries:',t26,f10.4,' cm --',f10.4,' cm'     /);
               1      IF(xinl>xinu)[
               2          OUTPUT; (//' ***ERROR in source 6:'/
               2          ' xinl > xinu '//);
               2          STOP;
               2          ]
               1      IF(yinl>yinu)[
               2          OUTPUT; (//' ***ERROR in source 6:'/
               2          ' yinl > yinu '//);
               2          STOP;
               2          ]
               1      IF(zinl>zinu)[
               2          OUTPUT; (//' ***ERROR in source 6:'/
               2          ' zinl > zinu '//);
               2          STOP;
               2          ]
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 7) [ "Parallel at multiple, user-selected angles"
               1      "------------------------------------------------------------------------"
               1      xiso   = temp(1);     yiso   = temp(2);     ziso   = temp(3);
               1      nang  = temp(4);     xcol   = temp(5);
               1      ycol   = temp(6);     phicol = temp(7);
               1      IF(nang>0)[
               2          OUTPUT iqin,xiso,yiso,ziso,nang,xcol,ycol,phicol;
               2          ( / ' Parallel beam incident from multiple, user-selected angles'/
               2          ' Electric charge of the source:'       ,t40,i12     /
               2          ' x-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' y-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' z-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' Number of incident theta-phi:'        ,t40,i12     /
               2          ' Total x-collimator width:'            ,t40,f10.4   /
               2          ' Total y-collimator width:'            ,t40,f10.4   /
               2          ' Collimator rotation angle:'           ,t40,f10.4   /);
               2          IF(nang>$MXANG)[
               3              OUTPUT61 $MXANG;
               3              (//' ***ERROR in source 7***'/
               3              ' Number of incident theta-phi > max. allowed (',I4,')'/
               3              ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               3              ' and try again.'//);
               3              STOP;
               3              ]
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          DO I=1,nang["get each theta-phi and prob."
               3              OUTPUT I;(' Incident theta-phi pair ',I4,':'/
               3              '    theta (deg.), phi (deg.), probability:',$);
               3              INPUT theta(I),phi(I),pang(I); (3F15.0);
               3              OUTPUT theta(I),phi(I),pang(I); (3F10.4);
               3              temp(1)=temp(1)+pang(I);
               3              ]
               2          DO I=1,nang["normalize probabilities + create cumulative prob distn"
               3              pang(I)=pang(I)/temp(1);
               3              IF(I>1)[
               4                  pang(I)=pang(I)+pang(I-1);
               4                  ]
               3              ]
               2          numang=nang;
               2          ]
               1      ELSEIF(nang<0)[
               2          OUTPUT iqin,xiso,yiso,ziso,-nang,xcol,ycol,phicol;
               2          ( / ' Parallel beam incident from multiple, user-selected angles'/
               2          ' Electric charge of the source:'       ,t40,i12     /
               2          ' x-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' y-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' z-coordinate of the isocenter:'       ,t40,f10.4   /
               2          ' No. of theta-phi groups:'             ,t40,i12     /
               2          ' Total x-collimator width:'            ,t40,f10.4   /
               2          ' Total y-collimator width:'            ,t40,f10.4   /
               2          ' Collimator rotation angle:'           ,t40,f10.4   /);
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          OUTPUT;(' For each theta-phi group, input:'/
               2          '   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
               2          '   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
               2          '   no. of varying angles in group (including min. and max.), '/
               2          '   probability for group (all on one line).');
               2          DO I=1,-nang["get angle groups and probabilities"
               3              OUTPUT I;(' Incident theta-phi group ',I4,/
               3              ' :',$);
               3              INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I12,3F15.0,I12,F15.0);
               3              IF(ngang(I)<2)[
               4                  OUTPUT;(//' ***WARNING***'/
               4                  ' ngang(i) must be >=2.  It will be reset to 2 '/
               4                  ' in this case. '//);
               4                  ngang(I)=2;
               4                  ]
               3              OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I10,3F10.4,I10,F10.4);
               3              temp(1)=temp(1)+pgang(I);
               3              ]
               2          K=0; "index for individual angles"
               2          DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
               3              "create cumulative prob distn"
               3              pgang(I)=pgang(I)/temp(1);"renormalize group probs"
               3              DO J=1,ngang(I)[
               4                  K=K+1;
               4                  IF(K>$MXANG)[
               5                      OUTPUT61 $MXANG;
               5                      (//' ***ERROR in source 7***'/
               5                      ' Number of incident theta-phi > max. allowed (',I4,')'/
               5                      ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               5                      ' and try again.'//);
               5                      STOP;
               5                      ]
               4                  IF(ivary(I)=1)["fixed phi"
               5                      phi(K)=angfixed(I);
               5                      theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  ELSE["fixed theta"
               5                      theta(K)=angfixed(I);
               5                      phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  pang(K)=pgang(I)/ngang(I);
               4                  IF(K>1)[
               5                      pang(K)=pang(K)+pang(K-1);
               5                      ]
               4                  ]
               3              ]
               2          numang=K;
               2          ]
               1      OUTPUT;(' ');
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 8)[ "Full phase space incident from multiple angles"
               1      "------------------------------------------------------------------------"
               1      xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
               1      nang   = temp(4);     dsource = temp(5);
               1      phicol  = temp(6);     iqphsp=iqin;
               1      i_dbs=temp(7); r_dbs=temp(8); ssd_dbs=temp(9); z_dbs=temp(10);
               1      e_split=temp(11);
               1      IF(nang>0)[
               2          OUTPUT xiso,yiso,ziso,nang,dsource,phicol,e_split;
               2          ( / ' Full hase space from multiple, user-selected angles'/
               2          ' x-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' y-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' z-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' Number of incident theta-phi:',t55,i10/
               2          ' Distance from isocenter to origin in source plane:',t55,f10.4/
               2          ' Source rotation angle:'            ,t55,f10.4/
               2          ' No. of times to split e+/e-:'    ,t55,i10/);
               2          IF(i_dbs=1)[
               3              OUTPUT r_dbs,ssd_dbs,z_dbs;
               3              (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
               3              ' in BEAM simulation to generate phase space source with:'/
               3              '    DBS splitting radius:',t55,f10.4/
               3              '    SSD where radius defined:',t55,f10.4/
               3              '    Z where source scored:',t55,f10.4/
               3              ' Photons whose trajectory takes them outside the DBS splitting'/
               3              ' radius at the SSD will be rejected.'/);
               3              IF(ssd_dbs<z_dbs)[
               4                  OUTPUT;(//' ***WARNING:'/
               4                  ' SSD where DBS splitting radius is defined < the Z'/
               4                  ' value of scoring plane for this source.'/
               4                  ' Particle rejection will be turned off.'//);
               4                  i_dbs=0;
               4                  ]
               3              ]
               2          ELSE[
               3              i_dbs=0;
               3              ]
               2          IF(iqphsp=2)[OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/);]
               3              ELSE[OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/);]
               2          IF(nang>$MXANG)[
               3              OUTPUT61 $MXANG;
               3              (//' ***ERROR in source 7***'/
               3              ' Number of incident theta-phi > max. allowed (',I4,')'/
               3              ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               3              ' and try again.'//);
               3              STOP;
               3              ]
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          DO I=1,nang["get each theta-phi and prob."
               3              OUTPUT I;(' Incident theta-phi pair ',I4,':'/
               3              '    theta (deg.), phi (deg.), probability:',$);
               3              INPUT theta(I),phi(I),pang(I); (3F15.0);
               3              OUTPUT theta(I),phi(I),pang(I); (3F10.4);
               3              temp(1)=temp(1)+pang(I);
               3              ]
               2          DO I=1,nang["normalize probabilities + create cumulative prob distn"
               3              pang(I)=pang(I)/temp(1);
               3              IF(I>1)[
               4                  pang(I)=pang(I)+pang(I-1);
               4                  ]
               3              ]
               2          numang=nang;
               2          ]
               1      ELSEIF(nang<0)[
               2          OUTPUT xiso,yiso,ziso,-nang,dsource,phicol;
               2          ( / ' Full phase space from multiple, user-selected angles'/
               2          ' x-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' y-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' z-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' Number of theta-phi groups:',t55,i10/
               2          ' Distance from isocenter to origin in source plane:',t55,f10.4/
               2          ' Source rotation angle:'            ,t55,f10.4/);
               2          IF(i_dbs=1)[
               3              OUTPUT r_dbs,ssd_dbs,z_dbs;
               3              (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
               3              ' in BEAM simulation to generate phase space source with:'/
               3              '    DBS splitting radius:',t55,f10.4/
               3              '    SSD where radius defined:',t55,f10.4/
               3              '    Z where source scored:',t55,f10.4/
               3              ' Photons whose trajectory takes them outside the DBS splitting'/
               3              ' radius at the SSD will be rejected.'/);
               3              IF(ssd_dbs<z_dbs)[
               4                  OUTPUT;(//' ***WARNING:'/
               4                  ' SSD where DBS splitting radius is defined < the Z'/
               4                  ' value of scoring plane for this source.'/
               4                  ' Particle rejection will be turned off.'//);
               4                  i_dbs=0;
               4                  ]
               3              ]
               2          ELSE[
               3              i_dbs=0;
               3              ]
               2          IF(iqphsp=2)[OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/);]
               3              ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          OUTPUT;(' For each theta-phi group, input:'/
               2          '   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
               2          '   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
               2          '   no. of varying angles in group (including min. and max.), '/
               2          '   probability for group (all on one line).');
               2          DO I=1,-nang["get angle groups and probabilities"
               3              OUTPUT I;(' Incident theta-phi group ',I4,/
               3              ' :',$);
               3              INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I12,3F15.0,I12,F15.0);
               3              IF(ngang(I)<2)[
               4                  OUTPUT;(//' ***WARNING***'/
               4                  ' ngang(i) must be >=2.  It will be reset to 2 '/
               4                  ' in this case. '//);
               4                  ngang(I)=2;
               4                  ]
               3              OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I10,3F10.4,I10,F10.4);
               3              temp(1)=temp(1)+pgang(I);
               3              ]
               2          K=0; "index for individual angles"
               2          DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
               3              "create cumulative prob distn"
               3              pgang(I)=pgang(I)/temp(1);"renormalize group probs"
               3              DO J=1,ngang(I)[
               4                  K=K+1;
               4                  IF(K>$MXANG)[
               5                      OUTPUT61 $MXANG;
               5                      (//' ***ERROR in source 7***'/
               5                      ' Number of incident theta-phi > max. allowed (',I4,')'/
               5                      ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               5                      ' and try again.'//);
               5                      STOP;
               5                      ]
               4                  IF(ivary(I)=1)["fixed phi"
               5                      phi(K)=angfixed(I);
               5                      theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  ELSE["fixed theta"
               5                      theta(K)=angfixed(I);
               5                      phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  pang(K)=pgang(I)/ngang(I);
               4                  IF(K>1)[
               5                      pang(K)=pang(K)+pang(K-1);
               5                      ]
               4                  ]
               3              ]
               2          numang=K;
               2          ]
               1      OUTPUT;(' ');
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 9)[ "BEAM simulation of treatment head"
               1      "------------------------------------------------------------------------"
               1      xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
               1      theta(1)   = temp(4);     phi(1)     = temp(5);     dsource = temp(6);
               1      phicol  = temp(7);     iqinc=iqin;
               1      i_dbs=temp(8); e_split=temp(9);
               1      OUTPUT xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,e_split;
               1      ( / ' BEAM simulation of treatment head incident from any direction'/
               1      ' x-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' y-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' z-coordinate of the isocenter:'    ,t55,f10.4/
               1      ' Polar angle of beam central axis:',t55,f10.4/
               1      ' Azimuthal angle of beam central axis:' ,t55,f10.4/
               1      ' Distance from isocenter to centre of'/
               1      '            scoring plane in BEAM simulation:',t55,f10.4/
               1      ' Rotation angle about beam axis:',t55,f10.4/
               1      ' No. of times to split e+/e-:',t55,i10/);
               1      IF(i_dbs=1)[
               2          OUTPUT;
               2          ( ' Fat photons resulting from DBS will be rejected'/);
               2          ]
               1      ELSE[
               2          OUTPUT;
               2          ( ' Fat photons resulting from DBS will not be rejected'/);
               2          i_dbs=0;
               2          ]
               1      IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
               1      ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 10)[ "BEAM simulation source from multiple angles"
               1      "------------------------------------------------------------------------"
               1      xiso    = temp(1);     yiso    = temp(2);     ziso    = temp(3);
               1      nang   = temp(4);     dsource = temp(5);
               1      phicol  = temp(6);     iqinc=iqin;
               1      i_dbs=temp(7); e_split=temp(8);
               1      IF (nang>0)[
               2          OUTPUT xiso,yiso,ziso,nang,dsource,phicol,e_split;
               2          ( / ' BEAM simulation source incident from multiple angles'/
               2          ' x-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' y-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' z-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' No. of incident theta-phi:',t55,i10/
               2          ' Distance from isocenter to centre of'/
               2          '            scoring plane in BEAM simulation:',t55,f10.4/
               2          ' Rotation angle about beam axis:',t55,f10.4/
               2          ' No. of time to split e+/e-:',t55,i10/);
               2          ]
               1      ELSEIF (nang<0) [
               2          OUTPUT xiso,yiso,ziso,-nang,dsource,phicol,e_split;
               2          ( / ' BEAM simulation source incident from multiple angles'/
               2          ' x-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' y-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' z-coordinate of the isocenter:'    ,t55,f10.4/
               2          ' No. of theta-phi groups:',t55,i10/
               2          ' Distance from isocenter to centre of'/
               2          '            scoring plane in BEAM simulation:',t55,f10.4/
               2          ' Rotation angle about beam axis:',t55,f10.4/
               2          ' No. of time to split e+/e-:',t55,i10/);
               2          ]
               1      IF(i_dbs=1)[
               2          OUTPUT;
               2          ( ' Fat photons resulting from DBS will be rejected'/);
               2          ]
               1      ELSE[
               2          OUTPUT;
               2          ( ' Fat photons resulting from DBS will not be rejected'/);
               2          i_dbs=0;
               2          ]
               1      IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
               1      ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]
               1      IF(nang>0)[
               2          IF(nang>$MXANG)[
               3              OUTPUT61 $MXANG;
               3              (//' ***ERROR in source 7***'/
               3              ' Number of incident theta-phi > max. allowed (',I4,')'/
               3              ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               3              ' and try again.'//);
               3              STOP;
               3              ]
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          DO I=1,nang["get each theta-phi and prob."
               3              OUTPUT I;(' Incident theta-phi pair ',I4,':'/
               3              '    theta (deg.), phi (deg.), probability:',$);
               3              INPUT theta(I),phi(I),pang(I); (3F15.0);
               3              OUTPUT theta(I),phi(I),pang(I); (3F10.4);
               3              temp(1)=temp(1)+pang(I);
               3              ]
               2          DO I=1,nang["normalize probabilities + create cumulative prob distn"
               3              pang(I)=pang(I)/temp(1);
               3              IF(I>1)[
               4                  pang(I)=pang(I)+pang(I-1);
               4                  ]
               3              ]
               2          numang=nang;
               2          ]
               1      ELSEIF(nang<0)[
               2          temp(1)=0.; "use temp(1) to normalize probabilities"
               2          OUTPUT;(' For each theta-phi group, input:'/
               2          '   ivary (=0 to vary phi, 1 to vary theta), fixed theta/phi (deg.), '/
               2          '   min. varying theta/phi (deg.), max. varying theta/phi (deg.), '/
               2          '   no. of varying angles in group (including min. and max.), '/
               2          '   probability for group (all on one line).');
               2          DO I=1,-nang["get angle groups and probabilities"
               3              OUTPUT I;(' Incident theta-phi group ',I4,/
               3              ' :',$);
               3              INPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I12,3F15.0,I12,F15.0);
               3              IF(ngang(I)<2)[
               4                  OUTPUT;(//' ***WARNING***'/
               4                  ' ngang(i) must be >=2.  It will be reset to 2 '/
               4                  ' in this case. '//);
               4                  ngang(I)=2;
               4                  ]
               3              OUTPUT ivary(I),angfixed(I),angmin(I),angmax(I),ngang(I),pgang(I);
               3              (I10,3F10.4,I10,F10.4);
               3              temp(1)=temp(1)+pgang(I);
               3              ]
               2          K=0; "index for individual angles"
               2          DO I=1,-nang["calculate individual theta-phi, normalize probs, and"
               3              "create cumulative prob distn"
               3              pgang(I)=pgang(I)/temp(1);"renormalize group probs"
               3              DO J=1,ngang(I)[
               4                  K=K+1;
               4                  IF(K>$MXANG)[
               5                      OUTPUT61 $MXANG;
               5                      (//' ***ERROR in source 7***'/
               5                      ' Number of incident theta-phi > max. allowed (',I4,')'/
               5                      ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               5                      ' and try again.'//);
               5                      STOP;
               5                      ]
               4                  IF(ivary(I)=1)["fixed phi"
               5                      phi(K)=angfixed(I);
               5                      theta(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  ELSE["fixed theta"
               5                      theta(K)=angfixed(I);
               5                      phi(K)=angmin(I)+(J-1)*(angmax(I)-angmin(I))/(ngang(I)-1);
               5                      ]
               4                  pang(K)=pgang(I)/ngang(I);
               4                  IF(K>1)[
               5                      pang(K)=pang(K)+pang(K-1);
               5                      ]
               4                  ]
               3              ]
               2          numang=K;
               2          ]
               1      OUTPUT;(' ');
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 20)[ "Phase Space Incident from multiple settings and "
               1      "through an MLC (optional)"
               1      "------------------------------------------------------------------------"
               1      nset   = temp(1);   iqinc=iqin;
               1      i_dbs=temp(2); r_dbs=temp(3); ssd_dbs=temp(4); z_dbs=temp(5);
               1      e_split=temp(6); i_muidx_out=temp(7); calflag=temp(8);
               1      "The following IF statement is used to preserve compatibility with old"
               1      "input files and keep the e_split value (JL)"
               1      IF(ssd_dbs=0 & z_dbs=0 & r_dbs>0)[
               2          r_dbs = 0;
               2          e_split = temp(3);
               2          ]
               1      IF(nset>1)[
               2          OUTPUT nset,e_split;
               2          ( / ' Phase Space source though dynamic library with multiple variable'/
               2          ' geometry settings'/
               2          ' Number of settings:',t55,i10/
               2          ' No. of time to split e+/e-:',t55,i10/);
               2          IF(i_dbs=1)[
               3              OUTPUT r_dbs,ssd_dbs,z_dbs;
               3              (/ ' Directional Bremsstrahlung Splitting (DBS) used'/
               3              ' in BEAM simulation to generate phase space source with:'/
               3              '    DBS splitting radius:',t55,f10.4/
               3              '    SSD where radius defined:',t55,f10.4/
               3              '    Z where source scored:',t55,f10.4/
               3              ' Photons whose trajectory takes them outside the DBS splitting'/
               3              ' radius at the SSD will be rejected.'/);
               3              IF(ssd_dbs<z_dbs)[
               4                  OUTPUT;(//' ***WARNING:'/
               4                  ' SSD where DBS splitting radius is defined < the Z'/
               4                  ' value of scoring plane for this source.'/
               4                  ' Particle rejection will be turned off.'//);
               4                  i_dbs=0;
               4                  ]
               3              IF(r_dbs=0)["r_dbs was set to 0 assuming it was incorrectly read"
               4                  "from an old input file (JL)"
               4                  OUTPUT;(//' ***WARNING:'/
               4                  ' DBS splitting radius is 0.'/
               4                  ' Make sure it is defined correctly in the input file.'/
               4                  ' Particle rejection will be turned off.'//);
               4                  i_dbs=0;
               4                  ]
               3              ]
               2          ELSE[
               3              i_dbs=0;
               3              ]
               2
               2          IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
               2          ELSE[ OUTPUT iqinc; (/' Charge of incident particles to use: ',i2/); ]
               2
               2          IF(nset>$MXANG)[
               3              OUTPUT61 $MXANG;
               3              (//' ***ERROR in source 20***'/
               3              ' Number of incident settings > max. allowed (',I4,')'/
               3              ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               3              ' and try again.'//);
               3              STOP;
               3              ]
               2
               2          IF(i_muidx_out<0 | i_muidx_out>1) i_muidx_out=0;
               2          IF(i_muidx_out=1)[
               3              OUTPUT;
               3              (' If writing phase space data on exit from phantom (i_phsp_out=1 or 2)'/
               3              ' frMU_indx (fractional monitor unit index) will be included.');
               3              ]
               2
               2          IF(calflag < 0 | calflag > 1) calflag = 0; "Default to running calib run"
               2          IF(calflag = 1)[
               3              OUTPUT;
               3              (' Skipping calibration run. Make sure that your phase space file has'/
               3              ' enough particles to avoid rewinding, otherwise uncertainty values'/
               3              ' will be inaccurate.');
               3              ]
               2
               2          DO I=1,nset["get each setting"
               3              OUTPUT I;(' Incident setting ',I4,':'/
               3              '    xiso (cm), yiso (cm), ziso (cm), theta (deg.)',
               3              ', phi (deg.), phicol (deg.),SAD (cm), MU Index:',$);
               3              INPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I),muIndex(I);(8F15.0);
               3              OUTPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I), muIndex(I); (8F10.4);
               3              ]
               2          dsource=dsourcetemp(1);"set to first one arbitrarily since its done"
               2          "later on the fly"
               2          ]"if nset is greater than 1
               1      ELSEIF(nset<2) [
               2          OUTPUT61 nset;
               2          (//' ***ERROR in source 20***'/
               2          'nset (',I8,') must be >= 2'//);
               2          STOP;
               2          ]
               1      OUTPUT;(' ');
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 21)[ "BEAM simulation with multiple settings and through"
               1      "MLC (optional)"
               1      "------------------------------------------------------------------------"
               1      nset=temp(1);
               1      i_dbs=temp(2);
               1      e_split=temp(3);
               1      i_muidx_out=temp(4);
               1      iqinc=iqin;
               1      IF(nset>1)[
               2          OUTPUT nset,e_split;
               2          ( / ' Full BEAM Sim. incident from multiple settings'/
               2          ' Number of settings:',t55,i10/
               2          ' No. of time to split e+/e-:',t55,i10/);
               2          IF(i_dbs=1)[
               3              OUTPUT;
               3              ( ' Fat photons resulting from DBS will be rejected'/);
               3              ]
               2          ELSE[
               3              OUTPUT;
               3              ( ' Fat photons resulting from DBS will not be rejected'/);
               3              i_dbs=0;
               3              ]
               2          IF(iqinc=2)[ OUTPUT;(/' Charge of incident particles to use: -1, 0, 1'/); ]
               2          ELSE[ OUTPUT iqphsp; (/' Charge of incident particles to use: ',i2/); ]
               2
               2          IF(nset>$MXANG)[
               3              OUTPUT61 $MXANG;
               3              (//' ***ERROR in source 12***'/
               3              ' Number of incident settings > max. allowed (',I4,')'/
               3              ' Increase $MXANG in dosxyz_user_macros.mortran, recompile'/
               3              ' and try again.'//);
               3              STOP;
               3              ]
               2
               2          IF(i_muidx_out<0 | i_muidx_out>1) i_muidx_out=0;
               2          IF(i_muidx_out=1)[
               3              OUTPUT;
               3              (' If writing phase space data on exit from phantom (i_phsp_out=1 or 2)'/
               3              ' frMU_indx (fractional monitor unit index) will be included.');
               3              ]
               2
               2          DO I=1,nset["get each setting"
               3              OUTPUT I;(' Incident setting ',I4,':'/
               3              '  xiso (cm), yiso (cm), ziso (cm), theta (deg.)',
               3              '  phi (deg.), phicol (deg.), SAD (cm), MU Index:',$);
               3              INPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I), muIndex(I);(8F15.0);
               3              OUTPUT xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I),muIndex(I); (8F10.4);
               3              ]
               2          dsource=dsourcetemp(1);"set to first one arbitrarily since its done"
               2          "later on the fly"
               2          ]
               1      ELSEIF(nset<2) [
               2          OUTPUT61 nset;
               2          (//' ***ERROR in source 21***'/
               2          'nset (',I8,') must be >= 2'//);
               2          STOP;
               2          ]
               1      OUTPUT;(' ');
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSE[ "Bad input, set error flag and return"
               1      "------------------------------------------------------------------------"
               1      OUTPUT61 isource;(' ***ISOURCE =', I10,' not valid: stopping');
               1      stop;
               1      ]
               0
               0  "     READ NEXT RECORD"
               0  "     ================"
               0
               0  OUTPUT;
               0  (' Enflag(0=mono-E,1=spectr,2=phsp or full BEAM sim.,3=dose comp,4=beam model),'
            '  0  /' Mode(0,2), medsur(0 = vacuum), dsurround(1), dflag(0=1 dsurround,'/
               0  ' 1=4 dsurrounds), dsurround(2), dsurround(3), dsurround(4)',/,' :',$);
               0  INPUT enflag,ismode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
               0  dsurround(4); (3I12,F15.0,I12,3F15.0);
               0
               0  "Set the defaults for the above parameters if needed"
               0  IF(enflag>1)[ "some sort of phase space input or BEAM simultion source"
               1      IF(ismode ~= 2)ismode=0;"default is 0"
               1      "now set the proper dsurrounds"
               1      IF(dflag~=1)[
               2          dflag=0;"default"
               2          IF(dsurround(1)<=0.)[
               3              dsurround(1)=50.;"default= 50 cm thickness"
               3              OUTPUT dsurround(1);(/10x,' dsurround(1) defaults to',F8.3,' cm.'/);
               3              ]
               2          dsurround(2)=dsurround(1);
               2          dsurround(3)=dsurround(1);
               2          dsurround(4)=dsurround(1);
               2          ]
               1      ELSE[
               2          IF(dsurround(1)<0.)["default to 0 here"
               3              dsurround(1)=0.;
               3              OUTPUT dsurround(1);(/10x,' dsurround(1) defaults to',F8.3,' cm.'/);
               3              ]
               2          IF(dsurround(2)<0.)["default to 0 here"
               3              dsurround(2)=0.;
               3              OUTPUT dsurround(2);(/10x,' dsurround(2) defaults to',F8.3,' cm.'/);
               3              ]
               2          IF(dsurround(3)<0.)["default to 0 here"
               3              dsurround(3)=0.;
               3              OUTPUT dsurround(3);(/10x,' dsurround(3) defaults to',F8.3,' cm.'/);
               3              ]
               2          IF(dsurround(4)<0.)["default to 0 here"
               3              dsurround(4)=0.;
               3              OUTPUT dsurround(4);(/10x,' dsurround(4) defaults to',F8.3,' cm.'/);
               3              ]
               2          ]
               1      ]
               0  IF(enflag > 1 & dflag = 1)[
               1      OUTPUT enflag,ismode,medsur,dsurround(1),dflag,dsurround(2),dsurround(3),
               1      dsurround(4) ;(3I12,F8.3,I12,3F8.3);
               1      ]
               0  ELSE[
               1      OUTPUT enflag,ismode,medsur,dsurround(1),dflag;(3I12,F8.3,I12);
               1      ]
               0  IF(enflag>1)[
               1      IF (medsur<=0) | ( medsur>nmed)[
               2          med($IR(imax,jmax,kmax)+1)=0;
               2          IF(dflag=0)[
               3              OUTPUT61 dsurround(1);
               3              (/' The material in the region outside the phantom is vacuum.'/
               3              ' The thickness of this region (in x, y & z direction) is:',F8.3,' cm'/);
               3              ]
               2          ELSE[
               3              OUTPUT61 dsurround(1),dsurround(2),dsurround(3),dsurround(4);
               3              (/' The material in the region outside the phantom is vacuum.'/
               3              ' The thickness of this region in the x direction is:',F8.3,' cm'/
               3              ' The thickness in the y direction is:',F8.3,' cm'/
               3              ' The thickness in the +z direction is:',F8.3,' cm'/
               3              ' The thickness in the -z direction is:',F8.3,' cm'/);
               3              ]
               2          ]
               1      ELSE[
               2          med($IR(imax,jmax,kmax)+1)=medsur;
               2          IF(dflag=0)[
               3              OUTPUT61(media(j,medsur),j=1,24),dsurround(1);
               3              (/' The material in the region outside the phantom is:',24a1/
               3              ' The thickness of this region (in x, y & z direction) is:',F8.3,' cm'/);
               3              ]
               2          ELSE[
               3              OUTPUT61(media(j,medsur),j=1,24),dsurround(1),dsurround(2),
               3              dsurround(3),dsurround(4);
               3              (/' The material in the region outside the phantom is:',24a1/
               3              ' The thickness of this region in the x direction is:',F8.3,' cm'/
               3              ' The thickness in the y direction is:',F8.3,' cm'/
               3              ' The thickness in the +z direction is:',F8.3,' cm'/
               3              ' The thickness in the -z direction is:',F8.3,' cm'/);
               3              ]
               2          ]
               1      dsurround(1)=dsurround(1)+0.0001;
               1      dsurround(2)=dsurround(2)+0.0001;
               1      dsurround(3)=dsurround(3)+0.0001;
               1      dsurround(4)=dsurround(4)+0.0001;
               1      "added a small margin to prevent roundoff error later"
               1      ]
               0  "----------------------------------------------------------------"
               0  IF(enflag = 0)[ "monoenergetic source"
               1      "----------------------------------------------------------------"
               1      OUTPUT;(' Beam Energy (K.E. in MeV):',$);
               1      read(5,*) ein;
               1      OUTPUT ein;(F10.3);
               1      ]
               0  "----------------------------------------------------------------"
               0  ELSEIF(enflag = 1)["input an energy spectrum"
               1      "----------------------------------------------------------------"
               1      OUTPUT;(' Energy spectrum:');
               1      OUTPUT;(' Input name of file with spectrum data (A256): ',$);
               1      READ(5,101,ERR=:ERR_SOURCE1:) FILNAM;
               1      101 FORMAT(A256);
               1      OUTPUT61 FILNAM;(/'   Read input energy spectrum from: ',/A);
               1      call replace_env(FILNAM);
               1      OPEN(UNIT=99,STATUS='OLD',file=FILNAM);
               1      READ(99,101) SPEC_TITLE;
               1      READ(99,'(I10,F15.0,I5)')NENSRC,ENMIN,IMODE;
               1      IF (NENSRC > $NENSRC)[
               2          OUTPUT61 NENSRC,$NENSRC;(//' Number of energy bins=',I4,
               2          ' is greater than max allowed =',I4/' Reduced to max allowed.'//);
               2          NENSRC = $NENSRC;
               2          ]
               1      READ(99,'(2F20.0)')(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
               1      CLOSE(UNIT=99);
               1      OUTPUT61 NENSRC; ('  Have read',I5,' input energy bins from file');
               1      IF(IMODE=0)[OUTPUT61;('      Counts/bin assumed');  ]
               1      ELSEIF(IMODE = 1)[
               2          OUTPUT61;('      Counts/MeV assumed');
               2          SRCPDF(1) = SRCPDF(1)*(ENSRCD(1)-ENMIN);
               2          DO IB=2,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
               2          ] "end mode = 1 block"
               1      ELSE [
               2          OUTPUT61 IMODE;(///'*****MODE not 0 or 1 in spectrum file? **'
               2          /80('*') //);
               2          ]
               1      EIN = ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
               1      OUTPUT61 ENMIN,EIN;('    Energy ranges from',F10.3,' MeV to',F12.3,' MeV');
               1
               1      "check that minimum energy of first non-zero bin is above ECUT,PCUT"
               1      IF(SRCPDF(1)>0.0)[
               2          IF(iqin=-1&ENMIN<ECUT)[
               3              OUTPUT61;(//' *******WARNING:'/
               3              ' min. energy of spectrum < ECUT'/
               3              ' May lead to artifically high dose in voxel(s) on which source is incident'//);
               3              ]
               2          ELSEIF(iqin=0&ENMIN<PCUT)[
               3              OUTPUT61;(//' *******WARNING:'/
               3              ' min. energy of spectrum < PCUT'/
               3              ' May lead to artifically high dose in voxel(s) on which source is incident'//);
               3              ]
               2          ]
               1      ELSE["find out the min energy of the first non-zero bin"
               2          DO IB=2,NENSRC[
               3              IF(SRCPDF(IB)>0.)[
               4                  IF(iqin=-1&ENSRCD(IB-1)<ECUT)[
               5                      OUTPUT61;(//' *******WARNING:'/
               5                      ' min. energy of spectrum < ECUT'/
               5                      ' May lead to artifically high dose in voxel(s) on which source is incident'//);
               5                      ]
               4                  ELSEIF(iqin=0&ENSRCD(IB-1)<PCUT)[
               5                      OUTPUT61;(//' *******WARNING:'/
               5                      ' min. energy of spectrum < PCUT'/
               5                      ' May lead to artifically high dose in voxel(s) on which source is incident'//);
               5                      ]
               4                  EXIT;
               4                  ]
               3              ]
               2          ]
               1
               1      "INITIALIZATION ROUTINE TO CALCULATE THE INVERSE OF THE CUMULATIVE "
               1      "PROBABILITY DISTRIBUTION THAT IS USED DURING EXECUTION TO SAMPLE  "
               1      "THE INCIDENT PARTICLE ENERGY"
               1      "CALCULATE THE CPDF FROM THE PDF AND NORMALIZE IT"
               1      SRCCDF(1)=SRCPDF(1);
               1      DO IB=2,NENSRC[ SRCCDF(IB)=SRCCDF(IB-1)+SRCPDF(IB); ]
               1      FNORM=1./SRCCDF(NENSRC);
               1      BINSOK=0.0;
               1      DELTAK=$INVDIM;
               1      GRIDSZ=1/DELTAK;
               1      DO IB=1,NENSRC[
               2          SRCCDF(IB)=FNORM*SRCCDF(IB);
               2          IF(IB = 1)[IF(SRCCDF(1) <= 3.*GRIDSZ )[BINSOK = 1.0;] ]
               2          ELSE [     IF((SRCCDF(IB)-SRCCDF(IB-1)) < 3.*GRIDSZ) [BINSOK=1.0;] ]
               2          ]"END OF LOOP ON IB"
               1      IF(BINSOK.NE.0.0)[OUTPUT61;(///' *******WARNING******'/
               2          T20,'SOME OF NORMALIZED BIN PROBABILITIES SO SMALL BINS MAY BE MISSED'/);
               2          ]
               1      "CALCULATE CDFINV - AN ARRAY WHICH ALLOWS THE RAPID SAMPLING FOR THE"
               1      "ENERGY BY PRECOMPUTING THE RESULTS FOR A FINE GRID"
               1
               1      DO K=1,$INVDIM [
               2          AK= FLOAT(K)*GRIDSZ;
               2          DO I=1,NENSRC [ IF(AK <= SRCCDF(I))[ GO TO :FOUND-BIN:;] ]
               2          "WE SHOULD NEVER FALL THROUGH TO HERE"
               2          :FOUND-BIN:
               2          IF(I ~= 1)[CDFINV(K,1) = ENSRCD(I-1);]
               2          ELSE [CDFINV(K,1) = ENMIN;]
               2          CDFINV(K,2) = ENSRCD(I)-CDFINV(K,1);
               2          ]"END LOOP OVER K"
               1
               1      "OUTPUT IF IWATCH IS ACTIVE"
               1      IF(IWATCH ~= 0)[
               2          OUTPUT SPEC_TITLE;(1x,80A1);
               2          OUTPUT;(/' ENSRCD,   SRCPDF,   SRCCDF:'//);
               2          OUTPUT (ENSRCD(IB),SRCPDF(IB),SRCCDF(IB),IB=1,NENSRC);(3E17.7);
               2          OUTPUT;(//);]
               1      ]"end of (enflag = 1)"
               0
               0  "----------------------------------------------------------------"
               0  ELSEIF( (enflag = 2) | (enflag = 3) )["phase space input or full BEAM sim."
               1      "----------------------------------------------------------------"
               1      IF(isource=2 | isource=8)[
               2          OLDSRC=0;"flag for old phase space files"
               2          OUTPUT;(' Input name of phase space file (A256)'/'  : ',$);
               2          READ(5,101,ERR=:ERR_SOURCE2:) FILNAM;
               2          OUTPUT61 FILNAM;(/' Particles will be read from file: ',/A);
               2
               2          call replace_env(FILNAM);
               2
               2          i_iaea_in=0; "assume not in IAEA format"
               2          ilen=lnblnk1(FILNAM);
               2          IF(FILNAM(ilen-8:ilen)='.IAEAphsp')[
               3              i_iaea_in=1;
               3              FILNAM=FILNAM(:ilen-9);
               3              ]
               2
               2          IF(i_iaea_in=1)[
               3              i_unit_in=44;
               3              $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,FILNAM);
               3              $IAEA_READ_PHSP_HEADER(i_unit_in,nshist,nphist,ein,nincsrc,
               3              Z_SOURCE,ismode,i_mu_phsp,izscore);
               3              OUTPUT nshist,nphist,ein,NINCSRC;
               3              (T10,' IAEA format Phase space source with:'/
               3              T5,'                    Total number of particles =',I13/
               3              T5,'                            Number of photons =',I13/
               3              T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
               3              T5,' # of particles incident from original source =',F13.3/);
               3              IF(izscore=0)[
               4                  OUTPUT Z_SOURCE;
               4                  (T5,'                        Z where source scored =',F13.3,' cm'/);
               4                  ]
               3              $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(i_unit_in);
               3              ]
               2          ELSE[
               3
               3              $OPEN_PHSP_FOR_READ(ismode,44,FILNAM,MODE,nshist,nphist,ein,temp(2),
               3              NINCSRC);
               3              IF(NINCSRC<2.)["old file with min phot. energy"
               4                  OUTPUT61;(//' ******WARNING*****'/
               4                  ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
               4                  ' VERSION OF BEAM IN WHICH # OF PARTICLES INCIDENT FROM'/
               4                  ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
               4                  ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE PHASE'/
               4                  ' SPACE SOURCE, AND DOSE WILL BE NORMALIZED'/
               4                  ' WITH RESPECT TO THE # OF HISTORIES RUN...NOT'/
               4                  ' THE # OF INCIDENT PARTICLES FROM THE ORIGINAL SOURCE'//);
               4                  NINCSRC=nshist;
               4                  OLDSRC=1;
               4                  ]
               3              OUTPUT61 nshist,nphist,ein,temp(2),NINCSRC;
               3              (/' Total number of particles in file      :',I13/
               3              ' Total number of photons                :',I13/
               3              ' The rest are electrons/positrons.'/ ' '/
               3              ' Maximum kinetic energy of the particles:     ',F13.3,' MeV'/
               3              ' Minimum kinetic energy of the electrons:     ',F13.3,' MeV'/
               3              ' # of particles incident from original source:',F13.1);
               3
               3              "now read 2nd record, if nhistm gets incremented, then we have a"
               3              "phsp file that stores nhist"
               3              nhistm=0;
               3              $READ_PHSP_RECORD(ismode,44,2:
               3              nhistm,zlastm,latchm,einm,wtm,xinm,yinm,uinm,vinm);
               3              IF(nhistm~=1)[
               4                  dose_stat=1;
               4                  OUTPUT;(//' ***WARNING***'/
               4                  ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
               4                  ' Dose and fluence will be analyzed assuming each particle read from'/
               4                  ' the ph-sp file is an independent history.  May result in an'/
               4                  ' underestimate of uncertainties.'//);
               4                  ]
               3              ]"end of standard BEAMnrc-format phsp source"
               2          ]
               1      ELSEIF(isource =9 | isource=10 )["full BEAM sim."
               2          "read in name of simulation, input file, pegs4 file"
               2          OUTPUT;
               2          (' Input name of beam code (BEAM_accelname), input file (no ext.), '/
               2          ' pegs data (no ext.) (A256)'/'  : ',$);
               2          READ(5,'(A)',ERR=:ERR_SOURCE9:) FILNAM;
               2          OUTPUT $cstring(FILNAM);(A);
               2          "now parse FILNAM for the inputs"
               2
               2          the_beam_code=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_beam_code,' ')=1) [
               3              ilen = lnblnk1(the_beam_code) - 1;
               3              IF(ilen>=2)[
               4                  the_beam_code=the_beam_code(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_beam_code=the_beam_code(:lnblnk1(the_beam_code));
               2
               2          the_input_file=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_input_file,' ')=1) [
               3              ilen = lnblnk1(the_input_file) - 1;
               3              IF(ilen>=2) [
               4                  the_input_file=the_input_file(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_input_file=the_input_file(:lnblnk1(the_input_file));
               2
               2          the_pegs_file=FILNAM(:lnblnk1(FILNAM));
               2          "strip leading blanks"
               2          WHILE(INDEX(the_pegs_file,' ')=1) [
               3              ilen = lnblnk1(the_pegs_file) - 1;
               3              IF(ilen>=2) [
               4                  the_pegs_file=the_pegs_file(2:);
               4                  ]
               3              ELSE [
               4                  "blank input"
               4                  the_pegs_file='pegsless';
               4                  EXIT;
               4                  ]
               3              ]
               2
               2          OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
               2          $cstring(the_pegs_file);
               2          (/' BEAM simulation name: ',A/
               2          '           input file: ',A/
               2          '   pegs data for BEAM: ',A/);
               2          ]
               1      ELSEIF(isource = 20)["Phase Space Incident from multiple settings"
               2          "and through an MLC or BEAM Accel."
               2          "read in name of MLC/BEAM code, input file"
               2          OUTPUT;
               2          (' Name of BEAM/MLC code (e.g. particelDmlc)--leave blank if no geometry, '/
               2          ' phase space file above shared library, '/
               2          ' input file for BEAM/MLC code (A256), '/'  : ',$);
               2          READ(5,'(A)',ERR=:ERR_SOURCE20:) FILNAM;
               2          OUTPUT $cstring(FILNAM);(A);
               2          "now parse FILNAM for the input"
               2
               2          the_shared_lib=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_shared_lib,' ')=1) [
               3              ilen = lnblnk1(the_shared_lib) - 1;
               3              IF(ilen>=2)[
               4                  the_shared_lib=the_shared_lib(2:);
               4                  ]
               3              ELSE [
               4                  "blank input"
               4                  the_shared_lib='0';
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_shared_lib=the_shared_lib(:lnblnk1(the_shared_lib));
               2
               2          the_phsp_file=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_phsp_file,' ')=1) [
               3              ilen = lnblnk1(the_phsp_file) - 1;
               3              IF(ilen >=2) [
               4                  the_phsp_file=the_phsp_file(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_phsp_file=the_phsp_file(:lnblnk1(the_phsp_file));
               2
               2          OUTPUT $cstring(the_phsp_file);
               2          (/'phase space file: ',A/);
               2
               2          OUTPUT61 the_phsp_file;(/' Particles will be read from file: ',/A);
               2
               2          call replace_env(the_phsp_file);
               2
               2          i_iaea_in=0; "assume not in IAEA format"
               2          dosxyz2beam_izscore=0; "assume not scoring Z for each particle"
               2          ilen=lnblnk1(the_phsp_file);
               2          IF(the_phsp_file(ilen-8:ilen)='.IAEAphsp')[
               3              i_iaea_in=1;
               3              the_phsp_file=the_phsp_file(:ilen-9);
               3              ]
               2
               2          IF(i_iaea_in=1)[
               3              i_unit_in=44;
               3              $IAEA_OPEN_PHSP_FOR_READ(i_unit_in,the_phsp_file);
               3              $IAEA_READ_PHSP_HEADER(i_unit_in,nshist,nphist,ein,NINCSRC,
               3              Z_SOURCE,ismode,i_mu_phsp,izscore);
               3              OUTPUT nshist,nphist,ein,NINCSRC;
               3              (T10,' IAEA format Phase space source with:'/
               3              T5,'                    Total number of particles =',I13/
               3              T5,'                            Number of photons =',I13/
               3              T5,'              Maximum particle kinetic energy =',F13.3,' MeV'/
               3              T5,' # of particles incident from original source =',F13.3/);
               3              IF(izscore=0)[
               4                  OUTPUT Z_SOURCE;
               4                  (T5,'                        Z where source scored =',F13.3,' cm'/);
               4                  ]
               3              IF(i_mu_phsp=1)[
               4                  OUTPUT;(T5,' Fractional MU index stored in phase space data.'/
               4                  T5,' This will be used to set the MU index in the DOSXYZ'/
               4                  T5,' simulation.'/);
               4                  ]
               3              $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(i_unit_in);
               3              dosxyz2beam_izscore=izscore;"this will be passed to BEAM if using"
               3              "an intervening BEAM geometry"
               3              ]
               2          ELSE[
               3              $OPEN_PHSP_FOR_READ(ismode,44,the_phsp_file,MODE,nshist,nphist,ein,temp(2),
               3              NINCSRC);
               3              IF(NINCSRC<2.)["old file with min phot. energy"
               4                  OUTPUT61;(//' ******WARNING*****'/
               4                  ' PHASE SPACE SOURCE WAS GENERATED USING AN OLDER'/
               4                  ' VERSION OF BEAM IN WHICH # OF PARTICLES INCIDENT FROM'/
               4                  ' ORIGINAL SOURCE WAS NOT STORED.  THIS NUMBER WILL'/
               4                  ' BE SET EQUAL TO THE NUMBER OF PARTICLES IN THE PHASE'/
               4                  ' SPACE SOURCE, AND DOSE WILL BE NORMALIZED'/
               4                  ' WITH RESPECT TO THE # OF HISTORIES RUN...NOT'/
               4                  ' THE # OF INCIDENT PARTICLES FROM THE ORIGINAL SOURCE'//);
               4                  NINCSRC=nshist;
               4                  OLDSRC=1;
               4                  ]
               3              OUTPUT61 nshist,nphist,ein,temp(2),NINCSRC;
               3              (/' Total number of particles in file      :',I13/
               3              ' Total number of photons                :',I13/
               3              ' The rest are electrons/positrons.'/ ' '/
               3              ' Maximum kinetic energy of the particles:     ',F13.3,' MeV'/
               3              ' Minimum kinetic energy of the electrons:     ',F13.3,' MeV'/
               3              ' # of particles incident from original source:',F13.1);
               3
               3              "now read 2nd record, if nhistm gets incremented, then we have a"
               3              "phsp file that stores nhist"
               3              nhistm=0;
               3              $READ_PHSP_RECORD(ismode,44,2:
               3              nhistm,zlastm,latchm,einm,wtm,xinm,yinm,uinm,vinm);
               3              IF(nhistm~=1)[
               4                  dose_stat=1;
               4                  OUTPUT;(//' ***WARNING***'/
               4                  ' Cannot read no. of primary (non-phsp) histories from ph-sp source.'/
               4                  ' Dose and fluence will be analyzed assuming each particle read from'/
               4                  ' the ph-sp file is an independent history.  May result in an'/
               4                  ' underestimate of uncertainties.'//);
               4                  ] "end of standard BEAMnrc-format phsp source"
               3              ]
               2          the_input_file=FILNAM(:lnblnk1(FILNAM));
               2          "strip leading blanks"
               2          WHILE(INDEX(the_input_file,' ')=1) [
               3              ilen = lnblnk1(the_input_file) - 1;
               3              IF(ilen>=2) [
               4                  the_input_file=the_input_file(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_input_file=the_input_file(:lnblnk1(the_input_file));
               2
               2          IF(the_shared_lib='0')[
               3              "no shared library
               3              SHLflag = 0;
               3              ]
               2          ELSEIF(the_shared_lib='particleDmlc') [
               3              "particles must go through MLC code compiled as a shared library
               3              MLCflag =1;
               3              SHLflag = 1;
               3              OUTPUT61; (/' Will use VCU simulation compiled as shared library:'/);
               3              OUTPUT61 the_input_file;(/' VCU input file: ',/A80);
               3              ]
               2          ELSE[
               3              "particles must go through BEAM shared library
               3              SHLflag =1;
               3              MLCflag=0;
               3              IF(is_pegsless) [ the_pegs_file='pegsless';]
               3              ELSE [ the_pegs_file= pegs_file; ]
               3              OUTPUT61 the_shared_lib;(/' BEAM library: ',/A80);
               3              OUTPUT61 the_input_file;(' BEAM input file: ',/A80);
               3              OUTPUT61 the_pegs_file;(' BEAM pegs data: ',/A80);
               3              ]
               2          ]
               1      ELSEIF(isource=21)["Full BEAM sim.incident from multiple settings"
               2          "and through an MLC"
               2          "read in name of BEAM simulation, input file, pegs4 file"
               2          OUTPUT;
               2          (' Input name of beam code (BEAM_accelname), BEAM input file (no ext.), '/
               2          ' BEAM pegs data (no ext.), name of MLC code (e.g. particelDmlc), '/
               2          ' MLC code input file (A256)'/'  : ',$);
               2          READ(5,'(A)',ERR=:ERR_SOURCE21:) FILNAM;
               2          OUTPUT $cstring(FILNAM);(A);
               2          "now parse FILNAM for the inputs"
               2
               2          the_beam_code=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_beam_code,' ')=1) [
               3              ilen = lnblnk1(the_beam_code) - 1;
               3              IF(ilen>=2)[
               4                  the_beam_code=the_beam_code(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_beam_code=the_beam_code(:lnblnk1(the_beam_code));
               2
               2          the_input_file=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_input_file,' ')=1) [
               3              ilen = lnblnk1(the_input_file) - 1;
               3              IF(ilen>=2) [
               4                  the_input_file=the_input_file(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_input_file=the_input_file(:lnblnk1(the_input_file));
               2
               2
               2          the_pegs_file=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_pegs_file,' ')=1) [
               3              ilen = lnblnk1(the_pegs_file) - 1;
               3              IF(ilen>=2) [
               4                  the_pegs_file=the_pegs_file(2:);
               4                  ]
               3              ELSE [
               4                  "blank input"
               4                  the_pegs_file='pegsless';
               4                  EXIT;
               4                  ]
               3              ]
               2
               2          the_pegs_file = the_pegs_file(:lnblnk1(the_pegs_file));
               2
               2          the_vcu_code=FILNAM(:INDEX(FILNAM,',')-1);
               2          FILNAM=FILNAM(INDEX(FILNAM,',')+1:);
               2          "strip leading blanks"
               2          WHILE(INDEX(the_vcu_code,' ')=1) [
               3              ilen = lnblnk1(the_vcu_code) - 1;
               3              IF(ilen>=2)[
               4                  the_vcu_code=the_vcu_code(2:);
               4                  ]
               3              ELSE [
               4                  "blank input"
               4                  the_vcu_code='0';
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_vcu_code=the_vcu_code(:lnblnk1(the_vcu_code));
               2
               2          IF(the_vcu_code='0')[
               3              "no MLC
               3              MLCflag = 0;
               3              ]
               2          ELSE[
               3              "particles must go through MLC code compiled as a shared library
               3              MLCflag = 1;
               3              ]
               2
               2          the_vcu_input_file=FILNAM(:lnblnk1(FILNAM));
               2          "strip leading blanks"
               2          WHILE(INDEX(the_vcu_input_file,' ')=1) [
               3              ilen = lnblnk1(the_vcu_input_file) - 1;
               3              IF(ilen>=2) [
               4                  the_vcu_input_file=the_vcu_input_file(2:);
               4                  ]
               3              ELSE [
               4                  EXIT;
               4                  ]
               3              ]
               2          "strip trailing blanks"
               2          the_vcu_input_file=the_vcu_input_file(:lnblnk1(the_vcu_input_file));
               2
               2
               2          OUTPUT $cstring(the_beam_code),$cstring(the_input_file),
               2          $cstring(the_pegs_file),$cstring(the_vcu_code),
               2          $cstring(the_vcu_input_file);
               2          (/' BEAM simulation name: ',A/
               2          '           input file: ',A/
               2          '   pegs data for BEAM: ',A/
               2          '  VCU simulation name: ',A/
               2          '       vcu input file: ',A/);
               2          ]
               1      IF( enflag = 3) ["Now do some bit checks on the phases space input"
               2          OUTPUT61;
               2          (/' I_BIT_FILTER(0-incl/excl bits,1-excl bits,2-incl regions,3-excl regions),'/
               2          ' NBIT1(# bits/regions to incl [I_BIT_FILTER=0 or 2] '/
               2          '                      or excl [I_BIT_FILTER=1 or 3],'/
               2          ' NBIT2(# bits to excl [I_BIT_FILTER=0 only])--all on one line'/
               2          ' :',$);
               2          INPUT I_BIT_FILTER,NBIT1,NBIT2; (3i5);
               2          OUTPUT61 I_BIT_FILTER,NBIT1,NBIT2; (3i5);
               2          IF(I_BIT_FILTER<0 | I_BIT_FILTER > 3)["default to no checking"
               3              OUTPUT;(//' ***ERROR: I_BIT_FILTER out of range.'//);
               3              STOP;
               3              ]
               2          IF(I_BIT_FILTER~=0 & NBIT2 ~= 0)[
               3              OUTPUT61;(//' ***WARNING: NBIT2 is not 0 and you are using'/
               3              ' I_BIT_FILTER=1, 2 or 3.  NBIT2 set to 0 here.'//);
               3              NBIT2=0;
               3              ]
               2          IF (NBIT1<0)[
               3              OUTPUT61;(//' ***ERROR: NBIT1 < 0'//);
               3              STOP;
               3              ]
               2          IF(NBIT2<0)[
               3              OUTPUT61;(//' ***ERROR: NBIT2 < 0'//);
               3              STOP;
               3              ]
               2
               2          IF (I_BIT_FILTER < 2 & (NBIT1+NBIT2<0|NBIT1+NBIT2>29))[
               3              OUTPUT61;(//' ***ERROR: '/
               3              ' Total # of bits must be >= 0 and <= 29'//);
               3              STOP;
               3              ]
               2          ELSEIF(NBIT1<0|NBIT1>24)[
               3              OUTPUT61;(//' ***ERROR: '/
               3              ' Total # of regions must be >= 0 and <= 23'//);
               3              STOP;
               3              ]
               2          IF(NBIT1 ~= 0)[
               3              IF(I_BIT_FILTER=0|I_BIT_FILTER=2)[
               4                  OUTPUT61;
               4                  (/' BIT(I)/IREGION_TO_BIT(I) (I=1,NBIT1) to include:'/' ',$);
               4                  ]
               3              IF(I_BIT_FILTER=1|I_BIT_FILTER=3)[
               4                  OUTPUT61;
               4                  (/' BIT(I)/IREGION_TO_BIT(I) (I=1,Nbit1) to exclude:'/' ',$);
               4                  ]
               3              INPUT (LATBIT(i),i=1,NBIT1); (30i5);
               3              OUTPUT61 (LATBIT(i),i=1,NBIT1); (30i5);
               3              DO i=1,NBIT1[
               4                  IF (I_BIT_FILTER < 2 & (LATBIT(i)<0|LATBIT(i)>28))[
               5                      OUTPUT;(//' ***ERROR:'/
               5                      ' BIT(I) must be >= 0 and <= 28'//);
               5                      STOP;
               5                      ]
               4                  ELSEIF(LATBIT(I)<0|LATBIT(I)>23)[
               5                      OUTPUT;(//' ***ERROR:'/
               5                      ' IREGION_TO_BIT(I) must be >=0 and <= 23'//);
               5                      STOP;
               5                      ]
               4                  ]
               3              ]
               2          IF(NBIT2 ~= 0)[
               3              OUTPUT61;
               3              (/' BIT(I)/IREGION_TO_BIT(I) (I=NBIT1+1,NBIT1+NBIT2) to exclude:'/' ',$);
               3              INPUT (LATBIT(NBIT1+i),i=1,NBIT2); (30i5);
               3              OUTPUT61 (LATBIT(NBIT1+i),i=1,NBIT2); (30i5);
               3              DO i=1,NBIT2[
               4                  IF (LATBIT(NBIT1+i)<0 | LATBIT(NBIT1+i)>28)[
               5                      OUTPUT;(//' ***ERROR:'/
               5                      ' BIT(I) must be  >= 0 and <= 28'//);
               5                      STOP;
               5                      ]
               4                  ]
               3              ]
               2          ]" end of block for just enflag=3"
               1      ] "end of (enflag = 2 or 3) block"
               0
               0  "----------------------------------------------------------------"
               0  ELSEIF(isource = 4)[ ;$BEAMMODEL-ENFLAG4-INPUT; ]
               0  "----------------------------------------------------------------"
               0  ELSE[OUTPUT;('In srcxyznrc:  error on input, ENFLAG inconsistent ');
               1      STOP;]
               0  "----------------------------------------------------------------"
               0
               0  return;  "normal return
               0
               0  :ERR_SOURCE1: "Error on reading spectrum file name, stop and print message"
               0  ;OUTPUT61;(//' *** error on reading spectrum file name ***');
               0  STOP;
               0
               0  :ERR_SOURCE2: "Error on reading file name, stop and print message"
               0  ;OUTPUT61;(//' *** error on reading file name ***');
               0  STOP; "End of input file return"
               0
               0  :ERR_SOURCE3: "error on opening file, stop and print message"
               0  ;OUTPUT61;(//' *** Error on opening file ***'//
               0  ' *** Please check whether this is a MODE0 file or '/
               0  ' *** it is in the right directory, and try again!'//);
               0  STOP; "End of input file return"
               0
               0  :ERR_SOURCE9: "error on reading accelerator, input file, pegs data names"
               0  ;OUTPUT61;(//' *** error on reading accelerator, input file, pegs data***');
               0  STOP;
               0
               0  :ERR_SOURCE20: "error on reading VCU sim., input file names
               0  ;OUTPUT61;(//' *** error on reading VCU sim., input file names ***');
               0  STOP;
               0
               0  :ERR_SOURCE21:"error on reading accelerator, input file, pegs data names"
               0  ;OUTPUT61;(//' *** error on reading accelerator, input file, pegs data***'//
               0  ' (MLC code, MLC input file if selected) '//);
               0  STOP;
               0
               0
               0  end; "End of subroutine srcinput
1              0  %E "srcxyznrc.mortran start of subroutine srcinit "
               0  "**************************************************************************"
               0  "
               0  subroutine srcinit(weight);
               0  "
               0  "This subroutine calculates 'one time only constants' that do not change
               0  "for a given source configuration
               0  "
               0  "**************************************************************************"
               0  implicit none;
               0  ;COMIN/GEOM,PHSPFILE,SOURCE,EGS-IO,RWPHSP/;
               0
               0  $REAL weight,
               0  costheta,sintheta,
               0  coscol,sincol,
               0  cosphi,sinphi;
               0  $INTEGER i;
               0
               0  OUTPUT61;(' ');
               0
               0  "------------------------------------------------------------------------"
               0  IF(isource = 0)[   "Frontal parallel beam source"
               1      "------------------------------------------------------------------------"
               1      "Calculate the x-direction input zones
               1      IF(xinl < xbound(1))[xinl = xbound(1);]
               1      IF(xinu <= xinl)[ xinu = xinl;] "Default a pencil beam
               1      "Check not too big
               1      IF( xinu > xbound(imax+1) ) [xinu=xbound(imax+1);]
               1      IF( xinl > xbound(imax+1) ) [xinl=xbound(imax+1);]
               1      "Now search for initial region x index range
               1      OUTPUT61; (/' Index ranges of beam field'/
               1      ' --------------------------'/);
               1      ixinl=0;
               1      LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
               1      ixinu=ixinl-1;
               1      LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
               1      OUTPUT61 xinl,xinu;(' ',2f10.3,$);
               1      OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);
               1
               1      "Calculate the y-direction input zones
               1      IF(yinl < ybound(1)) [yinl = ybound(1);]
               1      IF(yinu <= yinl)[ yinu = yinl; "Default a pencil beam"]
               1      "Check not too big
               1      IF( yinu > ybound(jmax+1)) [yinu=ybound(jmax+1);]
               1      IF( yinl > ybound(jmax+1)) [yinl=ybound(jmax+1);]
               1      "Now search for initial region y index range
               1      jyinl=0;
               1      LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
               1      jyinu=jyinl-1;
               1      LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
               1      OUTPUT61 yinl,yinu;(' ',2f10.3,$);
               1      OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);
               1
               1      "Calculate the incident direction cosines
               1      winc = cos(thetaz*3.141593/180.);
               1      uinc = cos(thetax*3.141593/180.);
               1      vinc = cos(thetay*3.141593/180.);
               1
               1      IF(thetaz > 90. | thetaz < -90.)[
               2          OUTPUT;(//' ***ERROR in source 0'/
               2          ' thetaz set so that source is not incident on front of'/
               2          ' phantom.  Check incident angles and try again.'//);
               2          STOP;
               2          ]
               1      ELSEIF(thetax > 180. | thetax < 0.)[
               2          OUTPUT;(//' ***ERROR in source 0'/
               2          ' thetax set so that source is not incident on front of'/
               2          ' phantom.  Check incident angles and try again.'//);
               2          STOP;
               2          ]
               1      ELSEIF(thetay > 180. | thetay < 0.)[
               2          OUTPUT;(//' ***ERROR in source 0'/
               2          ' thetay set so that source is not incident on front of'/
               2          ' phantom.  Check incident angles and try again.'//);
               2          STOP;
               2          ]
               1
               1      IF(uinc*uinc+vinc*vinc+winc*winc>1.001 |
               1      uinc*uinc+vinc*vinc+winc*winc<0.009)[
               2          OUTPUT;(//' ***ERROR in source 0'/
               2          ' Sum of squares of incident direction cosines must be 1.'/
               2          ' Check angles and try again.'//);
               2          STOP;
               2          ]
               1      ELSE["close enough"
               2          winc=SQRT(1-uinc*uinc-vinc*vinc);
               2          thetaz = acos(winc)*180./3.141593;
               2          ]
               1      OUTPUT61;(/' Angle of beam to'/
               1      '  axes(in deg, 90,90,0 is normal): ',$);
               1      OUTPUT61 thetax,thetay,thetaz;(' ',3f10.2,' deg');
               1
               1      "The remaining one-time constants
               1      beamarea = (xinu - xinl)*(yinu - yinl);
               1      zinc   = zbound(1);
               1      weight = 1.0; "Incident weight
               1      return;
               1      ]"end of (isource = 0) block"
               0
               0  "------------------------------------------------------------------------"
               0  IF(isource = 1 | isource=7) [ "Parallel beam directed in any direction"
               1      "or from side at user-selected angles"
               1      "------------------------------------------------------------------------"
               1      "Distance to the centre of the source plane
               1      "Pick a reasonable distance from the isocenter so that the
               1      "beam is guaranteed to come from the outside.
               1      "This is the maximum of the distance to and vertex of the irradiation
               1      "volume from the isocenter plus an allowance for the collimator size.
               1      dsource= max(
               1      (xiso-xbound(1     ))**2+(yiso-ybound(1     ))**2+(ziso-zbound(1     ))**2,
               1      (xiso-xbound(imax+1))**2+(yiso-ybound(1     ))**2+(ziso-zbound(1     ))**2,
               1      (xiso-xbound(1     ))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(1     ))**2,
               1      (xiso-xbound(1     ))**2+(yiso-ybound(1     ))**2+(ziso-zbound(kmax+1))**2,
               1      (xiso-xbound(imax+1))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(1     ))**2,
               1      (xiso-xbound(imax+1))**2+(yiso-ybound(1     ))**2+(ziso-zbound(kmax+1))**2,
               1      (xiso-xbound(1     ))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(kmax+1))**2,
               1      (xiso-xbound(imax+1))**2+(yiso-ybound(jmax+1))**2+(ziso-zbound(kmax+1))**2);
               1      dsource = -sqrt(dsource + xcol**2+ ycol**2); "- sign is our convention
               1      beamarea = xcol*ycol;
               1      ]
               0
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 2 | isource=8)["Full phase-space source"
               1      "------------------------------------------------------------------------"
               1      dsource = -dsource;
               1      esrc = 0; "initialize counter"
               1      OUTCNT = 0; "initialize no. of times phsp file restarts during this run"
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 3 )[   "Frontal point source"
               1      "------------------------------------------------------------------------"
               1      "Calculate the x-direction input zones
               1      IF(xinl < xbound(1))[xinl = xbound(1);]
               1      IF(xinu <= xinl)[ xinu = xinl;] "Default a pencil beam
               1      "Check not too big
               1      IF( xinu > xbound(imax+1) ) [xinu=xbound(imax+1);]
               1      IF( xinl > xbound(imax+1) ) [xinl=xbound(imax+1);]
               1      "Now search for initial region x index range
               1      OUTPUT61; (/' Index ranges of beam field'/
               1      ' --------------------------'/);
               1      ixinl=0;
               1      LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
               1      ixinu=ixinl-1;
               1      LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
               1      OUTPUT61 xinl,xinu;(' ',2f10.3,$);
               1      OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);
               1      "Calculate the y-direction input zones
               1      IF(yinl < ybound(1)) [yinl = ybound(1);]
               1      IF(yinu <= yinl)[ yinu = yinl; "Default a pencil beam"]
               1      "Check not too big
               1      IF( yinu > ybound(jmax+1)) [yinu=ybound(jmax+1);]
               1      IF( yinl > ybound(jmax+1)) [yinl=ybound(jmax+1);]
               1      "Now search for initial region y index range
               1      jyinl=0;
               1      LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
               1      jyinu=jyinl-1;
               1      LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
               1      OUTPUT61 yinl,yinu;(' ',2f10.3,$);
               1      OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);
               1
               1      "The remaining one-time constants
               1      beamarea = (xinu - xinl)*(yinu - yinl);
               1      zinc   = zbound(1);
               1      weight = 1.0; "Incident weight
               1      return;
               1      ]"end of (isource = 3 ) block"
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 6 )[   "Isotropically radiation source"
               1      "------------------------------------------------------------------------"
               1      "make sure source is within volume"
               1      IF(xinl<xbound(1))[
               2          IF(xinu < xbound(1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' xinl & xinu < xbound(1) of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              xinl= xbound(1);
               3              OUTPUT61 xinl;(//' ***WARNING in source 6:'/
               3              ' xinl < xbound(1)'/
               3              ' xinl reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      IF(xinu > xbound(imax+1))[
               2          IF(xinl > xbound(imax+1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' xinl & xinu > max xbound of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              xinu=xbound(imax+1);
               3              OUTPUT61 xinu;(//' ***WARNING in source 6:'/
               3              ' xinu > max xbound of geometry'/
               3              ' xinu reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      IF(yinl<ybound(1))[
               2          IF(yinu < ybound(1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' yinl & yinu < ybound(1) of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              yinl= ybound(1);
               3              OUTPUT61 yinl;(//' ***WARNING in source 6:'/
               3              ' yinl < ybound(1)'/
               3              ' yinl reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      IF(yinu > ybound(jmax+1))[
               2          IF(yinl > ybound(jmax+1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' yinl & yinu > max ybound of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              yinu=ybound(jmax+1);
               3              OUTPUT61 yinu;(//' ***WARNING in source 6:'/
               3              ' yinu > max ybound of geometry'/
               3              ' yinu reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      IF(zinl<zbound(1))[
               2          IF(zinu < zbound(1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' zinl & zinu < zbound(1) of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              zinl= zbound(1);
               3              OUTPUT61 zinl;(//' ***WARNING in source 6:'/
               3              ' zinl < zbound(1)'/
               3              ' zinl reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      IF(zinu > zbound(kmax+1))[
               2          IF(zinl > zbound(kmax+1))[
               3              OUTPUT;(//' ***ERROR in source 6:'/
               3              ' zinl & zinu > max zbound of volume'//);
               3              STOP;
               3              ]
               2          ELSE[
               3              zinu=zbound(kmax+1);
               3              OUTPUT61 zinu;(//' ***WARNING in source 6:'/
               3              ' zinu > max zbound of geometry'/
               3              ' zinu reset to',F10.4,' cm'//);
               3              ]
               2          ]
               1      "Now search for initial region x index range
               1      OUTPUT61; (/' Index ranges of source volume'/
               1      ' -----------------------------'/);
               1      ixinl=0;
               1      LOOP[ixinl=ixinl+1;]UNTIL(xbound(ixinl) <= xinl & xbound(ixinl+1) >  xinl);
               1      ixinu=ixinl-1;
               1      LOOP[ixinu=ixinu+1;]UNTIL(xbound(ixinu) <= xinu & xbound(ixinu+1) >= xinu);
               1      OUTPUT61 xinl,xinu;(' ',2f10.3,$);
               1      OUTPUT61 ixinl,ixinu;('   i index ranges over i=',i3,' to',i4);
               1      "Now search for initial region y index range
               1      jyinl=0;
               1      LOOP[jyinl=jyinl+1;]UNTIL(ybound(jyinl) <= yinl & ybound(jyinl+1) >  yinl);
               1      jyinu=jyinl-1;
               1      LOOP[jyinu=jyinu+1;]UNTIL(ybound(jyinu) <= yinu & ybound(jyinu+1) >= yinu);
               1      OUTPUT61 yinl,yinu;(' ',2f10.3,$);
               1      OUTPUT61 jyinl,jyinu;('   j index ranges over j=',i3,' to',i4);
               1      "Now search for initial region z index range
               1      kzinl=0;
               1      LOOP[kzinl=kzinl+1;]UNTIL(zbound(kzinl) <= zinl & zbound(kzinl+1) >  zinl);
               1      kzinu=kzinl-1;
               1      LOOP[kzinu=kzinu+1;]UNTIL(zbound(kzinu) <= zinu & zbound(kzinu+1) >= zinu);
               1      OUTPUT61 zinl,zinu;(' ',2f10.3,$);
               1      OUTPUT61 kzinl,kzinu;('   k index ranges over k=',i3,' to',i4);
               1
               1      weight=1.0;
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 9 | isource=10)["Full BEAM treatment head simulation"
               1      "------------------------------------------------------------------------"
               1      dsource = -dsource;
               1      OUTPUT 'About to call init_beamsource';(//a);
               1      call init_beamsource(i_parallel,n_parallel,i_log,$CONFIGURATION_NAME,
               1      hen_house,egs_home,the_beam_code,
               1      the_pegs_file,the_input_file);
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 20)["Phase Space Incident from multiple settings and "
               1      "optionally through an MLC"
               1      "------------------------------------------------------------------------"
               1      dsource = -dsource;
               1      IF(SHLflag = 1)[
               2          survival_ratio = 1; "initialize survivival ratio to 1 so that only"
               2          "dosxyz performs the calibration run. If it was set to 0 then VCU code"
               2          "would do this but it cannot read IAEA phsps"
               2          IF(MLCflag = 1)[
               3              OUTPUT 'About to initialise MLC code and run calibration...';(//a);
               3              call init_vcusource(survival_ratio,$CONFIGURATION_NAME,hen_house,
               3              egs_home,the_shared_lib,the_input_file);
               3              ]
               2          ELSE[
               3              OUTPUT 'About to initialise BEAM code..';(//a);
               3              call init_beamsource(i_parallel,n_parallel,i_log,$CONFIGURATION_NAME,
               3              hen_house,egs_home,the_shared_lib,
               3              the_pegs_file,the_input_file);
               3              ]
               2
               2          IF(calflag = 0)[
               3              call calibration_run(survival_ratio);
               3              OUTPUT61 survival_ratio;
               3              ('Survival Ratio is: ', F12.10);
               3              ]
               2          ELSE[
               3              survival_ratio = 1;  "We skipped the calibration run"
               3              OUTPUT61;
               3              (/'Calibration run skipped!'/);
               3              ]
               2          ]
               1      ELSE[
               2          OUTPUT61;
               2          (/'No shared library'/);
               2          survival_ratio = 1;
               2
               2          ]
               1      esrc = 0; "initialize counter"
               1      OUTCNT = 0; "initialize no. of times phsp file restarts during this run"
               1      ]
               0  "------------------------------------------------------------------------"
               0  ELSEIF(isource = 21)["Full BEAM sim. incident from multiple settings and "
               1      "optionally through an MLC"
               1      "------------------------------------------------------------------------"
               1      dsource = -dsource;
               1      OUTPUT 'About to call init_beamsource';(//a);
               1      call init_beamsource(i_parallel,n_parallel,i_log,$CONFIGURATION_NAME,
               1      hen_house,egs_home,the_beam_code,
               1      the_pegs_file,the_input_file);
               1      OUTPUT 'Done initialization';(//a);
               1      survival_ratio = 1; "set to 1 to let vcu code know
               1      "not to run calibration run or if not using MLC
               1      "to set survival_ratio to 1
               1      IF(MLCflag = 1)
               1      [
               2          OUTPUT 'About to initialise MLC code...';(//a);
               2          call init_vcusource(survival_ratio,$CONFIGURATION_NAME,hen_house,
               2          egs_home,the_vcu_code,the_vcu_input_file);
               2          ]
               1      ELSE[
               2          OUTPUT61;
               2          (/'No external library MLC'/);
               2          ]
               1      ]
               0  "------------------------------------------------------------------------"
               0  IF(isource >3 & isource <7)[   dsource=-dsource; ]
               0  "------------------------------------------------------------------------"
               0  IF(isource ~= 20 & isource ~= 21)["four 20 and 21 the matrices are calculated"
               1      "on the fly -per particle"
               1      "Collimator/source rotation sine's and cosine's needed locally
               1      costheta = cos(theta(1)*3.141593/180.); sintheta = sin(theta(1)*3.141593/180.);
               1      coscol   = cos(phicol*3.141593/180.); sincol   = sin(phicol*3.141593/180.);
               1      cosphi   = cos(phi(1)*3.141593/180.); sinphi   = sin(phi(1)*3.141593/180.);
               1
               1      "Rotation matrix needed during sampling routine
               1      r_11(1) =  costheta*cosphi*coscol + sinphi*sincol;
               1      r_12(1) = -costheta*cosphi*sincol + sinphi*coscol;
               1      r_13(1) = -sintheta*cosphi                       ;
               1      r_21(1) =  costheta*sinphi*coscol - cosphi*sincol;
               1      r_22(1) = -costheta*sinphi*sincol - cosphi*coscol;
               1      r_23(1) = -sintheta*sinphi                       ;
               1      r_31(1) = -sintheta*coscol                       ;
               1      r_32(1) =  sintheta*sincol                       ;
               1      r_33(1) = -costheta                              ;
               1      ]
               0  IF(isource=7 | isource=8 | isource=10)[
               1      "calculate the rest of the rotation matrices"
               1      DO I=2,numang[
               2          costheta = cos(theta(I)*3.141593/180.);
               2          sintheta = sin(theta(I)*3.141593/180.);
               2          cosphi = cos(phi(I)*3.141593/180.);
               2          sinphi= sin(phi(I)*3.141593/180.);
               2          r_11(I) =  costheta*cosphi*coscol + sinphi*sincol;
               2          r_12(I) = -costheta*cosphi*sincol + sinphi*coscol;
               2          r_13(I) = -sintheta*cosphi                       ;
               2          r_21(I) =  costheta*sinphi*coscol - cosphi*sincol;
               2          r_22(I) = -costheta*sinphi*sincol - cosphi*coscol;
               2          r_23(I) = -sintheta*sinphi                       ;
               2          r_31(I) = -sintheta*coscol                       ;
               2          r_32(I) =  sintheta*sincol                       ;
               2          r_33(I) = -costheta                              ;
               2          ]
               1      ]
               0
               0
               0  "Constant factors employed in the search for irin
               0  "This is done for efficiency, not understandability
               0  "These constant factors are derived from the mapping of i,j,k
               0  "to ir keeping ine if the surfaces constant
               0  klowx        = 2 - imax - ijmax;
               0  /khix,klowy/ = 1 - ijmax;
               0  /khiy,klowz/ = 1 - imax;
               0  khiz         = 1 - imax - ijmax + ijmax*kmax;
               0
               0  weight = 1.0; "Incident weight
               0
               0  return;
               0  end; "End of subroutine srcinit
               0
1              0  %E "srcxyznrc.mortran start of subroutine beam_calibration_run (JL & TP)"
               0  "**************************************************************************"
               0  "
               0  subroutine calibration_run(s_ratio);
               0  "
               0  "This subroutine describes the source configuration to the output files
               0  "
               0  "**************************************************************************"
               0  implicit none;
               0
               0  $REAL xsrc,ysrc,zlast,
               0  usrc,vsrc,wsrc,
               0  zsrc,weight,rncal,
               0  dist_dbs, mu_phsp;
               0  real*4 s_ratio, total_survived;
               0  $LONG_INT nhistdum;
               0  $INTEGER npassdum,latchinp,num_hist,num2run,num_dbsrj,num_blocked;
               0  ;COMIN/SOURCE,RWPHSP,RANDOM,EGS-IO/;
               0
               0  OUTPUT 'Performing BEAM calibration run...';(//a);
               0
               0  IF(nshist>1000000)[
               1      num2run=1000000;
               1      ] ELSE [ num2run = nshist;]
               0
               0  OUTPUT61 num2run;
               0  ('Running ',i8, ' particles to calibrate BEAM accelerator...'/);
               0
               0  num_hist=1;
               0  num_dbsrj=0;
               0  total_survived=0.0;
               0  more_in_cont=0;
               0  LOOP[
               1      IF(more_in_cont = 0)[
               2          :retry_read_phsp_calib:;
               2          num_hist=num_hist+1;
               2          IF(i_iaea_in=1)[
               3              $IAEA_READ_PHSP_RECORD(i_unit_in,npassdum,nhistdum,latchinp,iqin,
               3              einsrc,weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
               3              mu_phsp);
               3              ]  ELSE [
               3              $READ_PHSP(ismode,44,num_hist:nhistdum,npassdum,iqin,wsrc,zlast,
               3              latchinp,einsrc,weight,xsrc,ysrc,usrc,vsrc);
               3              ]
               2          IF(i_dbs=1 & iqin=0)["reject fat photons"
               3              IF(i_iaea_in=1)[
               4                  dist_dbs=(ssd_dbs-zsrc)/wsrc;
               4                  ] ELSE [
               4                  dist_dbs=(ssd_dbs-z_dbs)/wsrc;
               4                  ]
               3              IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
               4                  num_dbsrj=num_dbsrj+1;
               4                  goto :retry_read_phsp_calib:;
               4                  ]
               3              ]
               2
               2          IF(i_iaea_in=1 & i_mu_phsp=1)[
               3              frMU_indx = mu_phsp;
               3              ]ELSE [
               3              $RANDOMSET rncal;
               3              frMU_indx = rncal;
               3              ]
               2          ]
               1      IF(MLCflag=1)[
               2          call sample_vcusource(einsrc,xsrc,ysrc,zsrc,usrc,
               2          vsrc,wsrc,weight,iqin,latchinp,nhistdum,
               2          more_in_cont,frMU_indx);
               2          ] ELSE [
               2          call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,
               2          wsrc,weight,iqin,latchinp,nhistdum,iphatsrc,
               2          more_in_cont,frMU_indx);
               2          ]
               1
               1      IF(weight>0)[ total_survived=total_survived+1.0;]
               1      ELSE [ num_blocked=num_blocked+1;]
               1      ]UNTIL(num_hist>=(num2run+1));
               0
               0  IF(i_iaea_in=1)["rewind phsp"
               1      $IAEA_SET_PHSP_RECORD(i_unit_in,1);
               1      ]
               0
               0  more_in_cont=0;
               0  s_ratio=total_survived/(num2run);
               0
               0  OUTPUT61 num2run,total_survived,num_dbsrj,num_blocked;
               0  ('Number run: ', I12/
               0  'Number survived: ', F12.0/
               0  'Number dbs rejected: ', I12/
               0  'Number blocked', I12);
               0
               0  OUTPUT 'Calibration complete.';(//a);
               0
               0
               0  return;
               0  end; "End of subroutine beam_calibration_run
               0
1              0  %E "srcxyznrc.mortran start of subroutine srcout "
               0  "**************************************************************************"
               0  "
               0  subroutine srcout;
               0  "
               0  "This subroutine describes the source configuration to the output files
               0  "
               0  "**************************************************************************"
               0  implicit none;
               0  ;COMIN/SOURCE,SSMDIS,BMODEL,PHSPFILE/;
               0
               0  $INTEGER i,lnblnk1,IOUTLIST;
               0
               0  "This needs to be defined for beammodeling"
               0  IOUTLIST = 6;
               0
               0  OUTPUT61;
               0  ( /' ',79('*')//t10,
               0  'Summary of source parameters (srcxyznrc)' /
               0  ' ',79('*')/);
               0
               0  IF(isource = 0)[
               1      OUTPUT61 iqin,xinl,xinu,yinl,yinu,thetax,thetay,thetaz;
               1      ( t20,' Parallel beam incident from the front(+ve z-axis)'/
               1      /
               1      t25,' Electric charge of the source:',t57,i12           /
               1      t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
               1      t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
               1      T25,' Angle relative to +x:',t57,f10.4,' degrees'        /
               1      T25,' Angle relative to +y:',t57,f10.4,' degrees'        /
               1      T25,' Angle relative to -z:',t57,f10.4,' degrees'        /);
               1      ]
               0  ELSEIF(isource = 1)[
               1      OUTPUT61 iqin,xiso,yiso,ziso,theta(1),phi(1),xcol,ycol,phicol;
               1      ( t15,' Parallel beam incident from an arbitrary direction'   / /
               1      t20,' Electric charge of the source:'  ,t62,i12             /
               1      t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               1      t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               1      t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               1      t20,' Polar angle of collimator center:',t62,f10.4,' degrees'/
               1      t20,' Azimuthal angle of collimator center:',t62,f10.4,' degrees'/
               1      t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
               1      t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
               1      t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees'/);
               1      ]
               0  ELSEIF(isource = 2)[
               1      OUTPUT61 xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,nshist;
               1      ( t15,' Full phase space input for each incident particle'      //
               1      t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' Polar angle of source plane:'      ,t62,f10.4,' degrees'/
               1      t10,' Azimuthal angle of origin in source plane:'
               1      ,t62,f10.4,' degrees'/
               1      t10,' Distance from isocenter to origin in source',
               1      ' plane:',t62,f10.4,' cm'/
               1      t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
               1      t10,' Total number of particles in phase space file:',t62,i12/);
               1      IF(i_dbs=1)[
               2          OUTPUT61 r_dbs,ssd_dbs,z_dbs;
               2          ( ' Directional Bremsstrahlung Splitting (DBS) used'/
               2          ' in BEAM simulation to generate phase space source with:'/
               2          '    DBS splitting radius:',t55,f10.4/
               2          '    SSD where radius defined:',t55,f10.4/
               2          '    Z where source scored:',t55,f10.4/
               2          ' Photons whose trajectory takes them outside the DBS splitting'/
               2          ' radius at the SSD will be rejected.'/);
               2          ]
               1      IF(IPARALLEL>1)[
               2          IF(PARNUM>0)[
               3              OUTPUT61 IPARALLEL,INT((PARNUM-1)*nshist/IPARALLEL)+1,
               3              INT(PARNUM*nshist/IPARALLEL);
               3              ('    This is one of ',i4,' parallel simulations.'/
               3              '    It will use from particle ',i12,' to particle ',i12,' in '/
               3              '    the phase space source for the simulation.'/);
               3              ]
               2          ELSEIF(PARNUM=0)[
               3              OUTPUT61 IPARALLEL;
               3              ('    This is one of ',i4,' parallel simulations.'/
               3              '    It will use the entire specified phase space source'/
               3              '    for the simulation.'/);
               3              ]
               2          ]
               1      IF(iqphsp=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqphsp=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqphsp=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqphsp=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  ELSEIF(isource = 3)[
               1      OUTPUT61 iqin,xinl,xinu,yinl,yinu,ssd;
               1      ( t20,' Point source incident from the front(+ve z-axis)'/
               1      t25,' Electric charge of the source:',t57,i12           /
               1      t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
               1      t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm'       /
               1      t25,' SSD                           ',f10.4,' cm'       /);
               1      ]
               0  ELSEIF(isource = 6)[
               1      OUTPUT61 iqin,xinl,xinu,yinl,yinu,zinl,zinu;
               1      ( t20,' Uniform isotropically radiating parallelepiped'/
               1      t20,' within DOSXYZ volume'/
               1      t25,' Electric charge of the source:',t57,i12 /
               1      t25,' x-boundaries:',t43,f10.4,' cm-',f10.4,' cm' /
               1      t25,' y-boundaries:',t43,f10.4,' cm-',f10.4,' cm' /
               1      t25,' z-boundaries:',t43,f10.4,' cm-',f10.4,' cm'/);
               1      ]
               0  ELSEIF(isource = 7)[
               1      IF(nang>0)[
               2          OUTPUT61 iqin,xiso,yiso,ziso,nang,xcol,ycol,phicol;
               2          ( t15,' Parallel beam incident from multiple, user-selected angles'   / /
               2          t20,' Electric charge of the source:'  ,t62,i12             /
               2          t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' number of incident theta-phi:'   ,t62,i12/
               2          t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
               2          t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
               2          t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees');
               2          OUTPUT61;
               2          (t20,'  theta-phi     theta         phi        normalized'/
               2          t20,'    pair        (deg.)       (deg.)      probability');
               2          DO I=1,nang[
               3              IF(I=1)[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I); (t20,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
               4                  (t20,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(nang<0)[
               2          OUTPUT61 iqin,xiso,yiso,ziso,-nang,xcol,ycol,phicol;
               2          ( t15,' Parallel beam incident from side at user-selected angles'   / /
               2          t20,' Electric charge of the source:'  ,t62,i12             /
               2          t20,' x-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' y-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' z-coordinate of the isocenter,'  ,t62,f10.4,' cm'     /
               2          t20,' no. of theta-phi groups:'        ,t62,i12/
               2          t20,' Total x-width of collimator,'    ,t62,f10.4,' cm'     /
               2          t20,' Total y-width of collimator,'             ,t62,f10.4,' cm'/
               2          t20,' Collimator rotation angle,'      ,t62,f10.4,' degrees');
               2          OUTPUT61;
               2          ('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
               2          '    group      min.     max.      min.    max.    phi pairs    probability');
               2          DO I=1,-nang[
               3              IF(ivary(I)=1)[
               4                  OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ]
               2          ]
               1      OUTPUT61;(' ');
               1      ]
               0  ELSEIF(isource = 8)[
               1      IF(nang>0)[
               2          OUTPUT61 xiso,yiso,ziso,nang,dsource,phicol,nshist;
               2          ( t15,' Full phase space input incident from multiple angles'      //
               2          t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' number of incident theta-phi:'      ,t62,i10/
               2          t10,' Distance from isocenter to origin in source',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
               2          t10,' Total number of particles in phase space file:',t62,i12/);
               2          OUTPUT61;
               2          (t10,'  theta-phi     theta         phi        normalized'/
               2          t10,'    pair        (deg.)       (deg.)      probability');
               2          DO I=1,nang[
               3              IF(I=1)[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I); (t10,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
               4                  (t10,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(nang<0)[
               2          OUTPUT61 xiso,yiso,ziso,-nang,dsource,phicol,nshist;
               2          ( t15,' Full phase space input incident from multiple angles'      //
               2          t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' number theta-phi groups:'      ,t62,i10/
               2          t10,' Distance from isocenter to origin in source',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' Source plane rotation angle,'      ,t62,f10.4,' degrees'/
               2          t10,' Total number of particles in phase space file:',t62,i12/);
               2          OUTPUT61;
               2          ('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
               2          '    group      min.     max.      min.    max.    phi pairs    probability');
               2          DO I=1,-nang[
               3              IF(ivary(I)=1)[
               4                  OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ]
               2          ]
               1      OUTPUT61;(' ');
               1      IF(i_dbs=1)[
               2          OUTPUT61 r_dbs,ssd_dbs,z_dbs;
               2          ( ' Directional Bremsstrahlung Splitting (DBS) used'/
               2          ' in BEAM simulation to generate phase space source with:'/
               2          '    DBS splitting radius:',t55,f10.4/
               2          '    SSD where radius defined:',t55,f10.4/
               2          '    Z where source scored:',t55,f10.4/
               2          ' Photons whose trajectory takes them outside the DBS splitting'/
               2          ' radius at the SSD will be rejected.'/);
               2          ]
               1      IF(IPARALLEL>1)[
               2          IF(PARNUM>0)[
               3              OUTPUT61 IPARALLEL,INT((PARNUM-1)*nshist/IPARALLEL)+1,
               3              INT(PARNUM*nshist/IPARALLEL);
               3              ('    This is one of ',i4,' parallel simulations.'/
               3              '    It will use from particle ',i12,' to particle ',i12,' in '/
               3              '    the phase space source for the simulation.'/);
               3              ]
               2          ELSEIF(PARNUM=0)[
               3              OUTPUT61 IPARALLEL;
               3              ('    This is one of ',i4,' parallel simulations.'/
               3              '    It will use the entire specified phase space source'/
               3              '    for the simulation.'/);
               3              ]
               2          ]
               1      IF(iqphsp=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqphsp=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqphsp=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqphsp=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  ELSEIF(isource=9)[
               1      OUTPUT61 xiso,yiso,ziso,theta(1),phi(1),dsource,phicol,
               1      $cstring(the_beam_code),$cstring(the_input_file),
               1      $cstring(the_pegs_file);
               1      ( t15,' BEAM treatment head simulation used as source:'      //
               1      t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               1      t10,' Polar angle of beam axis:'      ,t62,f10.4,' degrees'/
               1      t10,' Azimuthal angle of beam axis:'
               1      ,t62,f10.4,' degrees'/
               1      t10,' Distance from isocenter to centre of scoring',
               1      ' plane:',t62,f10.4,' cm'/
               1      t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
               1      t10,' BEAM simulation: ',a/
               1      t10,'      input file: ',a/
               1      t10,'  pegs data file: ',a/);
               1      IF(i_dbs=1)[
               2          OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
               2          ]
               1      ELSE[
               2          OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
               2          ]
               1      IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  ELSEIF(isource=10)[
               1      IF(nang>0)[
               2          OUTPUT61 xiso,yiso,ziso,nang,dsource,phicol,
               2          $cstring(the_beam_code),$cstring(the_input_file),
               2          $cstring(the_pegs_file);
               2          ( t15,' BEAM simulation source from multiple angles:'      //
               2          t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' number of incident theta-phi:'      ,t62,i10/
               2          t10,' Distance from isocenter to centre of scoring',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
               2          t10,' BEAM simulation: ',a/
               2          t10,'      input file: ',a/
               2          t10,'  pegs data file: ',a/);
               2          OUTPUT61;
               2          (t10,'  theta-phi     theta         phi        normalized'/
               2          t10,'    pair        (deg.)       (deg.)      probability');
               2          DO I=1,nang[
               3              IF(I=1)[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I); (t10,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,theta(I),phi(I),pang(I)-pang(I-1);
               4                  (t10,i7,f16.4,f13.4,f15.4);
               4                  ]
               3              ]
               2          ]
               1      ELSEIF(nang<0)[
               2          OUTPUT61 xiso,yiso,ziso,-nang,dsource,phicol,
               2          $cstring(the_beam_code),$cstring(the_input_file),
               2          $cstring(the_pegs_file);
               2          ( t15,' BEAM simulation source from multiple angles:'      //
               2          t10,' x-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' y-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' z-coordinate of the isocenter,'    ,t62,f10.4,' cm'     /
               2          t10,' number of theta-phi groups:'      ,t62,i10/
               2          t10,' Distance from isocenter to centre of scoring',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' Rotation angle about beam axis,'      ,t62,f10.4,' degrees'/
               2          t10,' BEAM simulation: ',a/
               2          t10,'      input file: ',a/
               2          t10,'  pegs data file: ',a/);
               2          OUTPUT61;
               2          ('  theta-phi     theta (deg.)       phi (deg.)     no. theta-   normalized'/
               2          '    group      min.     max.      min.    max.    phi pairs    probability');
               2          DO I=1,-nang[
               3              IF(ivary(I)=1)[
               4                  OUTPUT61 I,angmin(I),angmax(I),angfixed(I),angfixed(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ELSE[
               4                  OUTPUT61 I,angfixed(I),angfixed(I),angmin(I),angmax(I),ngang(I),
               4                  pgang(I);(I8,F11.4,F10.4,F9.4,F10.4,I7,F14.4);
               4                  ]
               3              ]
               2          ]
               1      IF(i_dbs=1)[
               2          OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
               2          ]
               1      ELSE[
               2          OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
               2          ]
               1      IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  ELSEIF(isource=20)  [
               1      IF(nset>1) [
               2          OUTPUT61 nset,dsource,nshist,$cstring(the_shared_lib),
               2          $cstring(the_input_file);
               2          ( t15,'Phase Space Incident from multiple settings through a BEAM/MLC '//
               2          t10,' number of incident settings:'      ,t62,i10/
               2          t10,' first distance from isocenter to origin in source',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' Total number of particles in phase space file:',t62,i12/
               2          t10,' Shared library simulation: ',a/
               2          t10,' Shared library input file: ',a/);
               2          OUTPUT61;
               2          (t10,'   setting      xiso      yiso           ziso        theta',
               2          '       phi          phicol         ',
               2          'SAD         MU Index'/
               2          t10,'   num           (cm)          (cm)           (cm)         (deg.)',
               2          '     (deg.)             (deg.)          (cm)');
               2          DO I=1,nset[
               3              OUTPUT61 I,xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I),muIndex(I);
               3              (t10,i7,f15.4,f11.4,f15.4,f12.4,f13.4,f11.4,f11.4,f10.4);
               3              ]
               2
               2          ]
               1
               1      OUTPUT61;(' ');
               1      IF(i_dbs=1)[
               2          OUTPUT61 r_dbs,ssd_dbs,z_dbs;
               2          ( ' Directional Bremsstrahlung Splitting (DBS) used'/
               2          ' in BEAM simulation to generate phase space source with:'/
               2          '    DBS splitting radius:',t55,f10.4/
               2          '    SSD where radius defined:',t55,f10.4/
               2          '    Z where source scored:',t55,f10.4/
               2          ' Photons whose trajectory takes them outside the DBS splitting'/
               2          ' radius at the SSD will be rejected.'/);
               2          ]
               1      IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  ELSEIF(isource=21)  [
               1      IF(nset>1) [
               2          OUTPUT61 nset,dsource,
               2          $cstring(the_beam_code),$cstring(the_input_file),
               2          $cstring(the_pegs_file),$cstring(the_vcu_code),
               2          $cstring(the_vcu_input_file);
               2          ( t15,'BEAM treatment simulation used as source '    //
               2          t10,' number of incident settings:'      ,t62,i10/
               2          t10,' first distance from isocenter to origin in source',
               2          ' plane:',t62,f10.4,' cm'/
               2          t10,' BEAM simulation: ',a/
               2          t10,' input file: ',a/
               2          t10,' pegs data file: ',a/
               2          t10,' VCU simulation: ',a/
               2          t10,' VCU input file: ',a/);
               2          OUTPUT61;
               2          (t10,'   setting      xiso      yiso           ziso        theta',
               2          '       phi          phicol         ',
               2          'SAD         MU Index'/
               2          t10,'   num           (cm)          (cm)           (cm)         (deg.)',
               2          '     (deg.)             (deg.)          (cm)');
               2          DO I=1,nset[
               3              OUTPUT61 I,xtemp(I),ytemp(I),ztemp(I),thetatemp(I),phitemp(I),
               3              phicoltemp(I),dsourcetemp(I),muIndex(I);
               3              (t10,i7,f15.4,f11.4,f15.4,f12.4,f13.4,f11.4,f11.4,f10.4);
               3              ]
               2
               2          ]
               1
               1      OUTPUT61;(' ');
               1      IF(i_dbs=1)[
               2          OUTPUT61;(t10,' Fat photons from DBS will be rejected.'/);
               2          ]
               1      ELSE[
               2          OUTPUT61;(t10,' Fat photons from DBS will not be rejected.'/);
               2          ]
               1      IF(iqinc=2)[ OUTPUT61;(' Particles to be simulated: all'/);]
               1      ELSEIF(iqinc=0)[ OUTPUT61;(' Particles to be simulated: photon only'/);]
               1      ELSEIF(iqinc=1)[ OUTPUT61;(' Particles to be simulated: positron only'/);]
               1      ELSEIF(iqinc=-1)[ OUTPUT61;(' Particles to be simulated: electron only'/);]
               1      IF(e_split>1 & iqphsp~=0)[
               2          OUTPUT61 e_split;(/' Charged particles will be split ',i10,' times.'/);
               2          ]
               1      ]
               0  IF(isource = 4)[ ;$BEAMMODEL-SOURCE4-OUTPUT; ]
               0
               0  return;
               0  end; "End of subroutine srcout"
1              0  %E "srcxyznrc.mortran start of subroutine srchst "
               0  "*******************************************************************************
               0  "
               0  subroutine srchst(xin,yin,zin,uin,vin,win,irin,weight,latchi);
               0  "
               0  "This subroutine does the sampling of the source distribution
               0  "   Energy is passed in COMIN/SOURCE
               0  "      For isource =0,1,3 & enflag =1(spectrum) it passes back
               0  "                    esrc_sp which is the particles k.e.
               0  "      For phase space sources, it returns einsrc which is particles
               0  "                    total energy
               0  "      No energy is sample for enflag=0, monoenergetic source
               0  "                    since etotin is initialized and fixed in main
               0  "
               0  "**************************************************************************"
               0  ;
               0  implicit none;
               0  ;COMIN/ENERGYSRC,SOURCE,GEOM,RANDOM,SSMDIS,BMODEL,PHSPFILE,RWPHSP,EGS-IO,
               0  SCORE/;
               0
               0  $REAL xsrc,ysrc,zsrc, "X,Y,Z position of incident particle (isource=2,8,9)"
               0  xsrcp,ysrcp,zsrcp, "transformed X,Y,Z position of incident particle"
               0  usrc,vsrc,wsrc, "U,V,W of incident particle (isource=2,8,9)"
               0  xindel,yindel,zindel, "X,Y,Z widths of incident beam"
               0  xin,yin,zin, "X,Y,Z position of incident particle"
               0  uin,vin,win, "U,V,W of incident particle"
               0  enin,        "energy of incident particle"
               0  zsrcdum,     "dummy value of zsrc read in from BEAM sim (isource=9)"
               0  r1,rnno1,rnno2, "random no.s"
               0  fw,
               0  rxyz, "radial position of incident particle"
               0  costheta,sintheta,
               0  weight, "incident particle weight"
               0  zlast,
               0  dist,
               0  dist_dbs, "distance along particle trajectory for dbs rejection"
               0  coscol,sincol,
               0  cosphi,sinphi,
               0  mu_phsp; "stores fractional MU index from IAEA phsp source"
               0
               0  $REAL RBEAM,DIST_RAY;
               0
               0  $INTEGER ix,jy,kz,i,j,k,
               0  irin, "region of incident particle"
               0  latchi, "input latch value"
               0  ibit;
               0  $LONG_INT n_hist_dum;
               0
               0  save wsrc; "in case of phsp particle recycling"
               0
               0  zsrc = dsource;
               0  iaea_SAD = 0;
               0  IF(i_iaea_in = 1)[
               1      iaea_SAD = -dsource; "save SAD for iaea phsp sources"
               1      ]
               0
               0  "----------------------------------------------------------------"
               0  IF(isource = 0)[ "Frontal parallel beam source"
               1      "----------------------------------------------------------------"
               1      "Choose a point randomly in a rectangle
               1      xindel = xinu-xinl;
               1      IF(xindel = 0.0)[xin=xinl;]
               1      ELSE[ $RANDOMSET r1; xin = xinl + r1*xindel; ]
               1      yindel = yinu-yinl;
               1      IF(YINDEL = 0.0)[yin=yinl;]
               1      ELSE[ $RANDOMSET r1; yin = yinl + r1*yindel; ]
               1      zin = zinc;
               1      uin=uinc;vin=vinc;win=winc;
               1
               1      "Determine region index of source particle
               1      IF(xindel = 0.0)[ix=ixinl;]
               1      ELSE[
               2          ix=ixinl-1;
               2          LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
               2          ]
               1      IF(yindel = 0.0)[jy=jyinl;]
               1      ELSE[
               2          jy=jyinl-1;
               2          LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
               2          ]
               1      irin = 1 + ix +(jy-1)*imax; "Input region
               1
               1      IF(enflag = 1)[" select k.e. of input"
               2          $RANDOMSET RNNO1;
               2          $RANDOMSET RNNO2;
               2          K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
               2          esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
               2          ]
               1      return;
               1      ]  "end of isource = 0  Frontal parallel beam source"
               0
               0  "----------------------------------------------------------------"
               0  IF(isource = 3)[ "Frontal point source"
               1      "----------------------------------------------------------------"
               1      xindel = xinu-xinl;
               1      yindel = yinu-yinl;
               1      IF(xindel = 0.0 | yindel = 0.0 )[
               2          XIN = xinl; YIN = yinl; RXYZ=SQRT(SSD*SSD+XIN*XIN+YIN*YIN);
               2          ]
               1      ELSE[
               2          LOOP["this method is not so efficient for small SSDs"
               3              $RANDOMSET r1;
               3              xin=r1*xindel+xinl;
               3              $RANDOMSET r1;
               3              yin=r1*yindel+yinl;
               3              $RANDOMSET r1;
               3              RXYZ=SQRT(SSD*SSD+xin*xin+yin*yin);
               3              win=SSD/RXYZ;
               3              FW=win**3.;
               3              IF(r1<FW)GOTO :FOUND_A_POINT:;
               3              ]
               2          ;:FOUND_A_POINT:;
               2          ]
               1      zin = zinc;
               1      uin=XIN/RXYZ;
               1      vin=YIN/RXYZ;
               1      "win has been calaulated"
               1      "Determine region index of source particle
               1      IF(xindel = 0.0)[ix=ixinl;]
               1      ELSE[
               2          ix=ixinl-1;
               2          LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
               2          ]
               1      IF(yindel = 0.0)[jy=jyinl;]
               1      ELSE[
               2          jy=jyinl-1;
               2          LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
               2          ]
               1      irin = 1 + ix +(jy-1)*imax; "Input region
               1      IF(enflag = 1)[
               2          $RANDOMSET RNNO1;
               2          $RANDOMSET RNNO2;
               2          K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
               2          esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
               2          ]
               1      return;
               1      ]"end of (isource = 3) block -frontal point source"
               0
               0  "----------------------------------------------------------------"
               0  IF(isource = 6)[ "uniform isotropically radiating volume"
               1      "----------------------------------------------------------------"
               1      "Choose a point randomly in the active volume
               1      xindel = xinu-xinl;
               1      yindel = yinu-yinl;
               1      zindel = zinu-zinl;
               1      IF(xindel = 0.0)[xin=xinl;]
               1      ELSE[ $RANDOMSET r1; xin = xinl + r1*xindel; ]
               1      IF(yindel = 0.0)[yin=yinl;]
               1      ELSE[ $RANDOMSET r1; yin = yinl + r1*yindel; ]
               1      IF(zindel = 0.0)[zin=zinl;]
               1      ELSE[ $RANDOMSET r1; zin = zinl + r1*zindel; ]
               1
               1      "find the initial angle"
               1      $RANDOMSET costheta; costheta=2.*costheta-1;
               1      sintheta=SQRT(1.0-costheta**2);
               1      $RANDOMSET phi(1); phi(1)=6.283185*phi(1);
               1      uin=sintheta*COS(phi(1));vin=sintheta*SIN(phi(1));win=costheta;
               1
               1      "Determine region index of source particle
               1      IF(xindel = 0.0)[ix=ixinl;]
               1      ELSE[
               2          ix=ixinl-1;
               2          LOOP[ix=ix+1;]UNTIL( xbound(ix) <= xin & xbound(ix+1) > xin );
               2          ]
               1      IF(yindel = 0.0)[jy=jyinl;]
               1      ELSE[
               2          jy=jyinl-1;
               2          LOOP[jy=jy+1;]UNTIL( ybound(jy) <= yin & ybound(jy+1) > yin);
               2          ]
               1      IF(zindel = 0.0)[kz=kzinl;]
               1      ELSE[
               2          kz=kzinl-1;
               2          LOOP[kz=kz+1;]UNTIL( zbound(kz) <= zin & zbound(kz+1) > zin);
               2          ]
               1      irin = $IR(ix,jy,kz); "Input region
               1
               1      IF(enflag = 1)[" select k.e. of input"
               2          $RANDOMSET RNNO1;
               2          $RANDOMSET RNNO2;
               2          K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
               2          esrc_sp = CDFINV(K,1) + RNNO2*CDFINV(K,2);
               2          ]
               1      return;
               1      ]  "end of isource = 6  isotropically radiating volume"
               0
               0  "----------------------------------------------------------------"
               0  ;:GET-ANOTHER-PARTICLE:;
               0  "----------------------------------------------------------------"
               0
               0  "isource = 1, 2, 4, 5, 8 can produce phase space that misses the target"
               0  "Loop until a hit is obtained
               0  "----------------------------------------------------------------"
               0  IF(isource = 1 | isource=7) [
               1      "Parallel beam incident from an arbitrary direction"
               1      "or parallel beam incident from side at user-selected angles"
               1      "----------------------------------------------------------------"
               1      "Set the incident direction cosines"
               1      wsrc = 1.0; "Before rotation
               1      usrc = 0.;
               1      vsrc = 0.;
               1      "Choose a point randomly within the collimator
               1      $RANDOMSET xsrc; $RANDOMSET ysrc;
               1      xsrc = (xsrc-0.5)*xcol;
               1      ysrc = (ysrc-0.5)*ycol;
               1      IF(enflag = 1)[
               2          $RANDOMSET RNNO1;
               2          $RANDOMSET RNNO2;
               2          K = MIN(DELTAK*RNNO1+1.,DELTAK);  "MIN IN CASE RNNO1=1.0"
               2          enin = CDFINV(K,1) + RNNO2*CDFINV(K,2);
               2          esrc_sp = enin;
               2          ]
               1      ]
               0  "----------------------------------------------------------------"
               0  ELSEIF(isource = 2 | isource=8)[ "Full phase space for each particle"
               1      "----------------------------------------------------------------"
               1      "Recall nshist=#particles in ph sp file - given in header"
               1      "nnphsp is # of particle to read from file as start here"
               1      "          is initialized to 1 in main"
               1      IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)[ "recycle this particle"
               2          NofREPEAT=NofREPEAT+1;
               2          CYCLNUM=CYCLNUM+1;
               2          xsrc=xsrcold;
               2          ysrc=ysrcold;
               2          IF(i_iaea_in=1) zsrc=zsrcold;
               2          usrc=usrcold;
               2          vsrc=vsrcold;
               2          wsrc=wsrcold;
               2          einsrc=einsrcold;
               2          iqin=iqinold;
               2          weight=weightold;
               2          latchi=latchold;
               2          ]
               1      ELSE[ "choose a new particle"
               2          LOOP[
               3              :READ-PH-SP-DATA:;
               3              IF(n_parallel>0 & nnphsp>nnphsp_max)[
               4                  "rewind phsp source chunk and output a warning"
               4                  nnphsp=nnphsp_min;
               4                  OUTCNT=OUTCNT+1;
               4                  OUTPUT ;
               4                  (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
               4                  '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
               4                  /1x,79('*')// );
               4                  IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
               5                      $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               5                      ]
               4
               4                  ]
               3              ELSEIF(IPARALLEL>1 & PARNUM>0 & nnphsp > INT(PARNUM*nshist/IPARALLEL))[
               4                  NofREPEAT = NofREPEAT + 1;
               4                  OUTCNT=OUTCNT+1;
               4                  OUTPUT61;
               4                  (/' *** Warning *** Used all particles from partition of source file'/
               4                  '                 Restarting from first particle in this partition'/);
               4                  nnphsp = INT((PARNUM-1)*nshist/IPARALLEL)+1;
               4                  IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/IPARALLEL;
               5                      $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               5                      ]
               4                  ]
               3              ELSEIF( nnphsp > nshist)["Not enough particles to read from file"
               4                  "Start reading from top of source file and write warning"
               4                  NofREPEAT = NofREPEAT + 1;
               4                  OUTCNT=OUTCNT+1;
               4                  OUTPUT61;
               4                  (/' *** Warning *** Used all particles from source file'/
               4                  '                 Restarting from first particle in file'/);
               4                  nnphsp = 1;
               4                  IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC;
               5                      $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               5                      ]
               4                  ]
               3
               3              nnphsp = nnphsp+1;"we use nnphsp+1 because 1st record is for MODE"
               3              IF(i_iaea_in=1)[
               4                  $IAEA_READ_PHSP_RECORD(i_unit_in,npassi,nhist,latchi,iqin,einsrc,
               4                  weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
               4                  mu_phsp);
               4                  ]
               3              ELSE[
               4                  $READ_PHSP(ismode,44,nnphsp:nhist,npassi,iqin,wsrc,zlast,
               4                  latchi,einsrc,weight,xsrc,ysrc,usrc,vsrc);
               4                  ]
               3
               3              nnread = nnread +1; "total actually read, initialized to 0 in main"
               3
               3              IF(wsrc < 0.0) [nsrjct=nsrjct+1; goto :READ-PH-SP-DATA:;]
               3              "particle is going backward"
               3
               3              IF( npassi=1 ) [nsrjct=nsrjct+1; goto :READ-PH-SP-DATA:;]
               3              "particle is a multiple passer"
               3
               3              ELSEIF( iqin=1 & iqphsp ~= 1 & iqphsp ~=2) [
               4                  nsrjct=nsrjct+1;
               4                  goto :READ-PH-SP-DATA:;
               4                  ]
               3              ELSEIF( iqin=0 & iqphsp ~= 0 & iqphsp ~=2) [
               4                  nsrjct=nsrjct+1;
               4                  goto :READ-PH-SP-DATA:;
               4                  ]
               3              ELSEIF( iqin=-1 & iqphsp ~=-1 & iqphsp ~=2)[
               4                  nsrjct=nsrjct+1;
               4                  goto :READ-PH-SP-DATA:;
               4                  ]
               3              ELSEIF(i_dbs=1 & iqin=0)["only reject photons"
               4                  dist_dbs=(ssd_dbs-z_dbs)/wsrc;
               4                  IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
               5                      ndbsrjct=ndbsrjct+1;
               5                      goto :READ-PH-SP-DATA:;
               5                      ]
               4                  ]
               3
               3              IF(enflag = 3)["=> phase space input with bit filters"
               4                  IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
               5                      "and none of the second NBIT2 bits are set"
               5                      DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
               6                          IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
               6                          IF(IBIT=NBIT1)[
               7                              nsrjct=nsrjct+1;
               7                              goto :READ-PH-SP-DATA:;
               7                              ]"discard the particle"
               6                          ]
               5                      DO IBIT=1,NBIT2["if any are set, discard the particle"
               6                          IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
               7                              nsrjct=nsrjct+1;
               7                              goto :READ-PH-SP-DATA:;
               7                              ]"discard the particle"
               6                          ]
               5                      goto :FOUND-THE-PARTICLE:;
               5                      ]
               4                  ELSEIF(I_BIT_FILTER=1)[
               5                      DO IBIT= 1, NBIT1["discard if any of these bits are set"
               6                          IF($BTEST(latchi,LATBIT(IBIT)))[
               7                              nsrjct=nsrjct+1;
               7                              goto :READ-PH-SP-DATA:;
               7                              ]
               6                          ]
               5                      goto :FOUND-THE-PARTICLE:;
               5                      ]
               4                  ELSEIF(I_BIT_FILTER=2)[
               5                      DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
               6                          IF(IBITS(latchi,24,5)=LATBIT(IBIT))[goto :FOUND-THE-PARTICLE:;]
               6                          ]
               5                      nsrjct=nsrjct+1;
               5                      goto :READ-PH-SP-DATA:;
               5                      ]
               4                  ELSEIF(I_BIT_FILTER=3)[
               5                      DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
               6                          IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               7                              nsrjct=nsrjct+1;
               7                              goto :READ-PH-SP-DATA:;
               7                              ]
               6                          ]
               5                      goto :FOUND-THE-PARTICLE:;
               5                      ]
               4                  ]"end of (enflag = 3) block"
               3
               3              :FOUND-THE-PARTICLE:;
               3              IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
               4                  nsoutside=nsoutside+1;
               4                  ]
               3              ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
               2          "end of LOOP"
               2          IF(NRCYCL>0)[
               3              CYCLNUM=1;
               3              NofREPEAT=0;
               3              xsrcold=xsrc;
               3              ysrcold=ysrc;
               3              IF(i_iaea_in=1) zsrcold=zsrc;
               3              usrcold=usrc;
               3              vsrcold=vsrc;
               3              wsrcold=wsrc;
               3              einsrcold=einsrc;
               3              iqinold=iqin;
               3              weightold=weight;
               3              latchold=latchi;
               3              ]
               2          ] "end of choosing a new particle"
               1      ]"end of isource = 2 or 8 full phase space"
               0
               0  "----------------------------------------------------------------"
               0  ELSEIF( isource = 9 | isource =10 ) [ "full BEAM simulation"
               1      "----------------------------------------------------------------"
               1      LOOP [;
               2          :retry_sample_beamsource:;
               2          call sample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,wsrc,weight,
               2          iqin,latchi,nhist,iphatsrc);
               2          nnread = nnread +1; "keep track of how many particles read from sim."
               2          IF( iqinc < 2 & iqin ~= iqinc ) [
               3              nsrjct=nsrjct+1;
               3              goto :retry_sample_beamsource:;
               3              ]
               2          ELSEIF( iqinc = 3 & iqin = 0 ) [
               3              nsrjct=nsrjct+1;
               3              goto :retry_sample_beamsource:;
               3              ]
               2          ELSEIF(i_dbs=1 & iqin=0 & iphatsrc>1) [
               3              nsrjct=ndbsrjct+1;
               3              goto :retry_sample_beamsource:;
               3              ]
               2
               2          IF(enflag = 3)["=> full BEAM sim. with bit filters"
               3              IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
               4                  "and none of the second NBIT2 bits are set"
               4                  DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
               5                      IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
               5                      IF(IBIT=NBIT1)[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beamsource:;
               6                          ]"discard the particle"
               5                      ]
               4                  DO IBIT=1,NBIT2["if any are set, discard the particle"
               5                      IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beamsource:;
               6                          ]"discard the particle"
               5                      ]
               4                  goto :found_particle_beamsource:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=1)[
               4                  DO IBIT= 1, NBIT1["discard if any of these bits are set"
               5                      IF($BTEST(latchi,LATBIT(IBIT)))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beamsource:;
               6                          ]
               5                      ]
               4                  goto :found_particle_beamsource:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=2)[
               4                  DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
               5                      IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               6                          goto :found_particle_beamsource:;
               6                          ]
               5                      ]
               4                  nsrjct=nsrjct+1;
               4                  goto :retry_sample_beamsource:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=3)[
               4                  DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
               5                      IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beamsource:;
               6                          ]
               5                      ]
               4                  goto :found_particle_beamsource:;
               4                  ]
               3              ]"end of (enflag = 3) block"
               2
               2          :found_particle_beamsource:;
               2          IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
               3              nsoutside=nsoutside+1;
               3              ]
               2          ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
               1      ]
               0  "----------------------------------------------------------------"
               0  ELSEIF( isource = 20 ) [ "Phase Space Incident from multiple settings"
               1      "and through an MLC"
               1      "----------------------------------------------------------------"
               1      IF(more_in_cont = 0)["if there are no more particles in the container"
               2          IF(NRCYCL>0 & CYCLNUM>0 & CYCLNUM<=NRCYCL)[ "recycle this particle"
               3              NofREPEAT=NofREPEAT+1;
               3              CYCLNUM=CYCLNUM+1;
               3              einsrc=einsrcold;
               3              xsrc=xsrcold;
               3              ysrc=ysrcold;
               3              usrc=usrcold;
               3              vsrc=vsrcold;
               3              wsrc=wsrcold;
               3              weight=weightold;
               3              latchi=latchold;
               3              iqin=iqinold;
               3              IF(i_iaea_in=1)["added z coordinate for iaea phsps (JL and TP)"
               4                  zsrc = zsrcold;
               4                  IF(i_mu_phsp=1) mu_phsp = mu_phspold;
               4                  ]
               3              ]
               2          ELSE["choose a new particle"
               3              LOOP[
               4                  :retry_sample_vcusource:;
               4
               4                  "IF(more_in_cont = 0)[""if there are more particles in the container"
               4                  "we don't read from the phase space so we skip this"
               4                  IF(n_parallel>0 & nnphsp>nnphsp_max)[
               5                      "rewind phsp source chunk and output a warning"
               5                      nnphsp=nnphsp_min;
               5                      OUTCNT=OUTCNT+1;
               5                      OUTPUT ;
               5                      (///' ***WARNING*** USED ALL PARTICLES FROM CHUNK IN SOURCE FILE!'/
               5                      '               RESTARTING FROM FIRST PARTICLE IN THIS CHUNK.'//
               5                      /1x,79('*')// );
               5                      IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/(n_parallel*$N_CHUNKS);
               6                          $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               6                          ]
               5                      ]
               4                  ELSEIF(IPARALLEL>1 & PARNUM>0 & nnphsp > INT(PARNUM*nshist/IPARALLEL))[
               5                      NofREPEAT = NofREPEAT + 1;
               5                      OUTCNT=OUTCNT+1;
               5                      OUTPUT61;
               5                      (/' *** Warning *** Used all particles from partition of source file'/
               5                      '                 Restarting from first particle in this partition'/);
               5                      nnphsp = INT((PARNUM-1)*nshist/IPARALLEL)+1;
               5                      IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC/IPARALLEL;
               6                          $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               6                          ]
               5                      ]
               4                  ELSEIF( nnphsp > nshist)["Not enough particles to read from file"
               5                      "Start reading from top of source file and write warning"
               5                      NofREPEAT = NofREPEAT + 1;
               5                      OUTCNT=OUTCNT+1;
               5                      OUTPUT61;
               5                      (/' *** Warning *** Used all particles from source file'/
               5                      '                 Restarting from first particle in file'/);
               5                      nnphsp = 1;
               5                      IF(i_iaea_in=1)[nhist=OUTCNT*NINCSRC;
               6                          $IAEA_SET_PHSP_RECORD(i_unit_in,nnphsp);
               6                          ]
               5                      ]
               4
               4                  nnphsp = nnphsp+1;"we use nnphsp+1 because 1st record is for MODE"
               4                  IF(i_iaea_in=1)[
               5                      $IAEA_READ_PHSP_RECORD(i_unit_in,npassi,nhist,latchi,iqin,einsrc,
               5                      weight,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,zlast,
               5                      mu_phsp);
               5                      ]  ELSE [
               5                      $READ_PHSP(ismode,44,nnphsp:nhist,npassi,iqin,wsrc,zlast,
               5                      latchi,einsrc,weight,xsrc,ysrc,usrc,vsrc);
               5                      ]
               4
               4
               4                  nnread = nnread +1; "keep track of how many particles read from phsp."
               4                  " ] "
               4
               4                  IF( iqinc < 2 & iqin ~= iqinc ) [
               5                      nsrjct=nsrjct+1;
               5                      goto :retry_sample_vcusource:;
               5                      ]
               4                  ELSEIF( iqinc = 3 & iqin = 0 ) [
               5                      nsrjct=nsrjct+1;
               5                      goto :retry_sample_vcusource:;
               5                      ]
               4                  "ELSEIF(i_dbs=1 & iqin=0 & iphatsrc=1) [ "
               4                  "   nsrjct=ndbsrjct+1; "
               4                  "   goto :retry_sample_vcusource:; "
               4                  "] "
               4                  ELSEIF(i_dbs=1 & iqin=0)["only reject photons"
               5                      IF(i_iaea_in=1)[
               6                          dist_dbs=(ssd_dbs-zsrc)/wsrc;
               6                          ] ELSE [
               6                          dist_dbs=(ssd_dbs-z_dbs)/wsrc;
               6                          ]
               5                      IF((xsrc+usrc*dist_dbs)**2+(ysrc+vsrc*dist_dbs)**2>r_dbs**2)[
               6                          ndbsrjct=ndbsrjct+1;
               6                          goto :retry_sample_vcusource:;
               6                          ]
               5                      ]
               4                  IF(enflag = 3)["=> full VCU sim. with bit filters"
               5                      IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
               6                          "and none of the second NBIT2 bits are set"
               6                          DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
               7                              IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
               7                              IF(IBIT=NBIT1)[
               8                                  nsrjct=nsrjct+1;
               8                                  goto :retry_sample_vcusource:;
               8                                  ]"discard the particle"
               7                              ]
               6                          DO IBIT=1,NBIT2["if any are set, discard the particle"
               7                              IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
               8                                  nsrjct=nsrjct+1;
               8                                  goto :retry_sample_vcusource:;
               8                                  ]"discard the particle"
               7                              ]
               6                          goto :found_particle_vcusource:;
               6                          ]
               5                      ELSEIF(I_BIT_FILTER=1)[
               6                          DO IBIT= 1, NBIT1["discard if any of these bits are set
               7                              IF($BTEST(latchi,LATBIT(IBIT)))[
               8                                  nsrjct=nsrjct+1;
               8                                  goto :retry_sample_vcusource:;
               8                                  ]
               7                              ]
               6                          goto :found_particle_vcusource:;
               6                          ]
               5                      ELSEIF(I_BIT_FILTER=2)[
               6                          DO IBIT= 1, NBIT1["keep if any of these regions of origin set
               7                              IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               8                                  goto :found_particle_vcusource:;
               8                                  ]
               7                              ]
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_vcusource:;
               6                          ]
               5                      ELSEIF(I_BIT_FILTER=3)[
               6                          DO IBIT= 1, NBIT1["discard if any of these regions of origin set
               7                              IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               8                                  nsrjct=nsrjct+1;
               8                                  goto :retry_sample_vcusource:;
               8                                  ]
               7                              ]
               6                          goto :found_particle_vcusource:;
               6                          ]
               5                      ]"end of (enflag = 3) block
               4
               4                  :found_particle_vcusource:;
               4
               4                  IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
               5                      nsoutside=nsoutside+1;
               5                      ]
               4
               4                  ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
               3              "end of LOOP"
               3
               3              IF(NRCYCL>0)[
               4                  CYCLNUM=1;
               4                  NofREPEAT=0;
               4
               4                  einsrcold=einsrc;
               4                  xsrcold=xsrc;
               4                  ysrcold=ysrc;
               4                  usrcold=usrc;
               4                  vsrcold=vsrc;
               4                  wsrcold=wsrc;
               4                  weightold=weight;
               4                  latchold=latchi;
               4                  iqinold=iqin;
               4                  IF(i_iaea_in=1)["added z coordinate for iaea phsps (JL and TP)"
               5                      zsrcold = zsrc;
               5                      IF(i_mu_phsp=1) mu_phspold = mu_phsp;
               5                      ]
               4                  ]
               3              ]"end of choose new particle"
               2          "*****************************************************************"
               2          "HERE IS WHERE WE PICK A RANDOM frMU_indx         "
               2          "***************************************************************"
               2          IF(i_iaea_in=1 & i_mu_phsp=1)
               2          [
               3              frMU_indx = mu_phsp; "use frMU from phsp source"
               3              ]
               2          ELSE [
               3              $RANDOMSET RNNO1;
               3              frMU_indx = RNNO1;
               3              ]
               2          ]" end of if more_in_cont
               1
               1      "Recycled particles must still go through shared libraries
               1      IF(SHLflag=1 & MLCflag=1)
               1      ["if there is an MLC, pass particles through it"
               2          "vcu does not use Z so just input dummy variable for this"
               2          IF(more_in_cont=0) ["the particle was just read and so has the correct"
               3              "z value. Store it so this value is always used"
               3              zsrcold = zsrc;
               3              ] ELSE [ "we will read the next value from the container next "
               3              "but need to make sure the old zsrc is used since it is not set in "
               3              "particleDmlc and so will be -dsource from the beginning of srchst"
               3              zsrc = zsrcold;
               3              ]
               2          call sample_vcusource(einsrc,xsrc,ysrc,zsrcdum,usrc,
               2          vsrc,wsrc,weight,iqin,latchi,n_hist_dum,
               2          more_in_cont,frMU_indx);
               2          ] ELSEIF(SHLflag=1 & MLCflag=0) [" if there is a BEAM shared library"
               2          "******************************************************************"
               2          "changed to allow motion in BEAM as well"
               2          "necessary changes are also made in beam and in CMs"
               2          "******************************************************************"
               2          IF(i_iaea_in=1)[
               3              call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,
               3              wsrc,weight,iqin,latchi,nhist,iphatsrc,
               3              more_in_cont,frMU_indx);"
               3              ] ELSE [" don't change the Z coordinate"
               3              call phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,
               3              wsrc,weight,iqin,latchi,nhist,iphatsrc,
               3              more_in_cont,frMU_indx);
               3              ]
               2          ]
               1      ]
               0  "----------------------------------------------------------------"
               0  ELSEIF( isource = 21) [ "BEAM Sim. source Incident from multiple settings"
               1      "and through an MLC"
               1      "----------------------------------------------------------------"
               1      LOOP [;
               2          :retry_sample_beam_vcu_source:;
               2          IF(more_in_cont = 0)["if there are more particles in the vcu container"
               3              "we don't need to get another particle so we skip this"
               3              "******************************************************************"
               3              "HERE IS WHERE WE NEED TO PICK A RANDOM frMU_indx         "
               3              "****************************************************************"
               3              "note: since there is no recycling, every particle will get it's
               3              "own setting so this can stay here whether we have an MLC or not
               3              "******************************************************************"
               3              "changed to allow motion in BEAM as well"
               3              "necessary changes are also made in beam and in CMs"
               3              "******************************************************************"
               3              call motionsample_beamsource(einsrc,xsrc,ysrc,zsrcdum,usrc,vsrc,wsrc,
               3              weight,iqin,latchi,nhist,iphatsrc,frMU_indx);
               3
               3              IF(frMU_indx<0.0)[
               4                  "BEAM did not set frMU_index (i.e."
               4                  "there was no CMs with motion)"
               4                  $RANDOMSET RNNO1;
               4                  frMU_indx = RNNO1;
               4                  ]
               3
               3              nnread = nnread +1;"keep track of how many particles read from sim."
               3
               3              ]
               2
               2          IF(MLCflag=1)["if there is an MLC, pass particles through it
               3              call sample_vcusource(einsrc,xsrc,ysrc,zsrcdum,usrc,
               3              vsrc,wsrc,weight,iqin,latchi,n_hist_dum,
               3              more_in_cont,frMU_indx);
               3
               3              "IF(weight=0.0)[""MLC blocked particle"
               3              "goto :retry_sample_beam_vcu_source:;"
               3              "more_in_cont=0;"
               3              "]"
               3              ]
               2
               2
               2          IF( iqinc < 2 & iqin ~= iqinc ) [
               3              nsrjct=nsrjct+1;
               3              goto :retry_sample_beam_vcu_source:;
               3              ]
               2          ELSEIF( iqinc = 3 & iqin = 0 ) [
               3              nsrjct=nsrjct+1;
               3              goto :retry_sample_beam_vcu_source:;
               3              ]
               2          ELSEIF(i_dbs=1 & iqin=0 & iphatsrc>1) [
               3              nsrjct=ndbsrjct+1;
               3              goto :retry_sample_beam_vcu_source:;
               3              ]
               2
               2          IF(enflag = 3)["=> full BEAM sim. with bit filters"
               3              IF(I_BIT_FILTER = 0)["use if any of the first NBIT1 bits are set"
               4                  "and none of the second NBIT2 bits are set"
               4                  DO IBIT= 1, NBIT1["if any bit set, move on to excl check"
               5                      IF($BTEST(latchi,LATBIT(IBIT))) [EXIT;]"go to excl. check"
               5                      IF(IBIT=NBIT1)[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beam_vcu_source:;
               6                          ]"discard the particle"
               5                      ]
               4                  DO IBIT=1,NBIT2["if any are set, discard the particle"
               5                      IF($BTEST(latchi,LATBIT(IBIT+NBIT1)))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beam_vcu_source:;
               6                          ]"discard the particle"
               5                      ]
               4                  goto :found_particle_beam_vcu_source:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=1)[
               4                  DO IBIT= 1, NBIT1["discard if any of these bits are set"
               5                      IF($BTEST(latchi,LATBIT(IBIT)))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beam_vcu_source:;
               6                          ]
               5                      ]
               4                  goto :found_particle_beam_vcu_source:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=2)[
               4                  DO IBIT= 1, NBIT1["keep if any of these regions of origin set"
               5                      IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               6                          goto :found_particle_beam_vcu_source:;
               6                          ]
               5                      ]
               4                  nsrjct=nsrjct+1;
               4                  goto :retry_sample_beam_vcu_source:;
               4                  ]
               3              ELSEIF(I_BIT_FILTER=3)[
               4                  DO IBIT= 1, NBIT1["discard if any of these regions of origin set"
               5                      IF(IBITS(latchi,24,5)=LATBIT(IBIT))[
               6                          nsrjct=nsrjct+1;
               6                          goto :retry_sample_beam_vcu_source:;
               6                          ]
               5                      ]
               4                  goto :found_particle_beam_vcu_source:;
               4                  ]
               3              ]"end of (enflag = 3) block"
               2
               2          :found_particle_beam_vcu_source:;
               2          IF(ABS(xsrc) >= (BEAM_SIZE/2.0) | ABS(ysrc)>=(BEAM_SIZE/2.0))[
               3              nsoutside=nsoutside+1;
               3              ]
               2          ]UNTIL(ABS(xsrc) < (BEAM_SIZE/2.0) & ABS(ysrc)<(BEAM_SIZE/2.0));
               1      ]
               0
               0
               0  IF((isource = 20 | isource = 21) & weight = 0) ["library blocked particle
               1      more_in_cont=0;
               1      nsblocked = nsblocked + 1;
               1      goto :GET-ANOTHER-PARTICLE:;
               1      ]
               0
               0  "----------------------------------------------------------------"
               0  ELSEIF(isource = 4)[;$BEAMMODEL_SOURCE4_SAMPLING;"in beammodel_macros.mortran"]
               0  "----------------------------------------------------------------"
               0
               0  IF(NofREPEAT > 0 & ISMOOTH = 1)[
               1      CALL SHIFT_XYUV(NofREPEAT,xsrc,ysrc,usrc,vsrc);
               1      ]
               0
               0  "Rotate/translate the source particle into position
               0  IF(isource<7 | isource=9)[
               1      IF(i_iaea_in=1) zsrc = zsrc - iaea_SAD;
               1
               1      uin   = r_11(1)*usrc + r_12(1)*vsrc + r_13(1)*wsrc;
               1      vin   = r_21(1)*usrc + r_22(1)*vsrc + r_23(1)*wsrc;
               1      win   = r_31(1)*usrc + r_32(1)*vsrc + r_33(1)*wsrc;
               1      xsrcp = r_11(1)*xsrc + r_12(1)*ysrc + r_13(1)*zsrc + xiso;
               1      ysrcp = r_21(1)*xsrc + r_22(1)*ysrc + r_23(1)*zsrc + yiso;
               1      zsrcp = r_31(1)*xsrc + r_32(1)*ysrc + r_33(1)*zsrc + ziso;
               1      ]
               0  "---------------------------------------------------------------------"
               0  ELSEIF(isource=20 | isource=21)[
               1      " get the correct setting based on the mu index
               1      "---------------------------------------------------------------------"
               1      DO I=1, nset[
               2          "*********************************************************************"
               2          " get setting from randomly generated frMU_indx
               2          "*********************************************************************"
               2          IF(frMU_indx<muIndex(I))[
               3              K=I;
               3              EXIT;
               3              ]
               2          ]
               1
               1      IF(i_iaea_in=1)[
               2          "for iaea phase space z is read from the particle"
               2          " dsourcetemp is now supposed to be SAD"
               2          iaea_SAD = (dsourcetemp(K-1)+(dsourcetemp(K)-dsourcetemp(K-1))*
               2          (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1)));
               2          zsrc = zsrc - iaea_SAD;
               2          ]  ELSE [
               2          zsrc = -1.0*(dsourcetemp(K-1)+(dsourcetemp(K)-dsourcetemp(K-1))*
               2          (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1)));
               2          ]
               1
               1      "calculate rotation matrix"
               1      " get theta, phi, phicol x|y|ziso"
               1      theta(1)=thetatemp(K-1)+(thetatemp(K)-thetatemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1      phi(1)=phitemp(K-1)+(phitemp(K)-phitemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1      phicol=phicoltemp(K-1)+(phicoltemp(K)-phicoltemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1      xiso=xtemp(K-1)+(xtemp(K)-xtemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1      yiso=ytemp(K-1)+(ytemp(K)-ytemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1      ziso=ztemp(K-1)+(ztemp(K)-ztemp(K-1))*
               1      (frMU_indx-muIndex(K-1))/(muIndex(K)-muIndex(K-1));
               1
               1      "Collimator/source rotation sine's and cosine's needed locally
               1      costheta = cos(theta(1)*3.141593/180.); sintheta = sin(theta(1)*3.141593/180.);
               1      coscol   = cos(phicol*3.141593/180.); sincol = sin(phicol*3.141593/180.);
               1      cosphi   = cos(phi(1)*3.141593/180.); sinphi   = sin(phi(1)*3.141593/180.);
               1
               1      "Rotation matrix needed during sampling routine
               1      r_11(1) =  costheta*cosphi*coscol + sinphi*sincol;
               1      r_12(1) = -costheta*cosphi*sincol + sinphi*coscol;
               1      r_13(1) = -sintheta*cosphi                       ;
               1      r_21(1) =  costheta*sinphi*coscol - cosphi*sincol;
               1      r_22(1) = -costheta*sinphi*sincol - cosphi*coscol;
               1      r_23(1) = -sintheta*sinphi                       ;
               1      r_31(1) = -sintheta*coscol                       ;
               1      r_32(1) =  sintheta*sincol                       ;
               1      r_33(1) = -costheta                              ;
               1
               1
               1      uin   = r_11(1)*usrc + r_12(1)*vsrc + r_13(1)*wsrc;
               1      vin   = r_21(1)*usrc + r_22(1)*vsrc + r_23(1)*wsrc;
               1      win   = r_31(1)*usrc + r_32(1)*vsrc + r_33(1)*wsrc;
               1      xsrcp = r_11(1)*xsrc + r_12(1)*ysrc + r_13(1)*zsrc + xiso;
               1      ysrcp = r_21(1)*xsrc + r_22(1)*ysrc + r_23(1)*zsrc + yiso;
               1      zsrcp = r_31(1)*xsrc + r_32(1)*ysrc + r_33(1)*zsrc + ziso;
               1
               1      ]
               0  ELSE[ "choose an incident angle from the distribution"
               1      IF(i_iaea_in=1) zsrc = zsrc - iaea_SAD; "in case we have IAEA isource=8"
               1      $RANDOMSET RNNO1;
               1      k_field=numang;"use global variable k_field so we can untransform"
               1      "if scoring phsp in BEAM coordinate system"
               1      DO I=1,numang-1[
               2          IF(RNNO1<pang(I))[
               3              k_field=I;
               3              EXIT;
               3              ]
               2          ]
               1      uin   = r_11(k_field)*usrc + r_12(k_field)*vsrc + r_13(k_field)*wsrc;
               1      vin   = r_21(k_field)*usrc + r_22(k_field)*vsrc + r_23(k_field)*wsrc;
               1      win   = r_31(k_field)*usrc + r_32(k_field)*vsrc + r_33(k_field)*wsrc;
               1      xsrcp = r_11(k_field)*xsrc + r_12(k_field)*ysrc + r_13(k_field)*zsrc + xiso;
               1      ysrcp = r_21(k_field)*xsrc + r_22(k_field)*ysrc + r_23(k_field)*zsrc + yiso;
               1      zsrcp = r_31(k_field)*xsrc + r_32(k_field)*ysrc + r_33(k_field)*zsrc + ziso;
               1      ]
               0
               0  "Select the input region"
               0  "done already for isource =0 &3"
               0  "------------------------------------------------------------------------"
               0  IF(isource = 1 | isource=7)[
               1      "------------------------------------------------------------------------"
               1      "Find the distance to the outside of the geometry,
               1      "transport from the source plane to the surface.
               1      "If the coordinates place the particle on the surface of the
               1      "geometry then the solution is unique.
               1      IF(uin > 0.0) [
               2          "Going towards lower x-plane
               2          dist = (xbound_min - xsrcp)/uin; "Distance to boundary
               2          yin  = ysrcp + dist*vin; "Transport transverse coordinates...
               2          zin  = zsrcp + dist*win; "...from source to target surface
               2          IF ( (yin >= ybound_min) & (yin <= ybound_max) &
               2          (zin >= zbound_min) & (zin <= zbound_max)) [
               3              "Hits the lower x-plane, search for the entrance region number
               3              DO j=1,jmax [
               4                  IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
               5                      DO k=1,kmax [
               6                          IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
               7                              xin  = xbound_min;
               7                              irin = imax*j + klowx + ijmax*k;
               7                              return; "No other solution possible
               7                              ]
               6                          ]"end of do"
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on lower x-plane. Can not find irin! *';
               3              ]
               2          ]
               1      ELSEIF(uin < 0.0) [ "Going towards upper x-plane
               2          dist = (xbound_max - xsrcp)/uin; "Distance to boundary
               2          yin  = ysrcp + dist*vin; "Transport transverse coordinates...
               2          zin  = zsrcp + dist*win; "...from source to target surface
               2          IF ( (yin >= ybound_min) & (yin <= ybound_max) &
               2          (zin >= zbound_min) & (zin <= zbound_max)) [
               3              "Hits the upper x-plane, search for the entrance region number
               3              DO j=1,jmax [
               4                  IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
               5                      DO k=1,kmax [
               6                          IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
               7                              xin  = xbound_max;
               7                              irin = imax*j + khix + ijmax*k;
               7                              return; "No other solution possible
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on upper x-plane. Can not find irin! *';
               3              ]
               2          ]
               1      IF(vin > 0.0) [
               2          "Going towards lower y-plane
               2          dist = (ybound_min - ysrcp)/vin; "Distance to boundary
               2          xin  = xsrcp + dist*uin; "Transport transverse coordinates...
               2          zin  = zsrcp + dist*win; "...from source to target surface
               2          IF ( (xin >= xbound_min) & (xin <= xbound_max) &
               2          (zin >= zbound_min) & (zin <= zbound_max)) [
               3              "Hits the lower y-plane, search for the entrance region number
               3              DO i=1,imax [
               4                  IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               5                      DO k=1,kmax [
               6                          IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
               7                              yin  = ybound_min;
               7                              irin = i + klowy + ijmax*k;
               7                              return; "No other solution possible
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on lower y-plane. Can not find irin! *';
               3              ]
               2          ]
               1      ELSEIF(vin < 0.0) [ "Going towards upper y-plane
               2          dist = (ybound_max - ysrcp)/vin; "Distance to boundary
               2          xin  = xsrcp + dist*uin; "Transport transverse coordinates...
               2          zin  = zsrcp + dist*win; "...from source to target surface
               2          IF ( (xin >= xbound_min) & (xin <= xbound_max) &
               2          (zin >= zbound_min) & (zin <= zbound_max)) [
               3              "Hits the upper y-plane, search for the entrance region number
               3              DO i=1,imax [
               4                  IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               5                      DO k=1,kmax [
               6                          IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
               7                              yin  = ybound_max;
               7                              irin = i + khiy + ijmax*k;
               7                              return; "No other solution possible
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on upper y-plane. Can not find irin! *';
               3              ]
               2          ]
               1      IF(win > 0.0) [ "Going towards lower z-plane
               2          dist = (zbound_min - zsrcp)/win; "Distance to boundary
               2          xin  = xsrcp + dist*uin; "Transport transverse coordinates...
               2          yin  = ysrcp + dist*vin; "...from source to target surface
               2          IF ( (xin >= xbound_min) & (xin <= xbound_max) &
               2          (yin >= ybound_min) & (yin <= ybound_max)) [
               3              "Hits the lower z-plane, search for the entrance region number
               3              DO i=1,imax [
               4                  IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               5                      DO j=1,jmax [
               6                          IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
               7                              zin  = zbound_min;
               7                              irin = i + klowz + imax*j;
               7                              return; "No other solution possible
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on lower z-plane. Can not find irin! *';
               3              ]
               2          ]
               1      ELSEIF(win < 0.0) [ "Going towards upper z-plane
               2          dist = (zbound_max-zsrcp)/win; "Distance to boundary
               2          xin  = xsrcp + dist*uin; "Transport transverse coordinates...
               2          yin  = ysrcp + dist*vin; "...from source to target surface
               2          IF ( (xin >= xbound_min) & (xin <= xbound_max) &
               2          (yin >= ybound_min) & (yin <= ybound_max)) [
               3              "Hits the upper z-plane, search for the entrance region number
               3              DO i=1,imax [
               4                  IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               5                      DO j=1,jmax [
               6                          IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
               7                              zin  = zbound_max;
               7                              irin = i + khiz + imax*j;
               7                              return; "No other solution possible
               7                              ]
               6                          ]
               5                      ]
               4                  ]
               3              stop ' * Stopped in srchst on upper z-plane. Can not find irin! *';
               3              ]
               2          ]
               1
               1      nmissm = nmissm+1; "If gets here => it misses, count it and start again"
               1      goto :GET-ANOTHER-PARTICLE:;
               1      ]"end of isource=1 case"
               0
               0  "------------------------------------------------------------------------"
               0  ELSE["isource = 2,4,8,9,10,20,21"
               1      "------------------------------------------------------------------------"
               1      xin  = xsrcp;
               1      yin  = ysrcp;
               1      zin  = zsrcp;
               1      IF(IWATCH=-9999)[
               2          WRITE(*,*)' xin,yin,zin ',xin,yin,zin;
               2          "put to avoid roundoff error on zin when optimized"
               2          "this should never actually be printed"
               2          ]
               1      "IF(((isource=20)|(isource=21 ))& weight=0)["
               1      "the particle was blocked by the MLC leaves"
               1      "    nsblocked = nsblocked + 1;"
               1      "]"
               1      IF ( (xin >= xbound_min) & (xin <= xbound_max) &
               1      (yin >= ybound_min) & (yin <= ybound_max) &
               1      (zin >= zbound_min) & (zin <= zbound_max)) [
               2          "the particle is inside the phantom"
               2          DO i=1,imax [
               3              IF( (xbound(i) <= xin) & (xin <= xbound(i+1)) ) [
               4                  DO j=1,jmax [
               5                      IF( (ybound(j) <= yin) & (yin <= ybound(j+1)) ) [
               6                          DO k=1,kmax [
               7                              IF( (zbound(k) <= zin) & (zin <= zbound(k+1)) ) [
               8                                  irin = $IR(i,j,k);
               8                                  return; "No other solution possible
               8                                  ]
               7                              ]"end of do"
               6                          ]
               5                      ]"end of do"
               4                  ]
               3              ]
               2          stop ' * Stopped in srchst. Cannot find irin! *';
               2          ]
               1      ELSEIF( (xin> xbound_max+dsurround(1)) | (xin < xbound_min-dsurround(1))|
               1      (yin> ybound_max+dsurround(2)) | (yin < ybound_min-dsurround(2))|
               1      (zin> zbound_max+dsurround(3)) | (zin < zbound_min-dsurround(4)))[
               2          "the particle is outside the given surrounding air region"
               2          "IF((isource=20) & weight=0)[""it was blocked by leaves
               2          " return;"
               2          "] ELSE ["
               2          nsmiss = nsmiss+1;"it misses, count it and start again"
               2          goto :GET-ANOTHER-PARTICLE:;
               2          "]"
               2          ]
               1      ELSE["the particle is outside the phantom but in the "
               2          "given region surrounding the phantom"
               2          irin = imax*jmax*kmax+2; return;
               2          ]
               1
               1      ]"end of isource = 2,4,8,9,10,20,21 case"
               0  ;
               0  end; "End of subroutine srchst"
1              0  %E "srcxyznrc.mortran start of subroutine SHIFT_XYUV "
               0  "**************************************************************************"
               0  "
               0  SUBROUTINE SHIFT_XYUV(NofREPEAT,xsrc,ysrc,usrc,vsrc);
               0  implicit none;
               0
               0  $REAL xsrc,ysrc,usrc,vsrc,
               0  X,Y,U,V;
               0  $INTEGER NofREPEAT;
               0  "
               0  " Version 1.0 ---- 94/02/11 "
               0  " Version 1.1 ---- 94/10/18 removed NofREPEAT > 3 part."
               0  "**************************************************************************"
               0  X = xsrc;    Y = ysrc;    U = usrc;    V = vsrc;
               0
               0  IF(NofREPEAT = 1)[ xsrc = -X;    ysrc =  Y;    usrc = -U;    vsrc =  V; ]
               0  ELSEIF(NofREPEAT = 2)[ xsrc =  X; ysrc = -Y; usrc =  U; vsrc = -V; ]
               0  ELSEIF(NofREPEAT = 3)[ xsrc = -X; ysrc = -Y; usrc = -U; vsrc = -V; ]
               0  ELSEIF(NofREPEAT > 3)[ NofREPEAT = 0; ]
               0  RETURN;
               0
               0  "The following are not valid for particles from the collimators "
               0  "ELSEIF(NofREPEAT = 4)[ xsrc = Y; ysrc = X; usrc = V; vsrc = U; ]
               0  "ELSEIF(NofREPEAT = 5)[ xsrc = -Y; ysrc = X; usrc = -V; vsrc = U; ]
               0  "ELSEIF(NofREPEAT = 6)[ xsrc = Y; ysrc = -X; usrc = V; vsrc = -U; ]
               0  "ELSEIF(NofREPEAT = 7)[ xsrc = -Y; ysrc = -X; usrc = -V; vsrc = -U; ]
               0  "ELSEIF(NofREPEAT > 3)[ NofREPEAT = 0; ]
               0  "RETURN;
               0  END;
               0
               0  $HAVE_LOAD_DSO(#);
               0
               0  #ifndef HAVE_LOAD_DSO;
               0
               0  subroutine init_beamsource(i_parallel,n_parallel,i_log,conf_name,
               0  hen_house,egs_home,the_beam_code,
               0  the_pegs_file,the_input_file);
               0  $INTEGER i_parallel,n_parallel,i_log;
               0  character*(*) conf_name;
               0  character*(*) hen_house,egs_home,the_beam_code,the_pegs_file,the_input_file;
               0  write(6,*) 'You need a working C compiler to use source 9!';
               0  $CALL_EXIT(1);
               0  end;
               0
               0  subroutine sample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
               0  iqin,latchi,nhist,iphatsrc);
               0
               0  return; end;
               0
               0  subroutine motionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
               0  iqin,latchi,nhist,iphatsrc,frMU_indx);
               0  return; end;
               0
               0  subroutine phspmotionsample_beamsource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,
               0  weight,iqin,latchi,nhist,iphatsrc,
               0  more_in_cont,frMU_indx);
               0
               0  subroutine finish_beamsource;
               0  return; end;
               0
               0  subroutine call init_vcusource(conf_name,hen_house,egs_home,
               0  the_vcu_code,the_input_file);
               0
               0  character*(*) conf_name;
               0  character*(*) hen_house,egs_home,the_vcu_code,the_input_file;
               0  write(6,*) 'You need a working C compiler to use source 9!';
               0  $CALL_EXIT(1);
               0  end;
               0
               0  subroutine sample_vcusource(einsrc,xsrc,ysrc,zsrc,usrc,vsrc,wsrc,weight,
               0  iqin,latchi,n_hist_dum,more_in_cont,iphatsrc,frMU_indx);
               0  return; end;
               0
               0  subroutine finish_vcusource;
               0  return; end;
               0
               0  #endif;
               0  " end of srcxyznrc.mortran "
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc ranmar random number generator                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The following is the initialization routine for the RANMAR random number   "
               0  "  generator (RNG) proposed by Marsaglia and Zaman and designed to be used    "
               0  "  with the EGSnrc system.                                                    "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  The use of RANMAR requires the file ranmar.macros (which defines the       "
               0  "  actual random number generation as a macro).                               "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  subroutine init_ranmar;
               0
               0  implicit none;
               0
               0  ;COMIN/RANDOM/;
               0
               0  integer*4 s,t;
               0  integer*4 i,j,k,l,m,ii,jj;
               0
               0  IF( ixx <= 0 | ixx > 31328 ) ixx = 1802; "Sets Marsaglia default"
               0  IF( jxx <= 0 | jxx > 30081 ) jxx = 9373; "sets Marsaglia default"
               0
               0  i = mod(ixx/177,177) + 2;
               0  j = mod(ixx,    177) + 2;
               0  k = mod(jxx/169,178) + 1;
               0  l = mod(jxx,    169)    ;
               0
               0  DO ii = 1,97 [
               1
               1      s = 0; t = 8388608;  "t is 2**23 i.e. half of the maximum allowed"
               1      "(note that only 24 bits are used)          "
               1
               1      DO jj = 1,24 [
               2
               2          "The if( fool_optimizer ...) statements below are"
               2          "to prevent re-arangement of statements for high "
               2          "level optimizations and thus different sequences"
               2          "on different architectures                      "
               2
               2          m = mod(mod(i*j,179)*k,179);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          i = j;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          j = k;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          k = m;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          l = mod(53*l+1,169);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          IF(mod(l*m,64) >= 32) s = s + t;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          t = t/2;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          ]
               1      urndm(ii) = s;
               1      ]
               0
               0  crndm  =   362436;
               0  cdrndm =  7654321;
               0  cmrndm = 16777213;
               0
               0  twom24 = 1./16777216.;
               0
               0  ixx = 97;
               0  jxx = 33;
               0
               0  rng_seed = $NRANMAR + 1;
               0
               0  return;
               0  end; "End of init_ranmar for EGSnrc"
               0
               0  subroutine ranmar_get;
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $INTEGER i,iopt;
               0  IF( rng_seed = 999999 ) call init_ranmar;
               0  DO i=1,$NRANMAR [
               1      iopt = urndm(ixx) - urndm(jxx);
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      urndm(ixx) = iopt;
               1      ixx = ixx - 1; jxx = jxx - 1;
               1      IF(ixx = 0)        [ ixx = 97; ]
               1      ELSE IF( jxx = 0 ) [ jxx = 97; ]
               1      crndm = crndm - cdrndm;
               1      IF(crndm < 0) crndm = crndm + cmrndm;
               1      iopt = iopt - crndm;
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      rng_array(i) = iopt;
               1      ]
               0  rng_seed = 1; return; end;
               0
               0  ;"       end of ranmar.mortran    "
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc auxiliary routines for NRC user codes                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These are auxiliary routines used in many NRC user codes.                  "
               0  "                                                                             "
               0  "  If you include them via your configuration file, your user code will need  "
               0  "  to define $MXDATA and $STAT. For example, if you are not using the         "
               0  "  statistical analysis package:                                              "
               0  "                                                                             "
               0  "  REPLACE {$MXDATA} WITH {1}; REPLACE{$STAT} WITH {1};                       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80                                                                           ;
               0  "*****************************************************************************"
               0  "                                                                             "
               0  "                        WATCH                                                "
               0  "                                                                             "
               0  SUBROUTINE WATCH(IARG,IWATCH);
               0
               0  "============================================================================="
               0  "                                                                             "
               0  "     A general purpose auxiliary routine for use with the EGSnrc system
               0  "
               0  "     It prints out information about the particle transport                  "
               0  "                                                                             "
               0  "       For IWATCH = 1 it prints information about each discrete interaction  "
               0  "       For IWATCH = 2 or 3 it prints information about each step as well     "
               0  "       For IWATCH = 4 it prints graphing data for use with EGS_Windows       "
               0  "                                                                             "
               0  "                                                                             "
               0  "    Routine is used via two mandatory and 1 optional call from the user's    "
               0  "          code                                                               "
               0  "                                                                             "
               0  "   1)The routine must be initialized by a call with IARG=-99 before the first"
               0  "          call to SHOWER. It should be after all inputs are in place.        "
               0  "   2)The routine must be called near the beginning of the AUSGAB subroutine  "
               0  "          IF (IWATCH > 0 ) CALL WATCH(IARG,IWATCH);                          "
               0  "   3)The routine may be called at the end of each history with IARG = - 1 so "
               0  "          a message will get printed stated history is complete              "
               0  "                                                                             "
               0  "    Since WATCH cannot output values related to the initial values in a      "
               0  "    shower call, it is useful to also put something like the following       "
               0  "    immediately prior to the CALL SHOWER stmt                                "
               0  "           IF((IWATCH ~= 0) & (IWATCH ~= 4))[                                "
               0  "              OUTPUT 1,EIN,IQI,IRI,XI,YI,ZI,UI,VI,WI,LATCHI,WTI;              "
               0  "               (/' INITIAL SHOWER VALUES',T36,':',                           "
               0  "               I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);                         "
               0  "           ]                                                                 "
               0  "    Note EIN is the kinetic energy of the incident particle                  "
               0  "                                                                             "
               0  "                                                                             "
               0  "   The routine uses up to 132 columns for output.                            "
               0  "                                                                             "
               0  "     JAN 1984  GENERALIZED VERSION WITH INITIALIZATION                       "
               0  "                              DAVE ROGERS NRCC                               "
               0  "     JUN 1987  PUT IN IWATCH = 4 OPTION     AFB                              "
               0  "     JUL 1988  COMPATIBLE WITH X-RAY FLUORESCENCE  DWOR                      "
               0  "     SEP 1990  ADDED ENERGY OUTPUT TO IWATCH = 4 OPTION     AFB              "
               0  "     OCT 1990  UNIX compatible carriage control   DWOR                       "
               0  "     JAN 2000  Rewritten to output relaxation particles and also             "
               0  "               so some of the output makes more sense BW                     "
               0  "                                                                             "
               0  "*****************************************************************************"
               0
               0  "define a local macro"
               0  REPLACE {$CNTOUT(#);(#);} WITH {
            {  0  ICOUNT=ICOUNT+1;
            {  0  OUTPUT {P1},KE,IQ({P1}),IR({P1}),X({P1}),Y({P1}),Z({P1}),U({P1}),V({P1}),
            {  0  W({P1}),LATCH({P1}),WT({P1});  ({P2},I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            {  0  }
               0
               0  $IMPLICIT-NONE;
               0  $INTEGER iarg,iwatch,IP,ICOUNT,JHSTRY,J,N;
               0  $REAL KE;
               0  $INTEGER graph_unit;
               0  integer  egs_open_file;
               0  $INTEGER ku,kr,ka;
               0
               0  ;COMIN/BOUNDS, STACK,EPCONT,EGS-VARIANCE-REDUCTION,USEFUL,EGS-IO/;
               0
               0  DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/;
               0  save     ICOUNT,JHSTRY,graph_unit;
               0
               0  ku = 13; kr = 0; ka = 1;
               0  IF(IARG = -99) [ "Initialize flags so we will get calls thru AUSGAB"
               1      DO J=1,29[IAUSFL(J)=1;];
               1      /IAUSFL(22),IAUSFL(23),IAUSFL(24)/=0;
               1      ]
               0
               0  IF(IARG = -1) ["main is assumed to call AUSGAB with IARG=-1 at end of history"
               1      IF(IWATCH = 4) [
               2          IF( graph_unit < 0 ) [
               3              graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               3              ]
               2          WRITE(graph_unit,:GRAPHICS_FORMAT:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
               2          JHSTRY=JHSTRY+1;
               2          ]
               1      ELSE[
               2          OUTPUT JHSTRY;(' END OF HISTORY',I8,3X,40('*')/);
               2          JHSTRY=JHSTRY+1;ICOUNT=ICOUNT+2;RETURN;
               2          ]
               1      ]
               0
               0  IF( (IWATCH ~= 4) & ((ICOUNT >= 50) | (ICOUNT = 0) | (IARG = -99)) )[
               1      "PRINT HEADER"
               1      ICOUNT=1;
               1      OUTPUT;(//T39,' NP',3X,'ENERGY  Q REGION    X',7X,
               1      'Y',7X,'Z',6X,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/);
               1      ]
               0
               0  IF((IWATCH = 4) & (IARG >= 0) & (IARG ~= 5)) [ "GRAPHICS OUTPUT"
               1      IF( graph_unit < 0 ) graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               1      WRITE(graph_unit,:GRAPHICS_FORMAT:) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP);
               1      :GRAPHICS_FORMAT:FORMAT(2I4,1X,I6,4G15.8,I12);
               1      ]
               0
               0  IF(IARG = 5  |  IARG < 0) RETURN;
               0  IF(IWATCH = 4) RETURN; "NONE OF THE REST NEEDED FOR GRAPHICS OUTPUT"
               0
               0  KE=E(NP);IF(IQ(NP).NE.0)[KE=E(NP)-PRM;]
               0
               0  IF(IARG = 0 & IWATCH = 2)[
               1      $CNTOUT(NP);(T11,'STEP ABOUT TO OCCUR', T36,':');
               1      ]
               0  ELSEIF(IARG = 0)[RETURN;]
               0  IF(    IARG = 1)[
               1      $CNTOUT(NP);(' Discard  AE,AP<E<ECUT',T36,':');]
               0  ELSEIF(IARG = 2)[
               1      $CNTOUT(NP);(' Discard  E<AE,AP',T36,':');]
               0  ELSEIF(IARG = 3)[
               1      $CNTOUT(NP);(' Discard -user request',T36,':');]
               0  ELSEIF(IARG = 4)[OUTPUT EDEP,IR(NP);
               1      (T10,'Local energy deposition',T36,':',F12.5,' MeV in region ',I6);]
               0
               0  ELSEIF(IARG = 6)[
               1      $CNTOUT(NP);(' bremsstrahlung  about to occur',T36,':');]
               0  ELSEIF(IARG = 7)[
               1      IF(nbr_split =1) ["no splitting or SBS is on in BEAMnrc"
               2          DO IP=NPold,NP[
               3              IF(IQ(IP)=-1)[
               4                  KE = E(IP) - RM;
               4                  $CNTOUT(IP);(T10,'Resulting electron',T36,':');
               4                  ]
               3              ELSE[
               4                  KE = E(IP);
               4                  $CNTOUT(IP);(T10,'Resulting photon',T36,':');
               4                  ]
               3              ]
               2          ]
               1      ELSE ["splitting case--e- is always at NPold"
               2          KE = E(NPold) - RM;
               2          $CNTOUT(NPold);(T10,'Resulting electron',T36,':');
               2          DO IP=NPold+1,NP[
               3              KE= E(IP);
               3              IF(IP = NPold+1)["print info for first one only"
               4                  $CNTOUT(IP);(T10,'Split photons',T36,':');
               4                  ]
               3              ELSE[ $CNTOUT(IP);(T36,':'); ]
               3              ]
               2          ]" end of splitting block"
               1      ]
               0
               0  ELSEIF(IARG = 8)[$CNTOUT(NP);(' Moller   about to occur',T36,':');]
               0  ELSEIF(IARG = 9)[
               1      "surely this logic not needed?"
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(NP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting electrons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 10)[
               1      $CNTOUT(NP);(' Bhabba   about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 11)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[ $CNTOUT(IP);(T11,'Resulting e- or e+',T36,':'); ]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 12)[
               1      $CNTOUT(NP);(' Positron about to decay in flight',T36,':');
               1      ]
               0  ELSEIF(IARG = 13)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting photons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 28)[
               1      $CNTOUT(NP);(' Positron will annihilate at rest',T36,':');
               1      ]
               0  ELSEIF(IARG = 14)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(' Positron annihilates at rest',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 15)[
               1      $CNTOUT(NP);(' Pair production about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 16)["after pair production"
               1      IF(NP=NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP=NPold & i_survived_rr > 0)["we have cleared the stack"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting pair',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          IF(i_survived_rr > 0)[
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I2,'
            '  3              particle(s) with probability ',F8.5);
               3              $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 17)[$CNTOUT(NP);(' Compton  about to occur',T36,':');]
               0  ELSEIF(IARG = 18)["after call to COMPT"
               1      IF(NP = NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP > NPold)["have not cleared the stack with rus rou"
               2          DO IP=NPold,NPold+1[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IQ(IP).NE.0)[$CNTOUT(IP);(T11,'compton electron created',T36,':');]
               3              ELSE[$CNTOUT(IP);(T11,'compton scattered photon',T36,':');]
               3              ]
               2          ]
               1      IF(i_survived_rr > 0)["whether the stack has been cleared or not"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 19)[
               1      $CNTOUT(NP);(' Photoelectric about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 20)[
               1      IF(NPold=NP & IQ(NP)=0 & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Photon energy below N-shell',/,
               2          T11,'Photon discarded',T36,':');
               2          ]
               1      ELSEIF(IQ(NPold) = -1 & i_survived_rr = 0)[
               2          KE= E(NPold)-RM;
               2          $CNTOUT(NPold);(T10,'Resulting photoelectron',T36,':');
               2          ]
               1      ELSEIF(i_survived_rr > 0)["done some russian roulette"
               2          IF(NP=NPold-1 | IQ(NPold) ~= -1)[
               3              IF(i_survived_rr > 1)["eliminated more than the photoelectron"
               4                  OUTPUT i_survived_rr-1,prob_rr;
               4                  (T10,'Russian Roulette eliminated ',I4,
               4                  ' particle(s) with probability ',F8.5,' plus');
               4                  ]
               3              OUTPUT prob_rr;
               3              (T10,'Russian Roulette eliminated resulting photoelectron',
               3              ' with probability ',F8.5);
               3              ]
               2          ELSE["NPold could hold the photoelectron"
               3              KE = E(NPold) - RM;
               3              $CNTOUT(NPold);(T10,'Resulting photoelectron?',T36,':');
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I4,
               3              ' particle(s) with probability ',F8.5);
               3              ]
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 24)[$CNTOUT(NP);(' Rayleigh scattering occured',T36,':');]
               0
               0  ELSEIF(IARG = 25)[$CNTOUT(NP);(T10,'Fluorescent X-ray created',T36,':');]
               0
               0  ELSEIF(IARG = 26)[$CNTOUT(NP);(T10,'Coster-Kronig e- created',T36,':');]
               0
               0  ELSEIF(IARG = 27)[$CNTOUT(NP);(T10,'Auger electron created',T36,':');]
               0
               0  IF(IARG = 0  &  IWATCH = 2)[OUTPUT  USTEP,TUSTEP,VSTEP,TVSTEP,EDEP;
               1      (T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4));ICOUNT=ICOUNT+1;]
               0
               0  IF(NP = 1  |  IARG = 0) RETURN;
               0  IF( IARG <= 3)[
               1      N=NP-1;
               1      KE = E(N) - ABS(IQ(N))*RM;
               1      $CNTOUT(N);(T10,'Now on top of stack',T36,':');
               1      ]
               0  RETURN;END;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E
               0  "*******************************************************************************
               0  "
               0  "
               0  "                       *****************
               0  "                       *               *
               0  "                       * SIGMA.MORTRAN *
               0  "                       *               *
               0  "                       *****************
               0  "
               0  "
               0  "       SIGMA IS A STATISTICAL ANALYSIS ROUTINE DESIGNED TO BE USED BY EGS
               0  "       USER PROGRAMS TO GIVE THE TOTALS OR AVERAGES AND THEIR UNCERTAINTIES
               0  "       OF THE DATA CALCULATED BY THE MONTE CARLO CODE.
               0  "       THE UNCERTAINTIES ARE RETURNED AS PERCENTS.
               0  "
               0  "       VARIABLES
               0  "       =========
               0  "
               0  "       DATA(NDATA,ISTAT)       THE TWO DIMENSIONAL ARRAY OF DATA TO BE
               0  "                               ANALYZED. ISTAT IS THE NUMBER OF STATISTICAL
               0  "                               BATCHES AND NDATA IS THE NUMBER OF ERRORS TO
               0  "                               BE CALCULATED. AFTER THE END OF THE CALCULATION,
               0  "                               DATA(N,1) CONTAINS THE TOTAL OR AVERAGE AND
               0  "                               DATA(N,2) CONTAINS THE ERROR. NDATA SHOULD
               0  "                               BE < OR = $MAXDATA AND ISTAT SHOULD BE < OR =
               0  "                               $STAT WHCH MUST BE DEFINED IN THE MAIN ROUTINE.
               0  "                               Note $STAT must be 2 or greater, even if istat=1
               0  "
               0  "       MODE    =  0 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS
               0  "                               IGNORED. (eg. STOPPING POWER RATIO)
               0  "               =  1 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS NOT
               0  "                               IGNORED. (e.g. DOSE)
               0  "               =  2 =>         ANALYSIS ON TOTAL VALUES (eg. TOTAL EDEP)
               0  "
               0  "       IERR    =  0 =>         NORMAL COMPLETION.
               0  "               =  1 =>         WARNING: MODE OUT OF RANGE, DEFAULTED TO 0
               0  "               = 10 =>         ERROR: ONLY ONE BATCH INPUT, QUICK CALCULATION
               0  "                                      DONE. ERROR=99.9%
               0  "               = 11 =>         ERROR: NO NON-ZERO DATA FOUND IN A GIVEN SET,
               0  "                                       ERROR=99.9%
               0  "               = -1 =>         FATAL ERROR: NDATA OR ISTAT OUT OF RANGE, NO
               0  "                                            CALCULATION DONE.
               0  "
               0  "
               0  "               VERSION  1      A.F.B.  83/7/22
               0  "               Version  2      IK      Jan 6 6000 implemented implicit none
               0  "
               0  "*******************************************************************************
1              0  %E
               0  SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR);
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER NDATA,ISTAT,MODE,IERR;
               0
               0  REPLACE {;COMIN/ERROR/;} WITH {
            {  0  ;COMMON/ERROR/DATA($MXDATA,$STAT);
            {  0  $REAL data;
            {  0  }
               0  ;COMIN/ERROR,EGS-IO/;
               0
               0  $INTEGER n,non0,i;
               0  $REAL    stat,sdenom;
               0  real*8   emax,avg,error,datum,argmnt;
               0  "It is a good idea to use double precision"
               0  "in cases with very low stat. uncertainties"
               0
               0  DATA EMAX/99.9/;
               0
               0  IERR=0; "ASSUME NORMAL COMPLETION"
               0
               0  "TEST INPUTS AND SET ERROR CODES AND RETURN IF NEEDED."
               0
               0  IF((MODE < 0) | (MODE > 2)) [MODE=2;IERR=1;]
               0
               0  IF((NDATA.LE.0).OR.(NDATA.GT.$MXDATA).OR.(ISTAT.LE.0).OR.(ISTAT.GT.$STAT)) [
               1      IERR=-1;RETURN;"FATAL INPUT ERROR, RETURN IMMEDIATELY"
               1      ]
               0  IF(ISTAT = 1)[
               1      IERR=10;"ONLY ONE STATISTICAL BATCH, QUICK CALCULATION"
               1      DO N=1,NDATA[DATA(N,2)=EMAX;]
               1      RETURN;
               1      ]
               0
               0  "MOST ANOMALIES HAVE BEEN HANDLED. NOW DO THE ANALYSIS"
               0
               0  IF(MODE.NE.0)[STAT=FLOAT(ISTAT);SDENOM=STAT*(STAT-1.);]
               0  DO N=1,NDATA[
               1      NON0=0;             "NON-ZERO COUNTER"
               1      AVG=0.0;ERROR=0.0;
               1      DO I=1,ISTAT[
               2          DATUM=DATA(N,I);
               2          IF(DATUM.NE.0.0)[NON0=NON0+1;AVG=AVG+DATUM;ERROR=ERROR+DATUM**2;]
               2          ]
               1      IF(NON0 = 0)[IERR=11;ERROR=EMAX;GOTO :TRANSFER:;"NO NON-ZERO DATA "]
               1
               1      ELSEIF((NON0 = 1) & (MODE = 0))[ERROR=EMAX;GOTO:TRANSFER:;"ONLY ONE DATUM"]
               1
               1      ELSE[
               2          IF(MODE = 0)[STAT=FLOAT(NON0);SDENOM=STAT*(STAT-1.);]
               2          ]
               1
               1      AVG=AVG/STAT;ARGMNT=ERROR-STAT*AVG**2;
               1      "FLAG -VE SQUARE ROOTS THAT CAN ONLY OCCUR DUE TO ROUND-OFF ERRORS"
               1      IF(ARGMNT.LT.0.0)[
               2          OUTPUT ARGMNT,ERROR,STAT,AVG,SDENOM;
               2          (' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM='/' ',5E12.4);
               2          ARGMNT=0.0;
               2          ]
               1      ERROR=SQRT(ARGMNT/SDENOM);
               1
               1      IF(AVG = 0.)[ERROR=EMAX;]ELSE[ERROR=100.*ERROR/ABS(AVG);]
               1
               1      IF(MODE =  2)AVG=AVG*STAT;
               1
               1      :TRANSFER:;
               1      DATA(N,1)=AVG;DATA(N,2)=MIN(EMAX,ERROR);
               1      ] "END OF NDATA LOOP"
               0  RETURN;
               0  END; "END OF SIGMA"
               0  ;
               0
               0  "*****************************************************************************
               0  " The following are routines that implement
               0  " the alias sampling technique for sampling from a histogram
               0  " distribution coded for use with EGSnrc
               0  "
               0  " subroutine prepare_alias_sampling
               0  " function   alias_sample
               0  "
               0  " I. Kawrakow, January 2000
               0  "
               0  "*****************************************************************************
               0
               0  subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_array);
               0  "====================================================================
               0  "
               0  " inputs:  nsbin:    number of bins in the histogram
               0  "          fs_array: bin probabilities
               0  "
               0  " Note that we don't need the bin limits at this point, they
               0  " are needed for the actual sampling (in alias_sample)
               0  "
               0  " outputs: ws_array, ibin_array: alias table ready for sampling
               0  "
               0  "====================================================================
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     fs_array(nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      IF( fs_array(i) < 1e-30 ) fs_array(i) = 1e-30;
               1      ws_array(i) = -fs_array(i); ibin_array(i) = 1;
               1      sum = sum + fs_array(i);
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return;
               0  end;
               0
               0
               0  $REAL function alias_sample(nsbin,xs_array,ws_array,ibin_array);
               0  "===============================================================
               0  "
               0  " samples from an alias table which must have been prepared
               0  " using prepare_alias_table
               0  "
               0  "===============================================================
               0
               0  implicit none;
               0
               0  $INTEGER nsbin,ibin_array(nsbin);
               0  $REAL    xs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    v1,v2,aj;
               0  $INTEGER j;
               0
               0  $RANDOMSET v1; $RANDOMSET v2;
               0  aj = 1 + v1*nsbin; j = aj;
               0  IF( j > nsbin ) j = nsbin; " this happens only if $RANDOMSET produces
               0  " numbers in (0,1]
               0  aj = aj - j;
               0  IF( aj > ws_array(j) ) [ j = ibin_array(j); ]
               0  alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j);
               0  return;
               0  end;
               0  ;
1              0  %E
               0  ;
               0  "==========================end of nrcaux.mortran======================"
               0
               0
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc I/O functions                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " Iwan Kawrakow, 2004:                                                        "
               0  "                                                                             "
               0  " re-factored egs_init so that it is easy to program a corresponding egs_init "
               0  " when one loads a EGSnrc user code as a library and therefore no command     "
               0  " line arguments are available. (see beam library).                           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  REPLACE {$max_unit} WITH {99}
               0
               0  REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "
               0
               0  REPLACE {;COMIN/my_times/;} WITH {;
            {  0  common/my_times/ t_elapsed, t_cpu, t_first;
            {  0  $REAL            t_elapsed, t_cpu;
            {  0  integer          t_first(8);
            {  0  real             egs_tot_time,egs_etime;
            {  0  };
               0
               0  "******************************************************************************
               0  " subroutine egs_init;
               0  "******************************************************************************
               0  " A call to this subroutine becomes Step 0 in every EGSnrc user code.
               0  " Its purpose is to:
               0  "   - initialize arrays and default values for various transport options
               0  "     (this was previously done in block data, but due to the GNU Fortran
               0  "     compiler complaints and extremely slow compilation when the number of
               0  "     regions is large, we decided to remove block data from the source)
               0  "   - Process command line arguments specifying input file, pegs4 data file,etc.
               0  "     In the current version the following command line options are supported:
               0  "
               0  "       -i or --input ifile          Input file is ifile.egsinp
               0  "
               0  "       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
               0  "                                    The system will look for it in the
               0  "                                    HEN_HOUSE and the user's pegs4 data areas
               0  "
               0  "       -o or --output ofile         Output data will be writtent to
               0  "                                    ofile.egslog, ofile.egslst, etc., instead
               0  "                                    of ifile.egslog, etc.
               0  "
               0  "       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
               0  "                                    of the directory specified in the
               0  "                                    machine.macros file.
               0  "
               0  "       -e or --egs-home dir         Change EGS_HOME to be dir instead of
               0  "                                    the directory specified by the EGS_HOME
               0  "                                    environment variable
               0  "
               0  "       -h or --help                 Print a help message and exit
               0  "                                    ignoring all other arguments
               0  "
               0  "       -b or --batch                Specify a 'batch' run. The difference
               0  "                                    between a 'batch' run and an interactive
               0  "                                    run is that in 'batch' mode unit 6 is
               0  "                                    connected to a file, whereas in interactive
               0  "                                    mode unit 6 goes to the standard output.
               0  "                                    The file name in batch run is determined
               0  "                                    as follows:
               0  "                                     - ofile.egslog, if ofile was specified
               0  "                                       with the -o option
               0  "                                     - ifile.egslog, if there was no -o option
               0  "                                       used but an input file was specified
               0  "                                       with -i
               0  "                                     - test.egslog, if neither -i nor -o was
               0  "                                       used.
               0  "
               0  "       -P or --parallel n           Tell the system that this run is part of
               0  "                                    a parallel run and that this is job number
               0  "                                    n (so that the random number sequence
               0  "                                    can be initialized differently)
               0  "
               0  "       -c or --chunk N              Tell the system to use N histories per
               0  "                                    calculation 'chunk' in parallel runs.
               0  "
               0  "   - open default EGSnrc data file units thus avoiding the necessity for
               0  "     symbolik links
               0  "   - open user code specific I/O units if a .io file is found in
               0  "     the user code area. The format of this file is an integer
               0  "     followed by a string on every line.
               0  "     The string specifies the file extension
               0  "     and the integer the unit number this file should connect to, e.g.
               0  "       4   .egsdat
               0  "       15  .egserr
               0  "       1   .egslst
               0  "     will result in connecting unit 4 to the file ifile.egsdat
               0  "     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
               0  "  -  Outputs a summary to standard output about configuration etc
               0  "  -  Creates a temporary working directory in the user code area
               0  "
               0  "  The files always opened (appart from the ones specified in the .io file)
               0  "  are the following:
               0  "
               0  "  1. The PEGS data file (and so, for now, the -p pegs_file command line
               0  "     option must be always given)
               0  "     The algorithm for looking for a PEGS data file is:
               0  "       - The file name passed with -p. In this way, PEGS files can be located
               0  "         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
               0  "         and $EGS_HOME/pegs4/data) if the absolute path name is given after
               0  "         the -p option.
               0  "       - $EGS_HOME/pegs4/data/pegs_file or
               0  "         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
               0  "       - $HEN_HOUSE/pegs4/data/pegs_file or
               0  "         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
               0  "     See note below on how $HEN_HOUSE and $EGS_HOME are determined
               0  "
               0  "  2. If a -i ifile option was given as argument, ifile.egsinp is
               0  "     opened as fortran unit 5.
               0  "     The input file MUST be in the user code directory on $EGS_HOME
               0  "
               0  "  3. If the run is a batch run (the -b option was present on the command
               0  "     line), fortran unit 6 is connected to an output file with a .egslog
               0  "     extension instead of going to standard output.
               0  "     The algorithm for determining the .egslog file name is the following:
               0  "       - If the -o ofile option was present, the output to unit 6 will go
               0  "         to ofile.egslog
               0  "       - If there was no -o option, but there is an inpuit file specified
               0  "         with -i ifile, output to unit 6 will go to ifile.egslog
               0  "       - If neither of the above is true, the output will go to
               0  "         test.egslog.
               0  "
               0  "  Note on determining EGS_HOME:
               0  "  EGS_HOME is normally taken from the environment variable EGS_HOME.
               0  "  However, one can overwrite the environment by giving the
               0  "    -e | --egs-home  new_egs_home_location
               0  "  option on the command line.
               0  "  EGS_HOME must be set, either via the environment or via the command line,
               0  "  otherwise the job will abort.
               0  "
               0  "  Note on determining HEN_HOUSE:
               0  "  HEN_HOUSE is set to the value defined in machine.macros, which is
               0  "  created by the configure script or the configuration wizard in the GUI
               0  "  This value can be overwritten by giving the
               0  "    -H | --hen-house new_hen_house_location
               0  "  option on the command line.
               0  "  HEN_HOUSE is NOT taken from the environment.
               0  "
               0  "  The name of the temporary working directory is created using
               0  "    egsrun_getpid_ifile_hostname, if there was an input file, or
               0  "    egsrun_getpid_noinput_hostname, if there was no input file specified.
               0  "  In the above, getpid is the process id returned bt the getpid() intrinsic
               0  "  and hostname is the host name as determined by egs_get_hostnm().
               0  "  During run time, all output from the program (the .egslog file and
               0  "  all other files specified in the .io file) is kept in the
               0  "  temporary working directory. After succesful completion, egs_finish
               0  "  moves all output back to the user code area and removes the
               0  "  temporary working directory. This implies that if for whatever reason
               0  "  the job terminates prematurely, the temporary working directory
               0  "  with all output will be left behind.
               0  "
               0  "
               0  "
               0  "******************************************************************************
               0  subroutine egs_init;
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/my_times/;
               0  $REAL dum;
               0
               0
               0
               0
               0
               0  call egs_set_defaults;
               0  call egs_check_arguments;
               0  call egs_init1;
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_init1;
               0  "******************************************************************************
               0
               0  implicit none;
               0  ;COMIN/EGS-IO,MISC,my_times/;
               0  integer   l, lnblnk1, l1, l2;
               0  integer   i;
               0  character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
               0  line*80,
               0  line1*80,dattim*24;
               0  $LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home,is_opened;
               0  $INTEGER  mypid;
               0  integer   getpid;
               0  integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
               0  $REAL     dum;
               0  $declare_write_buffer;
               0
               0  t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
               0  call egs_date_and_time(t_first);
               0
               0  $set_string(line,'=');
               0  $set_string(line1,'.');
               0
               0  " Handy macros for checking command line arguments "
               0  REPLACE {$check_get_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg-1 [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; call getarg(i+1,{P3}); EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$check_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  IF(~is_pegsless)[
               1      " Get the pegs4 data file "
               1      on_egs_home = .false.;
               1      inquire(file=pegs_file,exist=ex);
               1      IF( ex ) [
               2          kmpi=egs_get_unit(kmpi);
               2          IF(kmpi<0)[
               3              $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               3              ]
               2          open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               2          $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               2          goto :found_pegs_file:;
               2          ]
               1      arg = $cstring(pegs_file);
               1      ex = egs_strip_extension(arg,'.pegs4dat');
               1      l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
               1      l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              on_egs_home = .true.;
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1      l = lnblnk1(hen_house);
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1
               1      $egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));
               1
               1      ]
               0
               0  :found_pegs_file:
               0  ;
               0  " Open egsnrc data files "
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  "set proposed unit numbers"
               0  i_nist_data=76;
               0  i_incoh=78;
               0  i_photo_relax=77;
               0  i_photo_cs=79;
               0  i_mscat=11;
               0
               0  REPLACE {$open_data_file(#,#,#,#);} WITH {;
            {  0  $set_string({P2},' ');
            {  0  {P2} = $cstring({P1}) // {P3};
            {  0  inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
            {  0  IF( ~ex ) [
            {  0  $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
            {  0  ]
            {  0  IF( ~is_opened ) [
            {  0  {P4}=egs_get_unit({P4});
            {  0  IF({P4}<0)[
            {  0  $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
            {  0  $cstring({P2}));
            {  0  ]
            {  0  open({P4},file={P2},status='old',err=:data_file_error:);
            {  0  ]
            {  0  ELSE [ {P4} = itmp; ]
            {  0  $egs_debug('(a,a)','opened data file ',$cstring({P2}));
            {  0  };
               0  $open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
               0  $open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);
               0
               0  $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0
               0  have_input = .false.;
               0  i_input=5;
               0  IF( lnblnk1(input_file) > 0 ) [
               1      have_input = .true.;
               1      l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
               1      l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
               1      IF( l + l1 + l2 > 1024 ) [
               2          $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
               2          ]
               1      ex = egs_strip_extension(input_file,'.egsinp');
               1      tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ~ex ) [
               2          $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
               2          ]
               1      $AVAILABLE_UNIT(i_input,tmp_string);
               1      open(i_input,file=tmp_string,status='old',err=:open_input_error:);
               1      ]
               0
               0  " Construct a temporary directory name to run from "
               0  $set_string(work_dir,' ');
               0  work_dir = 'egsrun_'; mypid = getpid();
               0  call egs_itostring(work_dir,mypid,.false.);
               0  call egs_get_hostnm(host_name);
               0  IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
               0  IF( have_input ) [
               1      work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               1      '_' // $cstring(host_name) // $file_sep;
               1      ]
               0  ELSE [
               1      work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               1      $file_sep;
               1      ]
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               0  DO i=1,lnblnk1(tmp_string) [
               1      IF( tmp_string(i:i) = '/' ) [
               2          tmp_string(i:i) = $file_sep;
               2          ]
               1      ]
               0  ex = egs_isdir(tmp_string);
               0  IF( ex ) [
               1      $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
               1      ]
               0  tmp1_string = 'mkdir ' // $cstring(tmp_string);
               0  l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
               0  " some systems need the command string to be 0 terminated"
               0  istat = egs_system(tmp1_string);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
               1      ]
               0
               0  call egs_open_units(.true.);
               0
               0  " Now print a summary of what happened "
               0  $egs_info('(a)',line);
               0  $egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
               0  call egs_get_fdate(dattim);
               0  $egs_info('(a,/,a)',dattim,line);
               0
               0  REPLACE {$write_description(#);} WITH {;
            {  0  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
            {  0  $egs_info('(a,$)',line1(:l));
            {  0  };
               0  pos1 = lnblnk1('output file(s)');
               0  pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
               0  pos2 = min(pos2,80-lnblnk1(user_code));
               0  $set_string(tmp_string,' '); tmp_string = pegs_file;
               0  call egs_strip_path(tmp_string);
               0  ex = egs_strip_extension(tmp_string,'.pegs4dat');
               0  IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
               0  ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
               0  IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
               1      $set_string(tmp_string,' '); tmp_string = pegs_file;
               1      ]
               0  pos2 = min(pos2,80-lnblnk1(tmp_string));
               0  pos2 = min(pos2,80-lnblnk1(host_name));
               0  pos2 = min(pos2,80-lnblnk1($CONFIG_TIME));
               0  IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
               0  pos2 = min(pos2,80-lnblnk1(output_file));
               0  IF( pos2 < pos1+2 ) pos2 = pos1 + 2;
               0
               0  $write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
               0  $write_description('configuration time'); $egs_info('(a)',$CONFIG_TIME);
               0  $write_description('app compile time'); $egs_info('(a)',COMPILE_TIME);
               0  $write_description('git commit hash'); $egs_info('(a)',GIT_HASH);
               0  $write_description('application'); $egs_info('(a)',$cstring(user_code));
               0  $write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
               0  $write_description('using host'); $egs_info('(a)',$cstring(host_name));
               0  IF( have_input ) [
               1      $write_description('input file'); $egs_info('(a)',$cstring(input_file));
               1      ]
               0  $write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
               0  IF( n_parallel > 0 ) [
               1      $write_description('number of parallel jobs');
               1      $egs_info('(i2)',n_parallel);
               1      $write_description('job number'); $egs_info('(i2)',i_parallel);
               1      ]
               0  $egs_info('(a)',line);
               0
               0  IF (is_uniform_run)[
               1      $egs_info('(//a,i0,a,i0,a//)',
               1      '-> User requests uniform run control. I am job # ',
               1      i_parallel,' of ',n_parallel,' jobs');
               1      ]
               0
               0  return;
               0
               0  " Errors "
               0  :open_input_error:
               0  $egs_fatal(*,'failed to open input file ',$cstring(tmp_string));
               0
               0  :open_pegs_error:
               0  $egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));
               0
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_check_arguments;
               0  "*****************************************************************************
               0  implicit none;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character arg*256,tmp_string*512, line1*80;
               0  $LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home;
               0  integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
               0  $declare_write_buffer;
               0
               0  narg = iargc();
               0  IF( narg < 1 ) return;
               0
               0  " Check for hen_house "
               0  $check_get_argument('-H','--hen-house',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(hen_house,' ');
               1      IF( l > 0 ) [
               2          IF( l > 254 ) [
               3              $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
               3              ]
               2          hen_house(:l) = $cstring(arg);
               2          IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
               2          ]
               1      ELSE [
               2          $egs_fatal('(a)',' empty argument after -H');
               2          ]
               1      DO i=1,lnblnk1(hen_house) [
               2          IF( hen_house(i:i) = '/' ) [
               3              hen_house(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(hen_house) ) [
               1      $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
               1      $warning('(a)','does not exist. Hope you know what you are doing.');
               1      ]
               0
               0  " Check if the user requested help "
               0  $check_argument('-h','--help',arg);
               0  IF( have_arg ) [
               1      call getarg(0,arg); call egs_strip_path(arg);
               1      $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
               1      tmp_string = $cstring(hen_house) // 'pieces/help_message';
               1      i_help=98;
               1      i_help=egs_get_unit(i_help);
               1      IF(i_help<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
               2          ]
               1      open(i_help,file=tmp_string,status='old',err=:no_help_file:);
               1      LOOP [
               2          read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
               2          $egs_info('(a)',line1);
               2          ]
               1      :end_of_help:;
               1      $CALL_EXIT(0);
               1      :no_help_file:;
               1      $egs_fatal(*,'Did not find the help_message file!');
               1      ]
               0
               0  " Check for batch option "
               0  $check_argument('-b','--batch',arg);
               0  IF( have_arg ) is_batch = .true.;
               0
               0  " Check for parallel run option"
               0  $check_get_argument('-P','--parallel',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_parallel_arg:) n_parallel;
               1      IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
               1      goto :ok_parallel_arg:;
               1      :wrong_parallel_arg:;
               1      $egs_warning(*,
               1      ' Wrong/missing parallel job number argument, -P option ignored');
               1      n_parallel = 0;
               1      :ok_parallel_arg:;
               1      ]
               0
               0  $check_get_argument('-j','--job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_job_arg:) i_parallel;
               1      IF( i_parallel < 0 ) goto :wrong_job_arg:;
               1      goto :ok_job_arg:;
               1      :wrong_job_arg:;
               1      $egs_warning(*,' Wrong/missing job argument, -j option ognored');
               1      i_parallel = 0;
               1      :ok_job_arg:;
               1      ]
               0
               0  $check_get_argument('-f','--first-job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_first_job_arg:) first_parallel;
               1      IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
               1      goto :ok_first_job_arg:;
               1      :wrong_first_job_arg:;
               1      $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
               1      first_parallel = 1;
               1      :ok_first_job_arg:;
               1      ]
               0
               0  IF( n_parallel > 0 | i_parallel > 0 ) [
               1      IF( n_parallel*i_parallel = 0 ) [
               2          $egs_warning(*,'You need to specify number of jobs AND job number ',
               2          '=> will not use parallel run ');
               2          n_parallel = 0; i_parallel = 0;
               2          ]
               1      IF( first_parallel > i_parallel ) [
               2          $egs_warning(*,'i_parallel (',i_parallel,
               2          ') can not be smaller than first_parallel (',first_parallel,')');
               2          first_parallel = i_parallel;
               2          ]
               1      ]
               0
               0  " Check for run control option "
               0  $check_argument('-u','--urc',arg);
               0  IF( have_arg ) is_uniform_run = .true.;
               0
               0  $egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));
               0
               0  " Check for egs_home "
               0  $check_get_argument('-e','--egs-home',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(egs_home,' ');
               1      IF( l = 0 ) [
               2          $egs_fatal('(a)',' empty argument after -e');
               2          ]
               1      IF( l > 254 ) [
               2          $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
               2          ]
               1      egs_home(:l) = $cstring(arg);
               1      IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
               1      DO i=1,lnblnk1(egs_home) [
               2          IF( egs_home(i:i) = '/' ) [
               3              egs_home(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(egs_home) ) [
               1      $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
               1      ]
               0  $egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));
               0
               0  " Get the pegs4 data file "
               0  on_egs_home = .false.;
               0  is_pegsless=.false.;
               0  $check_get_argument('-p','--pegs-file',arg);
               0  IF( ~have_arg ) [
               1      $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
            '  1      in pegs-less mode with media details specified in input file.');
               1      is_pegsless=.true.;
               1      ]
               0  ELSE[
               1      pegs_file = $cstring(arg);
               1      ]
               0
               0  " Deduct the user code name from the executable name "
               0  call egs_get_usercode(user_code);
               0
               0  " Check for an input file "
               0  $check_get_argument('-i','--input',arg);
               0  IF( have_arg ) [
               1      ex = egs_strip_extension(arg,'.egsinp');
               1      l2 = lnblnk1(arg) + lnblnk1('.egsinp');
               1      IF( l2 > 256 ) [
               2          $egs_fatal(*,'input file name is too long ',l2);
               2          ]
               1      input_file = $cstring(arg);
               1      ]
               0
               0  " Check for an output file option "
               0  $check_get_argument('-o','--output',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg);
               1      IF( l > 256 ) [
               2          $egs_fatal(*,'output file name is too long ',l);
               2          ]
               1      output_file(:l) = $cstring(arg);
               1      ]
               0  ELSE [
               1      IF( lnblnk1(input_file) > 0 ) [
               2          output_file(:lnblnk1(input_file)) = $cstring(input_file);
               2          ]
               1      ELSE [
               2          output_file = 'test';
               2          ]
               1      ]
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_open_units(flag);
               0  "******************************************************************************
               0  " Open output files.
               0  " Looks for output file definition in user_code.io.
               0  " In addition, if it is a batch run connects a .egslog file to unit 6.
               0  " If flag is .true., open the files in the temporary working directory,
               0  " else open them in the user code directory.
               0  "******************************************************************************
               0  implicit none;
               0  $LOGICAL flag;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
               0  input_line*100, arg*20;
               0  integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
               0  $LOGICAL  ex,is_open;
               0  $declare_write_buffer;
               0
               0  $set_string(tmp_string,' '); $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  IF( flag ) [
               1      tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               1      ]
               0  ELSE [
               1      tmp_string = $cstring(ucode_dir);
               1      ]
               0
               0  tmp_string = $cstring(tmp_string) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  $set_string(tmp1_string,' ');
               0  i_log=6;
               0  IF( is_batch ) [
               1      tmp1_string = $cstring(tmp_string) // '.egslog';
               1      $AVAILABLE_UNIT(i_log,tmp1_string);
               1      open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
               1      ]
               0  $set_string(tmp2_string,' ');
               0  tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
               0  inquire(file=tmp2_string,exist=ex);
               0  n_files = 0;
               0  IF( ex ) [
               1      i_iofile=99;
               1      i_iofile=egs_get_unit(i_iofile);
               1      IF (i_iofile<1)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
               2          ]
               1      open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
               1      LOOP [
               2          read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
               2          IF( input_line(1:1) = '#' ) NEXT;
               2          "The DEC and SGI compilers fail at the following statement!"
               2          "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
               2          read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
               2          istart = 1;
               2          DO i=lnblnk1(input_line),1,-1 [
               3              IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
               3              ]
               2          DO i=1,len(arg) [ arg(i:i) = ' '; ]
               2          DO i=istart,lnblnk1(input_line) [
               3              arg(i+1-istart:i+1-istart) = input_line(i:i);
               3              ]
               2          inquire(unit=u,opened=is_open);
               2          IF( is_open ) [
               3              $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
               3              'Unit ',u,' which you want to connect to a ',
               3              $cstring(arg),' file ',
               3              'is already in use. Will assume this code is being used as',
               3              'a shared library source and this file will be opened explicitly.');
               3              ]
               2          ELSE[
               3              n_files = n_files + 1;
               3              IF( n_files > $mx_units ) [
               4                  $egs_fatal(*,'Too many units requested in .io.',
               4                  ' Increas $mx_units and retry');
               4                  ]
               3              file_units(n_files) = u;
               3              $set_string(file_extensions(n_files),' ');
               3              l = lnblnk1(arg);
               3              IF( l > $max_extension_length ) [
               4                  $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
               4                  $max_extension_length,' chars. ',
               4                  'Increase $max_extension_length and retry ');
               4                  ]
               3              file_extensions(n_files) = $cstring(arg);
               3              tmp1_string = $cstring(tmp_string) // $cstring(arg);
               3              open(u,file=tmp1_string,status='unknown');
               3              $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
               3              ' to unit ',u);
               3              ]
               2          :end_of_ioline:
               2          ]
               1      :end_of_iofile:
               1      close(i_iofile);
               1      ]
               0  return;
               0
               0  :output_file_error:
               0  $egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));
               0
               0  :io_file_error:
               0  $egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
               0  return; end;
               0
               0
               0  "******************************************************************************
               0  subroutine egs_finish;
               0  "******************************************************************************
               0  " This subroutine becomes the last step in every EGSnrc user code.
               0  " It's purpose is to move the all output files from the temporary working
               0  " directory to the user code directory and to remove the working dir.
               0  " This was previously done by the egs_run script.
               0  " This routine also prints a summary to standard output.
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/EGS-IO,my_times/;
               0  character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
               0  character dattim*24;
               0  integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
               0  $LOGICAL is_open,egs_isdir;
               0  $REAL    t1,t2,tt_cpu;
               0  $declare_write_buffer;
               0
               0  $set_string(line,'=');
               0  IF( n_parallel = 0 | i_parallel > 0 ) [
               1      "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
               1      "or if it is parallel but it is not the final egs_finish (after combining"
               1      "results from parallel runs)"
               1      t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
               1      t1 = t_elapsed; t2 = t1/3600;
               1      $egs_info('(//a,/,a,/)',line,'Finished simulation');
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
               1      t1 = tt_cpu; t2 = t1/3600;
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
               1      $egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
               1      ]
               0  call egs_get_fdate(dattim);
               0  $egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);
               0
               0  " Close all I/O units "
               0  n_open=0;
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code);
               0  DO i=1,$max_unit [
               1      IF( is_batch | i ~= i_log ) [
               2          inquire(i,opened=is_open);
               2          IF( is_open ) [
               3              inquire(i,name=fname);
               3              IF(index($cstring(fname),$cstring(base))>0)[
               4                  close(i); n_open = n_open+1; ]
               3              ]
               2          ]
               1      ]
               0
               0  "If work_dir is empty, this is a second call to egs_finish for the last"
               0  "job in a parallel run. This implies that the temporary working "
               0  "directory has been already removed => just return"
               0
               0  IF( lnblnk1(work_dir) = 0 ) [ return; ]
               0
               0  " Now generate a junk file in the working directory so that the move "
               0  " command does not fail in case there are no files "
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir);
               0  DO i=1,lnblnk1(base) [
               1      IF( base(i:i) = '/' ) [
               2          base(i:i) = $file_sep;
               2          ]
               1      ]
               0  IF( egs_isdir(base) ) [
               1      $set_string(tmp_string,' '); $set_string(junk_file,' ');
               1      junk_file = $cstring(work_dir);
               1      l = lnblnk1(junk_file); junk_file(l:l) = ' ';
               1      junk_file = $cstring(junk_file) // '_junk';
               1      tmp_string = $cstring(base) // $cstring(junk_file);
               1      i_junk=99;
               1      i_junk=egs_get_unit(i_junk);
               1      IF(i_junk<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
               2          ]
               1      open(i_junk,file=tmp_string,status='unknown');
               1      write(i_junk,*) 'junk';
               1      close(i_junk);
               1
               1      " Move all files from the working directory to the user code directory "
               1      $set_string(base1,' ');
               1      base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               1      $cstring(work_dir);
               1      base1 = $cstring(egs_home) // $cstring(user_code);
               1      $set_string(tmp_string,' ');
               1      tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
               1      l = lnblnk1(tmp_string)+1;
               1      tmp_string(l:l) = char(0);
               1      istat = egs_system(tmp_string);
               1      IF( istat ~= 0 ) [
               2          $egs_warning(*,'Moving files from working directory failed ?');
               2          $warning(*,'=> will not remove working directory');
               2          ]
               1      ELSE [
               2          " Remove the working directory "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $remove_directory // $cstring(base);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = egs_system(tmp_string);
               2          IF( istat ~= 0 ) [
               3              $egs_warning(*,'Failed to remove working directory ',
               3              $cstring(work_dir));
               3              ]
               2          " Remove the junk file "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = unlink(tmp_string);
               2          ]
               1      ]
               0
               0  " Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
               0  " in the user code directory "
               0  $set_string(work_dir,' ');
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_set_defaults;
               0  "******************************************************************************
               0  " Replaces BLOCK DATA "
               0  implicit none;
               0  $COMIN-SET-DEFAULTS;
               0
               0  integer  i,j,lnblnk1;
               0  $TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
               0  character fool_dec;
               0  data MEDIA1/$S'NAI                     '/;
               0  data fool_dec/'/'/;
               0  data fool_intel_optimizer/.false./;
               0
               0  vacdst = 1e8;
               0  $set-region-by-region-defaults;
               0
               0  eii_flag = 0; "No EII by default. "
               0  eii_xfile = 'Off';
               0  eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
               0  "========================================="
               0  "See egsnrc.macros for defaults used below"
               0  "========================================="
               0  xsec_out = $XSEC-DEFAULT;
               0  photon_xsections = $XDATA-DEFAULT;"default photon xsection"
               0  comp_xsections = $COMP-XDATA-DEFAULT;
               0  eadl_relax = $EADL-RELAX-DEFAULT;
               0  mcdf_pe_xsections = $MCDF-PE-DEFAULT;
               0  "Ali:photonuc, 2 lines"
               0  photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
               0  "EMH:emf"
               0  ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented ONLY for the C++ applications     "
               0  BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
               0  Bx=BxIN;    By=ByIN;    Bz=BzIN;
               0  Bx_new=Bx;  By_new=By;  Bz_new=Bz;
               0  emfield_on=.false.;
               0  IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               1      emfield_on=.true.
               1      ]
               0
               0  DO i=1,$MXMED [
               1      iraylm(i) = 0; "Rayleigh data available?"
               1      DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
               1      DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
               1      " set all thresholds to zero "
               1      /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
               1      ]
               0  DO i=1,$MXSHXSEC [
               1      DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
               1      ]
               0  ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
               0  ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
               0  pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
               0  itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
               0  iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
               0  rhof = 1;
               0  DO i=1,5 [ iausfl(i) = 1; ]
               0  "Ali:photonuc, line below already includes iarg=29,30"
               0  DO i=6,$MXAUS [ iausfl(i) = 0; ]
               0  ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
               0  skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
               0  transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
               0  bca_algorithm = $BCA-ALGORITHM-DEFAULT;
               0  exact_bca = $EXACT-BCA-DEFAULT;
               0  spin_effects = $SPIN-EFFECTS-DEFAULT;
               0  count_pII_steps = 0; count_all_steps = 0;
               0  radc_flag = 0;
               0  nmed = $default_nmed;
               0  kmpi = 12; kmpo = 8; dunit = 1;
               0  rng_seed = 999999;
               0  latchi = 0;
               0
               0  rmt2 = 2*rm; rmsq = rm*rm;
               0
               0  pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
               0  nbr_split = 1;
               0  i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;
               0
               0  $set_string(hen_house,' ');
               0  i = lnblnk1($HEN_HOUSE);
               0  hen_house(:i) = $HEN_HOUSE;
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;
               0
               0  n_files = 0;
               0  $set_egs_home;
               0  i = lnblnk1(egs_home);
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
               0  $set_string(input_file,' ');
               0  $set_string(output_file,' ');
               0  $set_string(work_dir,' ');
               0  $set_string(pegs_file,' ');
               0  $set_string(host_name,' ');
               0  n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
               0  first_parallel = 1;
               0  is_uniform_run = $URC-DEFAULT;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_combine_runs(combine_routine,extension);
               0  "*****************************************************************************
               0  " This subroutine loops over job number i from 1 to $max_unit,
               0  " checks if the file output_file_wi.extension exists, and if yes,
               0  " calls the external subroutine combine_routine with that file name.
               0  "*****************************************************************************
               0  implicit none;
               0  external combine_routine;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  character*1024 tmp_string,base,command,outfile,parfile_name,base1,
               0  text_string;
               0  integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
               0  $INTEGER i,k,j,numparfiles,textindex;
               0  integer urcSleep, urcCheckIntervals;
               0  $LOGICAL ex,iwin;
               0
               0  iwin=.false.; "start off assuming a non-Windows system"
               0
               0  urcSleep          = $URC-SLEEP;    "Set to 1 s in egsnrc.macros"
               0  urcCheckIntervals = $URC-INTERVALS;"Set to 1 in egsnrc.macros"
               0
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w';
               0
               0  "the following is to count the number of output files from"
               0  "a parallel run"
               0  $set_string(base1,' ');
               0  base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w*' // $cstring(extension);
               0  $set_string(outfile,' ');
               0  outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  'parfiles_tmp';
               0
               0  :check-output-files:;
               0  "try Unix/Linux first"
               0  $set_string(command,' ');
               0  command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)["now assume a Windows system"
               1      command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
               1      $cstring(outfile);
               1      istat = egs_system($cstring(command));
               1      IF(istat~=0)[
               2          $egs_fatal(*,
               2          ' Failed to write number of output files from parallel runs.');
               2          ]
               1      ELSE [
               2          iwin=.true.;
               2          ]
               1      ]
               0
               0  "now open parfiles_tmp and read the number of files"
               0  ipar=1;
               0  ipar=egs_open_file(ipar,0,1,$cstring(outfile));
               0  IF(iwin)[
               1      "need to do a bit of manipulation of a text string to get the number of files
               1      read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
               1      text_string = $cstring(text_string);
               1      textindex = index(text_string,'File(s)');
               1      text_string = text_string(:textindex-1);
               1      read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
               1      ]
               0  ELSE[
               1      read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
               1      ]
               0  close(ipar);
               0
               0  #ifdef HAVE_C_COMPILER;
               0  IF ( is_uniform_run & numparfiles < n_parallel & urcCheckIntervals > 0 ) [
               1      call egs_sleep(urcSleep);"sleep for urcSleep seconds"
               1      urcCheckIntervals -= 1;
               1      goto :check-output-files:;
               1      ]
               0  #endif;
               0
               0  "now remove parfiles_tmp"
               0  $set_string(command,' ');
               0
               0  IF(iwin)[
               1      command = 'del /Q ' // $cstring(outfile);
               1      ]
               0  ELSE[
               1      command = 'rm -f ' // $cstring(outfile);
               1      ]
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)[
               1      $egs_warning(*,' Failed to delete list of output files from parallel runs.');
               1      ]
               0
               0  k=1;
               0  j=1;
               0  WHILE(j<=numparfiles) [
               1      $set_string(tmp_string,' ');
               1      tmp_string = $cstring(base);
               1      call egs_itostring(tmp_string,k,.false.);
               1      tmp_string = $cstring(tmp_string) // $cstring(extension);
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ex ) [
               2          call combine_routine(tmp_string);
               2          j=j+1;
               2          ]
               1      k=k+1;
               1      ]
               0  return;
               0
               0  :end_of_parfile:
               0  $egs_fatal(*,' Failed to read number of output files from parallel runs.');
               0  end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_strip_extension(filen,fext);
               0  "******************************************************************************
               0  " Check if the string pointed to by filen ends with the string pointed to by
               0  " fext and if yes, replace with blanks and return .true., otherwise return
               0  " false.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) filen,fext;
               0  integer  l1,l2,lnblnk1,i;
               0
               0  l1 = lnblnk1(filen); l2 = lnblnk1(fext);
               0  IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
               1      egs_strip_extension = .true.;
               1      DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
               1      ]
               0  ELSE [ egs_strip_extension = .false.; ]
               0  return; end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_is_absolute_path(fn);
               0  "******************************************************************************
               0  " Returns .true., if the string pointed to by fn is an absolute file name,
               0  " .fale. otherwise.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) fn;
               0  integer  i,lnblnk1;
               0  DO i=1,lnblnk1(fn) [
               1      IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
               1      ]
               0  egs_is_absolute_path = .false.; return; end;
               0
               0  "******************************************************************************
               0  integer  function egs_get_unit(iunit);
               0  "******************************************************************************
               0  " Returns iunit, if the Fortran I/O unit iunit is not currently in use.
               0  " Otherwise return the first free I/O unit found or -1 if none is available.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, i;
               0  $LOGICAL is_open;
               0
               0  IF( iunit > 0 ) [
               1      inquire(iunit,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = iunit; return; ]
               1      ]
               0  DO i=1,$max_unit [
               1      inquire(i,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = i; return; ]
               1      ]
               0  egs_get_unit = -1; return; end;
               0
               0  "******************************************************************************
               0  integer function egs_open_file(iunit,rl,action,extension);
               0  "******************************************************************************
               0  " Open a file trying to connect to Fortran I/O unit iunit.
               0  " If iunit is already in use, connect to the first free I/O unit found.
               0  " If no free I/O unit is found, then
               0  "   - if action = 0, return -1.
               0  "   - if action ~= 0, call the $egs_fatal macro.
               0  " If extension is an absolute file name (including path), use extension
               0  " as a file name, otherwise use output_file.extension in the temporary
               0  " working directory as name. In both cases use status='unknown' to open the
               0  " file. If rl = -1, open the file with stream access to write C-style binary
               0  " files. If rl = 0, open the file for formatted sequential access, otherwise
               0  " open for unformatted direct access with record length = rl.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, rl, action;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  $LOGICAL egs_is_absolute_path,is_open;
               0  integer  egs_get_unit;
               0  integer  i,lnblnk1;
               0  character*1024 tmp_string,error_string;
               0  $INTEGER the_unit;
               0  $declare_write_buffer;
               0
               0  egs_open_file = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_file = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      inquire(file=extension,opened=is_open);
               1      IF(is_open)[
               2          inquire(file=extension,number=the_unit);
               2          $egs_warning('(a,a,/,a,i3,/,a,/,a)',
               2          'File ',$cstring(extension),
               2          ' is already opened and connected to unit ',the_unit,
               2          ' Will not try to re-open this file, assuming it has been opened',
               2          ' by the .io file.');
               2          ]
               1      ELSE IF ( rl = -1 ) [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='stream');
               2          ]
               1      ELSE IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='unknown');
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='direct', recl=rl);
               2          ]
               1      egs_open_file = the_unit; return;
               1      ]
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  tmp_string = $cstring(tmp_string) // $cstring(extension);
               0
               0  inquire(file=tmp_string,opened=is_open);
               0  IF(is_open)[
               1      inquire(file=tmp_string,number=the_unit);
               1      $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
               1      'File ',$cstring(tmp_string),
               1      ' is already opened and connected to unit ',the_unit,
               1      ' Will not try to re-open this file, assuming it has been opened',
               1      ' by specifying it in the .io file.');
               1      ]
               0  ELSE IF ( rl = -1 ) [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='stream');
               1      ]
               0  ELSE IF( rl = 0 ) [
               1      open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='direct', recl=rl,err=:open_error:);
               1      ]
               0  egs_open_file = the_unit; return;
               0
               0  :open_error:
               0  error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
               0  // char(10) // 'iunit = ';
               0  call egs_itostring(error_string,iunit,.false.);
               0  error_string = $cstring(error_string) // ' the_unit = ';
               0  call egs_itostring(error_string,the_unit,.false.);
               0  $egs_fatal('(a)',$cstring(error_string));
               0  end;
               0
               0
               0  "******************************************************************************
               0  integer  function egs_open_datfile(iunit,rl,action,extension);
               0  "******************************************************************************
               0  "
               0  " Open an existing 'data' file.
               0  " First try to connect the file to Fortran unit iunit, but if iunit is
               0  " already in use, use the first free unit instead.
               0  " extension is the datafile extension (e.g. '.egsdat') .
               0  " The algorithm for searching for the file is as follows:
               0  "  1. If extension is an absolute file name (including path),
               0  "     try opening this file, else
               0  "  2. Try output_file.extension in the user code directory.
               0  "  3. Try input_file.extension in the user code directory (if input_file is
               0  "     different from output_file).
               0  " If the file is found, open it using status='old' for
               0  "   a) formatted sequential access, if rl=0
               0  "   b) unformatted direct access with record length = rl, if rl > 0.
               0  "
               0  " Return value:
               0  "   - if all is OK, return the opened unit number
               0  "   - if something fails, then
               0  "       * if action = 0, return error code less than 0.
               0  "       * if action != 0, call the $egs_fatal macro with an error message.
               0  "
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit,rl,action;
               0  character*(*) extension;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  integer  i,the_unit,lnblnk1,egs_get_unit;
               0  $LOGICAL egs_is_absolute_path;
               0  character base*1024, fn*1024;
               0  $declare_write_buffer;
               0
               0  egs_open_datfile = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_datfile = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='old',err=:no_datfile_0:);
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='old',form='unformatted',
               2          access='direct',recl=rl,err=:no_datfile_0:);
               2          ]
               1      egs_open_datfile = the_unit; return;
               1
               1      :no_datfile_0:;
               1      IF( action = 0 ) [ egs_open_datfile = -2; return; ]
               1      $egs_fatal(*,'Failed to open file ',$cstring(extension));
               1      ]
               0
               0  $set_string(base,' '); $set_string(fn,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  "fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(output_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_1:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_1:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_1:;
               0  $egs_warning('(a,a)','Failed to open ',$cstring(fn));
               0  $set_string(fn,' ');
               0  "fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(input_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_2:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_2:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_2:;
               0  $egs_fatal(*,'Failed to open data file');
               0  end;
               0
               0  "******************************************************************************
               0  integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
               0  "******************************************************************************
               0  " Open the file filen for sequential formatted I/O and return the unit
               0  " number it was connected to.
               0  " If iunit ~= 0, try to connect to unit |iuniti|, otherwise
               0  " use the first unconnected unit found.
               0  " If iunit > 0
               0  "    open the unit even if it was already open, if do_it_anyway is .true.,
               0  "    otherwise return -4.
               0  " If iunit < 0
               0  "    if the unit |iunit| is already in use and do_it_anyway is .true.,
               0  "    search for the first available unit, otherwise return -4.
               0  " Return values:
               0  "   unit number, if the file was succesfully opened.
               0  "   -1, if there was no free unit numer to connect to.
               0  "   -2, if the file does not exist.
               0  "   -3, if the file exist, but could not be opened.
               0  "   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit;
               0  $LOGICAL do_it_anyway;
               0  character*(*) filen;
               0
               0  $LOGICAL aux;
               0  $INTEGER the_unit,i;
               0
               0  inquire(file=filen,exist=aux);
               0  IF( ~aux ) [ egs_open_file_junk = -2; return; ]
               0  IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
               0  IF( the_unit ~= 0 ) [
               1      inquire(unit=the_unit,opened=aux);
               1      IF( aux ) [
               2          IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
               2          IF( iunit < 0 ) the_unit = 0;
               2          ]
               1      ]
               0  IF( the_unit = 0 ) [
               1      DO i=1,$max_unit [
               2          inquire(unit=i,opened=aux);
               2          IF( ~aux ) [ the_unit = i; EXIT; ]
               2          ]
               1      IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
               1      ]
               0  open(the_unit,file=filen,status='old',err=:failed_to_open:);
               0  egs_open_file_junk = the_unit; return;
               0  :failed_to_open:
               0  egs_open_file_junk = -3; return; end;
               0
               0  "==============================================================================
               0  subroutine egs_strip_path(fname);
               0  "==============================================================================
               0  " Strip the path name from fname (if any)
               0  implicit none;
               0  character*(*) fname;
               0  integer  i,l,l1,lnblnk1,j;
               0  character slash;
               0  slash = '/';
               0  l = lnblnk1(fname);
               0  DO i=1,l [
               1      IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
               1      ]
               0  DO i=l,1,-1 [
               1      IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
               2          l1 = l-i;
               2          fname(:l1) = fname(i+1:l);
               2          DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
               2          return;
               2          ]
               1      ]
               0  return; end;
               0
               0  "==============================================================================
               0  subroutine replace_env(fname);
               0  "==============================================================================
               0  "subroutine to replace environment variables (beginning with $) with their"
               0  "full names or ~ with the full name of $HOME"
               0  "Assumes environment variable or ~ appears only at the beginning of the"
               0  "file name"
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character*(*) fname;
               0  character*256 dirname;
               0  integer indsep,ind1,ind2;
               0
               0  indsep = index(fname,$file_sep);
               0  IF(indsep <= 0) return;
               0  "hope that the user has just supplied the file name"
               0  "and it is in the current directory"
               0
               0  ind1=index(fname,'$');
               0  ind2=index(fname,'~');
               0
               0  "examine first character of name"
               0  IF(ind1=1)[
               1      "get the environment variable"
               1      call getenv(fname(2:indsep-1),dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' First element in name does not specify a defined environment variable.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  ELSEIF(ind2=1)[
               1      call getenv('HOME',dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' HOME is undefined.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  return;
               0  end;
               0
               0  "=============================================================================
               0  subroutine egs_get_usercode(ucode);
               0  "=============================================================================
               0  " Deduct the user code name from the executable name
               0  " The algorithm assumes that the executable is called
               0  "   xxx[_debug|noopt][.exe]
               0  " and it will fail if this is not the case.
               0  "=============================================================================
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  character*(*) ucode;
               0  character*512 arg;
               0  integer  l,l1,lnblnk1,i;
               0  $declare_write_buffer;
               0
               0  call getarg(0,arg); call egs_strip_path(arg);
               0  l = lnblnk1(arg);
               0  IF( arg(l-3:l) = '.exe' ) [
               1      arg(l-3:l) = ' '; l = l - 4;
               1      ]
               0  IF( arg(l-5:l) = '_debug' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  IF( arg(l-5:l) = '_noopt' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  l1 = len(ucode);
               0  IF( l > l1 ) [
               1      $egs_fatal(*,' user code name is too long (',l,' chars)');
               1      ]
               0  $set_string(ucode,' '); ucode(:l) = arg(:l);
               0  return; end;
               0
               0  subroutine egs_itostring(string,i,leave_space);
               0  implicit none;
               0  character*(*) string;
               0  $INTEGER i;
               0  integer  l,lnblnk1,idiv,itmp,iaux;
               0  $LOGICAL first,leave_space;
               0  l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
               0  idiv = 1000000000; itmp = i; first = .false.;
               0  do while(idiv.gt.0) ;
               0  iaux = itmp/idiv;
               0  IF( (iaux > 0 | first ) & l <= len(string) ) [
               1      string(l:l) = char(iaux+48); first = .true.; l = l+1;
               1      ]
               0  itmp = itmp - iaux*idiv; idiv = idiv/10;
               0  end do;
               0  return; end;
               0
               0  "=============================================================================
               0  $REAL function egs_rndm();
               0  "=============================================================================
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET egs_rndm;
               0  return; end;
               0
               0  "=============================================================================
               0  integer  function egs_add_medium(medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed,medname_len;
               0  character c;
               0  $LOGICAL  same;
               0  $declare_write_buffer;
               0
               0  l = min(len(medname),24); medname_len = l;
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
               1      ]
               0  DO imed=1,nmed [
               1      l = 24;
               1      DO i=1,24 [
               2          IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
               2          ]
               1      IF( l = medname_len ) [
               2          same = .true.;
               2          DO i=1,l [
               3              c = medname(i:i);
               3              IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
               3              ]
               2          IF( same ) [
               3              egs_add_medium = imed; return;
               3              ]
               2          ]
               1      ]
               0  nmed = nmed + 1;
               0  IF( nmed > $MXMED ) [
               1      $egs_fatal('(a,/,a,i3,a)',
               1      'In egs_add_medium: maximum number of media exceeded ',
               1      'Increase the macro $MXMED (currently ',$MXMED,') and retry');
               1      ]
               0  l = min(len(medname),24);
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
               1      media(i,nmed) = ' ';
               1      media(i,nmed)(1:1) = c;
               1      ]
               0  IF( l < 24 ) [
               1      DO i=l+1,24 [ media(i,nmed) = ' '; ]
               1      ]
               0  egs_add_medium = nmed;
               0  return; end;
               0
               0  subroutine egs_get_medium_name(imed,medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed;
               0  DO i=1,len(medname) [ medname(i:i) = ' '; ]
               0  IF( imed < 1 | imed > nmed ) [ return; ]
               0  l = 24;
               0  DO l=24,1,-1 [
               1      IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
               1      ]
               0  l = min(l,len(medname));
               0  DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
               0  return; end;
               0  ;
               0
               0  "============================================================================"
               0  "  Pass pointers to the cross section interpolation coefficients to          "
               0  "  an external subroutine                                                    "
               0  "============================================================================"
               0  subroutine egs_get_electron_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - eke0(imed))/eke1(imed);
               0  lemax = (meke(imed) - eke0(imed))/eke1(imed);
               0  IF( which = 1 ) [
               1      call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
               1      ] ELSE IF( which = 6 ) [
               1      call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
               1      ] ELSE IF( which = 7 ) [
               1      call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
               1      ] ELSE IF( which = 8 ) [
               1      call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
               1      ] ELSE IF( which = 9 ) [
               1      call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown electron data type ',which);
               1      ]
               0  return; end;
               0
               0  subroutine egs_get_photon_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/PHOTIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - ge0(imed))/ge1(imed);
               0  lemax = (mge(imed) - ge0(imed))/ge1(imed);
               0  IF( which = 1 ) [
               1      call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown photon data type ',which);
               1      ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine egs_print_binding_energies;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EDGE,MEDIA,EGS-IO/;
               0  $INTEGER    i,j;
               0  integer*4   lnblnk1;
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0  ' M1',' M2',' M3',' M4',' M5',
               0  ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0  $egs_info('(a,a,a)',
               0  'Binding energies from ',$cstring(photon_xsections),
               0  ' photon cross section library');
               0  DO j = 1,$MXELEMENT [
               1      DO i = 1,$MXPESHELL [
               2          IF ( binding_energies(i,j) > 0 ) [
               3              $egs_info('(a,i3,a,a,a,1pe12.4,a)',
               3              ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
               3              ]
               2          ]
               1      ]
               0
               0  return;end;
               0
               0
               0  "============================================================================="
               0  "  scale elastic scattering strength by a given factor                        "
               0  "============================================================================="
               0  subroutine egs_scale_xcc(imed,factor);
               0  implicit none;
               0  $INTEGER imed;
               0  $REAL    factor;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA/;
               0  IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_write_string(ounit,string);
               0  implicit none;
               0  $INTEGER ounit;
               0  character*(*) string;
               0  write(ounit,'(a,$)') string;
               0  $FLUSH_UNIT(ounit);
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_swap_2(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(2),tmp;
               0  tmp=c(2); c(2)=c(1); c(1)=tmp;
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_swap_4(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(4),tmp;
               0  tmp=c(4); c(4)=c(1); c(1)=tmp;
               0  tmp=c(3); c(3)=c(2); c(2)=tmp;
               0  return; end;
               0
               0
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0  " Utility subroutines and functions previously in egsnrc.mortran
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0
1              0  %E
               0  subroutine set_spline(x,f,a,b,c,d,n);
               0  "======================================================================"
               0  "
               0  " Sets cubic spline interpolation coefficients for the data contained  "
               0  " in the array f(n) at the abscissas x(n)                              "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    x(n),f(n),a(n),b(n),c(n),d(n);
               0
               0  $INTEGER m1,m2,m,mr;
               0  $REAL    s,r;
               0
               0  m1 = 2; m2 = n-1; s = 0;
               0  DO m=1,m2 [
               1      d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
               1      c(m) = r - s; s = r;
               1      ]
               0  /s,r,c(1),c(n)/=0;
               0  DO m=m1,m2 [
               1      c(m) = c(m) + r*c(m-1);
               1      b(m) = 2*(x(m-1) - x(m+1)) - r*s;
               1      s = d(m); r = s/b(m);
               1      ]
               0  mr = m2;
               0  DO m=m1,m2 [
               1      c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
               1      mr = mr - 1;
               1      ]
               0  DO m=1,m2 [
               1      s = d(m); r = c(m+1) - c(m); d(m) = r/s;
               1      c(m) = 3*c(m);
               1      b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
               1      a(m) = f(m);
               1      ]
               0  return; end;
               0  ;
               0
               0  $REAL function spline(s,x,a,b,c,d,n);
               0  "======================================================================"
               0  "                                                                      "
               0  " Returns the value of the function at s using the spline coefficients "
               0  " a,b,c,d, which must have been set using set_spline                   "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    s,x(n),a(n),b(n),c(n),d(n);
               0
               0  integer  m_lower,m_upper,direction,m,ml,mu,mav;
               0  $REAL    q;
               0
               0  IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
               0  ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
               0  IF ( s >= x(m_upper + direction) ) [
               1      m = m_upper + 2*direction - 1;
               1      ]
               0  ELSE IF( s <= x(m_lower+1-direction) ) [
               1      m = m_lower - 2*direction + 1;
               1      ]
               0  ELSE [   " Perform a binary search to find the interval s is in "
               1      ml = m_lower; mu = m_upper;
               1      WHILE ( iabs(mu-ml) > 1 ) [
               2          mav = (ml+mu)/2;
               2          IF( s < x(mav) ) [ mu = mav; ]
               2          ELSE             [ ml = mav; ]
               2          ]
               1      m = mu + direction - 1;
               1      ]
               0  q = s - x(m);
               0  spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
               0  return; end;
               0  ;
               0
1              0  %E "start of prepare_alias_table subroutine"
               0  "****************************************************************************
               0
               0  subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Prepare an alias sampling table, given the histogram probabilities
               0  " xs_array,fs_array.
               0  "*****************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
               1      IF( aux < 1e-30 ) aux = 1e-30;
               1      ws_array(i) = -aux; ibin_array(i) = 1;
               1      sum = sum + aux;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT_1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT_2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return; end;
               0  ;
               0
1              0  %E   " start of alias_sample1 function "
               0  "******************************************************************************
               0
               0  $REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Sample a random variable from the alias table
               0  "    xs_array,fs_array,ws_array,ibin_array
               0  " which must have been prepared with prepare_alias_table
               0  "
               0  "******************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $INTEGER j;
               0  $REAL    r1,r2,aj,x,dx,a,rnno1;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  aj = 1 + r1*nsbin; j = aj; aj = aj - j;
               0  IF( aj > ws_array(j) ) j = ibin_array(j);
               0  x = xs_array(j-1); dx = xs_array(j)-x;
               0  IF( fs_array(j-1) > 0 ) [
               1      a = fs_array(j)/fs_array(j-1)-1;
               1      IF( abs(a) < 0.2 ) [
               2          rnno1 = 0.5*(1-r2)*a;
               2          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
               2          ]
               1      ELSE [
               2          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
               2          ]
               1      ]
               0  ELSE [
               1      alias_sample1 = x + dx*sqrt(r2);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of prepare_alias_histogram routine "
               0  subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
               0  "*************************************************************
               0  "                                                                           "
               0  " Prepares an alias histogram for the probability array ws_array of         "
               0  " dimension nsbin.                                                          "
               0  " On return, the ws_array is modified and contains the alias weights,       "
               0  " ibin_array holds the alias indices.                                       "
               0  " To be used with the integer function sample_alias_histogram, which        "
               0  " returns a bin index j with probability ws_array(j)                        "
               0  "                                                                           "
               0  " Iwan Kawrakow, November 2001
               0  "***************************************************************************"
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      sum = sum + ws_array(i); ibin_array(i) = -1;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
               2          ]
               1
               1      DO j_l = 1,nsbin [
               2          IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
               2          ]
               1
               1      aux = sum - ws_array(j_l);
               1      ws_array(j_h) = ws_array(j_h) - aux;
               1      ws_array(j_l) = ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1
               1      ]
               0
               0  DO i=1,nsbin [
               1      IF( ibin_array(i) < 0 ) [
               2          ibin_array(i) = i; ws_array(i) = 1;
               2          ]
               1      ]
               0
               0  return;
               0  end;
               0
1              0  %E   " start of sample_alias_histogram function "
               0  $INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
               0  "***********************************************************************
               0  "
               0  " This function samples a bin index using the alias sampling technique.
               0  " The arrays ws_array and ibin_array of dimension nsbin must have been
               0  " prepared with the subroutine prepare_alias_histogram.
               0  "
               0  " Iwan Kawrakow, November 2001.
               0  "***********************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(*);
               0  $REAL     ws_array(*);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    r1,r2;
               0  $INTEGER ibin;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  ibin = 1 + nsbin*r1;
               0  IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
               0  sample_alias_histogram = ibin;
               0  return;
               0  end;
               0
1              0  %E   " start of gauss_legendre subroutine "
               0  "******************************************************************************
               0
               0  subroutine gauss_legendre(x1,x2,x,w,n);
               0
               0  "     Given the lower and upper limit of integration, x1 and x2,
               0  "     and given n, this routine returns arrays x and w,
               0  "     containing the abscissas and weights of the Gauss-Legendre
               0  "     n - point quadrature formula
               0  "
               0  "******************************************************************************
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER n;
               0  real*8   x1,x2,x(n),w(n);
               0
               0  real*8     eps,Pi;
               0  parameter (eps = 3.D-14, Pi = 3.141592654D0);
               0
               0  $INTEGER i,m,j;
               0  real*8   xm,xl,z,z1,p1,p2,p3,pp;
               0
               0  m = (n + 1)/2;
               0  xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
               0  DO i=1,m [
               1      z=cos(Pi*(i-.25d0)/(n+.5d0));
               1      LOOP [
               2          p1=1.d0; p2=0.d0;
               2          DO j=1,n [
               3              p3 = p2; p2 = p1;
               3              p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
               3              ]
               2          pp=n*(z*p1-p2)/(z*z-1.d0);
               2          z1=z; z=z1-p1/pp;
               2          ] UNTIL (abs(z-z1) < eps);
               1      x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
               1      w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of lnblnk1 function"
               0  "******************************************************************************
               0
               0  integer  function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  integer i;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
1              0  %E   " start of erf1 function "
               0  "************************************************************************
               0  "       an error function routine which is needed since some of
               0  "       the compiler don't have it as an intrinsic
               0  "
               0  "       Originally came from some library somewhere (Harwell I think)
               0  "       recoded in mortran
               0  "************************************************************************
               0
               0  $REAL FUNCTION ERF1(X);
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL x;
               0
               0  double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
               0  " (K=1) and for erfc(x) x>3 (K=2)
               0  double precision
               0  CONST,                   " 2/sqrt(pi)
               0  BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
               0  Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
               0  $INTEGER N,                     " recursion index n
               0  K,                     " K=1,2 for x <= 3 or x > 3
               0  NLIM(2);               " Maximum value of n in sum for K=1,2
               0
               0  DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
               0  -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
               0  0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
               0  -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
               0  0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
               0  -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
               0  0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
               0  -0.0000000000000005 ,  0.0000000000000001 ,
               0  0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
               0  -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
               0  0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
               0  0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
               0  -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;
               0
               0  DATA NLIM/ 22,16 /;
               0  DATA CONST/ 1.128379167095513 /;
               0
               0  IF( x > 3 ) [ y = 3/x; k = 2; ]
               0  ELSE        [ y = x/3; k = 1; ]
               0
               0  " Calculate sum of Chebyshev polynomials by backwards recursion
               0  "
               0  "       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
               0  "       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
               0  "                                      = ( B(0) - B(2) + A(0) ) / 2
               0  "
               0  "       where B(N+2) = B(N+1) = 0
               0  "       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
               0  "
               0  FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
               0  BN1 = 0.0;                       " Initialise B(N+2) = 0
               0  BN  = 0.0;                       " Initialise B(N+1) = 0
               0
               0  DO n = NLIM(K),0,-1 [
               1      BN2 = BN1; BN1 = BN;
               1      BN = FAC * BN1 - BN2 + A(N,K)
               1      ]
               0
               0  IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
               0  ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]
               0
               0  RETURN;
               0  end;
               0
1              0  %E   " start of zero function "
               0  "********************************************************"
               0  "   Finds minimum non-zero value which can be used for   "
               0  "   evaluating logarithms without getting a NAN.         "
               0  "                                                        "
               0  " Starting with 10^-20 and decreasing it by 5 orders of  "
               0  " magnitud at a time, a check is made until the compiler "
               0  " recognizes the number as zero and the previous number  "
               0  " used. The same procedure is applied to this number but "
               0  " decreasing it by one order of magnitud. Finally it is  "
               0  " divided by 2..10 until the zero-check is successful.   "
               0  "********************************************************"
               0  $REAL FUNCTION ZERO();
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER i;
               0  $REAL    x, xtemp;
               0
               0  x = 1.E-20;
               0  "jump over 5 orders of magnitude"
               0  DO i=1,100[
               1      IF (x = 0.0) [EXIT;]
               1      ELSE[xtemp = x;]
               1      x = x/1.E5;
               1      ]
               0  x = xtemp;
               0  "jump over 1 order of magnitude"
               0  DO i=1,5[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/10;
               1      ]
               0  x = xtemp;
               0  "divide it up by 2...10"
               0  DO i=2,10[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/i;
               1      ]
               0  zero = xtemp;
               0  return;end;
               0  ;
               0
1              0  %E   " start of toUpper function "
               0  "**************************************"
               0  "
               0  "   Converts a string to upper case.   "
               0  "                                      "
               0  "**************************************"
               0  character*512 function toUpper(a_string);
               0  character*(*) a_string;
               0  character*512 the_string;
               0  $INTEGER cursor, i, lnblnk1;
               0  toUpper = a_string; the_string = a_string;
               0  DO i=1, lnblnk1(the_string) [
               1      cursor=ICHAR(the_string(i:i));
               1      IF ((cursor.GE.97).AND.(cursor.LE.122)) [
               2          cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
               2          ]
               1      ]
               0  return; end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0  "================================================================="
               0  integer*1 function egs_read_byte(iunit, jrec);
               0  "================================================================="
               0  " Reads one byte from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*1 i_1;
               0  character c_1;
               0  equivalence (i_1,c_1);
               0  ;COMIN/EGS-IO/;
               0  read(iunit,rec=jrec,IOSTAT=ierr) c_1;
               0  IF (ierr.ne.0) [
               1      $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
               1      $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               1      egs_read_byte = -1; return;
               1      ]
               0  jrec = jrec + 1; egs_read_byte = i_1;
               0  return; end;
               0
               0  "================================================================="
               0  integer*2 function egs_read_short(iunit, jrec);
               0  "================================================================="
               0  " Reads short int from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*2 i_2;
               0  character c_2(2);
               0  equivalence (i_2,c_2);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+1[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_2(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_short = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 2; egs_read_short = i_2;
               0  return; end;
               0
               0  "================================================================="
               0  integer*4 function egs_read_int(iunit, jrec);
               0  "================================================================="
               0  " Reads integer from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*4 i_4;
               0  character c_4(4);
               0  equivalence (i_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_int = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_int = i_4;
               0  return; end;
               0
               0
               0  "================================================================="
               0  real*4 function egs_read_real(iunit, jrec);
               0  "================================================================="
               0  " Reads float from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  real*4 r_4;
               0  character c_4(4);
               0  equivalence (r_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_real = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_real = r_4;
               0  return; end;
               0
               0  "****************************************************************
               0  "*                                                              *
               0  "*                 Function ibsearch(a, nsh, b)                 *
               0  "*                                                              *
               0  "*       binary search for an element l of array b such that    *
               0  "*   b[l] =< a < b[l+1], array must be monotonically increasing *
               0  "*                                                              *
               0  "****************************************************************
               0  $INTEGER function ibsearch(a, nsh, b);
               0  implicit none;
               0  $REAL a, b(*);
               0  $INTEGER min,max,help,nsh;
               0  $REAL x;
               0  min = 1; max = nsh; x = a;
               0  WHILE ( min < max-1 )[
               1      help = (max+min)/2;
               1      IF ( b(help).le.x)[min = help;]
               1      ELSE[max = help;]
               1      ]
               0  ibsearch = min;
               0  return;end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parallel processing functions                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " The following set of functions only gets included if we found a working     "
               0  " C compiler that can compile egs_c_utils.c                                   "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  #ifdef HAVE_C_COMPILER;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_create_lockfile(flag);
               0  "*****************************************************************************
               0  " Create a lock file in the user code directory to store parallel processing
               0  " information. To be called from job #1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_create_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to create a lock file named ',$cstring(fname));
               1      ]
               0  egs_create_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_open_lockfile(flag);
               0  "*****************************************************************************
               0  " Open a lock file in the user code directory to read/write parallel
               0  " processing info. To be called from all jobs except 1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_open_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to open the lock file named ',$cstring(fname));
               1      ]
               0  egs_open_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_remove_lockfile(istat);
               0  "*****************************************************************************
               0  $INTEGER istat;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_remove_file(fname,istat);
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,dres);
               0  "*****************************************************************************
               0  "
               0  " This subroutine controls a parallel run. It only works if the EGS_HOME
               0  " directory is the same for all machines participating in the parallel
               0  " processing (e.g. EGS_HOME is on a NFS for *nix or on a network share on
               0  " Windows).
               0  " n_case: number of histories to be run (all jobs, not just the current
               0  "         job)  (input)
               0  " n_run:  number of histories the user code should run (output). If n_run = 0,
               0  "         then finish simulation, clean up, call egs_finish and
               0  "         egs_pjob_finish (in that order) and exit.
               0  " n_left  no. of histories left to run after current job has been submitted
               0  " n_tot:  should be set to number of histories from previous runs (if any)
               0  "         for first call from job number 1. For all other jobs and for all
               0  "         other calls from job 1, it is set by egs_pjob_control to the
               0  "         number of histories run so far (including previous runs and other
               0  "         parallel jobs).
               0  "         Note: n_case, n_run and n_tot are $LONG_INT
               0  " sum,    input. for first call and job 1, score and score squared for quantity
               0  " sum2:   of interest, should be zero for first call from jobs other than 1.
               0  "         score for quantity of interest since last call to this subroutine
               0  "         for all other calls.
               0  " res:    combined result for the quantity of interest from previous runs
               0  "         and other parallel jobs, output
               0  " dres:   relative uncertainty of res in %
               0  "
               0  " The shower loop of a user code that wants to use the new parallel processing
               0  " implementation should look something like this:
               0  "
               0  " /sum,sum2/=0; (or result from a previous run, if i_parallel=1)
               0  " /last_sum,last_sum2/=0;
               0  " :start_simulation:
               0  " x=sum-last_sum; x2=sum2-last_sum2; last_sum=sum; last_sum2=sum2;
               0  " call egs_pjob_control(ncase,n_run,n_tot,x,x2,res,dres);
               0  " IF( n_run = 0 ) goto :end_simulation:
               0  " write(6,*) ' running ',n_run,' histories,' n_tot so far: ',n_tot;
               0  " write(6,*) ' result so far: ',res,' +/- ',dres,' %';
               0  " DO icase=1,n_run [
               0  "    get source particle, call shower. sum and sum2 are updated
               0  " ]
               0  " goto :start_simulation:;
               0  " :end_simulation:
               0  " analyze and output results for this job.
               0  " call egs_finish;
               0  "   (after egs_finish all output files are closed and moved to the user code
               0  "    directory from the temporary working directory).
               0  " call egs_pjob_finish(combine_results,'.egsdat');
               0  " output combined results.
               0  " end;
               0  "
               0  " In the above, combine_results is a user supplied subroutine that
               0  " combines parallel runs and takes a file name as an argument.
               0  " egs_pjob_finish  decreases the number of running job, n_job, in the
               0  " job control file by one. If n_job > 0, it simply returns.
               0  " If n_job = 0 (i.e. this job is the last job), it checks for
               0  " data files output_file_wj.egsdat, j=1,99. For each file found, it calls
               0  " combine_results with that file name.
               0  "
               0
               0  implicit none;
               0  $LONG_INT ncase,n_run,n_tot;
               0  $REAL    sum,sum2,res,dres;
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $LONG_INT n_last,n_left,nn_tot;
               0  integer   t_dum(8);
               0  $INTEGER  i,lnblnk1,n_write,n_read,istat,n_job;
               0  $INTEGER  egs_create_lockfile, egs_open_lockfile;
               0  $REAL     tmp,tmp2;
               0  $LOGICAL first_time;
               0  character control_string*256;
               0  data first_time/.true./;
               0  save first_time,n_last;
               0
               0
               0
               0
               0  IF( is_uniform_run ) [
               1      IF (first_time)[
               2          n_run = ncase/n_parallel;
               2          first_time = .false.;
               2          ]
               1      ELSE[
               2          n_run = 0;
               2          ]
               1      n_left = 0;
               1      return;
               1      ]
               0
               0  IF( n_parallel <= 0 ) [
               1      n_run = ncase; return;
               1      ]
               0
               0  IF( first_time ) n_last = 0;
               0
               0  $set_string(control_string,' ');
               0  n_run = ncase/n_parallel/$N_CHUNKS;
               0  n_left = ncase;
               0
               0  REPLACE {$control_format} WITH {
            {  0  '(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)'};
               0
               0  IF( first_time ) [
               1      IF( n_run > n_left ) n_run = n_left;
               1      n_left = ncase - n_run;
               1
               1      IF( i_parallel = first_parallel ) [ "I'm first job => "
               2          "create the job control file"
               2          istat = egs_create_lockfile(1); "The 1 tells egs_create_lockfile to "
               2          "print an error message and exit if"
               2          "it fails."
               2          IF( n_tot > 1 ) [ "=> a continuation from a previous run "
               3              res = sum/n_tot; dres = sum2/n_tot - res*res;
               3              IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               3              ELSE [ dres = 99.9 ]
               3              ] ELSE [ res = 0; dres = 99.9; ]
               2
               2
               2
               2
               2
               2          write(control_string,$control_format)
               2          n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8);
               2          n_write = lnblnk1(control_string) + 1;
               2          call egs_write_control_file(control_string,n_write,istat);
               2          IF( istat ~= n_write ) [
               3              $egs_fatal(*,'job 1: failed to write to lock file ',n_write,istat);
               3              ]
               2          call egs_unlock_control_file(istat);
               2          IF( istat ~= 0 ) [
               3              $egs_fatal(*,'job 1: failed to unlock the file ',istat);
               3              ]
               2          first_time = .false.;
               2          n_max_parallel = 1; n_last = n_run;
               2          return;
               2          ]
               1      istat = egs_open_lockfile(1);
               1      ]
               0
               0  " Here for all calls except first call from job 1. "
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,err=:error_lockfile_read:) n_left,nn_tot,n_job,tmp,tmp2,
               0  res,dres,(t_dum(i),i=1,8);
               0
               0  " Update the number of histories finished so far "
               0  nn_tot = nn_tot + n_last;
               0
               0  " Update the score for the quantity of interest "
               0  tmp = tmp + sum; tmp2 = tmp2 + sum2;
               0
               0  " First call => increase number of running jobs "
               0  IF( first_time ) [
               1      first_time = .false.; n_job = n_job + 1;
               1      nn_tot = nn_tot + n_tot;
               1      ]
               0  n_tot = nn_tot;
               0
               0  " If n_tot > 1, do stat. analysis and put result is res, dres "
               0  IF( n_tot > 1 ) [
               1      res = tmp/n_tot; dres = tmp2/n_tot - res*res;
               1      IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               1      ELSE [ dres = 99.9 ]
               1      ] ELSE [ res = 0; dres = 99.9; ]
               0
               0  " Take another chunk of histories to run "
               0  IF( n_run > n_left ) [
               1      n_run = n_left; n_left = 0;
               1      ] ELSE [ n_left = n_left - n_run; ]
               0
               0  n_last = n_run;
               0
               0  " Write new job control info into job control string "
               0  $set_string(control_string,' ');
               0  write(control_string,$control_format)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8);
               0
               0  " Rewind again the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1
               1      ]
               0
               0  " Write the new job control string "
               0  n_write = lnblnk1(control_string) + 1;
               0  call egs_write_control_file(control_string,n_write,istat);
               0  IF( istat ~= n_write ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               1      n_write,istat);
               1      ]
               0
               0  " Finally unlock the job control file so that other jobs can access it. "
               0  call egs_unlock_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to unlock the file ',istat);
               1      ]
               0  IF( n_job > n_max_parallel ) n_max_parallel = n_job;
               0  return;
               0
               0  :error_lockfile_read:
               0  $egs_fatal('(a,/a)','Failed to read from job control file: got ',
               0  $cstring(control_string));
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_pjob_finish(n_job);
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER n_job;
               0
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $INTEGER  istat,i,lnblnk1,n_read,n_write;
               0  $LONG_INT n_left,n_tot;
               0  integer   t_start(8),t_end(8);
               0  $REAL     tmp,tmp2,res,dres,t_run;
               0  real      egs_time_diff;
               0  character control_string*256;
               0
               0
               0
               0
               0  IF( is_uniform_run )[
               1      IF( i_parallel = n_parallel )[
               2          n_job = 0;"I am the last job!!!"
               2          goto :complete_calculation:;
               2          ]
               1      ELSE ["nothing to do here"
               2          n_job = 1;"Only last job allowed to finish!"
               2          return;
               2          ]
               1      ]
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,end=:error2_lockfile_read:,err=:error2_lockfile_read:)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               0
               0  n_job = n_job - 1;
               0  IF( n_job > 0 ) [  " Other jobs still running "
               1      $set_string(control_string,' ');
               1      write(control_string,$control_format)
               1      n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               1      call egs_rewind_control_file(istat);
               1      IF( istat ~= 0 ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the ',
               2          'control file, error was:', istat);
               2          ]
               1      n_write = lnblnk1(control_string) + 1;
               1      call egs_write_control_file(control_string,n_write,istat);
               1      IF( istat ~= n_write ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               2          n_write,istat);
               2          ]
               1      call egs_unlock_control_file(istat);
               1      call egs_close_control_file(istat);
               1      return;
               1      ]
               0
               0  " If here, I'm the last job => remove job control file
               0
               0  call egs_close_control_file(istat);
               0  call egs_remove_lockfile(istat);
               0
               0  :complete_calculation:;
               0  i_parallel = 0; call egs_open_units(.false.);
               0  IF ( is_uniform_run )[
               1      $egs_info('(/a/,a,t55,i3/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      '***************************************************************');
               1      ]
               0  ELSE[
               1      call egs_date_and_time(t_end);
               1      t_run = egs_time_diff(t_start,t_end);
               1      $egs_info('(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      ' max. number of jobs executing simultaneously: ',n_max_parallel,
               1      ' elapsed time since first job started: ',t_run,' s (',t_run/3600,' h)',
               1      '***************************************************************');
               1      ]
               0  return;
               0
               0  :error2_lockfile_read:;
               0  $egs_fatal('(a,/a)',
               0  'In egs_pjob_finish: failed to read from control string ',
               0  $cstring(control_string));
               0
               0  return; end;
               0
               0
               0  #endif;
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 routines                                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but NOTE, this doesn't happen inside a REPLACE macro
               0  "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE EFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  $REAL4 E,V(8);
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM;
               0
               0  "*****SUBROUTINE TO COMPUTE ELECTRON FUNCTIONS TO BE FIT           "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  COMIN/THRESHP,DERCON,EGS-IO/;
               0  THBREM=RMP+APP;"threshold for bremsstrahlung"
               0  IF(IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)[
               1  "  REGULAR DATA SET OR"
               1  "   UNRESTRICTED COLLISIONAL(1) OR RADIATIVE(5) STOPPING POWERS"
               1  "write(58,*)' here e ',e;"
               1  BREM=BREMTM(E);
               1  AMOLL=AMOLTM(E);
               1  BHAB=BHABTM(E);
               1  ANNIH=ANIHTM(E);
               1  ESIG=BREM+AMOLL; "TOTAL ELECTRON CROSS-SECTION"
               1  V(1)=ESIG;
               1  PSIG=BREM+BHAB+ANNIH;"TOTAL POSITRON CROSS SECTION"
               1  V(2)=PSIG;
               1  V(3)=SPTOTE(E,AEP,APP); "TOTAL ELECTRON STOPPING POWER"
               1  V(4)=SPTOTP(E,AEP,APP);"TOTAL POSITRON STOPPING POWER"
               1  "EBR1=BREM/(BREM+AMOLL)"
               1  IF (ESIG.GT.0.0)[V(5)=BREM/ESIG;]
               1  ELSE["BELOW THRESHOLD FOR BOTH BREMS AND MOLLER. USE THE BRANCHING"
               2  "RATIO THAT EXISTED WHEN CROSS SECTION APPROACHED ZERO"
               2  IF (THBREM.LE.THMOLLP)[V(5)=1.0;]ELSE[V(5)=0.0;]
               2  ]
               1  V(6)=BREM/PSIG;"PBR1=BREM/(BREM+BHABA+ANNIH)"
               1  V(7)=(BREM+BHAB)/PSIG;"PBR2=(BREM+BHABA)/(PSIG)"
               1  "MAXIMUM ALLOWED TRANSPORT STEP, FROM MULTIPLE SCATTERING"
               1  V(8)=TMXS(E);
               1  "write(*,*)'v1,v2,v3,v4,v5,v6,v7,v8 ',v(1),v(2),v(3),v(4),v(5),v(6),v(7),v(8);"
               1  ]
               0  "  THE FOLLOWING ARE UNDOCUMENTED ADDITIONS"
               0  ELSEIF(IUNRSTP.EQ.2)[ "FULL CSDA DATA SET WITH NO DISCRETE INTERACTIONS"
               1  /V(1),V(2),V(5),V(6),V(7)/=0.0;
               1  "ZERO TOTAL CROSS SECTION FOR EL & POS, AND ZERO BRANCHING RATIOS"
               1  V(3) = SPTOTE(E,E,E);"  TOTAL UNRESTRICTED STOPPING POWER"
               1  V(4) = SPTOTP(E,E,E);
               1  V(8) = TMXS(E);]
               0  ELSEIF(IUNRSTP.EQ.3)["CONSIDER BREM AND ANNIHILATION IN FLIGHT AS"
               1  "     DISCRETE EVENTS BUT TREAT DELTAS IN CSDA"
               1  BREM=BREMTM(E);  ANNIH=ANIHTM(E);
               1  V(1)=BREM; "TOTAL X-SECTION IS JUST BREM"
               1  V(2)=BREM + ANNIH;"POSITRONS ALSO HAVE ANNIHILATION IN FLIGHT"
               1  V(3)=SPTOTE(E,E,APP);"UNRESTRICTED COLLISIONAL+RESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,E,APP);"    ''                             ''    "
               1  V(5)=1.0;"ALL ELECTRON EVENTS ARE BREM EVENTS"
               1  V(6)=BREM/V(2);"FRACTION FOR POSITRONS WHICH IS BREM"
               1  V(7)=V(6);"FRACTION WHICH IS BREM + COLLISION(=0)"
               1  V(8)=TMXS(E);]
               0
               0  ELSEIF(IUNRSTP.EQ.4)["CREATE SECONDARIES BUT HAVE NO DISCRETE BREM OR"
               1  "ANNIHILATION IN FLIGHT"
               1
               1  V(1)=AMOLTM(E);"ONLY MOLLERS FOR ELECTRONS"
               1  V(2)=BHABTM(E);"ONLY BHABHA FOR POSITRONS"
               1  V(3)=SPTOTE(E,AEP,E);"RESTRICTED COLLISIONAL + UNRESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,AEP,E);"         ''                         ''       "
               1  V(5)=0.0;"I.E. NEVER BREMS"
               1  V(6)=0.0;"I.E. NEVER BREMS"
               1  V(7)=1.0;"ALL BHABHA - NO ANNIHILATION"
               1  V(8)=TMXS(E);]
               0
               0  ELSE ["IUNRST=6 OR 7 NOT ALLOWED HERE"
               1  OUTPUT IUNRSTP; (//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/
               1  ' IUNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//);
               1  $CALL_EXIT(20);]
               0  RETURN;
               0  END; "END OF SUBROUTINE EFUNS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,BREMRM;
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.APP+RMP) [BREMTM=0.; ]
               0  ELSE [BREMTM=BREMRM(E0,APP,E0-RMP);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2;
               0  $INTEGER I;
               0  $REAL4    BREMRZ;
               0  COMIN/MIXDAT/;
               0  BREMRM=0.;
               0  DO I=1,NEP [BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BREMFZ;
               0  $REAL4  DUMMY,BREMDZ,QD,BREMFZ;
               0  "     INITIALIZE BREMFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BREMDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BREMDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)'2 e ',e;"
               0  DUMMY=BREMDZ(Z,E,K1);
               0  BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ');
               0  "write(58,*)'bremrz ',BREMRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BREMRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMDZ(Z,E,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4    Z,E,K,BRMSDZ;
               0  "***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
               0  "   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
               0  "   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
               0  "   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
               0  "   BREMDZ.. D-SIGMA/D-K FOR BREMS IN Z                              "
               0  "   BRMSDZ.. K*(D-SIGMA/D-K) FOR SOFT ENERGY LOSS FROM BREMS IN Z    "
               0
               0  "EVALUATES EQUATION 2.7.108 IN SLAC-265"
               0
               0  BREMDZ=BRMSDZ(Z,E,K)/K;
               0  "write(58,*)'bremdz,z,e,k ',BREMDZ,z,e,k;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMDZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 K,BRMSFZ;
               0  BREMFZ=BRMSFZ(K)/K;
               0  "write(58,*)'bremfz ',BREMFZ;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 K;
               0  $REAL4 EMKLOC,DELTA,SB1,SB2,EE;
               0  COMIN/LBREMZ/;
               0  EMKLOC=EBREMZ-K;
               0  IF(EMKLOC.EQ.0.0) [EMKLOC=1.E-25;]
               0  DELTA=DELC*K/EMKLOC;
               0  IF (DELTA.GE.DELTAM) [BRMSFZ=0.0;]
               0  ELSE [IF (DELTA.LE.1.)[
               2  SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
               2  SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
               1  ELSE [SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ;
               2  SB2=SB1;]
               1  EE=EMKLOC/EBREMZ;
               1  BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2);]
               0  "write(58,*)' const,ee,sb1,sb2,brmsfz ',const,ee,sb1,sb2,brmsfz;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    T0,AMOLRM;
               0  "***TOTAL CROSS SECTION FOR MOLLER SCATTERING WITH INCIDENT ELECTRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.THMOLLP) [AMOLTM=0.; ]
               0  ELSE [T0=E0-RMP;
               1  AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP);] "EQ.2.10.6"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    EN0,EN1,EN2;
               0  $REAL4    T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2;
               0  "***MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  C1=(TM/EM)**2;
               0  C2=(2.*TM+1.)/EM**2;
               0  BETASQ=1.-1./EM**2;
               0  CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM); "CONSTANT FACTOR IN EQ.2.10.3"
               0  EPS1=T1/T0;
               0  EPSP1=1.-EPS1;
               0  EPS2=T2/T0;
               0  EPSP2=1.-EPS2;
               0  AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1
               0    -C2*LOG(EPS2*EPSP1/(EPS1*EPSP2))); "EQ.2.10.3"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR BHABHA SCATTERING WITH INCIDENT POSITRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4 E0,BHABRM;
               0  COMIN/THRESHP/;
               0  IF (E0.LE.AEP) [BHABTM=0.;]
               0  ELSE [BHABTM=BHABRM(E0,AEP,E0);]  "EQ.2.11.4"
               0  RETURN;
               0  END; "END OF FUNCTION BHABTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  ;
               0  implicit none;
               0  $REAL4 EN0,EN1,EN2;
               0  $REAL4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  Y=1./(TM+2.);
               0  BETASI=1./(1.-1./EM**2);
               0  CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM; "CONSTANT FACTOR IN EQ.2.11.2"
               0  B1=2.-Y**2;
               0  B2=3.-Y*(6.-Y*(1.-Y*2.));
               0  B3=2.-Y*(10.-Y*(16.-Y*8.));
               0  B4=1.-Y*(6.-Y*(12.-Y*8.));
               0  EPS1=T1/T0;
               0  EPS2=T2/T0;
               0  BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1)
               0    +B2*(EPS2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3)
               0    - EPS1*EPS1*(EPS1*B4/3.-0.5*B3));  "EQ.2.11.2"
               0  RETURN;
               0  END; "END OF FUNCTION BHABRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ANIHTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR TWO-PHOTON POSITRON-ELECTRON ANNIHILATION"
               0  "   WITH INCIDENT POSITRON ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    GAM,P0P2,P0P,CANIH;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  GAM=E0/RMP;   "EQ.2.12.3"
               0  P0P2=GAM*GAM-1.0;
               0  P0P=SQRT(P0P2);  "EQ.2.12.6"
               0  CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.); "CONSTANT FACTOR IN EQ.2.12.14"
               0  ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P)
               0     -(GAM+3.)/P0P);   "EQ.2.12.14"
               0  RETURN;
               0  END;  "END OF FUNCTION ANIHTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTP(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "MODIFIED JAN 1989 DWOR AS SPTOTE                                  "
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONP,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG);
               1  "write(*,*)' eo,ee,eg,spionp,brmstm ',e0,ee,eg,SPIONP(E0,EE),BRMSTM(E0,EG);"]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTP=SPIONP(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTP=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTP=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTP=SPIONP(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTE(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  " patched DWOR, Jan 1988 to correct IURST=2,3,4 and add 6 and 7    "
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONE,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTE=SPIONE(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTE=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTE=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTE=SPIONE(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONE(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONE=SPIONB(E0,EE,.FALSE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONB(E0,EE,POSITR);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***STOPPING POWER FOR AN ELECTRON.  THIS FUNCTION ALSO HAS OTHER    "
               0  "   ENTRY POINTS. . .                                                "
               0  "   SPIONP(E0,EE) - STOPPING POWER FOR A POSITRON                    "
               0  "   SPINIT(MEDIUM) - DOES INITIALIZATION FOR THE OTHER ENTRY POINTS  "
               0  "   WHENEVER THE MEDIUM CHANGES.                                     "
               0  "   THIS FUNCTION IS FOR STOPPING POWER DUE TO COLLISIONS WITH LESS  "
               0  "   THAN EE-RM ENERGY TRANSFER AND DOES NOT INCLUDE SOFT BREMS LOSS. "
               0  "   WE USE BERGER AND SELTZER'S FORMULATION.                         "
               0  "   STOPPING POWER IS RETURNED IN UNITS OF MEV/R.L.                  "
               0  ;
               0  implicit none;
               0  $REAL4   E0,EE;
               0  LOGICAL POSITR;
               0  $REAL4   G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA;
               0  $INTEGER I;
               0  COMIN/DERCON,LSPION,EPSTAR/; "MOD NOV 24,1988"
               0  "     COMMON POINT FOR E- AND E+ ENTRIES.                              "
               0  G=E0/RMP;
               0  EEM=EE/RMP-1.;
               0  "     T IS BERGER'S TAU                                                "
               0  T=G-1;
               0  ETA2=T*(G+1.);
               0  BETA2=ETA2/G**2;
               0  ALETA2=LOG(ETA2);
               0  X=0.21715*ALETA2;
               0  "     0.21715=ALOG10(E)/2.   THIS FACTOR IS BECAUSE THE DEFINITION OF  "
               0  "     X IS ALOG10(P/(MC)) AND ETA2=ETA**2=(P/MC)**2                    "
               0  IF (.NOT.POSITR)["THIS IS ELECTRON CASE"
               1  "     COMPUTE F-TERM FOR ELECTRON.  MAXIMUM TRANSFER IS T/2            "
               1  "     D IS BERGER'S CAPITOL DELTA.                                     "
               1  D=AMIN1(EEM,0.5*T);
               1  "     EEM IS DEFINED AS EE/RM-1 IS ENERGY TRANSFER THRESHOLD FOR       "
               1  "     DISCRETE MOLLER AND BHABHA SCATTERING(IN UNITS OF RM.)           "
               1  FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D)
               1    +(D*D/2.+(2.*T+1.)*LOG(1.-D/T))/(G*G);]
               0  "     COMPUTE F-TERM FOR POSITRON.  MAXIMUM TRANSFER IS T.             "
               0  ELSE ["THIS IS POSITRON CASE"
               1  D=AMIN1(EEM,T);
               1  TP2=T+2.;
               1  D2=D*D;
               1  D3=D*D2;
               1  D4=D*D3;
               1  FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2
               1   -(D-D3/3.)/(TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3);]
               0
               0  "     NOW COMPUTE THE DENSITY CORRECTION TERM.                         "
               0
               0  IF(EPSTFLP = 0) ["USE STANDARD PEGS4 METHOD"
               1  IF (X.LE.X0) [DELTA=0.0;]
               1  ELSEIF (X.LT.X1) [DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK;]
               1  ELSE [DELTA=TOLN10*X - CBAR;]]
               0
               0  ELSE ["USE LINEAR INTERPOLATION OF USER SUPPLIED INPUT TABLE"
               1
               1  "IEPST IS A POINTER SUCH THAT                              "
               1  "       EPSTEN(IEPST) <= E0 < EPSTEN(IEPST+1)              "
               1  "                                                          "
               1  "IEPST IS INITIALIZED IN BLOCK DATA TO 1. WE START FROM    "
               1  "THE PREVIOUS VALUE OF THE POINTER SINCE WE ASSUME THAT    "
               1  "THE CODE IS WORKING UP OR DOWN A GRID.                    "
               1  "  THIS CODING IS FAR FROM OPTIMAL                         "
               1
               1  IF(E0 >= EPSTEN(IEPST))["AT OR ABOVE PREVIOUS ENTRY"
               2  IF(E0 = EPSTEN(IEPST))["FOUND ENTRY, INCLUDING THE POSSIBILITY"
               3  "THAT WE ARE AT THE TOP OF THE TABLE"     GO TO :END-SEARCH:;]
               2
               2  DO I= IEPST,NEPST-1 [
               3       IF(E0<EPSTEN(I+1))["WE FOUND IT" IEPST = I; GO TO :END-SEARCH:]
               3       ]
               2  "IF WE FALL THRU TO HERE, WE MUST BE AT UPPER ENERGY"
               2  IEPST = NEPST; GO TO :END-SEARCH:;
               2  ]"END OF BLOCK E0>EPSTEN(IEPST)"
               1
               1  ELSE [ "E0<EPSTEN(IEPST)"
               2
               2  DO I = IEPST,2,-1 [
               3      IF(E0 >= EPSTEN(I-1)) [IEPST = I-1; GO TO :END-SEARCH:;]
               3      ]
               2  "   IF WE GET HERE WE MUST BE IN THE FIRST REGION"
               2      IEPST = 1;]
               1
               1  :END-SEARCH:
               1
               1  "NOW JUST INTERPOLATE LINEARLY IN THE ENERGY"
               1  IF(IEPST < NEPST) [
               2     DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/
               2     (EPSTEN(IEPST+1) - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST));]
               1  ELSE [DELTA = EPSTD(NEPST);]
               1
               1  ]"END OF EPSTFL NON-ZERO BLOCK"
               0
               0  "     NOW PUT IT ALL TOGETHER                                          "
               0  SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONP(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONP=SPIONB(E0,EE,.TRUE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSTM(E0,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EG,BRMSRM,AU,zero;
               0  parameter (zero=0);
               0  COMIN/DERCON/;
               0  IF (E0.LE.RMP) [BRMSTM=0.; ]
               0  ELSE [AU=AMIN1(EG,E0-RMP);
               1  BRMSTM=BRMSRM(E0,zero,AU);
               1  "write(*,*)'au,e0,brmsrm ',au,e0,BRMSRM(E0,zero,AU);"
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2,BRMSRZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  BRMSRM=0.;
               0  DO I=1,NEP[BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2);
               1  "write(*,*)'i,e,k1,k2,pz,brmsrz ',i,e,k1,k2,PZ(i_med,I),"
               1  "BRMSRZ(ZELEM(i_med,I),E,K1,K2);"]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BRMSFZ;
               0  $REAL4 DUMMY,BRMSDZ,QD,BRMSFZ;
               0  "     INITIALIZE BRMSFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BRMSDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BRMSDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)' e ',e;"
               0  DUMMY=BRMSDZ(Z,E,K1);
               0  BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ');
               0  "write(58,*)'brmsrz ',BRMSRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSDZ(Z,EA,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,EA,K;
               0  $REAL4 APRIM,XSIFP,FCOULCP,BRMSFZ;
               0  COMIN/PMCONS,DERCON,MOLVAR,LBREMZ/;
               0  EBREMZ=EA;
               0  DELC=136.*Z**(-1./3.)*RMP/EBREMZ;
               0  CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP;
               0  "write(58,*)' z,ebremz,an,rho,wm,r0,fsc,xsif,rlc,aprim ',z,ebremz,an,rhop,"
               0  "wm,r0,fsc,xsifp(z),RLCP,APRIM(Z,Ebremz);"
               0  XLNZ=4./3.*LOG(Z);
               0  IF (EBREMZ.GE.50)XLNZ=XLNZ+4.*FCOULCP(Z);
               0  ".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
               0  DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
               0  BRMSDZ=BRMSFZ(K);
               0  RETURN;
               0  END;  "END OF FUNCTION BRMSDZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION APRIM(Z,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     EMPIRICAL CORRECTION FACTOR TO BREMS CROSS SECTION               "
               0
               0  " This version can be switched to use different values:                "
               0  "   IAPRIM = 0  equivalent to old PEGS4 (default)                      "
               0  "            1  reads in values from unit 22                           "
               0  "            2  sets APRIM to 1.0                                      "
               0  " Future changes can be accommodated by reading in                     "
               0  " different data on unit 22 and if necessary changing the array sizes: "
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,E;
               0  $INTEGER  napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1;
               0  $REAL4     EM,AINTP;
               0  character  aprim_file*256;
               0  REPLACE {$NAPRE} WITH {115} " Maximum number of energies ( > 18 )      "
               0  REPLACE {$NAPRZ} WITH {14}  " Maximum number of elements ( > 5 )       "
               0
               0  REPLACE {$NAPR1} WITH {{COMPUTE $NAPRE - 18}}
               0  REPLACE {$NAPR2} WITH {{COMPUTE $NAPRZ - 5}}
               0  REPLACE {$NAPR3} WITH {{COMPUTE $NAPRE * $NAPR2}}
               0  ;COMIN/DERCON,EPSTAR,EGS-IO/; "NRC CHANGE NOV 88"
               0  $REAL4 APRIMD($NAPRE,$NAPRZ),EPRIM($NAPRE),ZPRIM($NAPRZ),APRIMZ($NAPRE);
               0  DATA APRIMD/
               0  1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*1.0,$NAPR1*0.0,
               0  1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*1.0,$NAPR1*0.0,
               0  1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.994,
               0   2*0.991,0.990,2*0.989,2*0.988,$NAPR1*0.0,
               0  1.46,1.34,1.23,1.15,1.11,1.08, 1.06,1.05,1.03,1.02,0.989,
               0   0.973,0.971,0.969,0.967,0.965,2*0.963,$NAPR1*0.0,
               0  1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,0.955,0.935,
               0   0.930,0.925,0.920,0.915,2*0.911,$NAPR1*0.0,
               0  $NAPR3*0.0/,
               0  EPRIM /
               0  2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81.,91.,
               0  $NAPR1*0.0/,
               0  ZPRIM /6.,13.,29.,50.,79.,$NAPR2*0.0/;
               0  save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz;
               0
               0  IF (IAPRIMP.EQ.0) [ " PEGS4 default APRIM"
               1      IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2
               2      ]
               1      IF (E.GE.50) [ APRIM=1.; ]
               1      ELSE [ " INTERPOLATE APRIM OVER Z "
               2          EM=E/RMP;
               2          DO IE=1,18[
               3             APRIMZ(IE)=
               3             AINTP(Z,ZPRIM,5,APRIMD(IE,1),$NAPRE,.FALSE.,.FALSE.);
               3             ] " Z INTERPOLATION IS NOW COMPLETE. NOW DO ENERGY "
               2          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.);
               2      ]
               1  ]
               0  ELSEIF (IAPRIMP.EQ.1) [
               1      IF (IAPRFL.EQ.0) [ " read in data from APRIME.DATA"
               2
               2
               2
               2
               2          aprim_file = $cstring(hen_house) // 'pegs4' // $file_sep //
               2                       'aprime.data';
               2          aprim_unit=22;" want unit 22"
               2          aprim_unit=egs_get_unit(aprim_unit);
               2          IF( aprim_unit < 1 ) [
               3               $egs_fatal(*,'APRIM: failed to get a free fortran unit');
               3          ]
               2          open(aprim_unit,file=aprim_file,status='old',err=:no_aprim_file:);
               2
               2          READ(aprim_unit,*) NAPRZ, NAPRE;
               2          IF (NAPRZ.GT.$NAPRZ) [
               3              OUTPUT; (//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRZ AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          IF (NAPRE.GT.$NAPRE) [
               3              OUTPUT; (//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRE AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE);
               2          DO IE=1,NAPRE [ EPRIM(IE)=1.+EPRIM(IE)/RMP; ]
               2          DO IZ=1,NAPRZ [READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE);]
               2          IAPRFL=1;
               2          close(aprim_unit);
               2          ]
               1      EM=E/RMP;
               1      DO IE=1,NAPRE [ " INTERPOLATE APRIM OVER LOG(Z)  "
               2          APRIMZ(IE)=
               2          AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),$NAPRE,.TRUE.,.FALSE.);
               2          ]           " NOW DO ENERGY INTERPOLATION     "
               1      APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.);
               1      ]
               0  ELSEIF (IAPRIMP.EQ.2) [
               1          IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2          ]
               1          APRIM=1.0]
               0  ELSE [ OUTPUT IAPRIMP; (//,' ILLEGAL VALUE FOR IAPRIM: ',I4);
               1         $CALL_EXIT(24); ]
               0  RETURN;
               0  :no_aprim_file:
               0  $egs_fatal(*,'Cannot open file $HEN_HOUSE/pegs4/aprime.data');
               0  RETURN;
               0  END; "END OF FUNCTION APRIM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0
               0  "     LINEAR OR LOG INTERPOLATION FUNCTION.                          "
               0
               0  "CHANGED"
               0  "REAL XA(1),YA(ISK,1);"
               0  "TO"
               0  "REAL XA(NX),YA(ISK,NX);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $INTEGER NX,ISK;
               0  $REAL4    X;
               0  $REAL4    XA(NX),YA(ISK,NX);
               0  LOGICAL XLOG,YLOG,XLOGL;
               0
               0  $INTEGER I,J;
               0  $REAL4    XI,XJ,XV,YI,YJ;
               0  XLOGL=XLOG;  "SET LOCAL VARIABLE"
               0  "     FIND INTERVAL FOR X INTERPOLATION.                             "
               0  DO J=2,NX[
               1  IF (X.LT.XA(J))GO TO :NSTEP:;]
               0  J=NX;
               0  :NSTEP:    I=J-1;
               0  IF (XA(I).LE.0.0) [XLOGL=.FALSE.;]
               0  IF (.NOT.XLOGL)[ XI=XA(I); XJ=XA(J); XV=X;]
               0  ELSE [XI=LOG(XA(I)); XJ=LOG(XA(J)); XV=LOG(X);]
               0  IF (YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))
               0     [AINTP=0.0;]
               0  ELSE[
               1      IF(YLOG)[YI=LOG(YA(1,I));YJ=LOG(YA(1,J));
               2      IF(XJ.EQ.XI) [AINTP=YI;]
               2      ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]
               2      AINTP=EXP(AINTP);]
               1      ELSE[YI=YA(1,I); YJ=YA(1,J);
               2           IF(XJ.EQ.XI) [AINTP=YI;]
               2           ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]]
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION AINTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXS(E);"MAXIMUM STEP SIZE VALID FOR MULTIPLE SCATTERING"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E,TMXB;
               0  $REAL4 SAFETY,TABSMX;
               0  DATA SAFETY/0.8/,TABSMX/10.0/;
               0  save SAFETY,TABSMX;
               0  TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX);
               0  "THE FACTORE 'SAFETY' IS TO KEEP SOMEWHAT BELOW BETHE'S LIMIT"
               0  "TABSMX IS AN ABSOLUTE LIMIT TO SIZE OF ELECTRON TRANSPORT,"
               0  "  INDEPENDENT OF THE MULTIPLE SCATTERING LIMIT"
               0  RETURN;
               0  END;  "END OF FUNCTION TMXS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXB(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E;
               0  "THIS FUNCTION FINDS THE TRANSPORT DISTANCE WHICH AT THIS ENERGY"
               0  "IS THE LARGEST CONSISTENT WITH BETHE'S CRITERION, NAMELY"
               0  "  XC**2*B.LE.1;   SINCE XC ANB B ARE INCREASING FUNCTIONS OF T"
               0  " THE TRANSPORT DISTANCE, THE CRITERION FOR TMXB IS THEN"
               0  "  XC**2*B=1;      OTHER RELATIONS USED IN THE DERIVATION ARE"
               0  "EXPLAINED IN SUBROUTINES MIX AND MOLIER.  THEY ARE:"
               0  "  XC=XCC*SQRT(T)/(E*BETA**2); "
               0  "  EXP(B)/B = BLCC*T/BETA**2;  "
               0  "FROM THESE IS DERIVED THE EQUATION THIS FUNCTION IS BASED ON:"
               0  "TMXB=(E**2*BETA**2/XCC**2)*BETA**2/LOG(BLCC*(E**2*BETA**2/XCC**2));"
               0  ;
               0  $REAL4 ESQ,BETA2,PX2;
               0  COMIN/DERCON,MOLVAR/;
               0  ESQ=E**2;
               0  BETA2=1.0-RMPSQ/ESQ;
               0  PX2=ESQ*BETA2/XCCP**2;
               0  TMXB=PX2*BETA2/LOG(BLCCP*PX2);
               0  RETURN;
               0  END;   "END OF FUNCTION TMXB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKE(E);"LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E;
               0  COMIN/DERCON/;
               0  ALKE=LOG(E-RMP);
               0  "write(58,*)' alke,e,rm,e-rm ',alke,e,rmp,e-rmp;"
               0  RETURN;
               0  END;  "END OF FUNCTION ALKE"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKEI(X);"INVERSE OF LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 x;
               0  COMIN/DERCON/;
               0  ALKEI=EXP(X) + RMP;
               0  RETURN;
               0  END;  "END OF FUNCTION ALKEI"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI,
               0                   AX,BX,NALM,NFUN,AF,BF,VFUNS);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***PWLF1 IS A ROUTINE WHICH WILL FIT UP TO 10(CURRENTLY) FUNCTIONS  "
               0  "   SIMULTANEOUSLY ON AN INTERVAL (XL,XU) OF THE INDEPENDENT VARIABLE"
               0  "   X OF THE FUNCTIONS. THE FIT IS A PIECEWISE LINEAR FUNCTION OF    "
               0  "   XFUN(X).  XFI IS THE INVERSE FUNCTION OF XFUN.  THE SUBINTERVALS "
               0  "   ARE CHOSEN OF UNIFORM WIDTH IN XFUN(X) AND SUFFICIENT OF THEM    "
               0  "   ARE CHOSEN SO THAT THE FIT GIVES A RELATIVE ERROR[EP FOR ALL     "
               0  "   THE FUNCTIONS OVER ALL THE SUBINTERVALS.                         "
               0  "   QFIT IS AN AUXILIARY FUNCTION.       "
               0  "   EXPLANATION OF THE ARGUMENTS:                                    "
               0  "   NI   ON RETURN IS NUMBER OF SUBINTERVALS USED FOR THE FIT.       "
               0  "   XL   LOWER LIMIT OF INTERVAL ON WHICH TO FIT THE FUNCTIONS.      "
               0  "   XU   UPPER LIMIT                                                 "
               0  "   XR   VALUE OF X WHICH WILL BE FORCED TO BE A SUBINTERVAL BOUNDARY"
               0  "        THE SIGNIFICANCE OF THIS IS THAT THE STRAIGHT LINES ON THE  "
               0  "        SUBINTERVALS ARE CHOSEN TO FIT EXACTLY AT THE SUBINTERVAL   "
               0  "        BOUNDARIES, THUS IF ONE WANTS AN EXACT FIT OF THE FUNCTIONS "
               0  "        AT A PARTICULAR POINT, XR SHOULD BE SET TO THAT VALUE.      "
               0  "        OTHERWISE XR SHOULD BE SET TO XH.  ANOTHER REQUIREMENT      "
               0  "        IS THAT XU SHOULD BE LARGER THAN XL.                        "
               0  "   EP   THE MAXIMUM RELATIVE ERROR ALLOWED THE FIT.                 "
               0  "   NIP  THE MINUIMUM NUMBER OF POINTS INTERIOR TO (XL,XU) AT WHICH  "
               0  "        THE FIT IS TO BE TESTED FOR RELATIVE ERROR VS. EP.          "
               0  "   XFUN A FUNCTION OF X OVER WHICH IT IS HOPED THE FUNCTIONS TO BE  "
               0  "        FIT ARE MORE LINEAR THAN OVER X.  XFUN IS EXPECTED TO BE    "
               0  "        MONOTONICALLY INCREASING IN X.                              "
               0  "   XFI  THE INVERSE OF XFUN. THAT IS XFI(XFUN(X))=X.                "
               0  "   AX,BX ARE COEFFICIENTS USED AS SHOWN BELOW TO DETERMINE WHICH    "
               0  "        SUBINTERVAL A VALUE OF X IS IN.                             "
               0  "   AF,BF ARE ARRAYS OF COEFFICIENTS USED TO GET VALUES OF THE FUNCS."
               0  "   THE PROCEDURE FOR FINDING THE FIT VALUE OF FUNCTION IFUN IS:     "
               0  "   INTERV=AX*XFUN(X)+BX                                             "
               0  "   VALUE=AF(INTERV,IFUN)*XFUN(X)+BF(INTERV,IFUN)                    "
               0  "   NALM  IS THE MAXIMUM NUMBER OF SUBINTERVALS FOR WHICH ARRAY SPACE"
               0  "         HAS BEEN ALLOCATED.                                        "
               0  "   NFUN  IS THE NUMBER OF FUNCTIONS TO BE FITTED(SIMULTANEOUSLY,I.E."
               0  "         ALL FUNCTIONS HAVE THE SAME XFUN AND SUBINTERVALS, AND ALL "
               0  "         ARE REQUIRED TO BE FIT WITH MAX REL ERR[EP)                "
               0  "   VFUNS IS A SUBROUTINE TO FILL AN ARRAY WITH THE VALUES OF THE    "
               0  "   FUNCTIONS TO BE FITTED.                                          "
               0  ;
               0  implicit none;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER NI,NIMX,NIP,NALM,NFUN;
               0  $REAL4    XL,XU,XR,EP,AX,BX,XFUN,XFI;
               0  EXTERNAL XFI,VFUNS,XFUN;
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "   QFIT IS A LOGICAL FUNCTION WHICH IS TRUE IF THE STATED NUMBER    "
               0  "   OF INTERVALS GIVES A SUFFICIENTLY CLOSE FIT.                     "
               0  LOGICAL QFIT;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER NL,NU,IPRN,NJ,NK;
               0  $REAL4    REM;
               0  "   FIND # OF INTERVALS REQUIRED.                                    "
               0  NL=0;
               0  NU=1;
               0  IPRN=0;
               0  LOOP [NJ=MIN0(NU,NIMX);
               1  "write(58,*)' 1 nj ',nj;"
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1   AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) EXIT;
               1  IF (NU.GE.NIMX) [
               2
               2
               2
               2
               2
               2  "write(58,*)' nj ',nj;"
               2  NI=NJ;RETURN;]
               1  NL=NU;
               1  NU=NU*2;]
               0  "   WE NOW HAVE AN UPPER AND LOWER LIMIT ON NI, REFINE IT.           "
               0  NU=NJ ; "SAVE SUCCESSFUL INDEX"
               0  WHILE(NU.GT.NL+1)["LOOP UNTIL CONVERGENCE"
               1  NJ=(NL+NU)/2;
               1  NK=NJ; "THIS IS NECESSARY BECAUSE QFIT MAY LOWER NJ,BUT NEED ORIGINAL"
               1  " FOR SETTING NL OR MAY GET INTO INFINITE LOOP."
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1  AX,BX,NALM,NFUN,AF,BF,VFUNS,0))[NU=NJ;]ELSE[NL=NK;]
               1  ]
               0  "     NU IS NOW THE SMALLEST NI WHICH FITS OK.                       "
               0  NI=NU;
               0  IF (NI.EQ.NJ)RETURN;"LAST TEST WAS SUCCESS"
               0  "     CALL IT ONCE MORE TO GET THE FITS.                             "
               0  IF (.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) OUTPUT NI;
               0  (' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5);
               0  RETURN;
               0  END;  "END OF SUBROUTINE PWLF1"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI,
               0   AX,BX,NALM,NFUN,AF,BF,VFUNS,IPRN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  "EXTERNAL XFUN,XFI,VFUNS;"
               0  EXTERNAL VFUNS;
               0  $REAL4    XFUN,XFI;
               0  $INTEGER NJ,NALM,NFUN,NJP,IPRN;
               0  $REAL4    XL,XH,XR,AX,BX,REM,EP;
               0  $REAL4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10);
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "     CONSTRUCT THE INTERVAL COEFFICIENTS.                             "
               0  "     XR SHOULD BE IN THE INTERVAL (XL,XH).  IF NOT IT WILL BE SE TO TH"
               0  "     NEAREST LIMIT.  SUBINTERVALS WILL BE ARRANGED SO                 "
               0  "     THAT XR IS ALWAYS ON A SUBINTERVAL BOUNDARY.   THE PURPOSE OF THI"
               0  "     FEATURE IS TO MORE EASILY FIT FUNCTIONS WHICH HAVE AN INTERIOR   "
               0  "     DISCONTINUITY IN SLOPE.  EXAMPLES ARE THE MOLLER AND PAIR        "
               0  "     CROSS SECTIONS WHICH CONTRIBUTE DISCONTINUITIES IN SLOPE         "
               0  "     TO THE ELECTRON AND PHOTON INTERACTION PROBABILITIES IN          "
               0  "     THE INTERIOR OF THE ENERGY RANGES FOR THESE PARTICLES.           "
               0  "     IN ABLE TO GIVE SOME VALUE FOR X'S WHICH MAY LIE SLIGHTLY OUTSIDE"
               0  "     THE INTERVAL (XL,XH) AN EXTRA SUBINTERVAL ON EACH SIDE OF (XL,XH)"
               0  "     IS PROVIDED, WHICH USED THE SAME STRAIGHT LINES AS THE ADJACENT  "
               0  "     INCLUDED SUBINTERVAL.  NJ IS THE TOTAL NUMBER OF SUBINTERVALS    "
               0  "     AND NI IS DEFINED TO BE THE NUMBER OF INTERNAL SUBINTERVALS=NJ-2."
               0  "     NJP IS THE MINUMUM NUMBER OF POINTS INTERIOR TO THE INTERVAL     "
               0  "     (XL,XH) AT WHICH THE FIT IS TO BE TESTED.  A NUMBER NIP WILL BE  "
               0  "     CHOSEN AS THE NUMBER OF INTERIOR POINTS WITHIN EACH SUBINTERVAL  "
               0  "     AT WHICH TO TEST SO THAT NIP*NI]=NJP.                        "
               0  $REAL4    XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP,
               0           SXFIP,XIP;
               0  $INTEGER NI,NIP,ISUB,IFUN,JSUB,IP;
               0  $INTEGER nkp;
               0  DATA NKP/3/;
               0  save nkp;
               0  IF (XH.LE.XL)[
               1  OUTPUT XL,XH;(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6);
               1  QFIT=.FALSE.; RETURN;]
               0  XS=AMAX1(XL,AMIN1(XH,XR));
               0  "     GET NUMBER OF INTERNAL SUBINTERVALS ARE ALLOWED AND CHECK        "
               0  NI=NJ-2;
               0  "     AT LEAST 2 SUBINTERVALS ARE NEEDED IF XR(XS) IS NOT AN END POINT."
               0  IF (((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2) [XFL=XFUN(XL);]
               0  ELSE [QFIT=.FALSE.; RETURN;]
               0  XFH=XFUN(XH);
               0  XFS=XFUN(XS);
               0  "write(58,*)'xfh,xfs,xh,xs ',xfh,xfs,xh,xs;"
               0  "     SET SUBINTERVAL WIDTH.                                           "
               0  XM=AMAX1(XFH-XFS,XFS-XFL);
               0  DX=XFH-XFL;
               0  W=XM/AMAX1(1.,AINT(NI*XM/DX));
               0  "write(58,*)' w,xm,ni,dx ',w,xm,ni,dx;"
               0  "     RESET NI TO HOW MANY WE'RE ACTUALLY GOING TO USE.                "
               0  NI=NI-AINT(NI-DX/W);
               0  "     COMPUTE HOW MANY INTERIOR POINTS TO SAMPLE IN EACH SUBINTERVAL.  "
               0  NIP=MAX0(NKP,(NJP+NI-1)/NI);
               0  "     MAKE NIP ODD                                                     "
               0  NIP=(NIP/2)*2+1;
               0  "     SET ACTUAL LOWER LIMIT OF INTERVAL.                              "
               0  IF (XFH-XFS.LE.XFS-XFL) [XLL=XFL;]
               0  ELSE [XLL=XFH-NI*W;]
               0  "     COEFICIENTS FOR USER TO COMPUTE WHICH SUBINTERVAL TO USE.        "
               0  "     ISUBINT=AX*XFUN(X)+BX                                            "
               0  AX=1./W;
               0  BX=2.-XLL*AX;
               0  "     THE RIGHT BOUNDARY OF SUBINTERVAL I IS XFI(XLL+W*(I-1))          "
               0  "     NOW COMPUTE THE FIT COEFFICIENTS FOR THE SUBINTERVALS            "
               0  "     AND FIND MAXIMUM RELATIVE ERROR(REM).                            "
               0  REM=0.0;
               0  QFIT=.TRUE.;
               0  "     LOOP OVER SUBINTERVALS                                           "
               0  "     INITIALIZE LOWER BOUNDARY AND VALUE.                             "
               0  SXFL=AMAX1(XLL,XFL);
               0  ISUB=0;
               0  XSXF=XFI(SXFL);
               0  "write(58,*)' 1 xsxf ',XSXF;"
               0  CALL VFUNS(XSXF,FSXL);
               0  IF (IPRN.NE.0) WRITE(6,:FMT:) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFUN);
               0  :FMT: FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4));
               0  DO ISUB=1,NI[
               1  "     ALLOW FOR EXTRA SUBINTERVAL OUTSIDE THE MAIN INTERVAL            "
               1  JSUB=ISUB+1;
               1  SXFH=AMIN1(XLL+W*ISUB,XH);
               1  XSXF=XFI(SXFH);
               1  "write(58,*)' 2 xsxf ',XSXF;"
               1  CALL VFUNS(XSXF,FSXH);
               1  IF (IPRN.NE.0)WRITE(6,:FMT:)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NFUN);
               1  DSXF=SXFH-SXFL;
               1  "write(58,*)' xll,w,isub,xh ',xll,w,isub,xh;"
               1  "write(58,*)' dsxf,sxfh,sxfl ',dsxf,sxfh,sxfl;"
               1  DO IFUN=1,NFUN[
               2  AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF;
               2  BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF;] "END OF IFUN"
               1  "     LOOP OVER INTERIOR POINTS TO LOOK FOR MAX. REL.ERROR             "
               1  "     COMPUTE INTERIOR POINT SPACING.                                  "
               1  WIP=DSXF/(NIP+1);
               1  "write(58,*)' dsxf,nip ',dsxf,nip;"
               1  DO IP=1,NIP[
               2  "     VALUE OF XFUN AT THE INTERIOR POINT OF THIS SUBINTERVAL.         "
               2  SXFIP=SXFL+IP*WIP;
               2  XIP=XFI(SXFIP);
               2  "write(58,*)' sxfl,ip,wip ',sxfl,ip,wip;"
               2  "     COMPUTE FUNCTION AT INTERIOR POINT                               "
               2  "write(58,*)' xip ',XIP;"
               2  CALL VFUNS(XIP,FIP);
               2  "     COMPUTE FITTED VALUES.                                           "
               2  DO IFUN=1,NFUN[
               3  FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN);
               3  AFIP(IFUN)=ABS(FIP(IFUN));
               3  AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN));
               3  RE(IFUN)=0.0;
               3  IF (FIP(IFUN).NE.0.0) [RE(IFUN)=AER(IFUN)/AFIP(IFUN);]
               3  IF (AFIP(IFUN).GE.ZTHR(IFUN)) [REM=AMAX1(REM,RE(IFUN));]
               3  ELSEIF (AER(IFUN).GT.ZEP(IFUN)) [QFIT=.FALSE.;]
               3  ] "END OF IFUN"
               2  "*****WRITE OUT SO WE CAN SEE HOW WE ARE DOING.                        "
               2  IF (IPRN.NE.0) [
               3  OUTPUT ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFUN),
               3   RE(IFUN),AER(IFUN),IFUN=1,NFUN);
               3  (1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G11.4/
               3   (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)));]
               2  ] "END OF IP"
               1  "     SAVE RIGHT BOUNDARY AND VALUE FOR NEXT SUBINTERVAL.              "
               1  SXFL=SXFH;
               1  DO IFUN=1,NFUN [FSXL(IFUN)=FSXH(IFUN);]
               1  ] "END OF ISUB"
               0  "     SET UP SKIRTING SUBINTERVALS(VIA EXTRAPOLATION)                  "
               0  DO IFUN=1,NFUN[
               1  AF(1,IFUN)=AF(2,IFUN);
               1  BF(1,IFUN)=BF(2,IFUN);
               1  AF(NI+2,IFUN)=AF(NI+1,IFUN);
               1  BF(NI+2,IFUN)=BF(NI+1,IFUN);] "END OF IFUN"
               0  QFIT=QFIT.AND.REM.LE.EP;
               0  NJ=NI+2; "TELL ACTUAL NO. OF SUBINTERVALS USED."
               0  "write(58,*)'ni ',ni;"
               0  RETURN;
               0  END; "END OF LOGICAL FUNCTION QFIT
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION QD(F,A,B,MSG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL4    A,B,F;
               0  EXTERNAL F;
               0  CHARACTER*6 MSG;
               0  logical first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0  "    CHANGED"
               0
               0  "    REAL*8 DCADRE,ADUM,BDUM,ERRDUM,MSG;"
               0
               0  "    TO"
               0
               0  "    DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  "    CHARACTER*6 MSG;"
               0
               0  "    FOR SUN COMPATIBILITY AFB 89/12/27"
               0
               0  "DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  $REAL4 DCADRE,ADUM,BDUM,ERRDUM;
               0  $INTEGER IER;
               0
               0  ADUM=A; BDUM=B;
               0  QD=DCADRE(F,ADUM,BDUM,$AERR,$RERR,ERRDUM,IER);
               0  "write(58,*)' qd ',QD;"
               0  IF (IER.GT.66)[
               1      OUTPUT IER,MSG,A,B,QD,ERRDUM;
               1      (' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,' TO ',G14.6,
               1      ',QD=',G14.6,'+-',G14.6);
               1  ]
               0  RETURN;
               0  END;  "END OF FUNCTION QD"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  "DOUBLE PRECISION FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);"
               0  $REAL4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);
               0  implicit none;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "                                                                  "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "-DCADRE--------D-------LIBRARY 1----------------------------------"
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  "FUNCTION:          - INTEGRATE F(X) FROM A TO B, USING CAUTIOUS   "
               0  "                     ADAPTIVE ROMBERG EXTRAPOLATION.              "
               0  "                                                                  "
               0  "USAGE:             - FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)   "
               0  "                                                                  "
               0  "PARAMETERS: DCADRE - ESTIMATE OF THE INTEGRAL OF F(X) FROM A TO B."
               0  "                                                                  "
               0  "            F      - A SINGLE-ARGUMENT REAL FUNCTION SUBPROGRAM   "
               0  "                     SUPPLIED BY THE USER.  F MUST BE DECLARED    "
               0  "                     EXTERNAL IN THE CALLING PROGRAM.             "
               0  "                                                                  "
               0  "            A,B    - THE TWO ENDPOINTS OF THE INTERVAL OF         "
               0  "                     INTEGRATION (INPUT).                         "
               0  "                                                                  "
               0  "            AERR   - DESIRED ABSOLUTE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            RERR   - DESIRED RELATIVE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            ERROR  - ESTIMATED BOUND ON THE ABSOLUTE ERROR OF     "
               0  "                     THE OUTPUT NUMBER, DCADRE.                   "
               0  "                                                                  "
               0  "            IER    - ERROR PARAMETER                              "
               0  "                                                                  "
               0  "                     WARNING ERROR(WITH FIX) = 64 + N             "
               0  "                                                                  "
               0  "                       N = 1 IMPLIES THAT ONE OR MORE SINGULAR-   "
               0  "                             ITIES WERE SUCCESSFULLY HANDLED.     "
               0  "                                                                  "
               0  "                       N = 2 IMPLIES THAT, IN SOME SUBINTERVAL(S),"
               0  "                             THE ESTIMATE OF THE INTEGRAL WAS     "
               0  "                             ACCEPTED MERELY BECAUSE THE ESTIMATED"
               0  "                             ERROR WAS SMALL, EVEN THOUGH NO REG- "
               0  "                             ULAR BEHAVIOR WAS RECOGNIZED.        "
               0  "                                                                  "
               0  "                     TERMINAL ERROR = 128 + N                     "
               0  "                                                                  "
               0  "                       N = 3 FAILURE DUE TO INSUFFICIENT INTERNAL "
               0  "                             WORKING STORAGE.                     "
               0  "                                                                  "
               0  "                       N = 4 FAILURE.  THIS MAY BE DUE TO TOO MUCH"
               0  "                             NOISE IN THE FUNCTION (RELATIVE TO   "
               0  "                             THE GIVEN ERROR REQUIREMENTS) OR DUE "
               0  "                             TO AN ILL-BEHAVED INTEGRAND.         "
               0  "                                                                  "
               0  "                       N = 5 INDICATES THAT RERR IS GREATER THAN  "
               0  "                             0.1, OR RERR IS LESS THAN 0.0, OR    "
               0  "                             RERR IS TOO SMALL FOR THE PRECISION  "
               0  "                             OF THE MACHINE.                      "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "VERSION DATE:      - 8 OCTOBER 1974                               "
               0  "                                                                  "
               0  "MORTRAN VERSION    - 4 OCTOBER 1984/1545 (W. R. NELSON)           "
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  ; "NOTE: SEMI-COLON TO CLEAR MORTRAN BUFFER                        "
               0  "                                                                  "
               0  "ADDED"
               0  "EXTERNAL F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  "EXTERNAL F;"
               0
               0  DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049);
               0  DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30);
               0  DIMENSION REGLSV(30);
               0  LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $REAL4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
               0  $REAL4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;
               0  $REAL4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;
               0  $REAL4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
               0  $REAL4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
               0  $REAL4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
               0  $REAL4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
               0  $REAL4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
               0  $REAL4 ERRET,H2TFEX,FI;
               0  "ADDED"
               0  "REAL RVAL,F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $REAL4 RVAL,F;
               0
               0  $INTEGER IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,ISTEP2,IT,NNLEFT;
               0  $INTEGER MAXTS,MAXTBL,MXSTGE;
               0  DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0,
               0       .1D0,.01D0,2049,10,30/;
               0  DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0,
               0       .1263305D0/;
               0  DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0,
               0       1.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/;
               0  save MAXTS,MAXTBL,MXSTGE;
               0  ALG4O2=LOG10(TWO);
               0  /CADRE,ERROR,CUREST,VINT/=ZERO;
               0  IER=0;
               0  LENGTH=ABS(B-A);
               0  IF(LENGTH.EQ.ZERO) GO TO 215;
               0  IF(RERR.GT.P1.OR.RERR.LT.ZERO) GO TO 210;
               0  IF(AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN) GO TO 210;
               0  ERRR=RERR;
               0  ERRA=ABS(AERR);
               0  STEPMN=(LENGTH/FLOAT(2**MXSTGE));
               0  STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN;
               0  STAGE=HALF;
               0  ISTAGE=1;
               0  FNSIZE=ZERO;
               0  PREVER=ZERO;
               0  REGLAR=.FALSE.;
               0  "                              THE GIVEN INTERVAL OF INTEGRATION   "
               0  "                                IS THE FIRST INTERVAL CONSIDERED. "
               0  BEG=A;
               0
               0  "CHANGED"
               0  "FBEG=F(BEG)*HALF;"
               0  "TO"
               0  "RVAL=BEG;FBEG=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG;FBEG=F(RVAL)*HALF;
               0  "write(*,*)' rval, f, half ',rval,F(RVAL),half;"
               0
               0  TS(1)=FBEG;
               0  IBEG=1;
               0  END=B;
               0
               0  "CHANGED"
               0  "FEND=F(END)*HALF;"
               0  "TO"
               0  "RVAL=END;FEND=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=END;FEND=F(RVAL)*HALF;
               0
               0  TS(2)=FEND;
               0  IEND=2;
               0  5 RIGHT=.FALSE.;
               0  "                              INVESTIGATION OF A PARTICULAR       "
               0  "                                SUBINTERVAL BEGINS AT THIS POINT. "
               0  10 STEP=END - BEG;
               0  ASTEP=ABS(STEP);
               0  IF(ASTEP.LT.STEPMN) GO TO 205;
               0  IF(STEPNM+ASTEP.EQ.STEPNM) GO TO 205;
               0  T(1,1)=FBEG + FEND;
               0  TABS=ABS(FBEG) + ABS(FEND);
               0  L=1;
               0  N=1;
               0  H2CONV=.FALSE.;
               0  AITKEN=.FALSE.;
               0  15 LM1=L;
               0  L=L + 1;
               0  "                              CALCULATE THE NEXT TRAPEZOID SUM,   "
               0  "                                T(L,1), WHICH IS BASED ON *N2* + 1"
               0  "                                EQUISPACED POINTS. HERE,          "
               0  "                                N2 = N*2 = 2**(L-1).              "
               0  N2=N + N;
               0  FN=N2;
               0  ISTEP=(IEND - IBEG)/N;
               0  IF(ISTEP.GT.1) GO TO 25;
               0  II=IEND;
               0  IEND=IEND + N;
               0  IF(IEND.GT.MAXTS) GO TO 200;
               0  HOVN=STEP/FN;
               0  III=IEND;
               0  FI=ONE;
               0  DO I=1,N2,2[
               1  TS(III)=TS(II);
               1
               1  "CHANGED"
               1  "TS(III-1)=F(END - FI * HOVN);"
               1  "TO"
               1  "RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);"
               1  "FOR SUN AFB 89/12/27"
               1
               1  RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);
               1
               1  FI=FI+TWO;
               1  III=III-2;
               1  II=II-1;]
               0  ISTEP=2;
               0  25 ISTEP2=IBEG + ISTEP/2;
               0  SUM=ZERO;
               0  SUMABS=ZERO;
               0  DO I=ISTEP2,IEND,ISTEP[
               1  SUM=SUM + TS(I);
               1  SUMABS=SUMABS + ABS(TS(I));]
               0  T(L,1)=T(L-1,1)*HALF+SUM/FN;
               0  TABS=TABS*HALF+SUMABS/FN;
               0  ABSI=ASTEP*TABS;
               0  N=N2;
               0  "                              GET PRELIMINARY VALUE FOR *VINT*    "
               0  "                                FROM LAST TRAPEZOID SUM AND UPDATE"
               0  "                                THE ERROR REQUIREMENT *ERGOAL*    "
               0  "                                FOR THIS SUBINTERVAL.             "
               0  IT=1;
               0  VINT=STEP*T(L,1);
               0  TABTLM=TABS*TEN;
               0  FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)));
               0  ERGL=ASTEP*FNSIZE*TEN;
               0  ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT));
               0  "                              COMPLETE ROW L AND COLUMN L OF *T*  "
               0  "                                ARRAY.                            "
               0  FEXTRP=ONE;
               0  DO I=1,LM1[
               1  FEXTRP=FEXTRP*FOUR;
               1  T(I,L)=T(L,I) - T(L-1,I);
               1  T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE);]
               0  ERRER=ASTEP*ABS(T(1,L));
               0  "                              PRELIMINARY DECISION PROCEDURE      "
               0  "                                IF L = 2 AND T(2,1) = T(1,1),     "
               0  "                                GO TO 135 TO FOLLOW UP THE        "
               0  "                                IMPRESSION THAT INTERGRAND IS     "
               0  "                                STRAIGHT LINE.                    "
               0  IF(L.GT.2) GO TO 40;
               0  IF(TABS+P1*ABS(T(1,2)).EQ.TABS) GO TO 135;
               0  GO TO 15;
               0  "                              CACULATE NEXT RATIOS FOR            "
               0  "                                COLUMNS 1,...,L-2 OF T-TABLE      "
               0  "                                RATIO IS SET TO ZERO IF DIFFERENCE"
               0  "                                IN LAST TWO ENTRIES OF COLUMN IS  "
               0  "                                ABOUT ZERO                        "
               0  40 DO 45 I=2,LM1;
               0  DIFF=ZERO;
               0  IF(TABTLM+ABS(T(I-1,L)).NE.TABTLM) DIFF=T(I-1,LM1)/T(I-1,L);
               0  T(I-1,LM1)=DIFF;
               0  45 CONTINUE;
               0  IF(ABS(FOUR-T(1,LM1)).LE.H2TOL) GO TO 60;
               0  IF(T(1,LM1).EQ.ZERO) GO TO 55;
               0  IF(ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL) GO TO 130;
               0  IF(L.EQ.3) GO TO 15;
               0  H2CONV=.FALSE.;
               0  IF(ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL) GO TO 75;
               0  50 IF(REGLAR) GO TO 55;
               0  IF(L.EQ.4) GO TO 15;
               0  55 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  GO TO 145;
               0  "                              CAUTIOUS ROMBERG EXTRAPOLATION      "
               0  60 IF(H2CONV) GO TO 65;
               0  AITKEN=.FALSE.;
               0  H2CONV=.TRUE.;
               0  65 FEXTRP=FOUR;
               0  70 IT=IT + 1;
               0  VINT=STEP*T(L,IT);
               0  ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L));
               0  IF(ERRER.LE.ERGOAL) GO TO 160;
               0  IF(ERGL+ERRER.EQ.ERGL) GO TO 160;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(T(IT,LM1).EQ.ZERO) GO TO 70;
               0  IF(T(IT,LM1).LE.FEXTRP) GO TO 125;
               0  IF(ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL)
               0  FEXTRP=FEXTRP*FOUR;
               0  GO TO 70;
               0  "                              INTEGRAND MAY HAVE X**ALPHA TYPE    "
               0  "                                SINGULARITY                       "
               0  "                                RESULTING IN A RATIO OF *SING*  = "
               0  "                                2**(ALPHA + 1)                    "
               0  75 IF(T(1,LM1).LT.AITLOW) GO TO 175;
               0  IF(AITKEN) GO TO 80;
               0  H2CONV=.FALSE.;
               0  AITKEN=.TRUE.;
               0  80 FEXTRP=T(L-2,LM1);
               0  IF(FEXTRP.GT.FOURP5) GO TO 65;
               0  IF(FEXTRP.LT.AITLOW) GO TO 175;
               0  IF(ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL) GO TO 175;
               0  SING=FEXTRP;
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  AIT(1)=ZERO;
               0  DO 85 I=2,L;
               0  AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1;
               0  R(I)=T(1,I-1);
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  85 CONTINUE;
               0  IT=2;
               0  90 VINT=STEP*AIT(L);
               0  ERRER=ERRER*FEXTM1;
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 95;
               0  ALPHA=LOG10(SING)/ALG4O2 - ONE;
               0  IER=MAX0(IER,65);
               0  GO TO 160;
               0  95 IT=IT + 1;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(IT.GT.3) GO TO 100;
               0  H2NXT=FOUR;
               0  SINGNX=SING+SING;
               0  100 IF(H2NXT.LT.SINGNX) GO TO 105;
               0  FEXTRP=SINGNX;
               0  SINGNX=SINGNX+SINGNX;
               0  GO TO 110;
               0  105 FEXTRP=H2NXT;
               0  H2NXT=FOUR*H2NXT;
               0  110 DO 115 I=IT,LM1;
               0  R(I+1)=ZERO;
               0  IF(TABTLM+ABS(DIF(I+1)).NE.TABTLM) R(I+1)=DIF(I)/DIF(I+1);
               0  115 CONTINUE;
               0  H2TFEX=-H2TOL*FEXTRP;
               0  IF(R(L)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  IF(R(L-1)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  ERRER=ASTEP*ABS(DIF(L));
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  DO 120 I=IT,L;
               0  AIT(I)=AIT(I) + DIF(I)*FEXTM1;
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  120 CONTINUE;
               0  GO TO 90;
               0  "                              CURRENT TRAPEZOID SUM AND RESULTING "
               0  "                                EXTRAPOLATED VALUES DID NOT GIVE  "
               0  "                                A SMALL ENOUGH *ERRER*.           "
               0  "                                NOTE -- HAVING PREVER .LT. ERRER  "
               0  "                                IS AN ALMOST CERTAIN SIGN OF      "
               0  "                                BEGINNING TROUBLE WITH IN THE FUNC"
               0  "                                TION VALUES. HENCE, A WATCH FOR,  "
               0  "                                AND CONTROL OF, NOISE SHOULD      "
               0  "                                BEGIN HERE.                       "
               0  125 FEXTRP=DMAX1(PREVER/ERRER,AITLOW);
               0  PREVER=ERRER;
               0  IF(L.LT.5) GO TO 15;
               0  IF(L-IT.GT.2.AND.ISTAGE.LT.MXSTGE) GO TO 170;
               0  ERRET=ERRER/(FEXTRP**(MAXTBL-L));
               0  IF(ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL) GO TO 170;
               0  GO TO 15;
               0  "                              INTEGRAND HAS JUMP (SEE NOTES)      "
               0  130 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170;
               0  "                                NOTE THAT  2*FN=2**L              "
               0  DIFF=ABS(T(1,L))*(FN+FN);
               0  GO TO 160;
               0  "                              INTEGRAND IS STRAIGHT LINE          "
               0  "                                TEST THIS ASSUMPTION BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO END POINTS OF THE SUB-INTERVAL"
               0  "                                IF TEST IS PASSED, ACCEPT *VINT*  "
               0  135 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  DO 140 I=1,4;
               0
               0  "CHANGED"
               0  "DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  IF(TABTLM+DIFF.NE.TABTLM) GO TO 155;
               0  140 CONTINUE;
               0  GO TO 160;
               0  "                              NOISE MAY BE DOMINANT FEATURE       "
               0  "                                ESTIMATE NOISE LEVEL BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO ENDPOINTS. IF SMALL ENOUGH,   "
               0  "                                ACCEPT *VINT*                     "
               0  145 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  I=1;
               0
               0  "CHANGED"
               0  "150 DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  155 ERRER=DMAX1(ERRER,ASTEP*DIFF);
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  I=I+1;
               0  IF(I.LE.4) GO TO 150;
               0  IER=66;
               0  "                              INTERGRATION OVER CURRENT SUB-      "
               0  "                                INTERVAL SUCCESSFUL               "
               0  "                                ADD *VINT* TO *DCADRE* AND *ERRER*"
               0  "                                TO *ERROR*, THEN SET UP NEXT SUB- "
               0  "                                INTERVAL, IF ANY.                 "
               0  160 CADRE=CADRE + VINT;
               0  ERROR=ERROR + ERRER;
               0  IF(RIGHT) GO TO 165;
               0  ISTAGE=ISTAGE - 1;
               0  IF(ISTAGE.EQ.0) GO TO 220;
               0  REGLAR=REGLSV(ISTAGE);
               0  BEG=BEGIN(ISTAGE);
               0  END=FINIS(ISTAGE);
               0  CUREST=CUREST - EST(ISTAGE+1) + VINT;
               0  IEND=IBEG - 1;
               0  FEND=TS(IEND);
               0  IBEG=IBEGS(ISTAGE);
               0  GO TO 180;
               0  165 CUREST=CUREST + VINT;
               0  STAGE=STAGE+STAGE;
               0  IEND=IBEG;
               0  IBEG=IBEGS(ISTAGE);
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  GO TO 5;
               0  "                              INTEGRATION OVER CURRENT SUBINTERVAL"
               0  "                                IS UNSUCCESSFUL. MARK SUBINTERVAL "
               0  "                                FOR FURTHER SUBDIVISION. SET UP   "
               0  "                                NEXT SUBINTERVAL.                 "
               0  170 REGLAR=.TRUE.;
               0  175 IF(ISTAGE.EQ.MXSTGE) GO TO 205;
               0  IF(RIGHT) GO TO 185;
               0  REGLSV(ISTAGE+1)=REGLAR;
               0  BEGIN(ISTAGE)=BEG;
               0  IBEGS(ISTAGE)=IBEG;
               0  STAGE=STAGE*HALF;
               0  180 RIGHT=.TRUE.;
               0  BEG=(BEG+END)*HALF;
               0  IBEG=(IBEG+IEND)/2;
               0  TS(IBEG)=TS(IBEG)*HALF;
               0  FBEG=TS(IBEG);
               0  GO TO 10;
               0  185 NNLEFT=IBEG - IBEGS(ISTAGE);
               0  IF(IEND+NNLEFT.GE.MAXTS) GO TO 200;
               0  III=IBEGS(ISTAGE);
               0  II=IEND;
               0  DO 190 I=III,IBEG;
               0  II=II + 1;
               0  TS(II)=TS(I);
               0  190 CONTINUE;
               0  DO 195 I=IBEG,II;
               0  TS(III)=TS(I);
               0  III=III + 1;
               0  195 CONTINUE;
               0  IEND=IEND + 1;
               0  IBEG=IEND - NNLEFT;
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  FINIS(ISTAGE)=END;
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  BEGIN(ISTAGE)=END;
               0  REGLSV(ISTAGE)=REGLAR;
               0  ISTAGE=ISTAGE + 1;
               0  REGLAR=REGLSV(ISTAGE);
               0  EST(ISTAGE)=VINT;
               0  CUREST=CUREST + EST(ISTAGE);
               0  GO TO 5;
               0  "                              FAILURE TO HANDLE GIVEN INTEGRA-    "
               0  "                                TION PROBLEM                      "
               0  200 IER=131;
               0  GO TO 215;
               0  205 IER=132;
               0  GO TO 215;
               0  210 IER=133;
               0  215 CADRE=CUREST + VINT;
               0  220 DCADRE=CADRE;
               0  9000 CONTINUE;
               0  9005 RETURN;
               0  END;  "END OF FUNCTION DCADRE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE SPINIT(density_file);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0
               0  COMIN/PMCONS,SPCOMM,DERCON,MOLVAR,BREMPRP,ELEMTB,LSPION,EPSTAR,THRESHP,
               0  EGS-IO,MIXDAT,MISC/;
               0
               0  $REAL4 IMEV;
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,egs_get_unit;
               0  $REAL4    VPLASM,ALIADG,EDENL,ALGASP,EPSTRH,
               0           TLRNCE,EPSTWT;
               0  CHARACTER*256 density_file;
               0
               0  TOLN10=2.0*LOG(10.0);IM=-100;
               0
               0  IF(EPSTFLP < 0 | EPSTFLP > 1) [
               1          EPSTFLP = 0;
               1  ]
               0  "ABOVE IS NRCC MOD DEC 1988"
               0
               0  IF(EPSTFLP=0)["DEFAULT TO STANDARD PEGS4 METHODS"
               1
               1  "MATERIAL MUST BE FOUND IN THE SSB TABLE OR THE S-P"
               1  "      GENERAL FORMULA WILL BE USED.
               1
               1  "CHECK TO SEE IF MATERIAL IS A 'STERNHEIMER-SELTZER-BERGER' (SSB)"
               1  "MATERIAL, FOR WHICH THE DENSITY EFFECT PARAMETERS ARE ALREADY"
               1  "SPECIFIED.  IF IT IS NOT, THEN CALCULATE THEM USING THE GENERAL"
               1  "FORMULA BY STERNHEIMER-PEIERLS (S-P)."
               1
               1  "STERNHEIMER-SELTZER-BERGER (SSB) LOOKUP TABLE SECTION:"
               1  :TRY: DO IM=1,NUMSTMED [DO J=1,LMED
               2  [IF (IDSTRN(J).NE.MEDTBL(J,IM)) NEXT :TRY:;]
               2  "CALCULATION FOLLOWS IF A MATCH IS FOUND"
               2  AFACT=STDATA(1,IM); SK=STDATA(2,IM); X0=STDATA(3,IM);
               2  X1=STDATA(4,IM); IEV=STDATA(5,IM); CBAR=STDATA(6,IM);
               2  IMEV=IEV*1.0E-6; "EV TO MEV"
               2  VPLASM=SQRT(EDEN*R0*C**2/PIP);
               2  GO TO :SSB-PARAMETERS-DEFINED:;]
               1
               1  "STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION:"
               1  IM=0;
               1  "DETERMINE THE MEAN EXCITATION ENERGY, IMEV (IN MEV)"
               1  IF (NEP.EQ.1) ["ELEMENT"
               2  IZ=ZELEMP(1);
               2  IF (IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8) ["I.E., DIATOMIC MOLECULE"
               3  OUTPUT ; (' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/,
               3   ' ELEMENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/,
               3   ' REMEDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/,
               3   '          AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/,
               3   '          (I.E., IDSTRN) LIKE H2-GAS');
               3  $CALL_EXIT(21);]
               2  IEV=ITBL(IZ);     "EV"
               2  ]
               1
               1  ELSE ["COMPOUND/MIXTURE---USE BRAGG ADDITIVITY RULE"
               2  ALIADG=0.0;
               2  DO IE=1,NEP [
               3  IZ=ZELEMP(IE);
               3  IF (IZ.EQ.1) [IEV=19.2;]   "EV"
               3  ELSEIF (IZ.EQ.6) [IF (GASPP.EQ.0.0) [IEV=81.0;] ELSE [IEV=70.0;]]
               3  ELSEIF (IZ.EQ.7) [IEV=82.0;]
               3  ELSEIF (IZ.EQ.8) [IF (GASPP.EQ.0.0) [IEV=106.0;] ELSE [IEV=97.0;]]
               3  ELSEIF (IZ.EQ.9) [IEV=112.0;]
               3  ELSEIF (IZ.EQ.17) [IEV=180.0;]
               3  ELSE [IEV=1.13*ITBL(IZ);]
               3  "NRCC comment - above 7 lines reflect table 6 in ref 59 of SLAC-265"
               3  "       Berger and Seltzer's fudge to get better agreement with expt"
               3  ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV);
               3  ]
               2  ALIADG=ALIADG/ZC;
               2  IEV=EXP(ALIADG);    "EV"
               2  ]
               1
               1  IMEV=IEV*1.0E-6;  "EV TO MEV"
               1  "COMPUTE VARIOUS STERNHEIMER CONSTANTS"
               1  IF (GASPP.EQ.0.0) [EDENL=EDEN;]
               1  ELSE ["VPLASM MUST BE FOR NTP FOR A GAS, AND EDEN HAS"
               2  "      BEEN DEFINED IN MIX FOR THE ACTUAL PRESSURE"
               2         EDENL=EDEN/GASPP;]
               1  VPLASM = SQRT(EDENL*R0*C**2/PIP);
               1  "ABOVE PATCHED JAN 9,1989 TO REFLECT ERROR POINTED OUT BY"
               1  "PROF KAMAE, TOKYO UNIVERSITY, VIA HIDEO HIRAYAMA"
               1
               1  CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV));
               1
               1  IF (NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)[
               2            "SPECIAL HE(GAS) CASE"
               2  X0=2.191; X1=3.0; SK=3.297;
               2  ]
               1
               1  ELSEIF (NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1
               1          .AND.INT(ZELEMP(2)).EQ.1) [
               2  IF (GASPP.EQ.0.0) ["SPECIAL H2(LIQUID) CASE"
               3  X0=0.425; X1=2.0; SK=5.949;
               3  ]
               2  ELSE ["SPECIAL H2(GAS) CASE"
               3  X0=1.837; X1=3.0; SK=4.754;
               3  ]
               2  ]
               1
               1  ELSE ["REGULAR CASES"
               2  SK=3.0;
               2  IF (GASPP.EQ.0.0) ["SOLIDS AND LIQUIDS"
               3  IF (IEV.LT.100.0) [
               4  IF (CBAR.LT.3.681) [X0=0.2; X1=2.0;]
               4  ELSE [X0=0.326*CBAR - 1.0; X1=2.0;]
               4  ]
               3  ELSE ["IEV GE 100.0"
               4  IF (CBAR.LT.5.215) [X0=0.2; X1=3.0;]
               4  ELSE [X0=0.326*CBAR - 1.5; X1=3.0;]
               4  ]
               3  IF (X0.GE.X1) [OUTPUT X0,X1,CBAR;
               4  (' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',3G15.5,/
               4  ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)'); $CALL_EXIT(21);]
               3  ]
               2  ELSE ["GASES---AT NTP AT THIS STAGE"
               3  IF (CBAR.LT.10.0) [X0=1.6; X1=4.0;]
               3  ELSEIF (CBAR.LT.10.5) [X0=1.7; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.0) [X0=1.8; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.5) [X0=1.9; X1=4.0;]
               3  ELSEIF (CBAR.LT.12.25) [X0=2.0; X1=4.0;]
               3  ELSEIF (CBAR.LT.13.804) [X0=2.0; X1=5.0;]
               3  ELSE [X0=0.326*CBAR - 2.5; X1=5.0;]
               3  ]
               2  ]  "END OF STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION"
               1
               1  :SSB-PARAMETERS-DEFINED:
               1
               1  "GAS PRESSURE CORRECTION COMES NEXT"
               1  IF (GASPP.NE.0.0) [
               2  ALGASP=LOG(GASPP);
               2  CBAR=CBAR - ALGASP;
               2  X0=X0 - ALGASP/TOLN10;
               2  X1=X1 - ALGASP/TOLN10;
               2  ]
               1
               1  IF (IM.EQ.0) [AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK;]
               1  ]"END OF EPSTFL=0 BLOCK"
               0
               0  ELSE[ "EPSTFL=1 BLOCK  I.E. READ IN THE INPUT FROM THE DENSITY"
               1       "INPUT FILE"
               1  "get the name of the density file"
               1  density_file=$cstring(density_file);
               1  density_unit=20;
               1  density_unit=egs_get_unit(density_unit);
               1  IF( density_unit < 1 ) [
               2          $egs_fatal(*,'SPINIT: failed to get a free fortran unit');
               2  ]
               1  open(density_unit,file=density_file,status='old',err=:no_density_file:);
               1
               1  READ(density_unit,:A:)EPSTTL;:A:  FORMAT(A);
               1  READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS;
               1  READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS);
               1  READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST);
               1
               1  close(density_unit);
               1
               1  IF(NEPST>150)[OUTPUT NEPST;
               2  (//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED');$CALL_EXIT(22);]
               1  "CONVERT TO TOTAL ENERGIES"
               1  DO I=1,NEPST[EPSTEN(I) = EPSTEN(I) + RMP;]
               1  IMEV = IEV*1.E-06;
               1
               1  "CHECK THAT WE HAVE COVERED ENERGY RANGES NEEDED"
               1  IF( AEP < EPSTEN(1))[OUTPUT EPSTEN(1),AEP;
               2  (//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO AE***'//);EPSTEN(1) = AEP;]
               1  IF( UEP > EPSTEN(NEPST))[ OUTPUT EPSTEN(NEPST),UEP;
               2  (//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO UE***'//);EPSTEN(NEPST) = UEP;]
               1
               1  "DO A CHECK ON THE COMPOSITION AND DENSITY TO INSURE THE RIGHT DELTA"
               1  "HAS BEEN PICKED UP. ALLOW A TOLERANCE OF 1 PERCENT ERROR ON THE"
               1  "COMPOSITION BY WEIGHT."
               1
               1  ICHECK=0; "FLAG GETS SET TO UNITY IF THE COMPOSITION DOES NOT MATCH"
               1      TLRNCE=0.01; "TOLERANCE ALLOWED ON FRACTION BY WEIGHT"
               1
               1  "FIRST CHECK THAT THE NUMBER OF ELEMENTS ARE THE SAME"
               1  IF(NELEPS.NE.NEP) ICHECK=1;
               1
               1  "NOW CHECK THAT THE DENSITIES ARE THE SAME WITHIN TOLERANCE"
               1  IF( (ICHECK.EQ.0)  .AND.
               1    ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR.
               1      (EPSTRH.GT.((1.0+TLRNCE)*RHOP))
               1    ) ) ICHECK=1; "DENSITY IS OUT OF RANGE"
               1  "WE MUST FIRST NORMALIZE THE PEGS FRACTIONS BY WEIGHT TO ENSURE THEY"
               1  "ARE NORMALIZED TO UNITY"
               1  EPSTWT = 0.0;DO I=1,NEP[ EPSTWT = EPSTWT + RHOZP(I);]
               1  IF(EPSTWT=0.0)[
               2  OUTPUT;(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHT OF',
               2  'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//);]
               1
               1  IF(ICHECK.EQ.0)[
               2      IESPEL=0;    "INITIALIZE ESP ELEMENT COUNTER"
               2      ICHECK=1;    "ASSUME FAILURE"
               2      LOOP["LOOP OVER ESP COMPONENTS"
               3          IESPEL=IESPEL+1;
               3          IPEGEL=0;    "INITIALIZE PEGS ELEMENT COUNTER"
               3          LOOP["LOOP OVER PEGS COMPONENTS"
               4              IPEGEL=IPEGEL+1;
               4              IF(INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))[ICHECK=0;EXIT;]
               4              ]WHILE(IPEGEL.LT.NEP);
               3              IF( (ICHECK.EQ.0) "Z OF ELEMENT MATCHES"
               3              .AND.
               3              ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3               .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3              ) ) ICHECK=1; "MATCHED ELEMENT BUT WEIGHT FRACTION WRONG"
               3          ]WHILE(IESPEL.LT.NELEPS);
               2      ] "END OF TEST FOR ICHECK = 0"
               1
               1  IF(ICHECK.EQ.1)[ "PRINT MESSAGE AND STOP"
               2  OUTPUT;
               2  (////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MATCH ',
               2  ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////);
               2  $CALL_EXIT(23); " ERRORS DETECTED";
               2  ]
               1
               1
               1  ]"END OF EPSTFL=1 BLOCK"
               0
               0
               0  SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP;
               0  SPC2=LOG((IMEV/RMP)**2/2.0);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP SPC1,SPC2;"
               0
               0  RETURN;
               0  :no_density_file:
               0  $egs_fatal(*,' Failed to open density file ',density_file);
               0  RETURN;
               0  END;  "END OF SUBROUTINE SPINIT"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE MIX;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0  implicit none;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER I,IZZ;
               0  $REAL4    AL183,ZAB,V2000;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 FCOULCP,XSIFP;
               0
               0  COMIN/MIMSD,MIXDAT,MOLVAR,PMCONS,DERCON,RADLEN,BREMPRP/;
               0  $REAL4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20);
               0  " MOLVAR - - MOLECULAR VARIABLES NEEDED BY DIFFER, AND MOLIER      "
               0
               0  " THE FOLLOWING ASSUMES THAT THE MATERIAL BEING DEALT WITH         "
               0  " IS EITHER A COMPOUND, OR A HOMOGENEOUS MIXTURE.                  "
               0  "          MOLECULAR VARIABLES                                     "
               0  " NE       NUMBER OF DIFFERENT TYPES OF ATOMS IN THE MATERIAL.     "
               0  " PZ(I)    PROPORTION OF ELEMENT OF TYPE I.  IF A COUMPOUND,       "
               0  " THEN PZ(I) WILL BE THE NUMBER OF ATOMS OF TYPE I IN THE MOLECULE."
               0  " IF A MIXTURE,SUCH AS CONCRETE, PZ(I) COULD BE THE PER CENT OF    "
               0  " THE ATOMS WHICH ARE OF TYPE I.                                   "
               0  " Z(I)     PERIODIC NUMBER OF ATOMS OF TYPE I                      "
               0  " WA(I)    ATOMIC WEIGHT FOR ATOMS OF TYPE I.                      "
               0  " WM = SUM(PZ(I)*WA(I)) = MOLECULAR  WEIGHT IF A COUMPOUND         "
               0  " OR A 'MIXTURE WEIGHT' IF A MIXTURE.                              "
               0  " RHO      DENSITY OF THE MATERIAL. (IN GRAMS/CM**3)               "
               0  " RHOZ(I)  PARTIAL DENSITY DUE TO ATOMS OF TYPE I. (GM/CM**3)      "
               0  "          ELECTRON DENSITY VARIABLE                               "
               0  " ZC = SUM(PZ(I)*Z(I)) = NUMBER OF ELECTRONS/MOLECULE              "
               0  "          BREMSSTRAHLUNG AND PAIR PRODUCTION VARIABLES ARE WEIGHTE"
               0  " BY PZ(I)*Z(I)**2 FOR THE NUCLEUS, AND BY PZ(I)*Z(I)*XSI(I) FOR   "
               0  " ATOMIC ELECTRONS.                                                "
               0  " TPZ = SUM(PZ(I))                                                 "
               0  " XSI(I) = LOG(A1440/Z(I)**(2./3.))/(LOG(A183/Z(I)**(1./3.))  -    "
               0  "               FCOUL(Z(I)) )                                      "
               0  " ZZX(I) =  PZ(I)*Z(I)*(Z(I)+XSI(I)) = BREMS AND PAAR WEIGHTS      "
               0  " EZ = ZC/TPZ  EFFECTIVE Z                                         "
               0  " ZT = SUM(ZZX(I))                                                 "
               0  " ZA = LOG(A183)*ZT   BUTCHER AND MESSELS L.C.'A' (1960)P.18       "
               0  " ZB = SUM(ZZX(I)*LOG(Z(I)**(-1./3.)  B&M'S L.C.'B' IBID.          "
               0  " ZF = SUM(ZZX(I)*FCOUL(Z(I))),WHERE FCOUL IS THE COULOMB          "
               0  " CORRECTION FUNCTION.                                             "
               0  " RATIOS--                                                         "
               0  " ZG = ZB/ZT ,EXP(ZG)=WEIGHTED GEOMETRIC MEAN OF Z**(-1/3)         "
               0  " ZP = ZB/ZA , B&M IBID.P18 L.C.'P'                                "
               0  " ZV= (ZB-ZF)/ZT                                                   "
               0  " ZU = (ZB-ZF)/ZA                                                  "
               0  "          MULTIPLE SCATTERING VARIABLES                           "
               0  " ACCORDING TO MESSEL AND CRAWFORD(1970), MOST OF THE MULTIPLE     "
               0  " SCATTERING DUE TO THE FIELD OF THE ATOMIC ELECTRONS IS ALREADY   "
               0  " ACCOUNTED FOR BY THE DISCRETE MOLLER SCATTERING. HENCE,THE       "
               0  " FOLLOWING VARIABLES ARE ONLY WEIGHTED BY PZ(I)*Z(I)**2           "
               0  " HOWEVER I HAVE NOT JUSTIFIED THE ABOVE ASSERTION THEORETICALLY   "
               0  " THEORETICALLY, AND COMPARISON OF EXPERIMENTS WITH EGS HAVE       "
               0  " SHOWN EGS PHOTON SPECTRUM DEFICIENT IN THE BACKWARD DIRECTION.   "
               0  " THEREFORE, I WILL EXPERIMENT WITH RESTORING THE ELECTRON SCATTER-"
               0  " ING TERM.  ITS CONTRIBUTION WILL BE REPRESENTED BY THE MACRO VAR-"
               0  " IABLE, $FUDGEMS, WHICH WILL HAVE THE VALUE 0.0 FOR NO ELECTRON   "
               0  " SCATTERING AND 1.0 FOR FULL ELECTRON SCATTERING.  AND WE NOW HAVE"
               0  " WEIGHTING BY PZ(I)*Z(I)*(Z(I)+$FUDGEMS).                         "
               0  " ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS) "
               0  " ZS = SUM(ZZ(I))                                                  "
               0  " ZE = SUM(ZZ(I)*LOG(Z(I)**(-2./3.)))                              "
               0  " ZX = SUM(ZZ(I)*LOG(1.+3.34*(FSC*Z(I))**2))                       "
               0  "               ELECTON DENSITY(ELECTRONS/CM**3)                   "
               0  " EDEN=AN*RHO/WM*ZC                                                "
               0  "          RADIATION LENGTH                                        "
               0  " USEFUL FOR GAUGING THE STEP SIZE, EVEN IF IT IS NOT USED AS THE  "
               0  " UNIT OF DISTANCE.                                                "
               0  "  1./RLC =(AN*RHO/WM)*4.0*FSC*R0**2*                              "
               0  "    SUM( Z(I)*(Z(I)+XSI(I))*(LOG(A183*Z(I)**(-1./3.)-FCOUL(Z(I))) "
               0  "        =(AN*RHO/WM)*4.*FSC*R0**2*(ZAB-ZF)                        "
               0  " INPUT MOLECULAR VARIABLES AND COMPUTE Z-RELATED PARAMETERS       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "SCALE RHO FOR GASES BY THE GAS PRESSURE"
               0  IF (GASPP.NE.0.0) [RHOP=GASPP*RHOP;]
               0  "     FIND VARIOUS SUMS AND SET OTHER VARIABLES                        "
               0  AL183 = LOG(A183);
               0  /TPZ,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZAB/=0.0;
               0  DO I=1,NEP[
               1  TPZ = TPZ + PZP(I);
               1  WM = WM + PZP(I)*WAP(I);
               1  ZC = ZC + PZP(I)*ZELEMP(I);
               1  FZC(I) =(FSC*ZELEMP(I))**2;
               1  FCOUL(I) = FCOULCP(ZELEMP(I));
               1  XSI(I) = XSIFP (ZELEMP(I));
               1  ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I));
               1  IF (ZELEMP(I).LE.4.0) [IZZ=ZELEMP(I);
               2  ZAB=ZAB+ZZX(I)*ALRAD(IZZ);] "IN THE CASE OF Z.LE.4 "
               1  ELSE [ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)));] "Z.GT.4"
               1  ZT = ZT + ZZX(I);
               1  ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.));
               1  ZF = ZF + ZZX(I)*FCOUL(I);
               1  ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+$FUDGEMS);
               1  ZS = ZS + ZZ(I);
               1  ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)));
               1  ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I));
               1  ]
               0  "END OF I LOOP"
               0  EZ = ZC/TPZ;
               0  ZA = AL183*ZT;
               0  ZG = ZB/ZT;
               0  ZP = ZB/ZA;
               0  ZV = (ZB-ZF)/ZT;
               0  ZU = (ZB-ZF)/ZA;
               0  EDEN=AN*RHOP/WM*ZC;
               0  RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) );
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP EDEN;"
               0
               0  "NOW COMPUTE MATERIAL-DEPENDENT CONSTANTS FOR MULTIPLE SCATTERING"
               0  "LET B BE MOLIERE'S UPPER CASE B, AND LET BLC BE MOLIERE'S LOWER CASE B"
               0  "THEN USING SCOTT'S NOTATION, A MEASURE OF THE NUMBER OF SCATTERS IS"
               0  "OMEGA0=EXP(BLC).  NOW B AND BLC ARE RELATED BY"
               0  "BLC=B-ALOG(B);, OR EXP(BLC)=EXP(B)/B; "
               0  "NOW LET T BE THE TRANSPORT DISTANCE IN RL. THEN,"
               0  "OMEGA0=EXP(BLC)"
               0  "      =( A6680*RHO*ZS*EXP(ZE/ZS)*RLC/(WM*EXP(ZX/ZS)) )*T/BETA**2"
               0  "WHERE BETA IS V/C FOR THE PARTICLE"
               0  "NOW SUPPOSE THAT XC IS CHI-SUB-C, THE CHARACTERISTIC ANGLE OF"
               0  "MOLIERE'S THEORY.  THEN IT IS GIVEN BY"
               0  "XC= (A22P9/RADDEG)*SQRT( ZS*RHO*RLC/WM ) * SQRT(T) /(E*BETA**2) "
               0  " WHERE E IS THE ENERGY OF THE PARTICLE IN MEV."
               0  "NOW IN MOLIERE'S THEORY, LET XRM BE XC*SQRT(B).  THEN"
               0  " (MOLIERE'S REDUCE ANGLE)=(REAL ANGLE)/XRM."
               0  "FOR THE VARIABLE SAMPLING DONE IN EGS, A DIFFERENT REDUCED"
               0  "ANGLE IS USED:"
               0  " (REDUCED ANGLE FOR VARIABLE SAMPLING)=(REAL ANGLE)/XRV "
               0  " WHERE NOW XRV=XC*SQRT(BLC)."
               0  "THIS IS DONE BECAUSE BLC IS MORE SIMPLY RELATED TO THE TRANSPORT"
               0  "DISTANCE THAN IS B."
               0
               0  "WITH THIS BACKGROUND WE NOW PROCEED TO COMPUTE"
               0  "XR0, TEFF0, BLCC, AND XCC, WHICH ARE PARAMETERS NEEDED IN EGS"
               0  "THESE PARAMETERS ARE USED AS FOLLOWS:(IN OUR NOTATION)"
               0  "XRM=XR0*SQRT(T*B/(T0*BMIN))/(E*BETA) "
               0  "  WHERE B IS EVALUATED FOR DISTANCE T, AND T0 IS THE"
               0  "  DISTANCE THAT WOULD GIVE B=BMIN. T0 IS A FUNCTION OF BETA, AND"
               0  "  IS GIVEN BY THE EXPRESSION  "
               0  "T0=TEFF0*BETA**2;  THIS IS ALSO THE DEFINING RELATION FOR TEFF0"
               0  "BMIN IS THE MINIMUM VALUE OF B FOR WHICH MOLIERE CONSIDERED HIS THEORY"
               0  "VALID.  WE CURRENTLY GIVE BMIN A VALUE OF 4.5."
               0  "OMEGA0=BLCC*T/BETA**2  IS THE USEAGE OF BLCC"
               0  "XRV= XCC*SQRT( T*BLC )/(E*BETA**2) IS THE USAGE OF XCC"
               0
               0  "WE NOW PROCEED TO SOLVE FOR THE ABOVE QUANTITIES."
               0  "COMPARING THE TWO EXPRESSIONS FOR OMEGA0, WE CONCLUDE THAT:"
               0
               0  BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS)) ;
               0  "NOW USING THE EXPRESSION FOR OMEGA0 AT B=BMIN,WE HAVE"
               0  " OMEGA0=EXP(BLCMIN)"
               0  "       =EXP(BMIN)/BMIN"
               0  "       =BLCC*T0/BETA**2"
               0  "       =BLCC*TEFF0    ,     THEREFORE"
               0
               0  TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP;
               0
               0  "COMPARING THE TWO EXPRESSION FOR XRV WE CONCLUDE THAT"
               0  "XC= XCC * SQRT(T) /(E*BETA**2)"
               0  "COMPARING THIS WITH OUR PREVIOUS EXPRESSION FOR XC, WE OBTAIN"
               0
               0  XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM );
               0
               0  "NOW COMPARING THE TWO EXPRESSIONS FOR XRM WE OBTAIN"
               0  "XRM=XC*SQRT(B)       USING DEFINITION OF XRM"
               0  "   =(XCC(i_med)*SQRT(T)/(E*BETA**2)) *SQRT(B)  AFTER SUBSTITUTING FOR XC"
               0  "   =XR0*SQRT((T*B)/(T0*BMIN))/(E*BETA)  USING EXPRESSION DEFINING XR0"
               0  "   =XR0*SQRT((T*B)/(TEFF0*BETA**2*BMIN))/(E*BETA)  EXPANDING T0"
               0  " THUS AFTER SOME CANCELLATION AND SOLVING FOR XR0 WE OBTAIN"
               0
               0  XR0P = XCCP*SQRT(TEFF0P*BMIN);
               0
               0  "THIS COMPLETE THE MS CALCULATIONS"
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE MIX"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE DIFFER;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN;
               0  INTEGER I;
               0
               0  COMIN/MOLVAR,BREMPRP,DBRPR,DERCON,RADLEN/;
               0  "**********************************************************************"
               0  "***THE DIFFERENTIAL CROSS-SECTIONS OF BREMSSTRAHLUNG AND PAIR       "
               0  "   PRODUCTION ARE Z-DEPENDENT.  BUTCHER AND MESSEL USE A SAMPLING   "
               0  "   TECHNIQUE FOR BREMSSTRAHLUNG WHICH ALSO DEPENDS ON THE LARGEST   "
               0  "   AND SMALLEST ALLOWED ENERGY VALUES.                              "
               0  "   THIS IS NOW TAKEN INTO ACCOUNT BY THE FUNCTION ILOG2(E/AP) WHICH "
               0  "   GIVES THE NUMBER OF SUBDISTRIBUTIONS NEED TO PRODUCE PHOTONS DOWN"
               0  "   TO THE LIMIT AP.                                                 "
               0  "   THE DIFFERENTAL CROSS SECTIONS USED FOR BREMS AND PAIR ARE--     "
               0  "   (THEY ARE CROSS SECTION PER RADIATION LENGTH)                    "
               0
               0  "***BELOW 50MEV (BETHE-HEITLER)--                                      "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZP)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3 - 1/(36*LOG(A183)*(1+ZP)))*(1) * C(DELTAPRIME)         "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZP))))* (12*(EPS-1/2)**2)       "
               0  "    2 * A(DELTAPRIME)                                                 "
               0  "       WHERE A,B,C ARE SCREENING REJECTION FUNCTIONS GIVEN BY         "
               0  "       A(D)=(3*F1(D)-F2(D)+8*ZG)/(3*F1(0)-F2(0)+8*ZG)                 "
               0  "       B(D)=(F1(D)+4*ZG)/(F1(0)+4*ZG)                                 "
               0  "       C(D)=(3*F1(D)+F2(D)+16*ZG)/(3*F1(0)+F2(0)+16*ZG)               "
               0  "       AND WHERE                                                      "
               0  "       DELTAPRIME= 136.*EXP(ZG)*RM*DEL= DELCM *DEL                    "
               0  "       AND                                                            "
               0  "       DEL =  EPS/(E*(1-EPS))      BREMSSTRAHLUNG                     "
               0  "           =  1/(E*EPS*(1-EPS))    PAIR PRODUCTION                    "
               0  "       F1(D) AND F2(D) ARE SCREENING FUNCTIONS GIVEN APPROXIMATELY BY "
               0  "             IF D.LE.1 ,THEN                                          "
               0  "       F1(D) = 20.867 - 3.242*D + 0.625*D**2                          "
               0  "       F2(D) = 20.209 - 1.930*D - 0.086*D**2                          "
               0  "         BUT IF D.GT.1 ,THEN                                          "
               0  "       F1(D)=F2(D)= 21.12 - 4.184*ALOG(D+0.952)                       "
               0  "         IN ADDITION WE HAVE THAT                                     "
               0  "       F1(0)= 4.*ALOG(A183)                                           "
               0  "       F2(0)= F1(0) - 2./3.                                           "
               0  "***ABOVE 50 MEV (COULOMB CORRECTED BETHE HEITLER)                     "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZU)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3-1/(36*LOG(A183)*(1+ZU)))* 1 * C(DELTAPRIME)            "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZU))))* (12*(EPS-1/2)**2)       "
               0  "    2  * A(DELTAPRIME)                                                "
               0  "       WHERE A,B,AND C ARE NOW GIVEN BY                               "
               0  "       A(D) = (3*F1(D)-F2(D)+8*ZV)/(3*F1(0)-F2(0)+8*ZV)               "
               0  "       B(D) = (F1(D)+4*ZV)/(F1(0)+4*ZV)                               "
               0  "       C(D) = (3*F1(D)+F2(D)+16*ZV)/(3*F1(0)+F2(0)+16*ZV)             "
               0  "       AND DELTAPRIME,DEL,F1, AND F2 ARE THE SAME AS BELOW 50 MEV.    "
               0  "   BREMSSTRAHLUNG ALPHA(I), I=1,...,N.  ALPHA(N+1)=0.5                "
               0  AL2 = LOG(2.);
               0  AL183= LOG(A183);
               0  ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)));
               0  ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)));
               0  "*****PAIR PRODUCTION DIFFERENTIAL CROSS-SECTION NUMBERS               "
               0  ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP));
               0  ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU));
               0  ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)));
               0  ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)));
               0  "*****BRANCHING RATIO FOR PAIR PRODUCTION SAMPLING                     "
               0  BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1));
               0  BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2));
               0
               0  "*****WE MUST ALWAYS HAVE A,B,C(DELTA) POSITIVE. SHOWER ASSURES THIS BY"
               0  "     REQUIRING DEL.LT.DELPOS(),AND HENCE THAT DELTA.LT.DELCM *DELPOS()"
               0  "     THE CROSS-OVER POINT IS IN THE DELTA.GT.1 REGION,AND THE CROSSING"
               0  "     CONDITION REDUCES TO --                                          "
               0  "       F1(D) + 4*ZG = 0     IF  E.LT.50 MEV                           "
               0  "       F1(D) + 4*ZV = 0     IF  E.GT.50 MEV                           "
               0  "     OR --                                                            "
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(1)+0.952) +4.*ZG =0     E.LT.5"
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(2)+0.952) +4.*ZV =0     E.GT.5"
               0  "       THUS DELPOS IN THE TWO ENERGY REGIONS IS GIVEN BY              "
               0  DELCMP= 136.0*EXP(ZG)*RMP;
               0  DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP;
               0  DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP;
               0  "     CALCULATION OF THE BETHE-HEITLER(B-H) A,B,C(DELTA).AND THE       "
               0  "     COULUMB CORRECTED(CC) A,B,C(DELTA).  THE SHOWER PROGRAM COMPUTES "
               0  "     THESE SIX SCREENING REJECTION FUNCTION WITH THE EXPRESSIONS--    "
               0  "       DL1(LVL)+DELTA*(DL2(LVL)+DELTA*DL3(LVL))   IF DELTA.LT.1 ,AND B"
               0  "       DL4(LVL)+DL5(LV)*ALOG(DELTA+DL6(LVL))      IF DELTA.GE.1       "
               0  "       WHERE LVL IS USED TO SELECT THE FUNCTION--                     "
               0  "       LVL=1   B-H A(DELTA)                                           "
               0  "          =2   B-H B(DELTA)                                           "
               0  "          =3   B-H C(DELTA)                                           "
               0  "          =4   CC  A(DELTA)                                           "
               0  "          =5   CC  B(DELTA)                                           "
               0  "          =6   CC  C(DELTA)                                           "
               0  "     FIRST COMPUTE THE DENOMINATORS                                   "
               0  F10=4.*AL183;
               0  F20=F10 - 2./3.;
               0  A1DEN =3.0*F10- F20 + 8.0*ZG;
               0  A2DEN =3.0*F10- F20 + 8.0*ZV;
               0  B1DEN = F10 + 4.0*ZG;
               0  B2DEN = F10 + 4.0*ZV;
               0  C1DEN = 3.0*F10+ F20 + 16.0*ZG;
               0  C2DEN = 3.0*F10+ F20 + 16.0*ZV;
               0  "     LVL=1, B-H A(DELTA)                                              "
               0  DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN;
               0  DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN;
               0  DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN;
               0  DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN;
               0  DLP5(1)=  2.0*(-4.184)/A1DEN;
               0  DLP6(1)=  0.952;
               0  "     LVL=4, CC  A(DELTA)                                              "
               0  DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN;
               0  DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN;
               0  DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN;
               0  DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN;
               0  DLP5(4)=  2.0*(-4.184)/A2DEN;
               0  DLP6(4)=  0.952;
               0  "     LVL=2, B-H B(DELTA)                                              "
               0  DLP1(2)= (20.867+4.0*ZG)/B1DEN;
               0  DLP2(2)= -3.242/B1DEN;
               0  DLP3(2)=  0.625/B1DEN;
               0  DLP4(2)= (21.12+4.0*ZG)/B1DEN;
               0  DLP5(2)= -4.184/B1DEN;
               0  DLP6(2)= 0.952;
               0  "     LVL=5, CC B(DELTA)                                               "
               0  DLP1(5)= (20.867+4.0*ZV)/B2DEN;
               0  DLP2(5)= -3.242/B2DEN;
               0  DLP3(5)= 0.625/B2DEN;
               0  DLP4(5)= (21.12+4.0*ZV)/B2DEN;
               0  DLP5(5)= -4.184/B2DEN;
               0  DLP6(5)= 0.952;
               0  "     LVL=3, B-H C(DELTA)                                              "
               0  DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN;
               0  DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN;
               0  DLP3(3)= (3.0*0.625+(-0.086))/C1DEN;
               0  DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN;
               0  DLP5(3)=  4.0*(-4.184)/C1DEN;
               0  DLP6(3)=  0.952;
               0  "     LVL=6, CC  C(DELTA)                                              "
               0  DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN;
               0  DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN;
               0  DLP3(6)= (3.0*0.625+(-0.086))/C2DEN;
               0  DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN;
               0  DLP5(6)=  4.0*(-4.184)/C2DEN;
               0  DLP6(6)=  0.952;
               0  "*****PUNCHED AND PRINTED OUTPUT                                       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE DIFFER"
               0
               0  $REAL4 function FCOULCP(Z);
               0  "************************"
               0  implicit none;
               0  $REAL4 Z,ASQ;
               0  COMIN/DERCON/;
               0  ASQ=(FSC*Z)**2;
               0  FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+
               0   ASQ*(0.0083+ASQ*(-0.002))));
               0  RETURN;
               0  END;  "END OF FUNCTION FCOULC"
               0
               0  $REAL4 function XSIFP(Z);
               0  "**********************"
               0  implicit none;
               0  $REAL4 Z,FCOULCP;
               0  $INTEGER IZ;
               0  COMIN/RADLEN/;
               0  IF (Z.LE.4.0) [IZ=Z;
               1  XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z));]
               0  ELSE [
               1  XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z));]
               0  RETURN;
               0  END;  "END OF FUNCTION XSIF"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ZTBL(IASYM);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  COMIN/ELEMTB,EGS-IO/;
               0  $TYPE IASYM,IA;
               0  $INTEGER ie;
               0  DATA IA/'A'/;
               0  save ia;
               0  IF (IASYM.EQ.IA)["ALTERNATE SYMBOL FOR ARGON" ZTBL=18.0;RETURN;]
               0  "     PUT IN THE REST LATER                                 "
               0  DO IE=1,NET[
               1  IF (IASYM.EQ.ASYMT(IE)) [ZTBL=IE; RETURN;]
               1  ]
               0  OUTPUT IASYM,NET;
               0  (1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3);
               0  ZTBL=0.0;
               0  RETURN;
               0  "END OF FUNCTION ZTBL" END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc core source code                                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but NOTE, this doesn't happen inside a REPLACE macro
               0              "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
               0  "   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
               0  "                                                                  "
               0  "   If the user requests radiative splitting (via nbr_split > 1),  "
               0  "   this routine produces 2*nbr_split annihilation photons at once,"
               0  "   each carying the fraction 1/nbr_split of the weight of the     "
               0  "   incident positron.                                             "
               0  "                                                                  "
               0  "   Except for taking out the calculation of                       "
               0  "   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
               0  "   rejection function normalized to its maximum, the sampling     "
               0  "   technique is the same as the original EGS4 implementation.     "
               0  "                                                                  "
               0  "   I. Kawrakow, January 2000                                      "
               0  "                                                                  "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                   "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
               0                   "EGS-VARIANCE-REDUCTION/;                         "
               0
               0  $DEFINE-LOCAL-VARIABLES-ANNIH;
               0  $INTEGER ip;
               0
               0  NPold = NP; "Set the old stack counter"
               0  IF( nbr_split <= 0 ) [ return; ]
               0  PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
               0                   "i.e. electron assumed to be at rest
               0  AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
               0  A=AVIP/RM;
               0  "AI=1.0/A;  AI not necessary, IK Oct 97"
               0  G=A-1.0;
               0  T=G-1.0;
               0  P=SQRT(A*T);
               0  POT=P/T;
               0  EP0=1.0/(A+P);
               0  "   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
               0  "Take the calculation of the logarithm out of the loop, IK Oct 97"
               0  WSAMP=LOG((1.0-EP0)/EP0);
               0
               0  aa = u(np); bb = v(np); cc = w(np);
               0  sinpsi = aa*aa + bb*bb;
               0  IF( sinpsi > 1e-20 ) [
               1     sinpsi = sqrt(sinpsi);
               1     sindel = bb/sinpsi; cosdel = aa/sinpsi;
               1  ]
               0
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0
               0  DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
               1                          "radiative event                              "
               1
               1      IF( np+1 > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1
               1      LOOP[
               2          $RANDOMSET RNNO01;
               2          EP=EP0*EXP(RNNO01*WSAMP);
               2          "   NOW DECIDE WHETHER TO ACCEPT"
               2          $RANDOMSET RNNO02;
               2          "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
               2          "The above rejection function has a maximum = 1 - 2/A**2"
               2          "For efficiency, it is better to divide by the maximum value, IK Oct 97"
               2          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
               2      ] UNTIL (RNNO02 <= REJF);
               1
               1
               1      "   SET UP ENERGIES"
               1      ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
               1      PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
               1      E(NP)=PESG1; IQ(NP)=0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1));
               1      SINTHE=SQRT(1.0-COSTHE*COSTHE);
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1      PESG2=PAVIP-PESG1; esg2 = pesg2;
               1      e(np) = pesg2; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2));
               1      SINTHE=-SQRT(1.0-COSTHE*COSTHE);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1
               1  ]
               0  np = np-1;
               0
               0  RETURN;
               0  "END OF SUBROUTINE ANNIH"   END;
               0
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH_AT_REST;
               0  "                                                                  "
               0  " It is handy to be able to initiate annihilation at rest from     "
               0  " places other than the electron discard section (e.g. AUSGAB)     "
               0  " Annihilation at rest takes a sufficent amount of time to not     "
               0  " have any real benefit from this code being inline in the         "
               0  " ELECTR subroutine.                                               "
               0  " I. Kawrakow, June 2005.                                          "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-ANNIH-ATREST;
               0  $REAL costhe,sinthe,cphi,sphi;
               0  $INTEGER ibr,ip;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  NPold = NP;
               0  $CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0      " nbr_split > 1 means user wants to use radiative "
               0      " splitting => produce 2*nbr_split annihilation   "
               0      " photons at once                                 "
               0  DO ibr = 1, nbr_split [
               1      "Pick random direction for first gamma
               1      $RANDOMSET costhe; costhe = 2*costhe-1;
               1      sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      e(np) = prm; iq(np) = 0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               1      np = np+1;
               1      e(np) = prm; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               1      np = np+1;
               1  ]
               0  np = np-1;
               0  return; end;
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BHABHA;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
               0  "   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
               0  "   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                     "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
               0                                  "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BHABHA;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
               0  EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
               0  PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
               0  EKIN=PEKIN;
               0  T0=EKIN/RM;
               0  E0=T0+1.;
               0  YY=1./(T0+2.);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
               0  BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  EP0C=1.-EP0;
               0  Y2=YY*YY;
               0  YP=1.-2.*YY;
               0  YP2=YP*YP;
               0  B4=YP2*YP;
               0  B3=B4+YP2;
               0  B2=YP*(3.+Y2);
               0  B1=2.-Y2;
               0  "   SAMPLE BR FROM MINIMUM(EP0) TO 1."
               0  LOOP[$RANDOMSET RNNO03;
               1  BR=EP0/(1.-EP0C*RNNO03);
               1  "   APPLY REJECTION FUNCTION"
               1  $RANDOMSET RNNO04;
               1  "REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
               1  REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
               1  ]UNTIL RNNO04.LE.REJF2 ;
               0  "   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
               0  $CHECK-STACK(np+1,'BHABHA');
               0  IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
               0  "THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
               0  "   DIVIDE UP THE ENERGY"
               0  BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
               0  PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
               0  PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
               0  ESE1=PESE1;
               0  ESE2=PESE2;
               0  E(NP)=PESE1;
               0  E(NP+1)=PESE2;
               0  "   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
               0  H1=(PEIP+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"
               0
               0  "AFB modified the following statement 92/10/28 to avoid"
               0  "numerical difficulties"
               0  "DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
               0  DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));
               0
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(2,1);
               0  NP=NP+1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE BHABHA"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BREMS;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Samples bremsstrahlung energy using                            "
               0  "    - Coulomb corrected Bethe-Heitler above 50 MeV                "
               0  "    - Bethe-Heitler below 50 MeV                                  "
               0  "   if ibr_nist = 0, or                                            "
               0  "    - the NIST bremsstrahlung cross section data base             "
               0  "      (prepared in a form of an alias table for rapid sampling)   "
               0  "   if ibr_nist = 1  or                                            "
               0  "    - the NRC bremsstrahlung cross section data base, which is    "
               0  "      the same as the NIST database, but with corrections to      "
               0  "      the electron-electron contribution, which are mostly        "
               0  "      important for low Z and low k                               "
               0  "   if ibr_nist = 2                                                "
               0  "   and direction using                                            "
               0  "    - formula 2BS from from Koch and Motz if IBRDST=1             "
               0  "    - leading term of the brems angular dsstr. if IBRDST=0        "
               0  "    - photon direction = electron direction if IBRDST<0           "
               0  "                                                                  "
               0  "   This version replaces the original EGS4 implementation         "
               0  "   because of a bug discovered in the EGS4 brems routine          "
               0  "   In order to work properly, the parameter DL1,..,DL6            "
               0  "   are re-calculated in subroutine fix_brems which is called      "
               0  "   from HATCH                                                     "
               0  "   In addition, this version has the internal capability of       "
               0  "   bremsstrahlung splitting.                                      "
               0  "   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
               0  "   to the desired number > 1 (1 is the default)                   "
               0  "   Be aware that event-by-event energy conservation is NOT        "
               0  "   guaranteed, so don't use for calculations where this is        "
               0  "   important (e.g. calculation of detector response functions)    "
               0  "   The result will be nbr_split photons, all with the weight      "
               0  "   wt(npold)/nbr_split, and an electron with the original weight  "
               0  "   and energy given by the incident energy - energy of last photon"
               0  "                                                                  "
               0  " I. Kawrakow, January 2000                                        "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
               0                             "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BREMS;
               0  $REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;
               0
               0  IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
               0                               "by setting nbr_split to zero!"
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
               0  EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
               0  weight = wt(np)/nbr_split;
               0
               0  "   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
               0  "   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
               0  IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
               0  L1 = L+1;
               0
               0  ekin = peie-prm;
               0  brmin = ap(medium)/ekin;
               0  "waux = -log(brmin);"
               0  waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
               0                                "log_ap = log(ap(medium)) is calculated in   "
               0                                "fix_brems for each medium, elke is needed   "
               0                                "in electr to calculate the branching ratios "
               0                                "and therefore it must be known at this point"
               0
               0  IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
               1                      "angle from KM-2BS (ibrdst=1) or from the leading"
               1                      "term (ibrdst=0). If nbr_split > 1, we can re-use"
               1                      "the following quantities several time"
               1
               1      a = u(np); b = v(np); c = w(np);
               1      sinpsi = a*a + b*b;
               1      IF( sinpsi > 1e-20 ) [
               2         sinpsi = sqrt(sinpsi);
               2         sindel = b/sinpsi; cosdel = a/sinpsi;
               2      ]
               1
               1      ztarg = zbrang(medium);
               1      tteie = eie/rm;
               1      beta = sqrt((tteie-1)*(tteie+1))/tteie;
               1      y2max = 2*beta*(1+beta)*tteie*tteie;
               1      y2maxi = 1/y2max;
               1      IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]
               1
               1  ]
               0
               0  IF( ibr_nist >= 1 ) [
               1      ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
               1      jj = ajj; ajj = ajj - jj;
               1      IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
               1  ]
               0
               0  DO ibr = 1,nbr_split [
               1
               1      IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
               2                           "data base"
               2          IF( ekin > nb_emin(medium) ) [
               3              $RANDOMSET r1;
               3              IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
               3              br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
               3                                 nb_fdata(0,j,medium),
               3                                 nb_wdata(1,j,medium),nb_idata(1,j,medium));
               3          ]
               2          ELSE [ $RANDOMSET br; ]
               2          esg = ap(medium)*exp(br*waux); pesg = esg;
               2          pese = peie - pesg; ese = pese;
               2      ]
               1      ELSE [
               2
               2          LOOP [ "User wants to use Bethe-Heitler"
               3
               3              $RANDOMSET rnno06; $RANDOMSET rnno07;
               3              br = brmin*exp(rnno06*waux);
               3              esg = ekin*br; pesg = esg;
               3              pese = peie - pesg; ese = pese;
               3              delta = esg/eie/ese*delcm(medium); aux = ese/eie;
               3              IF( delta < 1 ) [
               4                  phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4                  phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
               4                          delta*dl3(l1,medium));
               4              ]
               3              ELSE [
               4                  phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
               4                  phi2 = phi1;
               4              ]
               3              rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;
               3
               3          ] UNTIL (rnno07 < rejf);
               2      ]
               1
               1      "   SET UP THE NEW PHOTON                                          "
               1      np=np+1;
               1      IF( np > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1      e(np) = pesg; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      wt(np) = weight;
               1      IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
               2                          "the electron. This option is given so that "
               2                          "the user can implement their own brems angle "
               2                          "schemes via a call to ausgab"
               2          u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
               2      ]
               1      ELSE [
               2         IF( ibrdst = 1 ) [
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3             ttese = ese/rm; esedei = ttese/tteie;
               3             rjarg1 = 1+esedei*esedei;
               3             rjarg2 = rjarg1 + 2*esedei;
               3             aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
               3             IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
               3             ELSE [ rjarg3 = log(aux/(1+aux1)); ]
               3             rejmax = rjarg1*rjarg3-rjarg2;
               3             LOOP [
               4                 $RANDOMSET y2tst; $RANDOMSET rtest;
               4                 aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               4                 rtest = rtest*aux3*rejmax;
               4                 y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               4                 aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               4                 IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               4                 aux2 = log(aux/(1+aux1/aux3**4));
               4                 rejtst = aux4+aux5*aux2;
               4             ] UNTIL (rtest < rejtst );
               3
               3         ]
               2         ELSE [
               3             $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
               3         ]
               2         costhe = 1 - 2*y2tst*y2maxi;
               2         sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
               2         $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               2         IF( sinpsi >= 1e-10 ) [
               3             us = sinthe*cphi; vs = sinthe*sphi;
               3             u(np) = c*cosdel*us - sindel*vs + a*costhe;
               3             v(np) = c*sindel*us + cosdel*vs + b*costhe;
               3             w(np) = c*costhe - sinpsi*us;
               3         ]
               2         ELSE [
               3             u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
               3         ]
               2      ]
               1  ]
               0
               0  e(npold) = pese;
               0
               0  RETURN;
               0  "END OF SUBROUTINE BREMS"   END;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impulse approximation  "
               0  "   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections lead to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "                                                                  "
               0  "   I.Kawrakow, March 2008:                                        "
               0  "      If ibcmp = 2 or 3, the actual bound Compton scattering      "
               0  "      cross section is used and rejections lead to resampling     "
               0  "      instead of rejecting the entire interactions as stated above"
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT;
               0  $LOGICAL first_time;
               0  $INTEGER ibcmpl;
               0
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  $RADC_CHECK;
               0
               0  irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);
               0
               0  :resample-compton:;
               0  IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
               1                     "=>first sample the shell and see whether an    "
               1                     "  interaction is possible                      "
               1      $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
               1      i = int(rnno17); "rnno17 = rnno17 - i;
               1      IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:;     ]
               2      ]
               1      Jo = Jo_array(j);          "Jo is the Compton profile parameter"
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      IF( first_time ) [
               2          broi2 = broi*broi;
               2          alph1 = Log(broi);
               2          bro   = 1/broi;
               2          alph2 = ko*(broi+1)*bro*bro;
               2          alpha = alph1+alph2;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)*bro;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
               3          ]
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          aux = 1+br*br;
               2          rejf3 = aux - br*sinthe;
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19*aux.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      IF( first_time ) [
               2          bro = 1./broi; bro1 = 1 - bro;
               2          rejmax = broi + bro;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 + br*br - br*sinthe;
               2      ] UNTIL rnno16*br*rejmax.le.rejf3;
               1  ]
               0  first_time = .false.;
               0
               0  IF(br < bro | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2          $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE: ;
               1  ]
               0
               0  $RADC_REJECTION;
               0
               0  costhe = 1 - temp;
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0;
               1      goto :FINISHED-COMPTON-SAMPLING:;
               1  ]
               0
               0  " Check for rejection due to the limited range of pzmax "
               0  br2 = br*br;
               0  aux = ko*(ko-Uj)*temp;
               0  aux1 = 2*aux + Uj*Uj;
               0  pzmax = aux - Uj;
               0  IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0  pzmax = pzmax/sqrt(aux1);
               0
               0
               0
               0
               0
               0
               0
               0  qc2 = 1 + br*br - 2*br*costhe;
               0  qc  = sqrt(qc2);
               0
               0  IF( pzmax > 1 ) [
               1      pzmax = 1; af = 0; Fmax = 1; fpz = 1;
               1      goto :RETRY-PZ:;
               1  ]
               0
               0  aux3 = 1 + 2*Jo*abs(pzmax);
               0  aux4 = 0.5*(1-aux3*aux3);
               0  fpz  = 0.5*exp(aux4);
               0  af   = qc*(1+br*(br-costhe)/qc2);
               0
               0  IF( af < 0 ) [
               1      IF( pzmax > 0 ) fpz = 1 - fpz;
               1      $RANDOMSET eta_incoh;
               1      IF( eta_incoh > fpz ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:; ]
               2      ]
               1      af = 0; Fmax = 1; goto :RETRY-PZ:;
               1  ]
               0
               0  IF( pzmax < -0.15 ) [
               1      Fmax = 1-af*0.15;
               1      fpz1 = fpz*Fmax*Jo;
               1  ]
               0  ELSE IF( pzmax < 0.15 ) [
               1      Fmax = 1 + af*pzmax;
               1      aux3 = 1/(1+0.33267252734*aux3);
               1              "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
               1              "of Abramowitz and Stegun, needed for approximating Erf        "
               1      aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
               1             erfJo_array(j);
               1      IF( pzmax > 0 ) [
               2          "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
               2          fpz = 1 - fpz;
               2      ]
               1      ELSE [
               2          "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
               2      ]
               1  ]
               0  ELSE [
               1      Fmax = 1 + af*0.15;
               1      fpz1 = (1 - Fmax*fpz)*Jo;
               1      fpz = 1 - fpz;
               1  ]
               0  $RANDOMSET eta_incoh;
               0  IF(eta_incoh*Jo > fpz1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0
               0  "At this point, all rejections are handled, now we need to sample pz "
               0  "between -1 and pzmax using the Compton profile of the selected shell"
               0  "and F(pz,cos(theta)) as a rejection function                        "
               0
               0  :RETRY-PZ:;
               0  IF( ibcmpl ~= 2 ) [
               1    $RANDOMSET rnno18; rnno18 = rnno18*fpz;
               1    IF( rnno18 < 0.5 ) [
               2      rnno18 = Max(1e-30,2*rnno18);
               2      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
               2    ]
               1    ELSE [
               2      rnno18 = 2*(1-rnno18);
               2      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
               2    ]
               1    IF( abs(pz) > 1 ) goto :RETRY-PZ:;
               1        "Due to the non-relativistic approximation"
               1        "for pz, it has to be between -1 and 1    "
               1    IF( pz < 0.15  ) [
               2      IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
               2      ELSE             [ frej = 1 + af*pz;   ]
               2      $RANDOMSET eta;
               2      IF( eta*Fmax > frej ) goto :RETRY-PZ:;
               2    ]
               1    "If pz > 0.15, F is always 1 => no need for rejection"
               1  ]
               0  ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]
               0
               0  " Calculate energy of scattered photon "
               0  pz2 = pz*pz;
               0  IF( abs(pz) < 0.01 ) [
               1      br = br*(1 + pz*(qc + (br2-costhe)*pz));
               1  ]
               0  ELSE [
               1      aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               1      aux2 = qc2 - br2*pz2*sinthe;
               1      IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               1  ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmpl = 1 | ibcmpl = 3 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = pzero;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2          "relax will put all particles with energies above ecut,pcut on the "
               2          "stack, the remaining energy will be scored in edep and deposited  "
               2          "locally (via the call to ausgab below)                            "
               2      ]
               1      ELSE [
               2          edep = Uj;
               2          edep_local = edep;
               2          $AUSCALL($SPHOTONA);
               2      ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE old_COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impuls approximation   "
               0  "    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections leed to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "   This version ignores the function F(cos(theta),pz).            "
               0  "   This leads to a small error (at least compared to the cross    "
               0  "   section we want to sample) at low energies (say, below Z keV)  "
               0  "   The advantage is that it is substantially faster then the      "
               0  "   version with F taken into account.                             "
               0  "                                                                  "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
               0                                 "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT-old;
               0
               0  i_survived_RR = 0;"0=> all survived russian roulette if played"
               0                    "must set here since, if bound compton and event is"
               0                    "rejected, this wouldn't be set to the new 0 value"
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  irl = ir(np);
               0  IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
               1                         "=>first sample the shell and see whether an    "
               1                         "  interaction is possible                      "
               1      $RANDOMSET rnno17;
               1      DO i=1,n_shell(medium) [
               2          rnno17 = rnno17 - eno_array(i,medium);
               2          IF( rnno17 <= 0 ) EXIT;
               2      ]
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE-old:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      broi2 = broi*broi;
               1      alph1 = Log(broi);
               1      alph2 = ko*(broi+1)/broi2;
               1      alpha = alph1/(alph1+alph2);
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15 < alpha ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)/broi;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16 + (1-rnno16)/broi2);
               3          ]
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 - br*sinthe/(1+br*br);
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      bro = 1./broi; bro1 = 1 - bro;
               1      rejmax = broi + bro;
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = (br + 1./br - sinthe)/rejmax;
               2      ] UNTIL rnno16.le.rejf3;
               1  ]
               0
               0  IF(br < 1./broi | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2      $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE-old: ;
               1  ]
               0
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0; costhe = 1 - temp;
               1      goto :FINISHED-COMPTON-SAMPLING-old:;
               1  ]
               0
               0  " Sample Doppler broadening using the Compton profile of the selected shell"
               0  br2 = br*br;
               0  costhe = 1 - temp;
               0  aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
               0  pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
               0  :RETRY-PZ-old:;
               0  $RANDOMSET rnno18;
               0  IF( rnno18 < 0.5 ) [
               1      rnno18 = Max(1e-30,2*rnno18);
               1      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  ELSE [
               1      IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
               1      rnno18 = 2*(1-rnno18);
               1      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;
               0
               0  " Calculate energy of scattered photon "
               0  aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               0  aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
               0  IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING-old:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmp(irl) = 1 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = 0;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2            "relax will put all particles with energies above ecut,pcut on the "
               2            "stack, the remaining energy will be scored in edep and deposited  "
               2            "localy (via the call to ausgab below)                             "
               2      ]
               1      ELSE [ edep = Uj; ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED-old:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  SUBROUTINE ELECTR(IRCODE);
               0  "******************************************************************"
               0  "   This subroutine has been almost completely recoded to include  "
               0  "   the EGSnrc enhancements.                                       "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Complete recoding            "
               0  "   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
               0  "                                     fictitious method (important "
               0  "                                     for low energy transport     "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE;
               0
               0  $COMIN-ELECTR; "default replacement produces the following:
               0                 "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
               0                          "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
               0                          "UPHIOT,USEFUL,USER,RANDOM/;"
               0  ;COMIN/EII-DATA/;
               0  ;COMIN/EM/;
               0  $REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
               0  LOGICAL random_tustep;
               0
               0  $DEFINE-LOCAL-VARIABLES-ELECTR;
               0
               0
               0
               0
               0
               0  data ierust/0/;         "To count negative ustep's"
               0
               0  save ierust;
               0
               0  $CALL-USER-ELECTRON;
               0
               0  ircode = 1; "Set up normal return-which means there is a photon
               0              "with less available energy than the lowest energy electron,
               0              "so return to shower so it can call photon to follow it.
               0              "(For efficiency's sake, we like to stay in this routine
               0              " as long as there are electrons to process. That's why this
               0              " apparently convoluted scheme of STACK contro is effected.)
               0
               0  irold = ir(np);    "Initialize previous region
               0                     "(ir() is an integer that is attached to the particle's
               0                     " phase space. It contains the region
               0                     " number that the current particle is in.
               0                     " Np is the stack pointer, it points to where on the
               0                     " stack the current particle is.)
               0  irl    = irold;    "region number in local variable
               0
               0
               0  $start_new_particle;
               0  " Default replacement for the above is medium = med(irl); "
               0  " This is made a macro so that it can be replaced with a call to a "
               0  " user provided function start_new_particle(); for the C/C++ interface "
               0
               0  :NEWELECTRON:LOOP
               0  [
               1      "Go once through this loop for each 'new' electron whose charge and
               1      "energy has not been checked
               1
               1      lelec = iq(np); "Save charge in local variable
               1                      "(iq = -1 for electrons, 0 for photons and 1 for positrons)
               1      qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
               1      peie  = e(np);  "precise energy of incident electron (double precision)
               1      eie   = peie;   "energy incident electron (conversion to single)
               1
               1      IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               1          "(Ecut is the lower transport threshold.)
               1
               1      "medium = med(irl);" "(This renders the above assignment redundant!)
               1      "The above assignment is unnecessary, IK, June 2003"
               1
               1      IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"
               1
               1      :TSTEP:LOOP
               1      [
               2          "Go through this loop each time we recompute distance to an interaction
               2
               2
               2
               2          compute_tstep = .true.; "MFP resampled => calculate distance to the
               2                                  "interaction in the USTEP loop
               2          eke = eie - rm; "moved here so that kinetic energy will be known"
               2                          "to user even for a vacuum step, IK January 2000"
               2          IF(medium ~= 0)
               2          [
               3              "Not vacuum. Must sample to see how far to next interaction.
               3
               3              $SELECT-ELECTRON-MFP;
               3                  " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
               3                  "                                       demfp = -log(rnne1);
               3                  "($RANDOMSET is a macro'ed random number generator)
               3                  "(demfp = differential electron mean free path)
               3
               3              elke = log(eke);
               3              "(eke = kinetic energy, rm = rest mass, all in units of MeV)
               3              $SET INTERVAL elke,eke; "Prepare to approximate cross section
               3
               3              $EVALUATE-SIG0;
               3                 "The fix up of the fictitious method uses cross section per"
               3                 "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               3                 "until the next discrete interaction occures (see below)"
               3                 "As this quantity is a single constant for a material,"
               3                 "$SET INTERVAL is not necessary at this point. However, to not"
               3                 "completely alter the logic of the TSTEP and USTEP loops,"
               3                 "this is left for now"
               3
               3          ] "end non-vacuum test
               2
               2          :USTEP:LOOP
               2          [
               3              "Here for each check with user geometry.
               3              "Compute size of maximum acceptable step, which is limited
               3              "by multiple scattering or other approximations.
               3              IF(medium = 0)
               3              [
               4                      "vacuum
               4                      $EMFIELD_INITIATE_SET_TUSTEP;
               4                      tstep = vacdst; ustep = tstep; tustep = ustep;
               4                      callhowfar = .true.; "Always call HOWFAR for vacuum steps!"
               4
               4                      "(Important definitions:
               4                      " tstep  = total pathlength to the next discrete interaction
               4                      " vacdst = infinity (actually 10^8)
               4                      " tustep = total pathlength of the electron step
               4                      " ustep  = projected transport distance in the
               4                      "          direction of motion at the start of the step
               4                      " Note that tustep and ustep are modified below.
               4                      " The above provide defaults.)
               4
               4                      " EM field step size restriction in vacuum
               4                      $SET-TUSTEP-EM-FIELD;
               4                      ustep = tustep;
               4              ]
               3              ELSE
               3              [
               4                  "non-vacuum
               4                  $SET-RHOF;    "density ratio scaling template
               4                                "EGS allows the density to vary
               4                                "continuously (user option)
               4
               4                  $SCALE-SIG0;
               4                  IF(sig <= 0)
               4                  [
               5                      "This can happen if the threshold for brems,
               5                      "(ap + rm), is greater than ae.  Moller threshold is
               5                      "2*ae - rm. If sig is zero, we are below the
               5                      "thresholds for both bremsstrahlung and Moller.
               5                      "In this case we will just lose energy by
               5                      "ionization loss until we go below cut-off. Do not
               5                      "assume range is available, so just ask for step
               5                      "same as vacuum.  Electron transport will reduce
               5                      "into little steps.
               5                      "(Note: ae is the lower threshold for creation of a
               5                      "       secondary Moller electron, ap is the lower
               5                      "       threshold for creation of a brem.)
               5                      tstep = vacdst;
               5                      sig0 = 1.E-15;
               5                  ]
               4                  ELSE
               4                  [
               5                      $CALCULATE-TSTEP-FROM-DEMFP;
               5                  ] "end sig if-else
               4
               4                  "calculate stopping power"
               4                  IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
               4                  ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
               4                  dedx  = rhof*dedx0;
               4
               4                  "Determine maximum step-size (Formerly $SET-TUSTEP)
               4                  $EVALUATE tmxs USING tmxs(elke);
               4                  tmxs = tmxs/rhof;
               4
               4                  "Compute the range to E_min(medium) (e_min is the first
               4                  "energy in the table). Do not go more than range.
               4                  "Don't replace this macro and don't override range, because
               4                  "the energy loss evaluation below relies on the accurate
               4                  "(and self-consistent) evaluation of range!
               4                  $COMPUTE-RANGE;
               4
               4                  "The RANDOMIZE-TUSTEP option as coded by AFB forced the
               4                  "electrons to approach discrete events (Moller,brems etc.)
               4                  "only in a single scattering mode => waste of CPU time.
               4                  "Moved here and changed by IK Oct 22 1997
               4                  random_tustep = $RANDOMIZE-TUSTEP;
               4                  IF(random_tustep)
               4                  [
               5                      $RANDOMSET rnnotu;
               5                      tmxs = rnnotu*min(tmxs,smaxir(irl));
               5                  ]
               4                  ELSE
               4                  [
               5                      tmxs = min(tmxs,smaxir(irl));
               5                  ]
               4                  tustep = min(tstep,tmxs,range);
               4                  $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field
               4
               4                  $CALL-HOWNEAR(tperp);
               4                  dnear(np) = tperp;
               4                  $RANGE-DISCARD;       "optional regional range rejection for"
               4                                        "particles below e_max_rr if i_do_rr set"
               4
               4                  $USER-RANGE-DISCARD;  "default is ;, but user may implement"
               4
               4                  $SET-SKINDEPTH(eke,elke);
               4                    "This macro sets the minimum step size for a condensed"
               4                    "history (CH) step. When the exact BCA is used, the minimum"
               4                    "CH step is determined by efficiency considerations only"
               4                    "At about 3 elastic MFP's single scattering becomes more"
               4                    "efficient than CH and so the algorithm switches off CH"
               4                    "If one of the various inexact BCA's is invoked, this macro"
               4                    "provides a simple way to include more sophisticated"
               4                    "decisions about the maximum acceptable approximated CH step"
               4
               4                  tustep = min(tustep,max(tperp,skindepth));
               4                  $EMFIELD_INITIATE_SET_TUSTEP;
               4                  "The transport logic below is determined by the logical
               4                  "variables callhhowfar, domultiple and dosingle
               4                  "
               4                  "There are the following possibilities:
               4                  "
               4                  "   callhowfar = .false.  This indicates that the
               4                  "   ====================  intended step is shorter than tperp
               4                  "                         independent of BCA used
               4                  "  - domultiple = .false. dosingle = .false. and
               4                  "                         callmsdist = .true.
               4                  "       ==> everything has been done in msdist
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only if exact_bca = .false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only if exact_bca = .true.
               4                  "           sampled distance to a single scattering event is
               4                  "           shorter than tperp ==> do single scattering at the
               4                  "           end of the step
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4                  "
               4                  "   callhowfar = .true. This indicates that the intended step
               4                  "   =================== is longer than tperp and forces a
               4                  "                       call to hawfar which returns the
               4                  "                       straight line distance to the boundary
               4                  "                       in the initial direction of motion
               4                  "                       (via a modification of ustep)
               4                  "  - domultiple = .false. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           simply put the particle on the boundary
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           single elastic scattering has to be done
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4
               4                  "IF(tustep <= tperp & tustep > skindepth)"
               4                  "This statement changed to be consistent with PRESTA-I"
               4                  count_all_steps = count_all_steps + 1;
               4                  is_ch_step = .false.;
               4                  IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
               4                  [
               5                      "We are further way from a boundary than a skindepth, so
               5                      "perform a normal condensed-history step
               5                      callhowfar = .false.; "Do not call HAWFAR
               5                      domultiple = .false.; "Multiple scattering done here
               5                      dosingle   = .false.; "MS => no single scattering
               5                      callmsdist = .true.;  "Remember that msdist has been called
               5
               5                      "Fourth order technique for de
               5                      $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);
               5
               5                      tvstep = tustep; is_ch_step = .true.;
               5
               5                      IF (transport_algorithm = $PRESTA-II)
               5                      [
               6                        call msdist_pII
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                      ELSE
               5                      [
               6                        call msdist_pI
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "We are within a skindepth from a boundary, invoke
               5                      "one of the various boundary-crossing algorithms
               5                      callmsdist = .false.;
               5                           "Remember that msdist has not been called
               5                      IF (exact_bca)
               5                      [
               6                          "Cross the boundary in a single scattering mode
               6                          domultiple = .false.; "Do not do multiple scattering
               6                          "Sample the distance to a single scattering event
               6                          $RANDOMSET rnnoss;
               6                          IF( rnnoss < 1.e-30 ) [
               7                              rnnoss = 1.e-30;
               7                          ]
               6                          lambda = - Log(1 - rnnoss);
               6                          lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
               6                          IF( lambda >= 0 & lambda_max > 0 ) [
               7                              IF( lambda < lambda_max ) [
               8                                  tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
               8                              ]
               7                              ELSE [
               8                                tuss = 0.5 * lambda * ssmfp;
               8                              ]
               7                              IF (tuss < tustep) [
               8                                  tustep = tuss;
               8                                  dosingle = .true.;
               8                              ]
               7                              ELSE [
               8                                  dosingle = .false.;
               8                              ]
               7                          ]
               6                          ELSE [
               7                            $egs_warning(*,' lambda > lambda_max: ',
               7                               lambda,lambda_max,' eke dedx: ',eke,dedx,
               7                               ' ir medium blcc: ',ir(np),medium,blcc(medium),
               7                               ' position = ',x(np),y(np),z(np));
               7                            dosingle = .false.;
               7                            np=np-1; return;
               7                          ]
               6                          ustep = tustep;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Boundary crossing a la EGS4/PRESTA-I but using
               6                          "exact PLC
               6                          dosingle = .false.;
               6                          domultiple = .true.;
               6                          $SET-USTEP;
               6                      ]
               5                      IF(ustep < tperp)
               5                      [
               6                          callhowfar = .false.;
               6                      ]
               5                      ELSE
               5                      [
               6                          callhowfar = .true.;
               6                      ]
               5                  ]
               4              ] "end non-vacuum test
               3
               3              $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
               3                                    "default for $SET-USTEP-EM-FIELD; is ;(null)
               3              irold  = ir(np); "save current region
               3              irnew  = ir(np); "default new region is current region
               3              idisc  = 0; "default is no discard (this flag is initialized here)
               3              ustep0 = ustep; "Save the intended ustep."
               3
               3              "IF(callhowfar) [ call howfar; ]"
               3              $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"
               3
               3              "Now see if user requested discard
               3              IF(idisc > 0) "(idisc is returned by howfar)
               3              [
               4                  "User requested immediate discard
               4                  go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              $CHECK-NEGATIVE-USTEP;
               3
               3              IF(ustep = 0 | medium = 0)
               3              [
               4                  "Do fast step in vacuum
               4                  IF(ustep ~= 0)
               4                  [
               5                      IF $EM_MACROS_ACTIVE
               5                      [
               6                          edep = pzero; "no energy loss in vacuum
               6                          "transport in EMF in vacuum:"
               6                          "only a B or and E field can be active"
               6                          "(not both at the same time)"
               6                          $EMFieldInVacuum;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Step in vacuum
               6                          vstep  = ustep;
               6                          tvstep = vstep;
               6                          "( vstep is ustep truncated (possibly) by howfar
               6                          " tvstep is the total curved path associated with vstep)
               6                          edep = pzero; "no energy loss in vacuum
               6                          $VACUUM-ADD-WORK-EM-FIELD;
               6                              "additional vacuum transport in em field
               6                          e_range = vacdst;
               6                          $AUSCALL($TRANAUSB);
               6                          "Transport the particle
               6                          x(np) = x(np) + u(np)*vstep;
               6                          y(np) = y(np) + v(np)*vstep;
               6                          z(np) = z(np) + w(np)*vstep;
               6                          dnear(np) = dnear(np) - vstep;
               6                              "(dnear is distance to the nearest boundary
               6                              " that goes along with particle stack and
               6                              " which the user's howfar can supply (option)
               6                          $SET-ANGLES-EM-FIELD;
               6                              "default for $SET-ANGLES-EM-FIELD; is ; (null)
               6                               "(allows for EM field deflection
               6                      ] "end of EM_MACROS_ACTIVE block"
               5                  ] "end of vacuum step
               4
               4                  IF(irnew ~= irold) [ $electron_region_change; ];
               4
               4                  IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
               4                  IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               4                  IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
               4                  NEXT :TSTEP: ; "(Start again at :TSTEP:)
               4
               4              ] "Go try another big step in (possibly) new medium
               3
               3              vstep = ustep;
               3              $EM_FIELD_SS;
               3              IF(callhowfar)
               3              [
               4                  IF(exact_bca)
               4                  [
               5                      "If callhowfar=.true. and exact_bca=.true. we are"
               5                      "in a single scattering mode"
               5                      tvstep = vstep;
               5                      IF(tvstep ~= tustep)
               5                      [
               6                         "Boundary was crossed. Shut off single scattering"
               6                          dosingle = .false.;
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "callhowfar=.true. and exact_bca=.false."
               5                      "=>we are doing an approximate CH step"
               5                      "calculate the average curved path-length corresponding"
               5                      "to vstep"
               5                      $SET-TVSTEP;
               5                  ]
               4                  "Fourth order technique for dedx
               4                  "Must be done for an approx. CH step or a
               4                  "single scattering step.
               4                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               4              ]
               3              ELSE
               3              [
               4                 "callhowfar=.false. => step has not been reduced due to
               4                 "                      boundaries
               4                 tvstep = tustep;
               4                 IF ( ~callmsdist )
               4                 [
               5                    "Second order technique for dedx
               5                    "Already done in a normal CH step with call to msdist
               5                    $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               5                 ]
               4              ]
               3
               3              $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
               3                  "( Calculates tvstep given vstep
               3                  " default for $SET-TVSTEP-EM-FIELD; is ; (null)
               3
               3              save_de = de;     "the energy loss is used to calculate the number
               3                                "of MFP gone up to now. If energy loss
               3                                "fluctuations are implemented, de will be
               3                                "changed in $DE-FLUCTUATION; => save
               3
               3              "The following macro template allows the user to change the
               3              "ionization loss.
               3              "(Provides a user hook for Landau/Vavilov processes)
               3              $DE-FLUCTUATION;
               3                  "default for $DE-FLUCTUATION; is ; (null)
               3              edep = de; "energy deposition variable for user
               3              $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
               3              $ADD_WORK_EM_FIELD;  "EEMF implementation"
               3                  "Default for $ADD-WORK-EM-FIELD; is ; (null)
               3              ekef = eke - de;  "(final kinetic energy)
               3              eold = eie;       "save old value
               3              enew = eold - de; "energy at end of transport
               3
               3              "Now do multiple scattering
               3              IF ( ~callmsdist )   "everything done if callmsdist = .true.
               3              [
               4                  IF ( domultiple )
               4                  [
               5                      "Approximated CH step => do multiple scattering
               5                      "
               5                      "ekems, elkems, beta2 have been set in either $SET-TUSTEP
               5                      "or $SET-TVSTEP if spin_effects is .true., they are
               5                      "not needed if spin_effects is .false.
               5                      "
               5                      "chia2,etap,xi,xi_corr are also set in the above macros
               5                      "
               5                      "qel (0 for e-, 1 for e+) and medium are now also required
               5                      "(for the spin rejection loop)
               5                      "
               5                      lambda = blccl*tvstep/beta2/etap/(1+chia2);
               5                      xi = xi/xi_corr;
               5                      findindex = .true.; spin_index = .true.;
               5                      call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
               5                                 spin_effects,findindex,spin_index,
               5                                 costhe,sinthe);
               5                  ]
               4                  ELSE
               4                  [
               5                      IF(dosingle)
               5                      [
               6                         "Single scattering
               6
               6                         ekems = Max(ekef,ecut(irl)-rm);
               6                         p2 = ekems*(ekems + rmt2);
               6                         beta2 = p2/(p2 + rmsq);
               6                         chia2 = xcc(medium)/(4*blcc(medium)*p2);
               6                         IF( spin_effects ) [
               7                           elkems = Log(ekems);
               7                           $SET INTERVAL elkems,eke;
               7                           IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
               7                           ELSE          [$EVALUATE etap USING etap_ms(elkems);]
               7                           chia2 = chia2*etap;
               7                         ]
               6                         call sscat(chia2,elkems,beta2,qel,medium,
               6                                    spin_effects,costhe,sinthe);
               6                      ]
               5                      ELSE
               5                      [
               6                         theta  = 0; "No deflection in single scattering model
               6                         sinthe = 0;
               6                         costhe = 1;
               6                      ]
               5                  ]
               4              ]
               3
               3              "We now know distance and amount of energy loss for this step,
               3              "and the angle by which the electron will be scattered. Hence,
               3              "it is time to call the user and inform him of this transport,
               3              "after which we will do it.
               3
               3              "Now transport, deduct energy loss, and do multiple scatter.
               3              e_range = range;
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3              IF( callmsdist ) [
               4                 "Deflection and scattering have been calculated/sampled in msdist
               4                  u_final = uscat;
               4                  v_final = vscat;
               4                  w_final = wscat;
               4                  x_final = xtrans;
               4                  y_final = ytrans;
               4                  z_final = ztrans;
               4              ]
               3              ELSE
               3              [
               4                  IF ~($EM_MACROS_ACTIVE)
               4                  [
               5                      x_final = x(np) + u(np)*vstep;
               5                      y_final = y(np) + v(np)*vstep;
               5                      z_final = z(np) + w(np)*vstep;
               5                  ]
               4
               4                  IF ( domultiple | dosingle )
               4                  [
               5                      u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
               5                      call uphi(2,1); "Apply the deflection, save call to uphi if
               5                                      "no deflection in a single scattering mode
               5                      u_final = u(np); v_final = v(np); w_final = w(np);
               5                      u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
               5                  ]
               4                  ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
               4              ]
               3
               3              $AUSCALL($TRANAUSB);
               3
               3              "Transport the particle
               3
               3              x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3              u(np) = u_final; v(np) = v_final; w(np) = w_final;
               3
               3              dnear(np) = dnear(np) - vstep;
               3              irold = ir(np); "save previous region
               3              $SET-ANGLES-EM-FIELD;
               3              "Default for $SET-ANGLES-EM-FIELD; is ; (null)
               3
               3
               3              "Now done with multiple scattering,
               3              "update energy and see if below cut
               3              "below subtracts only energy deposited"
               3              peie  = peie - edep;
               3              "below subtracts energy deposited + work due to E field"
               3              "peie = peie - de;"
               3              eie   = peie;
               3              e(np) = peie;
               3
               3              "IF( irnew ~= irl & eie <= ecut(irl)) [
               3              "IK: the above is clearly a bug. If the particle energy falls "
               3              "    below ecut, but the particle is actually entering a new "
               3              "    region, the discard will happen in the current region "
               3              "    instead the next. If the particle is a positron, all "
               3              "    resulting annihilation photons will have the new position "
               3              "    but the old region => confusion in the geometry routine "
               3              "    is very likely.      Jan 27 2004 "
               3              IF( irnew = irl & eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              medold = medium;
               3              IF(medium ~= 0)
               3              [
               4                  ekeold = eke; eke = eie - rm; "update kinetic energy
               4                  elke   = log(eke);
               4                  $SET INTERVAL elke,eke; "Get updated interval
               4              ]
               3
               3              IF(irnew ~= irold) [ $electron_region_change; ]
               3
               3              "After transport call to user scoring routine
               3              $AUSCALL($TRANAUSA);
               3
               3              IF(eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              "Now check for deferred discard request.  May have been set
               3              "by either howfar, or one of the transport ausgab calls
               3              IF(idisc < 0) [
               4                go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              IF(medium ~= medold) NEXT :TSTEP:;
               3
               3              $USER_CONTROLS_TSTEP_RECURSION;
               3                  "NRCC update 87/12/08--default is null
               3
               3              $UPDATE-DEMFP;
               3
               3          ] UNTIL(demfp < $EPSEMFP); "end ustep loop
               2
               2          "Compute final sigma to see if resample is needed.
               2          "this will take the energy variation of the sigma into
               2          "account using the fictitious sigma method.
               2
               2          $EVALUATE-SIGF;
               2
               2          sigratio = sigf/sig0;
               2
               2          $RANDOMSET rfict;
               2
               2      ] UNTIL (rfict <= sigratio) ; "end tstep loop
               1
               1      " Now sample electron interaction
               1
               1      IF(lelec < 0)
               1      [
               2          "e-,check branching ratio
               2          $EVALUATE-EBREM-FRACTION;
               2            "Default is $EVALUATE ebr1 USING ebr1(elke);"
               2          $RANDOMSET rnno24;
               2          IF(rnno24 <= ebr1)
               2          [
               3              "It was bremsstrahlung
               3              go to :EBREMS:;
               3          ]
               2          ELSE
               2          [
               3              "It was Moller, but first check the kinematics.
               3              "However, if EII is on, we should still permit an interaction
               3              "even if E<moller threshold as EII interactions go down to
               3              "the ionization threshold which may be less than thmoll.
               3              IF(e(np) <= thmoll(medium) & eii_flag = 0)
               3                   "(thmoll = lower Moller threshold)
               3              [
               4                  "Not enough energy for Moller, so
               4                  "force it to be a bremsstrahlung---provided ok kinematically.
               4                  IF(ebr1 <= 0) [go to :NEWELECTRON:;]
               4                      "Brems not allowed either.
               4                  go to :EBREMS:;
               4              ]
               3              $AUSCALL($MOLLAUSB);
               3              call moller;
               3              "The following macro template allows the user to change the
               3              "particle selection scheme (e.g., adding importance sampling
               3              "such as splitting, leading particle selection, etc.).
               3              "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
               3              "which in turn has the 'null' replacement ';')
               3              $PARTICLE-SELECTION-MOLLER;
               3              $AUSCALL($MOLLAUSA);
               3              IF( iq(np) = 0 ) return;
               3          ]
               2
               2          go to :NEWELECTRON:; "Electron is lowest energy-follow it
               2      ]
               1
               1      "e+ interaction. pbr1 = brems/(brems + bhabha + annih
               1      $EVALUATE-PBREM-FRACTION;
               1         "Default is $EVALUATE pbr1 USING pbr1(elke);"
               1      $RANDOMSET rnno25;
               1      IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
               1      "Decide between bhabha and annihilation
               1      "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
               1      $EVALUATE-BHABHA-FRACTION;
               1         "Default is $EVALUATE pbr2 USING pbr2(elke);"
               1      IF(rnno25 < pbr2)
               1      [
               2          "It is bhabha
               2          $AUSCALL($BHABAUSB);
               2          call bhabha;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-BHABHA;
               2          $AUSCALL($BHABAUSA);
               2          IF( iq(np) = 0 ) return;
               2      ]
               1      ELSE
               1      [
               2          "It is in-flight annihilation
               2          $AUSCALL($ANNIHFAUSB);
               2          call annih;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-ANNIH;
               2          $AUSCALL($ANNIHFAUSA);
               2          EXIT :NEWELECTRON:; "i.e., in order to return to shower
               2          "After annihilation the gammas are bound to be the lowest energy
               2          "particles, so return and follow them.
               2      ] "end pbr2 else
               1
               1  ] REPEAT "newelectron
               0
               0  return; "i.e., return to shower
               0
               0
               0  "---------------------------------------------
               0  "Bremsstrahlung-call section
               0  "---------------------------------------------
               0  :EBREMS:
               0  $AUSCALL($BREMAUSB);
               0  call brems;
               0  "The following macro template allows the user to change the particle
               0  "selection scheme (e.g., adding importance sampling such as splitting,
               0  "leading particle selection, etc.).  (default macro is template
               0  "'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
               0  $PARTICLE-SELECTION-BREMS;
               0  $AUSCALL($BREMAUSA);
               0  IF(iq(np) = 0)
               0  [
               1      "Photon was selected.
               1      return;
               1      "i.e., return to shower
               1  ]
               0  ELSE
               0  [
               1      "Electron was selected
               1      go to :NEWELECTRON:;
               1  ]
               0
               0  "---------------------------------------------
               0  "Electron cutoff energy discard section
               0  "---------------------------------------------
               0  :ECUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(eie > ae(medium)) [
               2          idr = $EGSCUTAUS;
               2          IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
               2      ]
               1      ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
               1  ] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]
               0
               0
               0  $ELECTRON-TRACK-END; "The default replacement for this macros is "
               0                       "          $AUSCALL(idr);                   "
               0                       "Use this macro if you wish to modify the   "
               0                       "treatment of track ends                    "
               0
               0  :POSITRON-ANNIHILATION:; "NRCC extension 86/9/12
               0
               0  IF(lelec > 0) [
               1      "It's a positron. Produce annihilation gammas if edep < peie
               1      IF(edep < peie) [
               2          $AUSCALL($ANNIHRAUSB);
               2          call annih_at_rest;
               2          $PARTICLE-SELECTION-ANNIHREST;
               2          $AUSCALL($ANNIHRAUSA);
               2          "Now discard the positron and take normal return to follow
               2          "the annihilation gammas.
               2          return; "i.e., return to shower
               2      ]
               1  ] "end of positron block
               0
               0  np = np - 1;
               0  ircode = 2; "tell shower an e- or un-annihilated
               0              "e+ has been discarded
               0
               0  return; "i.e., return to shower"
               0
               0  "---------------------------------------------
               0  "User requested electron discard section
               0  "---------------------------------------------
               0  :USER-ELECTRON-DISCARD:
               0
               0  idisc = abs(idisc);
               0
               0  IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
               0  ELSE                          [edep = e(np) + prm;]
               0
               0  $AUSCALL($USERDAUS);
               0
               0  IF(idisc = 99) goto :POSITRON-ANNIHILATION:;
               0
               0  np = np - 1; ircode = 2;
               0
               0  return; "i.e., return to shower
               0  end;    "End of subroutine electr
               0  "*******************************************************************************
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE HATCH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Setup which the user is expected to do before calling HATCH is:"
               0  "     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
               0  "     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
               0  "        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
               0  "        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
               0  "        THE IM'TH MEDIUM IN A1 FORMAT."
               0  "     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
               0  "        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
               0  "        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
               0  "        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
               0  "     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
               0  "        REGIONS."
               0  "     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
               0  "        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
               0  "        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
               0  "        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
               0  "     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
               0  "        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
               0  "     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
               0  "        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
               0  "
               0  "   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
               0  "   The echo to unit 8 has been removed since it is sent"
               0  "                                          to /dev/null anyway!"
               0  "           To put it back search $UOUTPUT  and $ECHO and uncomment"
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  character*512 toUpper;
               0  $COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
               0                        "ELECIN,MEDIA,MISC,PHOTIN,STACK,
               0                        "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;
               0
               0  $DECLARE-PEGS4-COMMON-BLOCKS;
               0
               0  $DEFINE-LOCAL-VARIABLES-HATCH;
               0
               0  character*256 tmp_string;
               0  $INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
               0                        " support this"
               0
               0  DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
               0  DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;
               0
               0  $INIT-PEGS4-VARIABLES;
               0
               0  "   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
               0  :INT:FORMAT(1X,14I5);
               0  :FLT:FORMAT(1X,1PE14.5,4E14.5);
               0  :BYTE:FORMAT(72A1);
               0
               0  IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
               1  "   DO FIRST TIME INITIALIZATION"
               1
               1  $HATCH-USER-INPUT-INIT;
               1
               1  "   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
               1  "   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
               1  "   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
               1  "   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
               1  "   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
               1  "   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
               1  "   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
               1  "   FOR GOOD MEASURE."
               1  NISUB=MXSINC-2;FNSSS=NSINSS;
               1  WID=PI5D2/FLOAT(NISUB);
               1  WSS=WID/(FNSSS-1.0);
               1  ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;
               1
               1  DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
               2  SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"
               2
               2  XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
               2  "   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
               2  IZ=0; DO IZZ=1,3 [
               3  IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
               3  ] "END OF LOOP OVER ZEROS"
               2  IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
               2  DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
               3  XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
               3  YS=SIN(XS+XSI); "SINE OF ANGLE"
               3  SX=SX+XS; "ACCUMULATE SUMS"
               3  SY=SY+YS;
               3  SXX=SXX+XS*XS;
               3  SXY=SXY+XS*YS;
               3  ] "END SUB-SUBINTERVAL LOOP"
               2
               2  "   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
               2  IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
               3  "             FOR SMALL REL.ERR.&GOOD"
               3  "   VALUES OF SINTHE/THETA NEAR ZERO"
               3  SIN1(ISUB)=SXY/SXX;
               3  SIN0(ISUB)=-SIN1(ISUB)*XSI;]
               2  ELSE["DO FULL LEAST SQUARES"
               3  DEL=FNSSS*SXX-SX*SX;
               3  SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
               3  SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
               2  ] "END SUB-INTERVAL LOOP"
               1
               1  SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
               1  SINC1=1.0/WID;
               1
               1  "   NOW TEST FIT, IF REQUESTED"
               1  IF (ISTEST.NE.0)[
               2  "   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
               2  "   END SUBINTERVALS"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
               4  THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
               4  CTHET=PI5D2-THETA;
               4  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               4  $EVALUATE SINTHE USING SIN(THETA);
               4  $EVALUATE COSTHE USING SIN(CTHET);
               4  SINT=SIN(THETA); COST=COS(THETA);
               4  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               4  ADEV=max(ADEV,ASD,ACD);
               4  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               4  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               4  S2C2=SINTHE**2+COSTHE**2;
               4  S2C2MN=min(S2C2MN,S2C2);
               4  S2C2MX=max(S2C2MX,S2C2);
               4  IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
               4  ] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
               2  $egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
               2  $egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                   ADEV,RDEV,S2C2MN,S2C2MX);
               2  "   NOW DO RANDOM TEST"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
               3  CTHET=PI5D2-THETA;
               3  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               3  $EVALUATE SINTHE USING SIN(THETA);
               3  $EVALUATE COSTHE USING SIN(CTHET);
               3  SINT=SIN(THETA); COST=COS(THETA);
               3  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               3  ADEV=max(ADEV,ASD,ACD);
               3  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               3  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               3  S2C2=SINTHE**2+COSTHE**2;
               3  S2C2MN=min(S2C2MN,S2C2);
               3  S2C2MX=max(S2C2MX,S2C2);
               3  ] "END RANDOM ANGLE LOOP"
               2  $egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
               2  $egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                 ADEV,RDEV,S2C2MN,S2C2MX);
               2  ] "END OF SINE TABLE TEST"
               1
               1  "   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
               1  P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]
               1
               1  ] "END OF FIRST TIME INITIALIZATION"
               0
               0  "FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
               0  $need_rayleigh_data;
               0
               0  "Ali:photonuc, 2 lines"
               0  "FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
               0  $need_photonuc_data;
               0  $egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);
               0
               0  "   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
               0  IF(~is_pegsless) REWIND KMPI;
               0  "explicit file name for HP compiler  Nov 23, 1996   DR"
               0  IUECHO=KMPO;
               0  NM=0; "NUMBER OF MEDIA FOUND"
               0  DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
               1    "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
               1    IF(IRAYLM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  "Ali:photonuc, 1 block"
               0  DO IM=1,NMED [
               1    "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
               1    IF(IPHOTONUCM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  IF(~is_pegsless)[
               1  :MEDIUM:
               1  LOOP["MEDIUM SEARCH LOOP"
               2
               2  :MDLOOK:
               2  LOOP["MEDIUM HEADER SEARCH LOOP"
               3    "   FIRST LOOK FOR MEDIUM HEADER"
               3    READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
               3    DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
               3    "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
               3    :MDNAME:
               3    DO IM=1,NMED [
               4      DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
               5      IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
               4    ] "END :MDNAME: DO"
               3    "   NOT IN NAME TABLE, SO IGNORE IT"
               3  ]REPEAT "MDLOOK"
               2
               2  "   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
               2  IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
               2  LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"
               2
               2  "   NOW READY TO READ IN DATA FOR THIS MEDIUM"
               2  "$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"
               2
               2  "   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
               2  "THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  "The next two lines were line prior to Dec 89 mods to get IUNRST"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,5X,F11.0,4X,I2);"
               2  "following used to pick up IUNRST, IAPRIM and EPSTFL"
               2  "Problem is that GASP may or may not be printed, so we make"
               2  "a kludge which will work with all old data files"
               2  "FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
               2  "Note that this reading scheme counts on there being an"
               2  "error when GASP does exist on the line--an error does"
               2  "occur on most compilers, however, we have found that on"
               2  "the rs6000 an error does not occur.  Instead, a warning"
               2  "is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
               2  "This will make no difference in simulations but will cause"
               2  "a problem when running EXAMIN"
               2
               2  " IK: backspace(kmpi) fails under windows using g77 with I/O error"
               2  "     therefore we read the line in a temporary string and then "
               2  "     use memoty I/O to try to read with and without gasp there. "
               2
               2  read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
               2  goto :no_hatch_read_error1:;
               2  :hatch_read_error1:
               2  $egs_fatal(*,'Error while reading pegs4 file');
               2
               2  :no_hatch_read_error1:;
               2  read(tmp_string,1,ERR=:GASP-THERE:)
               2  "READ(KMPI,1,ERR=:GASP-THERE:)"
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
               2  1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
               2  "IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
               2  GO TO :GASP-NOT-THERE:;
               2
               2  :GASP-THERE:;
               2  "WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
               2  "BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
               2  "READ(KMPI,2)"
               2
               2  "The following output is only there because without it"
               2  "code compiled with the new gfortran GNU compiler "
               2  "fails with run time error. Another bug in their "
               2  "pre-alpha quality I/O system ----IK, Oct 26 2005 "
               2  "write(6,*) 'Found medium with gas pressure';"
               2  $egs_info(*,'Found medium with gas pressure');
               2  read(tmp_string,2)
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
               2  IAPRIM(IM);
               2  2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);
               2
               2  :GASP-NOT-THERE:
               2
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  ";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "DO IE=1,NE["
               2  DO IE=1,NNE(IM)[
               3      "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
               3      "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
               3      "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
               3      "IN COMMON BREMPR. AFB 88/05/31.                                  "
               3      "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
               3      $UINPUT(KMPI)
               3      (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
               3      ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
               3      (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
               3      "$UOUTPUT(KMPO)"
               3      "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
               3      "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
               3      "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
               3      ]
               2
               2  "   MEDIA AND THRESH"
               2  "$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
               2  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
               2
               2  "   ACTUAL ARRAY SIZES FROM PEGS"
               2  "$ECHO" READ(KMPI,:INT:)
               2  $LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
               2  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
               2  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
               2
               2  "   BREMPR"
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
               2  "$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
               2     DELPOS(I,IM)),I=1,2);
               2
               2  "   ELECIN"
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)
               2  ($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
               2     TMXS(I,IM)/0,1/),I=1,NEKE);
               2
               2  "   PHOTIN"
               2  "$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);
               2
               2  "   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"
               2
               2
               2  IF (IRAYL.EQ.1) [
               3  "$ECHO" READ(KMPI,:INT:) NGR(IM);
               3  NGRIM=NGR(IM);
               3  "$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
               3   "IF(IRAYLM(IM).NE.1) ["
               3   $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
               3            IM, ' in PEGS4 data set.');
               3   "]"
               3  ]
               2
               2
               2
               2
               2
               2  IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
               3    IF(IRAYL.NE.1) ["No data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["Rayleigh not possible"
               5       $egs_fatal('(a,i3 /,a /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
               5       ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
               5      ]
               4      ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
               5       $egs_warning('(a,i3 /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
               5      ]
               4    ]
               3   ELSE["Rayleigh data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["PEGS4 data selected"
               5        "***********************************************************"
               5        "Preparing data for new Rayleigh angular sampling when using"
               5        "the pegs4 data set,                                        "
               5        "***********************************************************"
               5         call egs_init_rayleigh_sampling(IM);
               5      ]
               4      "ELSE[Taking photon data from either si,epdl,xcom or user]"
               4    ]
               3  ]
               2
               2
               2  "   THAT'S ALL FOR THIS MEDIUM"
               2  ]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"
               1
               1  CLOSE (UNIT=KMPI);
               1
               1  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
               1  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
               1  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
               1  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
               1  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
               1  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
               1  DUNITR=DUNIT; "SAVE REQUESTED"
               1  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
               2     DUNIT=RLC(ID);]
               1  IF(DUNIT.NE.1.0) [
               2  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
               2           DUNITR,DUNIT,'(CM.)' );
               2  ]
               1  DO IM=1,NMED [
               2  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
               2  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
               2
               2  FOR I=1 TO MEKE(IM) [
               3  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
               3  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
               2  $SCALE TEFF0(IM) BY DFACT;
               2  $SCALE BLCC(IM) BY DFACTI;
               2  $SCALE XCC(IM) BY SQRT(DFACTI);
               2  RLDU(IM)=RLC(IM)/DUNIT;
               2  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
               2  ] "END IM DO"
               1
               1  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
               1  VACDST=VACDST*DUNITO/DUNIT;
               1  DUNITO=DUNIT; "SAVE OLD DUNIT"
               1
               1  ]"end regular pegs4 intake"
               0  ELSE["pegsless intake of medium data"
               1
               1  $egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');
               1
               1  $GET-PEGSLESS-XSECTIONS;
               1
               1  ]
               0
               0  "   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
               0  "   ALSO SET DEFAULT DENSITIES"
               0  $adjust_rhor_ecut_pcut;
               0
               0  "BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 88/05/31"
               0  $INITIALIZE-BREMS-ANGLE;
               0
               0  "PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 91/05/29"
               0  $INITIALIZE-PAIR-ANGLE;
               0
               0  " See if user has requested PEGS4 photon cross section data "
               0  IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
               1    $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
               1    'However, the new Rayleigh angular sampling will be used.',
               1    'The original EGS4 angular sampling undersamples large scattering ',
               1    'angles. This may have little impact as Rayleigh scattering ',
               1    'is forward peaked.',
               1    '*********************************************************');
               1
               1  ]
               0  ELSE["re-calculates photon xsections using available or user data"
               1  "Ali:photonuc, 2 lines"
               1      call egs_init_user_photon(photon_xsections,comp_xsections,
               1      photonuc_xsections,xsec_out);
               1  "    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
               1  ]
               0
               0  call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"
               0
               0  "Calling order of the subroutines below is important when using"
               0  "detailed atomic relaxation in order to use the binding energies"
               0  "corresponding to the requested photon cross section library"
               0  IF ( eadl_relax & photon_xsections = 'xcom' )[
               1     call init_compton; "Initialize bound Compton scattering"
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
               1  ]
               0  ELSE[
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
               1                        "if requested
               1     call init_compton; "Initialize bound compton scattering, IK, Jan 99"
               1                        "if requested
               1  ]
               0
               0  IF( xsec_out = 1 & eadl_relax) [
               1    call egs_print_binding_energies;
               1  ]
               0
               0  call fix_brems;    "Re-calculate dl1,... for the different technique"
               0                     "employed in BREMS. Note that the old EGS sampling"
               0                     "technique for BREMS had a bug that shows up only"
               0                     "if AP is not much smaller than electron kinetic energy"
               0
               0  IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
               0                     "initializes the sampling tables and modifies the total"
               0                     "brems cross sections if the NIST brems data base is to"
               0                     "be used                                               "
               0
               0  IF( pair_nrc = 1 ) [ call init_nrc_pair; ]
               0
               0  " Load and initialize EII data if needed. "
               0  call eii_init;
               0
               0  " Load and initialize the triplet data if needed "
               0  call init_triplet;
               0
               0  "   SETUP IS NOW COMPLETE"
               0  IF (NMED.EQ.1)[
               1     $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
               1  ]
               0  ELSE[
               1     $egs_info('(a,i5,a)',
               1               'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
               1  ]
               0
               0  RETURN;
               0
               0  :MDNOMORE:
               0  $egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
               0    ' PROGRAM STOPPED IN HATCH BECAUSE THE',
               0    ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
               0  DO IM=1,NMED [
               1     IF(LOK(IM).NE.1) [
               2        $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
               2     ]
               1  ]
               0  STOP;
               0  "END OF SUBROUTINE HATCH"   END;
               0
               0  subroutine fix_brems;
               0  "******************************************************************"
               0  "
               0  " Calculates the parameter for the rejection function used in
               0  " the current implementation of bremsstrahlung sampling
               0  "
               0  " I Kawrakow, January 2000
               0  "
               0  "*******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;
               0
               0  $INTEGER medium,i;
               0  $REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
               0           XSIF,FCOULC;
               0
               0  DO medium = 1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      Zt = 0; Zb = 0; Zf = 0;
               1      DO i=1, NNE(medium) [
               2          Zi = ZELEM(medium,i); pi = PZ(medium,i);
               2          fc = FCOULC(Zi); xi = XSIF(Zi);
               2          aux = pi*Zi*(Zi + xi);
               2          Zt = Zt + aux;
               2          Zb = Zb - aux*Log(Zi)/3;
               2          Zf = Zf + aux*fc;
               2      ]
               1      Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
               1      fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
               1      fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;
               1
               1      "These are used in BREMS"
               1      dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
               1      dl2(1,medium) = -3.242/fmax1;
               1      dl3(1,medium) = 0.625/fmax1;
               1      dl4(1,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(1,medium) = -4.184/fmax1;
               1      dl6(1,medium) = 0.952;
               1      dl1(2,medium) = (20.029+4*Zg)/fmax1;
               1      dl2(2,medium) = -1.93/fmax1;
               1      dl3(2,medium) = -0.086/fmax1;
               1      dl4(2,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(2,medium) = -4.184/fmax1;
               1      dl6(2,medium) = 0.952;
               1      dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
               1      dl2(3,medium) = -3.242/fmax2;
               1      dl3(3,medium) = 0.625/fmax2;
               1      dl4(3,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(3,medium) = -4.184/fmax2;
               1      dl6(3,medium) = 0.952;
               1      dl1(4,medium) = (20.029+4*Zv)/fmax2;
               1      dl2(4,medium) = -1.93/fmax2;
               1      dl3(4,medium) = -0.086/fmax2;
               1      dl4(4,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(4,medium) = -4.184/fmax2;
               1      dl6(4,medium) = 0.952;
               1
               1      "and these in PAIR"
               1      dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
               1      dl2(5,medium) = (3*(-3.242) - (-1.930));
               1      dl3(5,medium) = (3*(0.625)-(-0.086));
               1      dl4(5,medium) = (2*21.12+8*Zg);
               1      dl5(5,medium) = (2*(-4.184));
               1      dl6(5,medium) = 0.952;
               1      dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
               1      dl2(6,medium) = (3*(-3.242) + (-1.930));
               1      dl3(6,medium) = (3*0.625+(-0.086));
               1      dl4(6,medium) = (4*21.12+16*Zg);
               1      dl5(6,medium) = (4*(-4.184));
               1      dl6(6,medium) = 0.952;
               1      dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
               1      dl2(7,medium) = (3*(-3.242) - (-1.930));
               1      dl3(7,medium) = (3*(0.625)-(-0.086));
               1      dl4(7,medium) = (2*21.12+8*Zv);
               1      dl5(7,medium) = (2*(-4.184));
               1      dl6(7,medium) = 0.952;
               1      dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
               1      dl2(8,medium) = (3*(-3.242) + (-1.930));
               1      dl3(8,medium) = (3*0.625+(-0.086));
               1      dl4(8,medium) = (4*21.12+16*Zv);
               1      dl5(8,medium) = (4*(-4.184));
               1      dl6(8,medium) = 0.952;
               1
               1      bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1      bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1
               1  ]
               0  return;
               0  end;
               0
               0
               0  $REAL function FCOULC(Z);
               0  "************************"
               0  $IMPLICIT-NONE;
               0  $REAL Z;
               0  $REAL fine,asq;
               0  data fine/137.03604/;
               0  asq = Z/fine; asq = asq*asq;
               0  FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
               0  return;
               0  end;
               0
               0  $REAL function XSIF(Z);
               0  "**********************"
               0  $IMPLICIT-NONE;
               0  $REAL    Z;
               0  $INTEGER iZ;
               0  $REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
               0  data     alrad/5.31,4.79,4.74,4.71/;
               0  data     alradp/6.144,5.621,5.805,5.924/;
               0  data     a1440/1194.0/,A183/184.15/;
               0  IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
               0  ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  subroutine init_compton;
               0  "
               0  "  Reads in bound Compton scattering data from unit $INCOHUNIT
               0  "  and performs necessary initializations
               0  "
               0  "  See definitions of variables in egsnrc.macros with definition
               0  "  of COMIN/COMPTON-DATA/
               0  "
               0  "  I.Kawrakow, January 99
               0  "******************************************************************"
               0
               0  implicit none;
               0
               0  $COMIN-INIT-COMPT;
               0
               0  $INTEGER i,j,iz,nsh,j_l,j_h;
               0  $REAL    aux,pztot,atav;
               0  $REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
               0                          "compiler don't have an intrinsic error function"
               0  $LOGICAL getd;
               0
               0  " Initialize radiative Compton corrections, if needed "
               0  $RADC_HATCH;
               0
               0  $need_bound_compton_data(getd);
               0  IF( ~getd ) [
               1      IF( eadl_relax & photon_xsections = 'xcom' )[
               2          $egs_fatal('(a,/a,/a)',
               2                     'You must turn ON Compton binding corrections when using',
               2                     'a detailed atomic relaxation (eadl_relax=true) since ',
               2                     'binding energies taken from incoh.data below 1 keV!');
               2      ]
               1      $egs_info('(a/)',' Bound Compton scattering not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
               0  rewind($INCOHUNIT);
               0  DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
               0  iz = 0;
               0  DO j=1,$MXTOTSH [
               1      read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
               1                         Jo_array(j),be_array(j);
               1      Jo_array(j) = Jo_array(j)*137.;
               1      be_array(j) = be_array(j)*1e-6/PRM;
               1      aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
               1      erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
               1                      "0.82436063535 is exp(0.5)/2"
               1
               1      "For detailed atomic relaxations set shell type
               1      "to actual shell number and update binding energies
               1      "with values from the photo-electric cross sections
               1      IF (eadl_relax)[
               2         IF (iz_array(j) ~= iz)[
               3            shn_array(j) = 1; iz = iz_array(j);
               3         ]
               2         ELSE[
               3            shn_array(j) = shn_array(j-1)+1;
               3         ]
               2         IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
               3           be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
               3         ]
               2         ELSE IF(photon_xsections = 'xcom') [
               3           "Use binding energies from incoh.data below 1 keV"
               3           binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
               3         ]
               2      ]
               1
               1  ]
               0  $egs_info(*,' Done');
               0  $egs_info('(/a)',' Initializing Bound Compton scattering ......');
               0  DO medium = 1,nmed [
               1      pztot = 0; nsh = 0;
               1      DO i = 1, nne(medium) [
               2          iz = int(zelem(medium,i));
               2          DO j = 1, $MXTOTSH [
               3              IF( iz = iz_array(j) ) [
               4                  nsh = nsh + 1;
               4                  IF( nsh > $MXMDSH ) [
               5                      $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
               5                                ' the number of shells is > ',$MXMDSH,'!',
               5                                ' Increase the parameter $MXMDSH! ');
               5                  ]
               4                  shell_array(nsh,medium) = j;
               4                  aux = pz(medium,i)*ne_array(j);
               4                  eno_array(nsh,medium) = aux;
               4                  pztot = pztot + aux;
               4              ]
               3          ]
               2      ]
               1      IF( nsh = 0 ) [
               2          $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
               2      ]
               1      n_shell(medium) = nsh;
               1      $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
               1      DO i=1,nsh [
               2          j = shell_array(i,medium);
               2          eno_array(i,medium) = eno_array(i,medium)/pztot;
               2          $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
               2                    i,j,shn_array(j),eno_array(i,medium),
               2                    Jo_array(j),be_array(j)*PRM*1000.);
               2          eno_array(i,medium) = -eno_array(i,medium);
               2          eno_atbin_array(i,medium) = i;
               2      ]
               1      atav = 1./nsh;
               1      DO i=1,nsh-1 [
               2          DO j_h = 1,nsh-1 [
               3              IF( eno_array(j_h,medium) < 0 ) [
               4                  IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
               4              ]
               3          ]
               2          DO j_l = 1,nsh-1 [
               3              IF( eno_array(j_l,medium) < 0 ) [
               4                  IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
               4              ]
               3          ]
               2          aux = atav - abs(eno_array(j_l,medium));
               2          eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
               2          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
               2          eno_atbin_array(j_l,medium) = j_h;
               2          IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
               2      ]
               1      DO i=1,nsh [
               2          IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
               2      ]
               1  ]
               0
               0  $egs_info('(a/)',' ...... Done.');
               0
               0  $need_relaxation_data(getd);
               0  IF( getd ) return;
               0  $egs_fatal('(/a,/a,/a,/a)',
               0  ' In subroutine init_compton: ',
               0  '   Scattering off bound electrons creates atomic vacancies,',
               0  '   potentially starting an atomic relaxation cascade. ',
               0  '   Please turn ON atomic relaxations.');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE MOLLER;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
               0  "   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
               0  "   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
               0  "   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
               0  "   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
               0  "   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
               0  "   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
               0  "   LOSS DURING TRANSPORT.                                         "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
               0                                            "UPHIOT,USEFUL,RANDOM/;"
               0  ;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;
               0
               0  $DEFINE-LOCAL-VARIABLES-MOLLER;
               0
               0  $REAL sigm,pbrem,rsh,Uj,sig_j;
               0  $INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;
               0
               0  "IRCODE=1;  appears to be unused, IK Oct 97"
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
               0  EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
               0  PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
               0  EKIN=PEKIN;
               0
               0  IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
               1      "The EII flag is set and this medium has shells for which we want to"
               1      "simulate EII => sample if the interaction is with a EII shell"
               1      $SET INTERVAL elke,eke;
               1      $EVALUATE sigm USING esig(elke);
               1      $EVALUATE pbrem USING ebr1(elke);
               1      sigm = sigm*(1 - pbrem);
               1      $RANDOMSET rsh; rsh = sigm*rsh;
               1      DO iele=1,nne(medium) [
               2          iZ = int(zelem(medium,iele)+0.5);
               2          nsh = eii_no(medium,iele);
               2          IF( nsh > 0 ) [
               3              ifirst = eii_first(medium,iele);
               3              DO ish = 1,nsh [
               4                  Uj = binding_energies(ish,iZ);
               4                  IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
               5                      jj = ifirst + ish - 1;
               5                      i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
               5                      sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
               5                      sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
               5                      rsh = rsh - sig_j;
               5                      IF( rsh < 0 ) [
               6                          $AUSCALL($EIIB);
               6                          call eii_sample(ish,iZ,Uj);
               6                          $AUSCALL($EIIA);
               6                          return;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1  ]
               0  IF( ekin <= 2*te(medium) ) return;
               0  T0=EKIN/RM;
               0  E0=T0+1.0;
               0  EXTRAE = EIE - THMOLL(MEDIUM);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  "G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  G2=T0*T0/E02;
               0  G3=(2.*T0+1.)/E02;
               0  "   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
               0  "   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
               0  "   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
               0  "   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
               0  "   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
               0  "   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
               0  "   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
               0  "   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "
               0
               0  "   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
               0  "   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
               0  "   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
               0  "   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
               0  "   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "
               0
               0  GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
               0  LOOP[" TO RETRY IF REJECTED"
               1  $RANDOMSET RNNO27;
               1  BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);
               1
               1  "   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
               1  R=BR/(1.-BR);
               1  $RANDOMSET RNNO28;
               1  REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
               1  RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
               1  ]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"
               0
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
               0  PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
               0  PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
               0  ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
               0  ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
               0  E(NP)=PESE1;
               0  $CHECK-STACK(np+1,'MOLLER');
               0  E(NP+1)=PESE2;
               0  "   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
               0  "   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "
               0
               0  " One possible way of dealing with double counting of angular      "
               0  " deflections in inelastic scattering would be to                  "
               0  " not deflect the 'old' electron as these deflections are          "
               0  " already taken into account in the multiple elastic scattering    "
               0  " This approach has the disadvantage of loosing correlations       "
               0  " between big energy losses and strong angular deflections         "
               0  " The advantage of such an approach is its simplicity.             "
               0  " If spin effects for multiple elastic scattering are turned on,   "
               0  " the double counting is taken into account by the appropriate     "
               0  " modification of the scattering power (which depends on AE)       "
               0  "                                                                  "
               0  "                                                                  "
               0  " IK, June 1999                                                    "
               0
               0  H1=(PEIE+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
               0  DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0
               0  "sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"
               0
               0  CALL UPHI(2,1);
               0
               0  "   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
               0  NP=NP+1;
               0  IQ(NP)=-1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE MOLLER"  END;
               0
1              0  %E
               0
               0  subroutine mscati;
               0  "**********************************************************************"
               0
               0  " Subroutine to read the pre-calculated q^(2+)-surface, prepare data
               0  " required by the mscat and msdist subroutines, initialize spin effect
               0  " corrections
               0  "
               0  " I.Kawrakow, NRC
               0  "**********************************************************************"
               0
               0  implicit none;
               0
               0  $REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
               0  $REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
               0  $INTEGER
               0      i,leil,leip1l,neke,lelke,lelkef,lelktmp;
               0  $LOGICAL  ise_monoton, isp_monoton;
               0
               0  $declare_write_buffer;
               0
               0  "cross section per energy loss"
               0  $REAL sigee,sigep,sig,sige_old,sigp_old;
               0
               0  "entry mscat variables
               0  "======================
               0
               0  $COMIN-MSCATI;
               0
               0  " moved the following from prestaII_inputs, "
               0  " if transport_algorithm = presta-I, exact_bca = .false. and
               0  " skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"
               0
               0  IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               0  ELSE                    [ exact_bca = .false.; ]
               0  IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
               0  IF( ximax <= 0  | ximax >= 1 ) [
               1      IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
               1      ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
               1  ]
               0  IF (transport_algorithm ~= $PRESTA-II &
               0      transport_algorithm ~= $PRESTA--I &
               0      transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
               0  IF( skindepth_for_bca <= 1e-4 ) [
               1      "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
               1      IF( ~exact_bca ) [
               2          $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
               2          $set_ecutmn;
               2          $egs_info(*,'     minimum ECUT found: ',ecutmn);
               2          tstbmn = 1e30;
               2          DO medium = 1,nmed [
               3              tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
               3              tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
               3              aux = Log(tstbm);
               3              IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
               3              tstbm = Log(tstbm/aux);
               3              "Changed the following to the above so that the Intel compiler"
               3              " does not vectorize the loop with -xK. Vectorizing this loop"
               3              " on an Athlon CPU results in segmentation fault."
               3              " IK, Jan 29 2004."
               3              "tstbm = Log(tstbm/Log(tstbm));"
               3              tstbmn = Min(tstbmn,tstbm);
               3          ]
               2          $egs_info(*,'     default BLCMIN is: ',tstbmn);
               2          skindepth_for_bca = Exp(tstbmn);
               2          $egs_info(*,'     this corresponds to ',skindepth_for_bca,
               2           ' elastic MFPs ');
               2      ]
               1      ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
               1  ]
               0
               0  " read MS data for screened Rutherford scattering "
               0  call init_ms_SR;
               0
               0  DO medium = 1,nmed
               0  [
               1      "Absorb Euler constant into the multiple scattering parameter
               1      "1.16699413758864573 = Exp[2 EulerGamma - 1]
               1      blcc(medium) = 1.16699413758864573*blcc(medium);
               1
               1      "Take its square as this is employed throughout
               1      xcc(medium)  = xcc(medium)**2;
               1  ]
               0
               0  IF( spin_effects ) [ call init_spin; ]
               0
               0  "Determine maximum cross section per energy loss for every medium
               0  $egs_info(*,' ');
               0  esige_max = 0;
               0  psige_max = 0;
               0  DO medium = 1,nmed
               0  [
               1
               1    sigee = 1E-15; sigep = 1E-15;
               1    neke = meke(medium); "Number of elements in storage array
               1    ise_monoton = .true.; isp_monoton = .true.;
               1    sige_old = -1; sigp_old = -1;
               1    DO i = 1,neke
               1    [
               2
               2      ei   = exp((float(i) - eke0(medium))/eke1(medium));
               2      eil  = log(ei);
               2      leil = i;
               2      $EVALUATE ededx USING ededx(eil);
               2      $EVALUATE sig USING esig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigee) sigee = sig;
               2      IF( sig < sige_old ) ise_monoton = .false.;
               2      sige_old = sig;
               2      $EVALUATE ededx USING pdedx(eil);
               2      $EVALUATE sig USING psig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigep) sigep = sig;
               2      IF( sig < sigp_old ) isp_monoton = .false.;
               2      sigp_old = sig;
               2
               2    ]
               1    $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
               1            ise_monoton,isp_monoton);
               1    sig_ismonotone(0,medium) = ise_monoton;
               1    sig_ismonotone(1,medium) = isp_monoton;
               1    esig_e(medium) = sigee; psig_e(medium) = sigep;
               1    IF( sigee > esige_max ) esige_max = sigee;
               1    IF( sigep > psige_max ) psige_max = sigep;
               1  ]
               0  $egs_info(*,' ');
               0
               0  $egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
               0  $egs_info(*,' ');
               0
               0  "Determine upper limit in step size for multiple scattering
               0  DO medium = 1,nmed
               0  [
               1      " Calculate range array first "
               1      " =========================== "
               1      ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
               1      eil  = log(ei);
               1      leil = 1;
               1      E_array(1,medium) = ei;
               1      expeke1(medium) = Exp(1./eke1(medium))-1;
               1      range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
               1      neke = meke(medium); "Number of elements in storage array
               1      DO i = 1,neke - 1
               1      [
               2          eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
               2          E_array(i+1,medium) = eip1;
               2          " Calculate range. The following expressions result from the"
               2          " logarithmic interpolation for the (restricted) stopping power "
               2          " and a power power series expansion of the integral "
               2          eke = 0.5*(eip1+ei); elke = Log(eke);
               2          $SET INTERVAL elke,eke;
               2          $EVALUATE ededx USING pdedx(elke);
               2          aux = pdedx1(i,medium)/ededx;
               2          range_ep(1,i+1,medium) = range_ep(1,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          $EVALUATE ededx USING ededx(elke);
               2          aux = ededx1(i,medium)/ededx;
               2          range_ep(0,i+1,medium) = range_ep(0,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          ei = eip1;
               2      ]
               1
               1      " Now tmxs "
               1      " ======== "
               1
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
               1      p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
               1      chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               1      $EVALUATE dedx0 USING ededx(eil);
               1      estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               1      estepx = estepx*ximax;
               1      IF( estepx > estepe ) [ estepx = estepe; ]
               1      si = estepx*ei/dedx0;
               1
               1      DO i = 1,neke - 1
               1      [
               2
               2          elke = (i + 1 - eke0(medium))/eke1(medium);
               2          eke  = Exp(elke); lelke = i+1;
               2          p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
               2          chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               2          $EVALUATE ededx USING ededx(elke);
               2          estepx = 2*p2*beta2*ededx/eke/
               2                    Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               2          estepx = estepx*ximax;
               2          IF( estepx > estepe ) [ estepx = estepe; ]
               2          ekef = (1-estepx)*eke;
               2          IF( ekef <= E_array(1,medium) )
               2          [
               3              sip1 = (E_array(1,medium) - ekef)/dedx0;
               3              ekef = E_array(1,medium);
               3              elkef = (1 - eke0(medium))/eke1(medium);
               3              lelkef = 1;
               3          ]
               2          ELSE
               2          [
               3              elkef = Log(ekef);
               3              $SET INTERVAL elkef,eke;
               3              leip1l = lelkef + 1;
               3              eip1l  = (leip1l - eke0(medium))/eke1(medium);
               3              eip1   = E_array(leip1l,medium);
               3              aux    = (eip1 - ekef)/eip1;
               3              elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
               3              ektmp  = 0.5*(ekef+eip1);
               3              lelktmp = lelkef;
               3              $EVALUATE ededx USING ededx(elktmp);
               3              aux = ededx1(lelktmp,medium)/ededx;
               3              sip1 = (eip1 - ekef)/ededx*(
               3                       1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
               3          ]
               2          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);
               2
               2          "Now solve these equations
               2          "  si   = tmxs1 * eil   + tmxs0
               2          "  sip1 = tmxs1 * eip1l + tmxs0
               2
               2          tmxs1(i,medium) = (sip1 - si)*eke1(medium);
               2          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;
               2
               2          si  = sip1;
               2      ]
               1
               1      "Now pick up last table entry which applies only to last energy
               1      tmxs0(neke,medium) = tmxs0(neke - 1,medium);
               1      tmxs1(neke,medium) = tmxs1(neke - 1,medium);
               1
               1  ]
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
               0                   spin_effects,find_index,spin_index,
               0                   cost,sint);
               0  "========================================================================="
               0  "                                                                         "
               0  " Subroutine to sample multiple electron scattering angles from the exact "
               0  " distribution resulting from elastic scattering described by the screened"
               0  " Rutherford cross section (spin_effects=.false.) or by the screened      "
               0  " Rutherford cross times Mott correction (spin_effects=.true.)            "
               0  "                                                                         "
               0  " I.Kawrakow, NRC                                                         "
               0  "========================================================================="
               0
               0  implicit none;
               0
               0  $REAL    lambda, chia2,q1,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects,find_index,spin_index;
               0
               0  COMIN/MS-Data,RANDOM,EGS-IO/;
               0
               0  $declare_write_buffer;
               0
               0  $REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
               0           cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
               0  $INTEGER icount,i,j,k;
               0
               0  save     i,j,omega2;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  IF(lambda <= 13.8)
               0  [
               1      "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
               1      "that contribute to the forward no-scattering amplitude.
               1      $RANDOMSET sprob;
               1      explambda = Exp(-lambda);
               1      IF (sprob < explambda)
               1      [
               2          "It was a no scattering event
               2          cost = 1; sint = 0;
               2          return;
               2      ]
               1      wsum = (1+lambda)*explambda;
               1      IF ( sprob < wsum )
               1      [
               2        :RETRY_1:;
               2        $RANDOMSET xi;
               2        xi  = 2*chia2*xi/(1 - xi + chia2);
               2        cost = 1 - xi;
               2        IF( spin_effects ) [
               3            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
               3                                  spin_index,.false.);
               3            $RANDOMSET rnno;
               3            IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
               3        ]
               2        sint = sqrt(xi*(2 - xi));
               2        return;
               2      ]
               1      IF ( lambda <= 1 )      "IK introduced this portion because with
               1                              "alternative BCAs mscat can be called with
               1                              " lambda < 1 where there are no pre-calculated
               1                              "data
               1      [
               2          wprob = explambda; wsum = explambda;
               2          cost = 1; sint = 0;
               2          icount = 0;
               2          LOOP
               2          [
               3              icount = icount + 1;
               3              IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
               3              wprob = wprob*lambda/icount;
               3              wsum = wsum + wprob;
               3              :RETRY_2:;
               3              $RANDOMSET xi;
               3              xi  = 2*chia2*xi/(1 - xi + chia2);
               3              cosz = 1 - xi;
               3              IF( spin_effects ) [
               4                  rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
               4                                        spin_index,.false.);
               4                  $RANDOMSET rnno;
               4                  IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
               4              ]
               3              sinz = xi*(2 - xi);
               3              IF ( sinz > 1.e-20 )
               3              [
               4                 sinz = Sqrt(sinz);
               4                 $RANDOMSET xi;
               4                 phi = xi*6.2831853;
               4                 cost = cost*cosz - sint*sinz*Cos(phi);
               4                 sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
               4               ]
               3          ] UNTIL ( wsum > sprob);
               2          return;
               2      ]
               1  ]
               0
               0  "It was a multiple scattering event
               0  "Sample the angle from the q^(2+) surface
               0
               0  IF (lambda <= $LAMBMAX_MS ) [
               1
               1      IF (find_index)
               1      [
               2          llmbda = log(lambda);
               2
               2          " First fix lambda bin
               2          ai = llmbda*dllambi; i = ai; ai = ai - i;
               2          $RANDOMSET xi;
               2          IF(xi < ai) i = i + 1;
               2
               2          " fix now q1 bin
               2          IF( q1 < $QMIN_MS ) [ j = 0; ]
               2          ELSE IF( q1 < $QMAX_MS ) [
               3              aj = q1*dqmsi; j = aj; aj = aj - j;
               3              $RANDOMSET xi;
               3              IF( xi < aj ) j = j + 1;
               3          ]
               2          ELSE [ j = $MAXQ_MS; ]
               2
               2          " Calculate omega2 "
               2          IF(llmbda < 2.2299) [
               3            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
               3              0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
               3          ]
               2          ELSE [
               3            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
               3                     llmbda*(0.1535754 - llmbda*0.00552888)));
               3          ]
               2
               2          find_index = .false.;
               2      ]
               1      "If this is a re-iteration with the same lambda, then omega2, i, and k
               1      "should have been defined in the previous iteration
               1
               1  :RETRY_3:;
               1      $RANDOMSET xi;
               1      ak = xi*$MAXU_MS; k = ak; ak = ak - k;
               1      IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
               1      a = fms_array(i,j,k); u = ums_array(i,j,k);
               1      du = ums_array(i,j,k+1) - u;
               1      $RANDOMSET xi;
               1      IF( abs(a) < 0.2 ) [
               2          x1 = 0.5*(1-xi)*a;
               2          u  = u + xi*du*(1+x1*(1-xi*a));
               2      ]
               1      ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]
               1
               1      xi      = omega2*u/(1 + 0.5*omega2 - u);
               1      IF( xi > 1.99999 ) [ xi = 1.99999; ]
               1        "some machines have trouble when xi is very close to 2 in subsequent"
               1        "calculations. IK, April 25 2002"
               1      cost    = 1 - xi;
               1      IF( spin_effects ) [
               2          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
               2          $RANDOMSET rnno;
               2          IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
               2      ]
               1      sint    = sqrt(xi*(2-xi));
               1      return;
               1  ]
               0
               0  "This is an error condition
               0
               0  $egs_info(*,' ');
               0  $egs_info(*,' *************************************');
               0  $egs_info(*,' Maximum step size in mscat exceeded! ');
               0  $egs_info(*,' Maximum step size initialized: 100000');
               0  $egs_info(*,' Present lambda: ',lambda);
               0  $egs_info(*,' chia2: ',chia2);
               0  $egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
               0  $egs_info(*,' medium: ',medium);
               0  $egs_fatal(*,' Stopping execution');
               0
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  $REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
               0                                spin_index,is_single);
               0  "============================================================================="
               0  "                                                                             "
               0  " Determines the rejection function due to spin effects for                   "
               0  "   charge        qel (=0 for e-, =1 for e+)                                  "
               0  "   log(energy)   elke                                                        "
               0  "   speed         beta2                                                       "
               0  "   1. MS moment  q1                                                          "
               0  "   cos(theta)    cost                                                        "
               0  "                                                                             "
               0  " I.Kawrakow, NRC                                                             "
               0  "============================================================================="
               0
               0  implicit none;
               0
               0  $REAL      elke,beta2,q1,cost;
               0  $INTEGER   qel,medium;
               0  $LOGICAL   spin_index,is_single;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,RANDOM/;
               0
               0  $REAL      rnno,ai,qq1,aj,xi,ak;
               0  $INTEGER   i,j,k;
               0
               0  save       i,j;
               0
               0  IF( spin_index ) [  "Determine the energy and q1 index
               1      spin_index = .false.;
               1      IF( beta2 >= b2spin_min ) [
               2          ai = (beta2 - b2spin_min)*dbeta2i;
               2          i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
               2      ]
               1      ELSE IF( elke > espml ) [
               2          ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
               2      ]
               1      ELSE [ i = 0; ai = -1; ]
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) i = i + 1;
               1      IF( is_single ) [ j = 0; ]
               1      ELSE [
               2          qq1 = 2*q1; qq1 = qq1/(1 + qq1);
               2          aj = qq1*dqq1i; j = aj;
               2          IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
               2          ELSE [  aj = aj - j;
               3                  $RANDOMSET rnno;
               3                  IF( rnno < aj ) j = j + 1;
               3          ]
               2      ]
               1  ]
               0  xi = Sqrt(0.5*(1-cost));
               0  ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
               0  spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
               0                       ak*spin_rej(medium,qel,i,j,k+1);
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0
               0  subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
               0  "============================================================================"
               0  "                                                                            "
               0  " single elastic scattering                                                  "
               0  "                                                                            "
               0  " I.Kawrakow, NRC                                                            "
               0  "============================================================================"
               0
               0  implicit none;
               0
               0  $REAL    chia2,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects;
               0
               0  COMIN/RANDOM/;
               0
               0  $REAL    xi,rnno,rejf,spin_rejection,qzero;
               0  $LOGICAL spin_index;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  spin_index = .true.;
               0  :RETRY-SPIN:;
               0  $RANDOMSET xi;
               0  xi  = 2*chia2*xi/(1 - xi + chia2);
               0  cost = 1 - xi;
               0  IF( spin_effects ) [
               1      qzero=0;
               1      rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
               1      $RANDOMSET rnno;
               1      IF( rnno > rejf ) goto :RETRY-SPIN:;
               1  ]
               0  sint = sqrt(xi*(2 - xi));
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_ms_SR;
               0  "================================================================"
               0  "                                                                "
               0  " Reads in pre-calculated screened Rutherford multiple elastic   "
               0  " scattering data                                                "
               0  "                                                                "
               0  " I. Kawrakow, NRC                                               "
               0  "================================================================"
               0
               0  implicit none;
               0
               0  COMIN/MS-Data,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  integer*4 i,j,k;
               0
               0  $egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
               0  rewind($MSCAT-DATAFILE);
               0  DO i=0,$MAXL_MS [
               1      DO j=0,$MAXQ_MS [
               2          read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
               2          read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
               2          DO k=0,$MAXU_MS-1 [
               3             fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
               3             ims_array(i,j,k) = ims_array(i,j,k)-1;
               3          ]
               2          fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
               2      ]
               1  ]
               0  $egs_info('(a)',' done ');
               0
               0  llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
               0  dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
               0  dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_spin;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline,dloge,eloge;
               0
               0  real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"
               0
               0  real*4        fmax_array(0:$MAXQ_SPIN);
               0  integer*2     i2_array(512),ii2;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,ii4,irec;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0
               0  $INTEGER      spin_unit, rec_length, want_spin_unit;
               0  integer       egs_get_unit;
               0  character     data_version*32,endianess*4;
               0  $LOGICAL      swap;
               0
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " stupid GNU compiler complains that the arguments to egs_swap_ are of "
               0  " one kind here, but of some other kind there => need character arrays and "
               0  " equivalence statements"
               0  real*4        tmp_4;
               0  character     c_2(2), c_4(4);
               0  equivalence   (ii2,c_2), (tmp_4,c_4);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
               0  want_spin_unit = 61;
               0  spin_unit = egs_get_unit(want_spin_unit);
               0  IF( spin_unit < 1 ) [
               1      $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               1  ]
               0  rec_length = 276*$RECL-FACTOR;
               0  open(spin_unit,file=spin_file,form='unformatted',access='direct',
               0       status='old',recl=rec_length,err=:spin-open-error:);
               0  read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
               0                        espin_min,espin_max,b2spin_min,b2spin_max;
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
               1      tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
               1      tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
               1      tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
               0  $egs_info('(a)',data_version);
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,
               0          ' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
               0  $egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
               0          b2spin_min,b2spin_max);
               0  n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
               0  dloge = log(espin_max/espin_min)/n_ener;
               0  eloge = log(espin_min); earray(0) = espin_min;
               0  $FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
               0  DO i=1,n_ener [
               1      eloge = eloge + dloge; earray(i) = exp(eloge);
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0  dbeta2 = (b2spin_max - b2spin_min)/n_ener;
               0  beta2 = b2spin_min; earray(n_ener+1) = espin_max;
               0  DO i=n_ener+2,2*n_ener+1 [
               1      beta2 = beta2 + dbeta2;
               1      IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
               1      ELSE [ earray(i) = 50585.1; ]
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0
               0  " Convert to MeV and set interpolation interavals"
               0
               0
               0
               0
               0  espin_min = espin_min/1000; espin_max = espin_max/1000;
               0  dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               0  espml = Log(espin_min);
               0  dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               0  dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              DO i=0,$MAXE_SPI1 [
               4                  irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
               4                  $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
               4                  read(spin_unit,rec=irec,err=:spin-read-error:)
               4                    dum1,dum2,dum3,aux_o,fmax_array,i2_array;
               4                  IF( swap ) [
               5                    tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
               5                    tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
               5                    tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
               5                    tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
               5                  ]
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      tmp_4 = fmax_array(j);
               5                      IF( swap ) call egs_swap_4(c_4);
               5                      DO k=0,$MAXU_SPIN [
               6                          ii2 = i2_array((n_point+1)*j + k+1);
               6                          IF( swap ) call egs_swap_2(c_2);
               6                          ii4 = ii2;
               6                          IF( ii4 < 0 ) ii4 = ii4 + 65536;
               6                          dum1 = ii4; dum1 = dum1*tmp_4/65535;
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*dum1;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2          $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
               2            c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
               2      ]
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
               2           etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
               2            q1ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
               2            q1cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
               2            q2ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
               2            q2cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  close(spin_unit);
               0  return;
               0
               0  :spin-open-error:
               0  $egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));
               0
               0  :spin-read-error:
               0  $egs_fatal(*,'Error while reading spin data file for element',iZ);
               0
               0  return; end;
1              0  %E
               0
               0  subroutine init_spin_old;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " This version uses the old EGSnrc ASCII spin data format.              "
               0  " If the installation failed to figure out the byte order of your       "
               0  " machine, rename this subroutine to init_spin, the current init_spin   "
               0  " to init_spin_new (or whatever) and download the old spinms data       "
               0  " directory.
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
               0               $file_sep // 'z000';
               0  length = lnblnk1(spin_file);
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
               1                            ' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
               2          iiZ = iZ - iii*100;
               2          iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
               2          iiZ = iiZ - 10*iii;
               2          spin_file(length:length) = char(iiZ+48);
               2          want_spin_unit = 61;
               2          spin_unit = egs_get_unit(want_spin_unit);
               2          IF( spin_unit < 1 ) [
               3              $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               3          ]
               2          open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
               2          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
               2          read(spin_unit,*) n_ener,n_q,n_point;
               2          IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
               3              $egs_fatal(*,' Wrong spin file for Z = ',iZ);
               3          ]
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              read(spin_unit,*); read(spin_unit,*);
               3              DO i=0,$MAXE_SPI1 [
               4                  read(spin_unit,'(a,g14.6)') string,earray(i);
               4                  read(spin_unit,*) dum1,dum2,dum3,aux_o;
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      read(spin_unit,*) tmp_array;
               5                      DO k=0,$MAXU_SPIN [
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
               6                      ]
               5                  ]
               4              ]
               3          ]
               2          close(spin_unit);
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2      ]
               1
               1      " Convert to MeV and set interpolation interavals"
               1      espin_min = espin_min/1000; espin_max = espin_max/1000;
               1      dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               1      espml = Log(espin_min);
               1      dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               1      dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  return;
               0
               0  :SPIN-DBASE-ERROR:
               0  $egs_info(*,' ******************** Error in init_spin ******************* ');
               0  $egs_info('(a,a)','  could not open file ',spin_file);
               0  $egs_fatal(*,' terminating execution ');
               0
               0  end;
1              0  %E
               0  ; "buffer flush
               0
               0  "======================================================================"
               0  "                 subroutine msdist_pII                                "
               0  "                 =====================                                "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep.                         "
               0  "  For description of input and output variables see below             "
               0  "                                                                      "
               0  "  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
               0  "  March 1997          Alex Bielajew        Adaption for EGS4          "
               0  "  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
               0  "                                           mortran version by Bielajew"
               0  "  June 1997           Iwan Kawrakow        Improved energy loss       "
               0  "                                           corrections                "
               0  "  June 1999           Iwan Kawrakow        spin effects, removed      "
               0  "                                           $SUBSTEP-ELOSS-EVALUATION  "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pII
               0  (
               0      e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      med,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects;
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      b,         "substep transport distance,
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      c,         "substep transport distance,
               0      eta,eta1,  "randomization of the substep transport distances
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi1,     "cosine of the first azimuthal angle
               0      cphi2,     "cosine of the second azimuthal angle
               0      w1,        "cosine of the first substep polar scattering angle
               0      w2,        "cosine of the second substep polar scattering angle
               0      w1v2,      "w1*v2;
               0      delta,     "transport parameter (see paper)
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)"
               0      beta2,     "speed at e in units of c, squared"
               0      etap,      "correction to the screening parameter derived from PWA
               0      xi_corr,   "correction to the first MS moments due to spin
               0      ms_corr,
               0      tau,       "average kinetic energy over the step divided by electron mass
               0      tau2,      "tau squared
               0      epsilon,   "fractional energy loss
               0      epsilonp,  "fractional energy loss
               0      temp,temp1,"auxilarity variables for energy loss corrections
               0      temp2,     "
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      gamma,     "q2/q1
               0      lambda,    "distance in number of elastic scattering mean free paths
               0                 "for each sample of the multiple scattering angle
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of ap2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sint1,     "sine   of the first substep polar scattering angle
               0      sint2,     "sine   of the second substep polar scattering angle
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      sphi1,     "sine   of the first azimuthal angle
               0      sphi2,     "sine   of the second azimuthal angle
               0      u2p,       "intermediate scatter or transport direction cosine
               0      u2,        "sint2*cphi2;
               0      v2,        "sint2*sphi2;
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index,  "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index   "saves locating the spin rejection index in 2. call to mscat"
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  medium  = med;
               0
               0  count_pII_steps = count_pII_steps + 1;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  "Commonly used factors
               0  e       = e0 - 0.5*eloss;
               0  tau     = e/prm;
               0  tau2    = tau*tau;
               0  epsilon = eloss/e0;
               0  epsilonp= eloss/e;
               0  "e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
               0  e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
               0  p2      = e*(e + rmt2);
               0  "p2i     = 1/p2;
               0  beta2   = p2/(p2 + rmsq);
               0  "chia2   = xcccc*p2i/(4*blccc);
               0  chia2   = xcccc/(4*p2*blccc);
               0  lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step
               0
               0  temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
               0               (epsilonp/((tau+1)*(tau+2)))**2;
               0  lambda = lambda*(1 - temp2);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2         $EVALUATE gamma USING q2ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2         $EVALUATE gamma USING q2cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]
               0
               0  chia2  = chia2*etap;
               0  lambda = lambda/(etap*(1+chia2))*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
               0  xi     = q1*lambda;
               0
               0  "Sample first substep scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w1,sint1);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);
               0
               0  "Sample second substep scattering angle
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w2,sint2);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);
               0
               0  "Final direction of motion, relative to z-axis motion
               0  u2  = sint2*cphi2;
               0  v2  = sint2*sphi2;
               0  u2p = w1*u2 + sint1*w2;
               0  us  = u2p*cphi1 - v2*sphi1;
               0  vs  = u2p*sphi1 + v2*cphi1;
               0  ws  = w1*w2 - sint1*u2;
               0
               0  "Calculate delta, b, c
               0
               0  xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects
               0
               0  $RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
               0  delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;
               0
               0  "Correct the coefficients for energy loss
               0  temp1 = 2 + tau;
               0  temp = (2+tau*temp1)/((tau+1)*temp1);
               0  "Take logarithmic dependence into account as well
               0  temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
               0  temp = temp * epsilonp;
               0  temp1 = 1 - temp;
               0  delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
               0            (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
               0             "0.40824829 is 1/Sqrt(6)"
               0  b      = eta*delta;
               0  c      = eta*(1-delta);
               0
               0  "Calculate transport direction cosines
               0  w1v2 = w1*v2;
               0  ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
               0  vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
               0  wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;
               0
               0  "Calculate transport distance
               0  ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PII;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
               0
               0  "                 subroutine msdist_pI                                 "
               0  "                 ====================                                 "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep                          "
               0  "  resampling PRESTA-I behaviour.                                      "
               0  "                                                                      "
               0  "  October 1997        Iwan Kawrakow        Initial coding             "
               0  "  June    1999        Iwan Kawrakow        spin effects               "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pI
               0  (
               0      e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      medium,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
               0      r2max,
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi,      "cosine of the azimuthal scattering angle
               0      sphi,      "sine of the  azimuthal scattering angle
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)
               0      beta2,     "speed at e in units of c, squared
               0      etap,      "correction to the screening angle derived from PWA
               0      xi_corr,   "correction to the first MS moment due to spin
               0      ms_corr,
               0      epsilon,   "fractional energy loss
               0      temp,      "auxilarity variable for energy loss corrections
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      lambda,    "distance in number of elastic scattering mean free paths
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of p2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint,      "sine of the MS angle
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      u2p,       "intermediate scatter or transport direction cosine
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index, "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  e       = e0 - 0.5*eloss;
               0  p2      = e*(e + rmt2);
               0  p2i     = 1/p2;
               0  chia2   = xcccc*p2i/(4*blccc);
               0  beta2   = p2/(p2 + rmsq);
               0  lambda  = tustep*rhof*blccc/beta2;
               0
               0  "Account for energy loss in the MS distribution
               0  factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
               0  epsilon= eloss/e0;
               0  epsilon= epsilon/(1-0.5*epsilon);
               0  temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
               0  lambda = lambda*(1 + temp);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]
               0
               0  chia2   = xcccc*p2i/(4*blccc)*etap;
               0  lambda = lambda/etap/(1+chia2)*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  xi     = q1*lambda;
               0
               0  "Sample multiple scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             ws,sint);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               0  us  = sint*cphi;
               0  vs  = sint*sphi;
               0
               0  "Correct xi used for the PLC calc. for spin effects
               0  xi     = xi*xi_corr;
               0
               0  "Calculate PLC and lateral transport a la PRESTA-I
               0  "Note that we use here the exact expression for <z>
               0  "because it is much simpler and faster than the original PRESTA-I formulas
               0  "(which are also second order approximations)
               0  IF ( xi < 0.1 )
               0  [
               1     z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
               1  ]
               0  ELSE
               0  [
               1     z = (1 - Exp(-xi))/xi;
               1  ]
               0  r  = 0.5*sint;
               0  r2 = r*r; z2 = z*z;
               0  r2max = 1 - z2;
               0  IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]
               0
               0  "Calculate final position vector
               0  ut   = r*cphi; vt = r*sphi; wt = z;
               0
               0  "Calculate transport distance
               0  ustep = Sqrt(z2 + r2)*tustep;
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PI;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PAIR;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   For a photon energy below 2.1 MeV, the energies of the pair    "
               0  "   particles are uniformly distributed in the allowed range via   "
               0  "   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
               0  "   If the user has a better approach, modify this macro.          "
               0  "   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
               0  "   cross section is employed, above 50 MeV the Coulomb-corrected  "
               0  "   Bethe-Heitler is used.                                         "
               0  "   Modified from its original version to make compatible with the "
               0  "   changes made in BREMS.                                         "
               0  "                                                                  "
               0  "   I. Kawrakow                                                    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
               0                                   "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PAIR;
               0
               0  $DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;
               0
               0  $REAL    k,xx,abin,rbin,alias_sample1;
               0  $INTEGER ibin, iq1, iq2, iprdst_use;
               0  $LOGICAL do_nrc_pair;
               0  $INTEGER itrip;
               0  $REAL    ftrip;
               0
               0  NPold = NP;      "Set the old stack counter"
               0
               0  IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
               1                        " it is much more efficient to do it BEFORE the "
               1                        " actual sampling "
               1      i_survived_RR = 0;  "flag they all survive inititally"
               1      IF( prob_RR <= 0 ) [
               2          IF( n_RR_warning < $MAX-RR-WARNING ) [
               3            n_RR_warning = n_RR_warning + 1;
               3            $egs_warning('(a,g14.6)',
               3                        'Attempt to play Russian Roulette with prob_RR<0! ');
               3          ]
               2      ]
               1      ELSE [
               2          $RANDOMSET rnno_RR;
               2          IF( rnno_RR > prob_RR ) [  "The pair was killed "
               3              i_survived_RR =2; "flag both particles eliminated"
               3              IF( np > 1 ) [ np = np-1; ]
               3              ELSE [ " We have just one photon left on the stack. In order to  "
               4                     " get a proper exit from PHOTO, we have to leave at least "
               4                     " one particle on the stack                               "
               4                  wt(np) = 0; e(np) = 0;
               4              ]
               3              return;
               3          ]
               2          ELSE [ "The pair survived, increase the weight"
               3              wt(np) = wt(np)/prob_RR;
               3          ]
               2      ]
               1  ]
               0
               0  $CHECK-STACK(np+1,'PAIR');
               0  PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
               0  EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
               0  do_nrc_pair = .false.;
               0
               0  IF( itriplet > 0 & eig > 4*rm ) [
               1      itrip = dli_triplet*gle + bli_triplet;
               1      ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
               1      $RANDOMSET rnno34;
               1      IF( rnno34 < ftrip ) [  " Triplet production "
               2          call sample_triplet;
               2          return;
               2      ]
               1  ]
               0
               0  IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
               1                        "(privided the energy is within the available range)"
               1      k = eig/rm;
               1      IF( k < nrcp_emax ) [
               2          do_nrc_pair = .true.;
               2          IF( k <= nrcp_emin ) [ ibin = 1; ]
               2          ELSE [
               3              abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
               3              ibin = abin; abin = abin - ibin;
               3              $RANDOMSET rbin;
               3              IF( rbin < abin ) ibin = ibin + 1;
               3          ]
               2          xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
               2                  nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
               2                  nrcp_idata(1,ibin,medium));
               2             " The above returns the energy fraction of the positron "
               2          IF( xx > 0.5 ) [
               3              pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
               3              pese2 = peig - pese1; iq2 = -1;
               3          ]
               2          ELSE [
               3              pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
               3              pese1 = peig - pese2; iq1 = -1;
               3          ]
               2      ]
               1  ]
               0
               0
               0  IF( ~do_nrc_pair ) [
               1  IF (EIG.LE.2.1) [
               2      "   BELOW 2.1,USE APPROXIMATION"
               2      $SELECT-LOW-ENERGY-PAIR-PRODICTION;
               2  ]
               1  ELSE[   "ABOVE 2.1, MUST SAMPLE"
               2
               2      "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
               2      "   COULOMB CORRECTED
               2
               2      IF (EIG.LT.50.) [ "Use BH without Coulomb correction"
               3
               3          L = 5;
               3          L1 = L + 1;
               3
               3          "Find the actual rejection maximum for this photon energy"
               3          delta = 4*delcm(medium)/eig;
               3          IF( delta < 1 ) [
               4             Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4             Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4             aux2 = log(delta+dl6(l,medium));
               4             Amax = dl4(l,medium)+dl5(l,medium)*aux2;
               4             Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
               4          ]
               3          "and then calculate the probability for sampling from (br-1/2)**2"
               3          aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
               3          aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
               3      ]
               2      ELSE [
               3          "Use BH Coulomb-corrected"
               3          L = 7;
               3          "The absolute maxima are close to the actual maxima at high energies"
               3          "=>use the absolute maxima to save time"
               3          Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
               3          aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
               3      ]
               2
               2      del0 = eig*delcm(medium);
               2      Eavail = eig - rmt2;
               2
               2      LOOP [
               3
               3          $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
               3          IF( rnno30 > aux1 ) [ "use the uniform part"
               4              br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
               4          ]
               3          ELSE [  "use the (br-1/2)**2 part of the distribution"
               4              $RANDOMSET rnno32; $RANDOMSET rnno33;
               4              br = 0.5*(1-max(rnno31,rnno32,rnno33));
               4              rejmax = Amax; l1 = l;
               4          ]
               3          Eminus = br*Eavail + rm;
               3          Eplus  = eig - Eminus;
               3          delta = del0/(Eminus*Eplus);
               3          IF( delta < 1 ) [
               4             rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4            rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
               4          ]
               3
               3      ] UNTIL ( rnno34*rejmax <= rejf );
               2
               2      pese2 = Eminus; pese1 = peig - pese2;
               2      $RANDOMSET RNNO34;
               2      IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
               2
               2  ]
               1  ]
               0
               0  "   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
               0  ESE2=PESE2;
               0  E(NP)=PESE1; E(NP+1)=PESE2;
               0  "   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
               0  "   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
               0  "   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
               0  "   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
               0  "   SET UP A NEW 'ELECTRON'  "
               0  $SET-PAIR-ANGLE;
               0  " DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
               0  " of the angular distribution "
               0  CALL UPHI(1,1);
               0  "   SET UP A NEW 'ELECTRON' "
               0  NP=NP+1;
               0  SINTHE=-SINTHE;
               0  CALL UPHI(3,2);
               0
               0  IQ(NP)=iq2; IQ(NP-1)=iq1;
               0  RETURN;
               0  "END OF SUBROUTINE PAIR"    END;
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " Sampling of triplet production events.                                    "
               0  "                                                                           "
               0  " The treatment is based on Borsellino's first Born approximation           "
               0  " result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
               0  " As the kinematic of the process is already complicated enough and the     "
               0  " cross section itself is not simple either, a Markov-chain method is used  "
               0  " to sample triplet events from the Borsellino equation without any         "
               0  " additional approximations (other then the use of the first Born           "
               0  " approximation and the assumption of free electrons implied by             "
               0  " Borsellino's derivation)                                                  "
               0  "                                                                           "
               0  " Iwan Kawrakow, April 2005.                                                "
               0  "***************************************************************************"
               0
               0  subroutine sample_triplet;
               0
               0  "***************************************************************************"
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  " We use double precision throughout as in many cases the kinematically "
               0  " permitted angular interval is too small to be resolved accurately enough "
               0  " in single precision "
               0
               0  real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
               0         eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
               0         eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
               0         wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);
               0
               0  real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;
               0
               0  real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
               0         Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
               0         aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
               0  real*8 Er,pr,pr2,eta_pr;
               0  real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
               0         eta_costp,Epp,pp_sintp,pp_sntp2;
               0  real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
               0         eta_costm;
               0  real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
               0  real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
               0         a,c,sindel,cosdel,sinpsi;
               0
               0  $INTEGER i;
               0  $LOGICAL use_it;
               0  $INTEGER iscore; " needed for BEAM "
               0
               0  $LOGICAL is_initialized;
               0  data is_initialized/.false./;
               0  save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
               0       eta_costm_array,ebin_array,wp_array,qmin_array,
               0       kmin,kmax,dlogki,alogkm,prmi,tiny_eta;
               0
               0  IF( ~is_initialized ) [
               1      is_initialized = .true.;
               1      tiny_eta = 1e-6;
               1      " Set current cross section value to -1 in each energy bin "
               1      DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
               1      " Find the maximum energy of the cross section data "
               1      kmax = 0; kmin = 4.1*prm;
               1      DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
               1      IF( kmax <= kmin ) return;
               1      dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
               1      alogkm = 1 - dlogki*log(kmin);
               1      prmi = 1/prm;
               1      DO i=1,$MAX_TRIPLET [
               2          k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
               2          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
               2          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
               2          qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
               2      ]
               1  ]
               0
               0  peig = e(np);
               0  IF( peig <= 4*prm ) return;
               0  $CHECK-STACK(np+2,'sample_triplet');
               0
               0  " Determine energy bin "
               0  IF( peig <= kmin ) [ i = 1; ]
               0  ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
               0  ELSE [
               1      ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) [ i = i+1; ]
               1  ]
               0
               0  " First use the bin energy to sample the random numbers "
               0  " that determine recoil momentum and electron/postron angles "
               0  k = ebin_array(i);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  :retry_triplet:;
               0
               0  " Pick the recoil electron momentum from 1/p.
               0  $RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
               0  pr = qmin_array(i)*exp(eta_pr*wp_array(i));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  " Determine min./max. kinematically permitted postron energy for "
               0  " this k and p "
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  " Pick the positron energy "
               0  $RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0
               0  " Now we can determine the pair electron energy from energy conservation "
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  " The minimum cosine of the positron angle follows from the kinematics. "
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0
               0  " Now pick the positron direction from 1/(Ep-pp*cost_p) "
               0  $RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  wmup = wmup*(cost_p - Epp);
               0  sint_p = 1-cost_p*cost_p;
               0  IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  " The minimum amd maximum cosine of the pair electron angle follows from "
               0  " the kinematics "
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0
               0  " Now pick the electron direction from "
               0  "  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
               0  " We have to take into account the "
               0  " 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
               0  " otherwise we end up with 1/sqrt() singularities near the ends of the "
               0  " allowed cost_m range                                                 "
               0  $RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
               0  wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
               0  wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
               0  cost_m = cost_m/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  " Now we have selected all independent kinematic variables. "
               0  " Determine the azimuthal angle between the pair electrons "
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0  " And now evaluate the Borsellino cross section "
               0  k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
               0  k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
               0  s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
               0  s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
               0  S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
               0  aux4 = k3*Ep-k2*Em;
               0  S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
               0  sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));
               0
               0  " We get the following factor due to the transformation from phi to "
               0  " the recoil momentum pr "
               0  cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);
               0
               0  " We have to also multiply by the various factors from the sampling of "
               0  " pr, Ep, cost_p and cost_m "
               0  sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
               0  IF( sigma < 0 ) [
               1      $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
               1  ]
               0
               0  " Now determine if we accept this new event "
               0  use_it = .true.;
               0  IF( sigma < fmax_array(i) ) [
               1      $RANDOMSET rnno;
               1      IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
               1  ]
               0  IF( use_it ) [       " Yes, event accepted "
               1      fmax_array(i) = sigma;
               1      eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
               1      eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
               1  ] ELSE [             " Nop, event rejected => use last accepted "
               1      eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
               1      eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
               1  ]
               0
               0  " We now have a set of random number accepted for sampling around "
               0  " the i'th bin energy. We need to recalculate all variables using "
               0  " the actual photon energy "
               0
               0  k = peig*prmi;
               0  aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
               0  qmin = 4*k/aux5; qmax = aux5/(2*k+1);
               0  pr = qmin*exp(eta_pr*log(qmax/qmin));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  sint_p = sqrt(1-cost_p*cost_p);
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $RANDOMSET phi; phi = phi*6.283185307179586;
               0  ppx = pp*sint_p; ppy = 0;
               0  pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
               0  cphi = cos(phi); sphi = sin(phi);
               0  tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
               0  tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
               0  ppz = pp*cost_p; pmz = pm*cost_m;
               0  prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
               0  " Set up particles on the stack ";
               0  " We always put the recoil electron on top (even if its energy is higher "
               0  " then the energies of the pair particles) because                       "
               0  "   - that way, we know which particle is the recoil  electron in case   "
               0  "     we want to score some quantity related to it                       "
               0  "   - its energy is, on average, lower than the pair particle energies   "
               0  NPold = np;
               0  $TRANSFER PROPERTIES TO (np)   FROM (np);
               0  $TRANSFER PROPERTIES TO (np+1) FROM (np);
               0  $TRANSFER PROPERTIES TO (np+2) FROM (np+1);
               0  pp = 1/pp; pm = 1/pm; pr = 1/pr;
               0  a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
               0  IF( sinpsi > 1e-20 ) [
               1      sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
               1      IF( Ep > Em ) [
               2          u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
               1      v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
               1      w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
               1  ] ELSE [
               1      IF( Ep > Em ) [
               2          u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
               2          iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
               2          iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
               2          iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
               2          iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
               1      iq(np) = -1; E(np) = Er*prm;
               1  ]
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE PHOTO;
               0  "******************************************************************"
               0  " Programmers:  I. Kawrakow, complete recoding,                    "
               0  "                            Fluorescent X-rays, Auger,            "
               0  "                            Coster-Kronig treated in RELAX        "
               0  "               A.F. Bielajew (NRC) photoelectric angular distn    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0
               0  data n_warning/0/;
               0
               0  IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  IF( peig < edge_energies(2,1) ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine PHOTO called with E = ',peig,
               2                     ' which is below the current min. energy of 1 keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  iZ = iedgfl(irl);
               0  do_relax = .false.;
               0  edep = pzero;
               0  IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
               1                             " first sample the element "
               1      IF( nne(medium) = 1 ) [
               2          iZ = int( zelem(medium,1) + 0.5 );
               2          DO j=1,edge_number(iZ) [
               3              IF( peig >= edge_energies(j,iZ) ) EXIT;
               3          ]
               2      ]
               1      ELSE [
               2          aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
               2          sigtot = 0;
               2          DO k=1,nne(medium) [
               3              iZ = int( zelem(medium,k) + 0.5 );
               3              IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                  $egs_info(*,' Error in PHOTO: ');
               4                  $egs_fatal(*,'   Atomic number of element ',k,
               4                     ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4              ]
               3              IF( peig > edge_energies(1,iZ) ) [
               4                  j = 1;
               4                  sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
               4                       edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
               4              ]
               3              ELSE [
               4                  DO j=2,edge_number(iZ) [
               5                      IF( peig >= edge_energies(j,iZ) ) EXIT;
               5                  ]
               4                  sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
               4                          gle*edge_d(j,iZ) ));
               4                  sigma = Exp(sigma);
               4              ]
               3              sigma = sigma * pz(medium,k);
               3              sigtot = sigtot + sigma;
               3              probs(k) = sigma;
               3              ints(k) = j;
               3          ]
               2          $RANDOMSET br; br = br*sigtot;
               2          DO k=1,nne(medium) [
               3              br = br - probs(k);
               3              IF( br <= 0 ) EXIT;
               3          ]
               2          iZ = int( zelem(medium,k) + 0.5 );
               2          j  = ints(k);
               2      ]
               1      " Now we know the atomic number (iZ) and the energy interval the "
               1      " photon energy is in (j). It is time to sample the shell the photon "
               1      " is interacting with. "
               1      " left for now as before, to be changed!!! "
               1      IF( peig <= binding_energies($MXSHELL,iZ) )
               1      [   "Outer shells, no atomic relaxation"
               2             "EADL relax: Below  M2-shell -> just emit e- "
               2             iq(np) = -1;
               2             e(np) = peig + prm;
               2      ]
               1      ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
               2          $RANDOMSET br;
               2          DO k=1,$MXINTER [
               3              IF( peig > binding_energies(k,iZ) ) [
               4                  IF( br < interaction_prob(k,iZ) ) EXIT;
               4                  br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
               4              ]
               3          ]
               2          "Interaction possible with any shell from k=1 to $MXSHELL"
               2          "Defaults to $MXSHELL interaction if DO loop completes"
               2          "****************"
               2          "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
               2          "**************** from previous EGSnrc approach as it doesn't"
               2          "                 generate e- nor x-rays from <M> and <N> shells."
               2          IF (eadl_relax & k > 4)[
               3             "No initial vacancy below L3 for now, just emit e-"
               3             iq(np) = -1;
               3             e(np) = peig + prm;
               3          ]
               2          ELSE["EADL:    Interacts with K,L1..L3 shells"
               3               "default: Interacts with K,L1..L3,<M>, and <N> shells"
               3             e_vac = binding_energies(k,iZ);
               3             e(np) = peig - e_vac + prm; do_relax = .true.;
               3             iq(np) = -1;
               3          ]
               2      ]
               1  ]
               0  ELSE [
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  "****************"
               0  "EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
               0  "**************** but vacancies below L3 deposit energy locally. It wont"
               0  "                 produce x-rays from <M> and <N> shells."
               0  "IF ($EADL_RELAX & k > 4)[
               0  "   edep = e_vac; do_relax = .false.;
               0  "]
               0  IF( do_relax ) [
               1      call relax(e_vac,k,iZ);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  subroutine egs_shellwise_photo;
               0  "******************************************************************"
               0  " Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
               0  " Shellwise implementation and      "
               0  "                                sampling optimizations            "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0  ;COMIN/PE-SHELL-DATA/;
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0  $REAL slope, logE, int_prob;
               0  $INTEGER zpos, ibsearch;
               0  data n_warning/0/;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  do_relax = .false.;
               0  IF( peig < $RELAX-CUTOFF ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
               2                      peig,' which is below the current min. energy of ',
               2                     $RELAX-CUTOFF,' keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  edep = pzero;
               0
               0  IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
               1                          " sample element and atomic shell for"
               1     j = -1;              " the interaction."
               1     IF( nne(medium) = 1 ) [
               2      iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
               2      IF( pe_nshell(zpos) > 0) [
               3        logE = log(peig);
               3        j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3      ]
               2     ]
               1     ELSE [
               2        $RANDOMSET br; logE = log(peig);
               2        "DO k=1,nne(medium) ["
               2        DO k=nne(medium),1,-1 [
               3            iz = int(pe_zsorted(k,medium)+0.5); zpos = pe_zpos(iZ);
               3            IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                $egs_info(*,' Error in egs_shellwise_photo: ');
               4                $egs_fatal(*,'   Atomic number of element ',k,
               4                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4            ]
               3            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3            slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
               3            slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               3            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
               3            br -= exp(int_prob);
               3            IF ( br <= 0 ) EXIT;
               3        ]
               2     ]
               1     " Now we know the atomic number (iZ) and the energy interval the "
               1     " photon energy is in (j). It is time to sample the shell the photon "
               1     " is interacting with. "
               1     IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
               1     [   "no atomic relaxation, create photo-electron"
               2           iq(np) = -1;
               2           e(np) = peig + prm;
               2     ]
               1     ELSE ["sample the shell the photon is interacting with"
               2        $RANDOMSET br; sigtot = 0;
               2        DO k=1,pe_nshell(zpos) [
               3            IF( peig > pe_be(zpos,k) ) [
               4              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
               4              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               4              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
               4              br -= exp(int_prob); sigtot += exp(int_prob);
               4              IF ( br <= 0 ) EXIT;
               4            ]
               3        ]
               2        IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
               3           iq(np) = -1;
               3           e(np) = peig + prm;
               3        ]
               2        ELSE[
               3           e_vac = pe_be(zpos,k);
               3           e(np) = peig - e_vac + prm; do_relax = .true.;
               3           iq(np) = -1;
               3        ]
               2     ]
               1  ]
               0  ELSE ["No atomic relaxations, just create photo-electron"
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  IF( do_relax ) [
               1      call egs_eadl_relax(iZ,k);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_read_shellwise_pe;
               0  "*************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-SHELLWISE-PE-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,l,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  $REAL      rest_xs($MXNE,$MXELEMENT);
               0  $REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
               0  $REAL      new_e($MXNE),deltaEb,slope;
               0  $INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
               0  character  data_dir*128,pe_sw_file*144;
               0
               0  $INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
               0  real*4    egs_read_real,e_r, e_old,sigma_r;
               0  integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
               0  $LOGICAL  is_open, is_there, shift_required;
               0
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0              ' M1',' M2',' M3',' M4',' M5',
               0              ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0
               0
               0
               0  $egs_info('(/a$)',
               0  ' Reading renormalized photoelectric cross sections ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';
               0
               0
               0  pe_sw_unit = egs_get_unit(0);
               0  IF( pe_sw_unit < 1 ) [
               1    $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
               1  ]
               0  open(pe_sw_unit,file=pe_sw_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=1,
               0       err=:no-pe-sw-file:);
               0  GOTO :read-pe-sw:;
               0  :no-pe-sw-file:
               0  $egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
               0             pe_sw_file);
               0  :read-pe-sw:
               0  is_open = .true.;
               0
               0
               0
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [
               2        pe_nshell(i*medio) = 0;
               2        pe_nge(i*medio) = 0;
               2        pe_zsorted(i,medio) = 0;
               2     ]
               1  ]
               0  DO l = 1,$MXELEMENT [
               1     pe_zpos(l) = -1;
               1     DO k = 1,$MXNE [
               2        pe_energy(k,l) = 0.0;
               2        DO m = 1,$MXPESHELL [
               3           pe_xsection(k,l,m) = 0.0;
               3        ]
               2     ]
               1     DO k = 1,$MXPESHELL [
               2        pe_be(l,k) = -99;
               2     ]
               1  ]
               0
               0
               0
               0
               0  curr_rec = 1; iZpos = 0;
               0  nz = egs_read_short(pe_sw_unit,curr_rec);
               0  "$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,medio-1 [
               3           DO k = 1, nne(j)[
               4             IF( iZ = pe_zsorted(k,j) ) [
               5                 is_there = .true.; EXIT;
               5             ]
               4           ]
               3        ]
               2        IF (is_there) NEXT;
               2        "Read data for this element"
               2        iZpos += 1; zread(iZpos) = iZ;
               2        pe_zpos(iZ) = iZpos;
               2        pos         = 3 + (iZ-1)*4;
               2        curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
               2        i_nge       = egs_read_short(pe_sw_unit,curr_rec);
               2        i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
               2        "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
               2        "  ' energy points and ',i_nshell,' shells');
               2        pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
               2        e_old = -1.0; ish = 0;
               2        DO j = 1,i_nge[
               3           e_r = egs_read_real(pe_sw_unit,curr_rec);
               3           sigma_r = egs_read_real(pe_sw_unit,curr_rec);
               3           pe_energy(j,iZpos) = e_r;
               3           pe_xsection(j,iZpos,0) = sigma_r;
               3           rest_xs(j,iZpos) = sigma_r;
               3           DO k = 1, i_nshell[
               4              sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
               4              pe_xsection(j,iZpos,k) = sigma_r;
               4              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;
               4
               4           ]
               3           "Extract binding energies from the data base"
               3           IF (e_r - e_old < 1e-15)[
               4              pe_be(iZpos,i_nshell-ish) = e_r;
               4              ish += 1;
               4           ]
               3           e_old = e_r;
               3
               3        ]
               2        "DO k = 1, i_nshell[
               2        "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
               2        "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
               2        "]
               2
               2     ]
               1  ]
               0  pe_ne = iZpos;
               0  "$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');
               0
               0
               0
               0
               0
               0
               0  "$egs_info(*,' Adjusting cross sections to new binding energies ...');
               0  DO i=1,pe_ne[
               1     iZ = zread(i);
               1     IF (pe_nshell(i) = 0)[
               2        DO j=1,pe_nge(i)[
               3           pe_energy(j,i) =  log(pe_energy(j,i));
               3        ]
               2        NEXT;
               2     ]
               1     "Shift energy scale for different binding energy sets"
               1     DO l=1,pe_nshell(i)[
               2        IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
               3             shift_required = .true.;
               3             deltaEb = binding_energies(l,iZ)-pe_be(i,l);
               3             "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
               3             "           'Eb_p_',labels(l),' = ',pe_be(i,l),
               3             "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
               3             "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
               3             "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
               3             "          );
               3        ]
               2        ELSE[shift_required =.false.;]
               2        is_there = .false.;
               2        DO j=1,pe_nge(i)[
               3           tmp_e(j,l)  = pe_energy(j,i);
               3           tmp_xs(j,l) = pe_xsection(j,i,l);
               3           IF ( shift_required &
               3                pe_energy(j,i) => pe_be(i,l) )[
               4              tmp_e(j,l) += deltaEb;
               4              "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
               4              "Determine edge position in energy array"
               4              IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               5                 ib(l) = j; is_there = .true.;
               5              ]
               4              "Update new energy grid"
               4              IF (l = 1)[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4              "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
               4              ELSE IF(j < ib(l-1))[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4           ]
               3        ]
               2        pe_be(i,l) = binding_energies(l,iZ);
               2     ]
               1     "Re-compute sub-shell xsections for new energy grid new_e"
               1     "Not needed for K shell"
               1     DO l=2,pe_nshell(i)[
               2        DO j=1,pe_nge(i)[
               3           IF ( new_e(j) >= pe_be(i,l-1) )[
               4              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
               4              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
               4              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = log(tmp_xs(m,l));
               4              pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
               4           ]
               3        ]
               2     ]
               1     "Re-compute total xsections for new energy grid new_e"
               1     "$egs_info(*,'-> Z = ',iZ);"
               1     DO j=1,pe_nge(i)[
               2        IF ( j < ib(pe_nshell(i)))[
               3           new_e(j) = pe_energy(j,i);
               3        ]
               2        m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
               2        slope = log(rest_xs(m+1,i)/rest_xs(m,i));
               2        slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
               2        pe_xsection(j,i,0)  = log(rest_xs(m,i));
               2        pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
               2        pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,0) += pe_xsection(j,i,l);
               3        ]
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0));
               2     ]
               1     "Normalize shell cross sections to total for sampling"
               1     "and update energy grid of ith element."
               1     " Prepare for log/log interpolation."
               1     DO j=1,pe_nge(i)[
               2        pe_energy(j,i) =  log(new_e(j));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
               3        ]
               2     ]
               1  ]
               0
               0  $egs_info('(a/)',' done');
               0
               0  IF( is_open ) close(pe_sw_unit);
               0  return;
               0  end;
               0
               0
               0  "******************************************************************"
               0  SUBROUTINE RELAX(energy,n,iZ);
               0  "******************************************************************"
               0  " Subroutine to fill a vacancy in shell n, element iZ              "
               0  " by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
               0  " Transitions between K,L1,L2,L3,average M,average N are taken into"
               0  " account. Particles with energies above the transport cut-offs    "
               0  " (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
               0  " particles is stored in EDEP.                                     "
               0  " In this version a global cut-off of 1 keV applies                "
               0  "  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
               0  "  1 keV will still be absorbed locally (due to lack of data)      "
               0  "                                                                  "
               0  " Version 1:  I. Kawrakow, December 1998                           "
               0  "******************************************************************"
               0  implicit none;
               0
               0  " Input variables "
               0  "================="
               0  $INTEGER n,iZ;
               0  $REAL    energy;  "
               0
               0  $declare_write_buffer;
               0
               0  " Local variables "
               0  "================="
               0  REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
               0                              "relaxation cascade                    "
               0
               0  $INTEGER vac_array($MXVAC), "array with shell vacancies            "
               0           n_vac,             "current number of vacancies           "
               0           shell;             "current shell                         "
               0  $INTEGER final,finala,      "code of final state                   "
               0           final1,final2,     "two vacancies in the final state in   "
               0                              "the case of Auger transitions         "
               0           iql,               "particle charge                       "
               0           irl;               "present region"
               0  $INTEGER first_transition($MXINTER),
               0           last_transition($MXINTER);
               0                              "first and last transition for a given "
               0                              "shell in the list of all possible     "
               0                              "transitions                           "
               0  $INTEGER final_state($MXTRANS);
               0             " final_state(i) is the final atomic state                "
               0             " after transition i coded as follows:                    "
               0             "   * fluorescence - final_state is the shell number      "
               0             "                    of the new vacancy                   "
               0             "   * Coster-Kronig - final_state is the shell number     "
               0             "                     of the new vacancy + 10             "
               0             "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
               0             "             are the shell numbers of the 2 new vacancies"
               0
               0  $INTEGER k, np_old, ip, iarg;
               0  $REAL    e_array($MXVAC),   "array with vacancy energies           "
               0           Ei,Ef,             "initial,final binding energies        "
               0           Ex,                "kinetic energy of emitted particle    "
               0           eta,               "a random number                       "
               0           e_check,           "energy conservation check             "
               0           min_E,ekcut,pkcut,elcut; "cut-off energies  "
               0
               0  $REAL    xphi,yphi,xphi2,yphi2,rhophi2,
               0           cphi,sphi;         "for azimuthal angle selection"
               0
               0  " Global EGS4 variables "
               0  "======================="
               0  $COMIN-RELAX;
               0  ;COMIN/RELAX-USER/;
               0
               0  data first_transition/1,20,27,33,38/;
               0  data last_transition/19,26,32,37,39/;
               0  data final_state/ "See the final_state definition above"
               0           4,3,5,6,                           " K-shell fluorescence    "
               0           202,302,402,404,403,303,           " K-shell Auger           "
               0           502,503,504,602,603,604,           " K-shell Auger           "
               0           505,605,606,                       " K-shell Auger           "
               0           13,14,                             " L1 Coster-Kronig        "
               0           5,6,                               " L1 fluorescence         "
               0           505,605,606,                       " L1 Auger                "
               0           14,                                " L2 Coster-Kronig        "
               0           5,6,                               " L2 fluorescence         "
               0           505,605,606,                       " L2 Auger                "
               0           5,6,                               " L3 fluorescence         "
               0           505,605,606,                       " L3 Auger                "
               0           6,                                 " M  fluorescence         "
               0           606/;                              " M  Auger                "
               0
               0  save first_transition,last_transition,final_state; "to avoid problems with "
               0                                                     "non-static compiler options"
               0
               0  IF (eadl_relax)[
               1     call egs_eadl_relax(iZ,n);
               1     return;
               1  ]
               0
               0  IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"
               0
               0  iz_relax = iZ;
               0  irl = ir(np);
               0  ekcut = ecut(irl)-rm; pkcut = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  IF( energy <= min_E ) [
               1      edep = edep + energy;  "We assume that edep is zeroed "
               1                          "(or set to the appropriate value) in the routine "
               1                          "calling RELAX "
               1      edep_local = energy;
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return;
               1  ]
               0
               0  " Set-up the array of vacancies for the relaxation cascade "
               0  n_vac = 1; vac_array(n_vac) = n; np_old = np;
               0  e_check = 0; e_array(n_vac) = energy;
               0
               0  :START: LOOP[     "Until no  >N-shell vacancies"
               1
               1      shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;
               1
               1      IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
               2          edep = edep + Ei;
               2
               2          edep_local = Ei;
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1
               1      "Set the relax_user common block variables, IK March 22 2004"
               1      ish_relax = shell; u_relax = Ei;
               1      IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
               2          IF( Ei > ekcut ) [
               3              np = np + 1;
               3              $CHECK-STACK(np,'RELAX');
               3              e(np) = Ei + prm; iq(np) = -1;
               3              $TRANSFER PROPERTIES TO (np) FROM (np-1);
               3              $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
               3              eta = (1-eta)*(1+eta);
               3              IF( eta > 1e-20 ) [
               4                  eta = Sqrt(eta);
               4                  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               4                  u(np) = eta*cphi; v(np) = eta*sphi;
               4              ]
               3              ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               3              $AUSCALL($AUGERTRA);
               3          ]
               2          ELSE             [
               3              edep = edep + Ei;
               3
               3              edep_local = Ei;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1      " Sample transition number for this vacancy "
               1      $RANDOMSET eta;
               1      DO k=first_transition(shell),last_transition(shell)-1 [
               2          eta = eta - relaxation_prob(k,iZ);
               2          IF( eta <= 0 ) EXIT;
               2      ]
               1      final = final_state(k); finala = final;
               1      IF( final < 100 ) [
               2          IF( final < 10 ) [ "fuorescence"
               3              iql = 0; elcut = pkcut;
               3          ]
               2          ELSE             [ "Coster-Kronig"
               3              final = final - 10;
               3              iql = -1; elcut = ekcut;
               3          ]
               2          Ef = binding_energies(final,iZ);
               2          Ex = Ei - Ef;
               2          n_vac = n_vac + 1;
               2          vac_array(n_vac) = final;
               2          e_array(n_vac) = Ef
               2      ]
               1      ELSE [  "Auger"
               2          final1 = final/100; final2 = final - final1*100;
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final1;
               2          e_array(n_vac) = binding_energies(final1,iZ);
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final2;
               2          e_array(n_vac) = binding_energies(final2,iZ);
               2          iql = -1;
               2          Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
               2          elcut = ekcut;
               2      ]
               1      IF( Ex <= elcut ) [ "Below cut-off"
               2          edep = edep + Ex;
               2
               2          IF( finala <  10 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ]
               2          ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ]
               1      ELSE [
               2          np = np + 1;
               2          $CHECK-STACK(np,'RELAX');
               2          iq(np) = iql;
               2          IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
               2          $TRANSFER PROPERTIES TO (np) FROM (np-1);
               2          $RANDOMSET eta;
               2          eta = 2*eta - 1;
               2          w(np) = eta;
               2          eta = (1-eta)*(1+eta);
               2          IF( eta > 1e-20 ) [
               3              eta = Sqrt(eta);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = eta*cphi;
               3              v(np) = eta*sphi;
               3          ]
               2          ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               2          IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
               2          ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
               2          ELSE                    [ $AUSCALL($AUGERTRA);  ]
               2      ]
               1  ]
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_init_relax;
               0  "*************************************************************************"
               0  " Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
               0  " data base was originally created by I. Kawrakow to be used with C++ user"
               0  " codes. It has been re-created using 4 bytes integers instead of using   "
               0  " optimized integer sizes to save space. It is now about 34% larger (760K)"
               0  " than before (557K). Reason for this was that some compilers need a switch"
               0  " to get it to read binary files on byte at a time. This would have been a"
               0  " nuisance for users when configuring the already complex system.         "
               0  "                                                                        "
               0  " The final relaxation state from radiative transitions assumes C-style  "
               0  " array indexing and hence needs to be increased by 1.                   "
               0  " Similarly, for non-radiative transitions, there is need to increase the"
               0  " codified value of the two electron states by 65. The reason is that the"
               0  " two transition states are encoded as 64*state1+state2. Because of the C"
               0  " style indexing, state1 and state2 must be increased by 1, increasing the"
               0  " above codified value by 65.                                            "
               0  "                                                                        "
               0  "Shell information for all media elements stored in one-dimensional arrays:"
               0  "                                                                        "
               0  " ish              => absolute shell index (1...shell_ntot)              "
               0  " shell_be(ish)    => shell binding energy                               "
               0  " shell_type(ish)  => shell type according to EADL notation              "
               0  " shell_Z(ish)     => Z of shell element                                 "
               0  " shell_num(ish)   =>  relative shell position within one element        "
               0  " shell_ntot       => total number of shells for all media elements      "
               0  " relax_first(ish) => initial absolute relaxation position               "
               0  " relax_ntran(ish) => number of transitions                              "
               0  " shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
               0  "                                                                        "
               0  "Transition information for all shells also stored in one-dimensional arrays:"
               0  "                                                                         "
               0  " transition index itran runs from 1...relax_ntot                         "
               0  " relax_prob(itran)  => transition probabilities                          "
               0  " relax_atbin(itran) => holds the alias indices                           "
               0  " relax_state(itran) => final relaxation state:                           "
               0  "                       radiative: relative shell position                "
               0  "                   non-radiative: relative position of shells(64*sh1+sh2)"
               0  "                                                                         "
               0  "                              Originally coded by IK in a standalone code"
               0  "                          Modified for use with EGSnrc by EMH, June 2011 "
               0  "                          Corrected bugs and commented by EMH, April 2012"
               0  "*************************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  character  data_dir*128,relax_file*144;
               0
               0  $INTEGER  ish,medio,iZ,ntran;
               0  $REAL     Ec, Pc, tmp, min_be, sumw,Ex;
               0  $LOGICAL  is_open, is_there;
               0  $REAL     wtmp($MAXTRANS);
               0  $INTEGER  itmp($MAXTRANS);
               0
               0  integer*4 pos, curr_rec, sh_eadl;
               0  integer*4 nz, nshell, tr_type;
               0  integer*4 ttype;
               0  real*4    be_r, prob_r;
               0
               0
               0  DO iZ=1,$MXELEMENT[
               1   DO k=1,$MXESHLL[
               2     shell_eadl(iZ,k) = -1;
               2   ]
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  min_be = $RELAX-CUTOFF;
               0  $egs_debug('(a)',' ************ relax_init **************** ');
               0  $egs_debug('(a,f10.7)',
               0          ' Minimum binding energy requiring relaxation data: ',min_be);
               0
               0
               0
               0
               0  $egs_info('(/a)',' Reading EADL relaxation data ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  relax_file = $cstring(data_dir) // 'relax.data';
               0
               0
               0  relax_unit = egs_get_unit(0);
               0  IF( relax_unit < 1 ) [
               1     $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
               1  ]
               0  open(relax_unit,file=relax_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
               0       err=:no-relax-file:);
               0  GOTO :read-relax:;
               0  :no-relax-file:
               0  $egs_fatal('(2a)','egs_init_relax: failed to open ',
               0             relax_file);
               0  :read-relax:
               0  is_open = .true.;
               0
               0
               0
               0  curr_rec = 1;
               0  read(relax_unit,rec=curr_rec) nz;
               0  "$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
               0  shell_ntot = 0;relax_ntot = 0;
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,shell_ntot [
               3           IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
               3        ]
               2        IF (is_there) NEXT;
               2        pos = iZ + 1;
               2        read(relax_unit,rec=pos) curr_rec;
               2        read(relax_unit,rec=curr_rec) nshell;
               2        IF( shell_ntot + nshell > $MAXSHELL ) [
               3           $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
               3                  shell_ntot + nshell,' (at least).',
               3                  ' Increase the parameter $MAXSHELL and retry ');
               3        ]
               2        $egs_info('(a,i3,a,i2,a)',
               2        '  Z = ',iZ,' has ',nshell,' shells');
               2        DO ish=shell_ntot+1,shell_ntot+nshell[
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) shell_type(ish);
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) ntran;
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;
               3
               3          shell_Z(ish) = iZ;
               3          shell_num(ish) = ish - shell_ntot;
               3          shell_eadl(iZ,shell_num(ish)) = ish;
               3          IF (binding_energies(shell_num(ish),iZ) > 0)[
               4             shell_be(ish) = binding_energies(shell_num(ish),iZ);
               4          ]
               3          ELSE IF( photon_xsections = 'epdl' )[
               4            "Use binding energies from relax.data below 1 keV"
               4             binding_energies(shell_num(ish),iZ) = shell_be(ish);
               4          ]
               3          DO k=1,ntran[
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) itmp(k);
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
               4
               4
               4
               4              IF (itmp(k)<64) [itmp(k) +=1;]
               4              ELSE            [itmp(k) += 65;]
               4          ]
               3          IF( shell_be(ish) < min_be ) [
               4              relax_first(ish) = -1;
               4              relax_ntran(ish) = -1;
               4          ]
               3          ELSE [
               4              sumw = 0;
               4              DO k=1,ntran [  sumw = sumw + wtmp(k); ]
               4              IF( sumw > 1 ) [
               5                  DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
               5              ]
               4              ELSE IF( sumw < 1 ) [
               5                  ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
               5              ]
               4              IF( relax_ntot + ntran > $MAXRELAX ) [
               5                 $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
               5                   relax_ntot + ntran,' (at least).',
               5                   ' Increase $MAXRELAX and retry ');
               5              ]
               4              relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
               4              call prepare_alias_histogram(ntran,wtmp,
               4                                   relax_atbin(relax_ntot+1));
               4              DO k=1,ntran [
               5                 j = relax_ntot + k;
               5                 relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
               5              ]
               4              relax_ntot = relax_ntot + ntran;
               4          ]
               3        ]
               2
               2        shell_ntot = shell_ntot + nshell;
               2
               2     ]
               1
               1  ]
               0  $egs_debug('(a,i4,a)',' There are ',
               0          shell_ntot,' shells in the list of shells ');
               0  $egs_info('(a/)',' ...... Done.');
               0
               0
               0  IF( is_open ) close(relax_unit);
               0  return;
               0
               0  stop;
               0  end;
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_warning('(3(a,f10.6),a,i2)',
            {  0         'Evac = ',Evac, ' Ef = ',Ef,
            {  0         "' Z = ',iZ,' Nvac = ',Nvac,"
            {  0         ' min_E = ', min_E,' iq = ',iqf);
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0  "***********************************************************************"
               0    subroutine egs_eadl_relax(iZ, shell_egs);
               0  "************************************************************************"
               0  " Subroutine, called from subroutine relax, to fill a vacancy in         "
               0  " shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
               0  " and Coster-Kronig electrons.  Uses EADL data.                          "
               0  " Results passed via variables in comins.                                "
               0  "   edep                                                                 "
               0  "   edep_local                                                           "
               0  "   e(np)                                                                "
               0  "                                                                        "
               0  " There are calls to ausgab with IARG values                             "
               0  "   24  A fluorescent transition just occurred                           "
               0  "   26  An Auger transition just occurred                                "
               0  "   32  Sub-threshold fluorescent transition just occurred               "
               0  "   33  Sub-threshold Auger transition just occurred                     "
               0  "                                                                        "
               0  " There is an inconsistency in the binding energies (BE) as COMPT uses   "
               0  " different BE (incoh.data)                                              "
               0  "                                                                        "
               0  " Explain need to reduce new_state by 1 below as alias sampling provides "
               0  " bin number from 1...nbin and not 0...nbin-1                            "
               0  "                                                                        "
               0  "                             Originally coded by IK in a standalone code"
               0  "                         Modified for use with EGSnrc by EMH, June 2011 "
               0  "                         Corrected bugs and commented by EMH, April 2012"
               0  "************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-EADL;
               0  ;COMIN/RELAX-USER/;
               0
               0  $REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
               0           cost,sint,cphi,sphi;
               0  "Ec      ecut as k.e. for current region"
               0  "Pc      pcut for current region"
               0  "min_E   the minimum energy for transitions to continue"
               0  "rnno    a random number"
               0  "Evac    binding energy of current vacancy"
               0  "Ef      the sum of the binding energies of the new vacancies"
               0  "Ef1     the first new binding energy of for non-radiative transitions"
               0  "Ef2     the second new binding energy of for non-radiative transitions"
               0  "Ex      the change in total binding energy"
               0  "Ecc     the cutoff energy (Ec or Pc)"
               0  "cost,sint,cphi,sphi variables for calculating particle direction"
               0
               0  $INTEGER  shell, shell_egs, iZ, iarg;
               0  "shell       number in master eadl list"
               0  "shell_egs   shell number in current element"
               0  "iZ          atomic number of element"
               0
               0  $INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
               0  "irl           current region"
               0  "vacs($MAXVAC) array of vacancy shell numbers"
               0  "nvac          current number of vacancies in vacs"
               0  "vac           shell number of current vacancy"
               0  "new_state     the state number that represents the new vacancy"
               0  "iqf           the charge of the emitted relaxation particle"
               0  "np_save       the stack index of the particle inducing in relaxations"
               0  "new1          the first new vacancy for non-radiative transitions"
               0  "new2          the second new vacancy for non-radiative transitions"
               0
               0  $INTEGER sample_alias_histogram;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  shell = shell_eadl(iZ,shell_egs);
               0  IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"
               0
               0  irl = ir(np);
               0  Ec = ecut(irl) - rm;
               0  Pc = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
               0  "store some information in comin RELAX-FOR-USER.  This just duplicates"
               0  "various pieces of info so the user can access them."
               0  rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
               0  rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
               0  rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
               0  rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
               0  rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
               0  "
               0  "Local energy deposition for vacancies below L3 shell."
               0  "Added here for consistency in algorithm for as long as"
               0  "<M> and <N> shells considered instead of proper shells."
               0  "AUSGAB call should be updated when charge of particle"
               0  "creating vacancy becomes available."
               0  IF (shell_egs > 4 & ~mcdf_pe_xsections) [
               1      edep = Evac;        "add energy of vacancy to edep"
               1      edep_local = Evac;  "set value of edep_local to energy of vacancy"
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
               1  ]
               0
               0  vac = shell; Nvac = 0; np_save = np;
               0  LOOP [ "from here to end of routine over all vacancies created"
               1
               1      "check if energy of vacancy < cutoff OR no transitions from this shell"
               1      IF( Evac < min_E | relax_ntran(vac) < 1 ) [
               2          edep += Evac;         "add energy of vacancy to edep"
               2          edep_local = Evac;    "set value of edep_local to energy of vacancy"
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
               2      ]
               1
               1      "prepare_alias_histogram is called from subroutine egs_init_relax and"
               1      "sample_alias_histogram uses the array of bin probabilities and bin"
               1      "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
               1      "to return the bin which has been sampled, i.e. new_state"
               1      "relax_ntran(vac) tells how many transitions are available"
               1      new_state = sample_alias_histogram(relax_ntran(vac),
               1                    relax_prob(relax_first(vac)),
               1                    relax_atbin(relax_first(vac)));
               1      IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
               2                            "EADL was < 1. In this case the entire energy is"
               2                            "given to an electron and no new vacancy is created"
               2          Ef = 0;
               2          iqf = -1;
               2          Ecc = Ec;
               2      ]
               1      ELSE[
               2          new_state = relax_state(relax_first(vac)+new_state-1);
               2          IF( new_state <= 64 ) [ "It was a radiative transition (fluorescence)"
               3            iqf = 0;
               3            new_state += vac - shell_num(vac);
               3            Ef = shell_be(new_state);
               3            Nvac += 1;
               3            vacs(Nvac) = new_state;
               3            Ecc = Pc;
               3          ] "end of fluorescence block"
               2          ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
               3            iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
               3            new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
               3            Ef1 = shell_be(new1); Ef2 = shell_be(new2);
               3            Nvac += 1; vacs(Nvac) = new1;
               3            Nvac += 1; vacs(Nvac) = new2;
               3            Ef = Ef1 + Ef2; Ecc = Ec;
               3          ] "end Auger or Coster-Kronig block"
               2      ]
               1      Ex = Evac - Ef;
               1      edep_local = 0;
               1      IF( Ex > Ecc ) [
               2          np += 1; $CHECK-RELAX-STACK(np,'new_relax');
               2          iq(np) = iqf;
               2          $TRANSFER PROPERTIES TO (np) FROM (np_save);
               2          $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
               2          IF( sint > 0 ) [
               3              sint = sqrt(sint);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
               3          ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
               2          rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
               2          rfu_E = shell_be(vac);
               2          IF( iqf = 0 ) [
               3              e(np) = Ex; $AUSCALL($FLUORTRA);
               3          ]
               2          ELSE [
               3              e(np) = Ex + rm; $AUSCALL($AUGERTRA);
               3          ]
               2      ] ELSE [ "Ex <= Ecc"
               2          edep += Ex;
               2
               2          IF( iqf = 0 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ] ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ] "end Ex <= Ecc block"
               1      :VACANCY:;
               1      IF( Nvac = 0 ) EXIT;
               1      "get next vacancy to process"
               1      vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
               1  ] "end of main loop"
               0  return;
               0  end;
               0  ;
               0
               0  "***************************************************************************"
               0  "     Triplet production stuff                                              "
               0  "***************************************************************************"
               0
               0  REPLACE {$N_TRIPLET_DATA} WITH {55}
               0  REPLACE {$N_ELEMENT} WITH {100}
               0  ;
               0  subroutine init_triplet;
               0  implicit none;
               0  $declare_max_medium;
               0  $COMIN-INIT-TRIPLET;
               0  $REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
               0         sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
               0         sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
               0         as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
               0         ds($N_TRIPLET_DATA);
               0  character*128  triplet_data_file;
               0  $INTEGER want_triplet_unit, triplet_unit, triplet_out;
               0  $INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
               0  $REAL    logE, f_new, f_old, spline;
               0
               0  IF( itriplet = 0 ) return;
               0  $set_string(triplet_data_file,' ');
               0  triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
               0                      'triplet.data';
               0  want_triplet_unit = 63;
               0  triplet_unit = egs_get_unit(want_triplet_unit);
               0  IF( triplet_unit < 1 ) [
               1      $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
               1  ]
               0  open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
               0  $egs_info('(a,$)',' init_triplet: reading triplet data ... ');
               0  read(triplet_unit,*) ntrip;
               0  IF( ntrip > $N_TRIPLET_DATA ) [
               1      $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
               1  ]
               0  read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
               0  DO iel=1,$N_ELEMENT [
               1      read(triplet_unit,*);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_pair(iel,i),i=1,ntrip);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_triplet(iel,i),i=1,ntrip);
               1  ]
               0  $egs_info(*,'OK');
               0  ifirst = 0;
               0  DO i=1,ntrip [
               1      IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
               1      energies(i) = log(energies(i));
               1  ]
               0  log_4rm = log(4*rm);
               0  energies(ifirst-1) = log_4rm;
               0  dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
               0  dli_triplet = 1/dl_triplet;
               0  bli_triplet = 1 - log_4rm/dl_triplet;
               0
               0  DO imed = 1, nmed [
               1
               1      $egs_info('(a,i3,a,$)',
               1        '   Preparing triplet fraction data for medium ',imed,' ... ');
               1      iz1 = zelem(imed,1) + 0.1;
               1      DO i=1,ntrip [
               2          sigp(i) = pz(imed,1)*sig_pair(iz1,i);
               2          sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
               2          DO iel=2,nne(imed) [
               3              izi = zelem(imed,iel) + 0.1;
               3              sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
               3              sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
               3          ]
               2      ]
               1
               1      DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
               1      f_triplet(1) = 0;
               1      call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);
               1
               1      logE = log_4rm; f_old = 0;
               1      DO i=1, $MAX_TRIPLET-1 [
               2          logE = logE + dl_triplet;
               2          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
               2          a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
               2          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
               2          f_old = f_new;
               2      ]
               1      $egs_info(*,'OK');
               1
               1  ]
               0  close(triplet_unit);
               0  return;
               0
               0  :no-triplet-file:;
               0  $egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
               0               triplet_data_file(:lnblnk1(triplet_data_file)));
               0
               0  :error_triplet_data:;
               0  $egs_fatal(*,' init_triplet: error while reading triplet data ');
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE EDGSET(NREGLO,NREGHI);
               0  "******************************************************************"
               0  " SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
               0  " and proper handling of photo-electric absorption
               0  "******************************************************************"
               0  " Programmer:   I. Kawrakow, (NRC)                                 "
               0  "******************************************************************"
               0  "                                                                  "
               0  "  Input:  NREGLO and NREGHI, not needed but left there for        "
               0  "                             compatibility with older user codes  "
               0  "
               0  "  This routine is called from HATCH, it checks whether one of the "
               0  "  elements of IEDGFL has been set to an integer number between    "
               0  "  1 and 100 and if so reads in photo-absorption and relaxation    "
               0  "  data. Note that the array IEDGFL, which used to be the          "
               0  "  `effecvtive' atomic number of a medium is not used for any      "
               0  "  purpose other than to indicate that relaxations are requested   "
               0  "  (if non-zero).
               0  "******************************************************************"
               0  "                                                                  "
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EDGE,X-OPTIONS,EGS-IO/;
               0
               0  "Input variables"
               0  integer  NREGLO,NREGHI;
               0
               0  $INTEGER i,j,k,jj,iz;
               0  logical  do_relax;
               0  logical  got_data;
               0  save     got_data;
               0  data     got_data/.false./;
               0
               0  IF( got_data ) return;
               0     "EDGSET is now called from HATCH. In older user codes it was called
               0     "from within the user code. If this happens, and the data is already
               0     "available, we don't need to read it again. That's why the above
               0     "statement.
               0
               0  $egs_info('(a/,a)',
               0            'Output from subroutine EDGSET:',
               0            '==============================');
               0
               0  $need_relaxation_data(do_relax);
               0  IF( ~do_relax ) [
               1
               1      IF(eadl_relax)[
               2          $egs_fatal('(a,/a)',
               2                     'You must turn ON atomic relaxations when requesting',
               2                     'detailed atomic relaxation (eadl_relax=true)!');
               2      ]
               1      $egs_info('(a/)',' Atomic relaxations not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(a/)',' Atomic relaxations requested! ');
               0
               0  $egs_info('(a$)',' Reading simplified photo-absorption data .....');
               0
               0  got_data = .true.;
               0  rewind($PHOTOUNIT);
               0
               0  DO i=1,$MXELEMENT
               0  [
               1      IF (eadl_relax)[
               2         "Skip, using binding_energies from *_photo.data file
               2         read($PHOTOUNIT,*);
               2      ]
               1      ELSE[
               2         read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
               2         DO k=1,$MXSHELL [
               3            binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
               3         ]
               2      ]
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT
               0  [
               1      read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
               1      interaction_prob($MXSHELL,i)=1.01;
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  $egs_info('(/a$)',' Reading simplified relaxation data .....');
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
               1  ]
               0  $egs_info('(a)',' Done');
               0  $egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
               0  rewind($PHOCSUNIT);
               0  DO i=1,$MXELEMENT [
               1      read($PHOCSUNIT,*) j,edge_number(i);
               1      DO j=1,edge_number(i) [
               2          read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
               2                             edge_d(j,i),edge_energies(j,i);
               2      ]
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  IF (eadl_relax)[
               1   call egs_init_relax;
               1  ]
               0
               0  RETURN;
               0  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PHOTON(IRCODE);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE; "1 => normal return"
               0
               0  $COMIN-PHOTON;   "default replacement produces the following:
               0                   "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
               0                   "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PHOTON;
               0
               0
               0  IRCODE=1;"set up normal return"
               0  PEIG=E(NP);
               0  EIG=PEIG; "energy of incident gamma"
               0  IRL=IR(NP);
               0  $start_new_particle;
               0
               0  IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               0
               0  :PNEWENERGY:
               0  LOOP["enter this loop for each photon with new energy"
               1
               1  IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"
               1
               1  GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"
               1
               1  "   here to sample no. mfp to transport before interacting"
               1
               1  $SELECT-PHOTON-MFP;
               1  " DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
               1  "                                      DPMFP=-LOG(RNNO35);"
               1  "NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
               1  "       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."
               1
               1  IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"
               1
               1  :PNEWMEDIUM:
               1  LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
               2  IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
               3  $EVALUATE GMFPR0 USING GMFP(GLE);]
               2
               2  :PTRANS:
               2  LOOP["PHOTON TRANSPORT LOOP"
               3  IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
               3  ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
               4  GMFP=GMFPR0/RHOF;
               4  $RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
               4  "Ali:photonuc, 1 line"
               4  $PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
               4  TSTEP=GMFP*DPMFP;]
               3  "   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
               3  IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
               3  IDISC=0;"ASSUME PHOTON NOT DISCARDED"
               3  USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
               3  TUSTEP=USTEP;
               3
               3  "IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
               3  $CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"
               3
               3
               3  "   NOW CHECK FOR USER DISCARD REQUEST"
               3  IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
               4  GO TO :USER-PHOTON-DISCARD:;]
               3
               3  VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
               3  TVSTEP=VSTEP;
               3  EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"
               3
               3  x_final = x(np) + u(np)*vstep;
               3  y_final = y(np) + v(np)*vstep;
               3  z_final = z(np) + w(np)*vstep;
               3
               3  $AUSCALL($TRANAUSB);
               3
               3  "   TRANSPORT THE PHOTON"
               3  x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3  DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
               3  IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
               3  IROLD=IR(NP); "SAVE PREVIOUS REGION"
               3
               3  MEDOLD=MEDIUM;
               3  IF (IRNEW.NE.IROLD) ["REGION CHANGE"
               4    $photon_region_change;
               4  ]
               3
               3  "   AFTER TRANSPORT CALL TO USER"
               3  $AUSCALL($TRANAUSA);
               3  "oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
               3  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               3
               3  "   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
               3  "   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
               3  IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;
               3
               3  IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;
               3
               3  IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
               4  EXIT :PNEWMEDIUM:;]
               3  ]REPEAT ":PTRANS: LOOP"
               2
               2  ]REPEAT ":PNEWMEDIUM: LOOP"
               1
               1
               1  "   IT IS FINALLY TIME TO INTERACT."
               1  "   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
               1  $RAYLEIGH-SCATTERING;
               1  "Ali:photonuclear, 1 line"
               1  $PHOTONUCLEAR;
               1  $RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
               1  "   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
               1  $EVALUATE GBR1 USING GBR1(GLE);
               1  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
               2      $AUSCALL($PAIRAUSB);
               2      CALL PAIR;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PAIR;
               2      $AUSCALL($PAIRAUSA);
               2      IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
               2      ELSE [ "this may happen if pair electrons killed via Russian Roulette"
               3          goto :PAIR-ELECTRONS-KILLED:;
               3      ]
               2  ]
               1  "GBR2=(PAIR+COMPTON)/GTOTAL"
               1  $EVALUATE GBR2 USING GBR2(GLE);
               1  IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
               2      $AUSCALL($COMPAUSB);
               2      CALL COMPT;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-COMPT;
               2      $AUSCALL($COMPAUSA);
               2      IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
               2  ]
               1  ELSE["IT WAS PHOTOELECTRIC EFFECT"
               2      $AUSCALL($PHOTOAUSB);
               2      CALL PHOTO;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PHOTO;
               2      IF (NP = 0 | NP < NPOLD ) [RETURN;]
               2        "The above may happen if Russian Roulette is on"
               2        "NP<NPOLD means that only electrons were created in the interaction"
               2        "and that all of them were killed. Hence, the top particle on the "
               2        "stack is from a previous interaction and may be in another region"
               2        "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
               2        "a return to shower so that ELECTR or PHOTON are properly re-entered."
               2        "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
               2        "wrong dose with brems splitting and Russian Roulette on in a low "
               2        "energy calculation."
               2
               2      $AUSCALL($PHOTOAUSA);
               2      IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
               2  ] "END OF PHOTO ELECTRIC BLOCK"
               1
               1  :PAIR-ELECTRONS-KILLED:
               1
               1  "   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
               1  PEIG=E(NP);
               1  EIG=PEIG;
               1  IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
               1  ]REPEAT ":PNEWENERGY: LOOP"
               0
               0  "   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "PHOTON CUTOFF ENERGY DISCARD SECTION         "
               0  "---------------------------------------------"
               0  :PCUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
               1  ] ELSE [ IDR=$EGSCUTAUS; ]
               0  EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
               0  $PHOTON-TRACK-END;
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "User requested photon discard section        "
               0  "---------------------------------------------"
               0  :USER-PHOTON-DISCARD:
               0  EDEP=PEIG;
               0  $AUSCALL($USERDAUS);
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "END OF SUBROUTINE PHOTON"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  $REAL EI,      "initial shower energy"
               0        XI,YI,ZI,"initial co-ordinates"
               0        UI,VI,WI,"initial direction cosines"
               0        WTI;     "initial weight"
               0
               0  $INTEGER
               0        IQI,     "initial particle charge"
               0        IRI;     "initial region number"
               0
               0  "Local variables"
               0  DOUBLE PRECISION
               0        DEG,    "energy for pi-zero option"
               0        DPGL,   "angle factor for pi-zero option"
               0        DEI,    "incident energy for pi-zero option"
               0        DPI,    "intermediate factor for pi-zero option"
               0        DCSTH,  "random number for pi-zero option"
               0        DCOSTH, "cos(theta) for pi-zero option"
               0        PI0MSQ; "pi-zero mass squared (in MeV**2)"
               0
               0  $REAL DNEARI, "initial distance to closest boundary"
               0        CSTH;   "random number for pi-zero option"
               0
               0  $INTEGER
               0        IRCODE; "status returned by ELECTR or PHOTON"
               0
               0  DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"
               0
               0  NP=1; NPold = NP;      "Set the old stack counter"
               0  DNEARI=0.0;
               0  IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
               0  $TRANSFER PROPERTIES TO (1) FROM I;
               0
               0  IF (IQI = 2) ["PI-ZERO OPTION"
               1    "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
               1    "                  noted by      Dr.  Muroyama at Nagoya University
               1    IF(EI**2 <= PI0MSQ) [
               2       $egs_fatal('(//a/,a,g15.5,a)',
               2       ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
               2       ' but the total energy was too small (EI=',EI,' MeV)');
               2    ]
               1    $RANDOMSET CSTH;
               1    DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
               1    DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(1)=0; E(1)=DEG/2.;
               1    CALL UPHI(2,1);
               1    NP=2;
               1    DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(2)=0; E(2)=DEG/2.;
               1    CALL UPHI(3,2);
               1  ]"end of pi-zero option"
               0
               0  LOOP [
               1      ;
               1      IF( np <= 0 ) EXIT;
               1      IF( iq(np) = 0 ) [ call photon(ircode); ]
               1      ELSE             [ call electr(ircode); ]
               1
               1  ]
               0
               0  RETURN;
               0  "end of subroutine shower"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE UPHI(IENTRY,LVL);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
               0  "   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
               0  "   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
               0  "   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  integer  IENTRY,LVL; "entry switches"
               0
               0  "Local variables"
               0  $REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
               0        RNNO38, "random number for azimuthal angle selection"
               0        PHI,    "azimuthal scattering angle"
               0        CPHI,   "5/2*pi-PHI"
               0        A,B,C,  "direction cosines before rotation"
               0        SINPS2, "SINPS2=A*A+B*B"
               0        SINPSI, "Sqrt(SINPS2)"
               0        US,VS,  "x- and y- component of scattering vector"
               0        SINDEL,COSDEL;
               0                "aux. variables for the rotation algorithm"
               0
               0  $INTEGER
               0        IARG,   "index for AUSGAB"
               0        LPHI,LTHETA,LCTHET,LCPHI;
               0                "indeces for sine table"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0  save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;
               0
               0  $AUSCALL($UPHIAUSB);
               0  GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
               0  "   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;
               0
               0  :UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
               0          "TABLE LOOK-UP"
               0  $SET INTERVAL THETA,SINC;
               0  $EVALUATE SINTHE USING SIN(THETA);
               0  CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
               0  $EVALUATE COSTHE USING SIN(CTHET);
               0
               0  "   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
               0  "   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
               0  "   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
               0  "   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "
               0
               0  :UPHI2:;
               0
               0  " It is much faster to use the box method for azimuthal angle selection"
               0  " than the following                                                   "
               0  " $RANDOMSET RNNO38;
               0  " PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
               0  " $EVALUATE SINPHI USING SIN(PHI);
               0  " CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
               0  " $EVALUATE COSPHI USING SIN(CPHI);
               0  $SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);
               0
               0  "   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
               0  "   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
               0  "   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
               0  "   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
               0  "   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
               0  "   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
               0  "   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
               0  "   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
               0  "   SO THAT IT CAN BE USED ON BOTH CALLS."
               0
               0  "   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
               0  "   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
               0  "   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
               0  "   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."
               0
               0  :NRK:
               0  GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
               0  "   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;
               0
               0  :OLD-PARTICLE:
               0  A=U(NP);B=V(NP);C=W(NP);
               0  GO TO :ADJUST:;
               0
               0  :BREMS-GAMMA:
               0  A=U(NP-1);B=V(NP-1);C=W(NP-1);
               0
               0  :NEW-PARTICLE:
               0  $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
               0
               0  "   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
               0  "   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
               0  "   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "
               0
               0  :ADJUST:
               0  SINPS2=A*A+B*B;
               0  "   If SINPS2 is small, no rotation is needed    "
               0  IF (SINPS2.LT.1.0E-20)["small polar angle case"
               1     U(NP)=SINTHE*COSPHI;
               1     V(NP)=SINTHE*SINPHI;
               1     W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
               1  ] "end small polar angle case"
               0  ELSE["large polar angle case"
               1     SINPSI=SQRT(SINPS2);
               1     US=SINTHE*COSPHI;
               1     VS=SINTHE*SINPHI;
               1     SINDEL=B/SINPSI;
               1     COSDEL=A/SINPSI;
               1     U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
               1     V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
               1     W(NP)=-SINPSI*US+C*COSTHE;
               1  ]"end large polar angle case"
               0
               0  $AUSCALL($UPHIAUSA);
               0
               0  RETURN;
               0
               0  :ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
               0  $egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);
               0
               0  "END OF SUBROUTINE UPHI"    END;
               0
               0  ;
1              0  %E
               0  "*************************************************************************
               0  "
               0  " The following is a set of macros and subroutines that implement
               0  " bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
               0  " (which are the basis for ICRU radiative stopping powers, into the
               0  " EGSnrc environment) or the NRC cross sections, which are essentially
               0  " the same as NIST, but with corrections to the electron-electron
               0  " contribution (corrections are only significant for low values of
               0  " atomic number Z and low values of the emitted photon energy k.
               0  "
               0  " In order to use it, you have to `turn on' this option by
               0  " setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
               0  " original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
               0  " data (nrc_brems.data).
               0  "
               0  " If this option is turned on, subroutine HATCH will call
               0  " subroutine init_nist_brems.
               0  " In init_nist_brems the NIST cross sections are read in,
               0  " total bremsstrahlung cross sections are calculated using
               0  " 64 point Gauss-Legendre quadrature, the interpolation arrays
               0  " that are used for total cross sections and brems fraction interpolations
               0  " (esig0, esig1, ebr10, ebr11               for electrons)
               0  " (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
               0  " are updated and alias sampling tables for rapid sampling of brems
               0  " energies are created. These alias sampling tables are then used
               0  " during the simulation in subroutine BREMS.
               0  " Be aware that there is a slight inconsistency when using this option
               0  " as resttricted radiative stopping powers used are the ones coming
               0  " from PEGS and so, they are calculated using Bethe-Heitler.
               0  " This will not matter at all if
               0  "   - AP is much smaller than the electron energy
               0  "       and/or
               0  "   - the restricted radiative stopping power is much smaller
               0  "     then the restricted collision stopping power
               0  " Both conditions are usually satisfied.
               0  "
               0  " I. Kawrakow, NRC, January 2000.
               0  "
               0  " Added NRC brems cross-sections
               0  " F. Tessier, NRC, August 2007.
               0  "
               0  "****************************************************************************
               0
               0  subroutine init_nist_brems;
               0  "**************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL    energy_array($MXBREN),x_array($MXBRXX),
               0           cs_array($MXBREN,$MXBRXX,$MXBREL);
               0  $REAL    xi_array($MXBRXX);
               0  real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);
               0
               0  $INTEGER nmix,kmix,i,n,k,j,ii;
               0  $INTEGER ngauss,i_gauss;
               0  $INTEGER lnblnk1,egs_get_unit;
               0  $INTEGER ifirst,ilast,nener,neke,leil;
               0
               0  $REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
               0  $REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
               0  $REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
               0  $REAL    Z,sumA;
               0  $REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
               0  $REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
               0           sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
               0  $INTEGER iz;
               0  $REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
               0  $INTEGER ndat,k_max_error;
               0  character tmp_string*512, tmp1_string*512;
               0  integer  itmp;
               0
               0  $declare_write_buffer;
               0
               0  $REAL amu;
               0  parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
               0                                "to cm^2/g"
               0  $LOGICAL ex,is_opened;
               0  $declare_max_medium;
               0  $COMIN-INIT-NIST-BREMS;
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  IF( ibr_nist = 1 ) [
               1      $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE [
               1      $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
            '  1      ibr_nist = ', ibr_nist);
               1  ]
               0
               0  "Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
               0  "
               0  rewind($NIST-DATA-UNIT);
               0  read($NIST-DATA-UNIT,*);
               0  read($NIST-DATA-UNIT,*) nmix,kmix;
               0  IF (kmix > $MXBRXX) [
               1      $egs_fatal(*,' init_nist_brems: to many k values in data file!');
               1  ]
               0  IF (nmix > $MXBREN) [
               1      $egs_fatal(*,' init_nist_brems: to many T values in data file!');
               1  ]
               0
               0  read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
               0  DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
               0  read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
               0  read($NIST-DATA-UNIT,*);
               0  DO i=1,$MXBREL [
               1      read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
               1  ]
               0  close($NIST-DATA-UNIT);
               0
               0  DO k=1,kmix [
               1      xi_array(k)=Log(1-x_array(k)+1e-6);
               1      IF( fool_intel_optimizer ) [
               2          $egs_info(*,'xi_array(k): ',xi_array(k));
               2      ]
               1  ]
               0
               0  "Get abscissas and weights for Gauss-Legendre quadrature"
               0  "
               0  ngauss = $MXGAUSS;
               0  call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);
               0
               0  "Calculate total brems cross sections and sampling tables"
               0  "for all media                                           "
               0
               0  $egs_info(*,' ');
               0  IF (ibr_nist = 1) [
               1  $egs_info(*,'Using NIST brems cross sections! ');
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $egs_info(*,'Using NRC brems cross sections! ');
               1  ]
               0  $egs_info(*,' ');
               0  DO medium=1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      $egs_info(*,' Initializing brems data for medium ',medium,'...');
               1      emin = max(ae(medium) - rm, ap(medium));
               1      DO i=1,nmix [
               2          IF( energy_array(i) >= emin ) EXIT;
               2      ]
               1      ifirst = i;
               1      DO i=nmix,1,-1 [
               2          IF( energy_array(i) < ue(medium) - rm ) EXIT;
               2      ]
               1      ilast = i+1;
               1      IF( ifirst < 1 | ilast > nmix ) [
               2          $egs_info(*,' init_nist_brems: data available only for ');
               2          $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
               2          $egs_info(*,' will use spline interpolations to get cross ');
               2          $egs_info(*,' sections beyond the available data but this may');
               2          $egs_info(*,' produce nonsense!');
               2          IF( ifirst < 1 ) ifirst=1;
               2          IF( ilast > nmix ) ilast = nmix;
               2      ]
               1      DO i=ifirst,ilast [
               2          ii = i+1 - ifirst;
               2          ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
               2          sumA = 0;
               2          DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
               2          sumA = sumA*amu;
               2          DO k=1,kmix [
               3              cs(ii,k) = 0;
               3              DO j=1,NNE(medium) [
               4                  Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
               4                  cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
               4              ]
               3              csx(k) = Log(cs(ii,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " Integrate
               2          "
               2          cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
               2          DO i_gauss = 1,ngauss [
               3              xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
               3              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               3              cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
               3          ]
               2      ]
               1      nener = ilast - ifirst + 1;
               1      call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
               1      "
               1      " Now replace the PEGS cross sections "
               1      "
               1      neke = meke(medium);
               1      sigee = 1E-15; sigep = 1E-15;
               1      DO i = 1,neke [
               2          eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
               2          leil = i;
               2          beta2 = ei*(ei+2*rm)/(ei+rm)**2;
               2          IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
               2          ELSE [
               3              sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
               3              sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
               3          ]
               2          $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
               2          $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
               2                                           " then the brems cross section "
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( i > 1 ) [
               3              si_esig = si1_esig;
               3              si_ebr1 = si1_ebr1;
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3              esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
               3              esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
               3              ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
               3              ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3          ]
               2
               2          "
               2          " Positrons "
               2          "
               2          $EVALUATE sigt USING psig(eil);
               2          $EVALUATE ebr1 USING pbr1(eil);
               2          $EVALUATE ebr2 USING pbr2(eil);
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( ebr2 > 1 ) ebr2 = 1;
               2          IF( ebr2 < 0 ) ebr2 = 0;
               2          sig_bhabha = sigt*(ebr2 - ebr1);
               2          IF( sig_bhabha < 0 ) sig_bhabha = 0;
               2          IF( i > 1 ) [
               3              si_psig = si1_psig;
               3              si_pbr1 = si1_pbr1;
               3              si_pbr2 = si1_pbr2;
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3              psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
               3              psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
               3              pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
               3              pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
               3              pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
               3              pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3          ]
               2          $EVALUATE ededx USING ededx(eil);
               2          sige = si1_esig/ededx;
               2          IF( sige > sigee ) sigee = sige;
               2          $EVALUATE ededx USING pdedx(eil);
               2          sige = si1_psig/ededx;
               2          IF( sige > sigep ) sigep = sige;
               2      ]
               1      esig1(neke,medium) = esig1(neke-1,medium);
               1      esig0(neke,medium) = esig0(neke-1,medium);
               1      ebr11(neke,medium) = ebr11(neke-1,medium);
               1      ebr10(neke,medium) = ebr10(neke-1,medium);
               1      psig1(neke,medium) = psig1(neke-1,medium);
               1      psig0(neke,medium) = psig0(neke-1,medium);
               1      pbr11(neke,medium) = pbr11(neke-1,medium);
               1      pbr10(neke,medium) = pbr10(neke-1,medium);
               1      pbr21(neke,medium) = pbr21(neke-1,medium);
               1      pbr20(neke,medium) = pbr20(neke-1,medium);
               1      $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
               1      esig_e(medium) = sigee; psig_e(medium) = sigep;
               1      IF( sigee > esige_max ) esige_max = sigee;
               1      IF( sigep > psige_max ) psige_max = sigep;
               1
               1      "
               1      " Now prepare the arrays for brems sampling
               1      "
               1      nb_emin(medium) = energy_array(ifirst);
               1      IF( nb_emin(medium) <= ap(medium) ) [
               2          nb_emin(medium) = energy_array(ifirst+1);
               2      ]
               1      nb_emax(medium) = energy_array(ilast);
               1      nb_lemin(medium) = log(nb_emin(medium));
               1      nb_lemax(medium) = log(nb_emax(medium));
               1      nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
               1      nb_dlei(medium) = 1/nb_dle(medium);
               1      "
               1      eil = nb_lemin(medium) - nb_dle(medium);
               1      DO i=1,$MXBRES [
               2          eil = eil + nb_dle(medium); ei = exp(eil);
               2          DO ii=1,nener [
               3              IF( ei < ee(ii) ) EXIT;
               3          ]
               2          ii = ii-1;
               2          IF( ii < 1) ii = 1;
               2          IF( ii > nener-1 ) ii = nener-1;
               2          "
               2          " ple and qle are energy interpolation coefficients
               2          "
               2          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
               2          DO k=1,kmix [
               3              csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " fill the abscissas for this energy
               2          "
               2          x = ap(medium)/ei; aux = -log(x);
               2          xi = log(1 - x+1e-6);
               2          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               2          nb_xdata(0,i,medium) = 0;
               2          nb_fdata(0,i,medium) = exp(res);
               2
               2          DO k=1,kmix [
               3              IF( x_array(k) > x ) EXIT;
               3          ]
               2          IF( k > kmix ) k = kmix;
               2          ndat = 0;
               2          DO j=k+1,kmix-1 [
               3              ndat = ndat+1;
               3              nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
               3              nb_fdata(ndat,i,medium) = exp(csx(j));
               3              IF( fool_intel_optimizer ) [
               4                  $egs_info(*,'nb_xdata(ndat,i,medium): ',
               4                          nb_xdata(ndat,i,medium));
               4              ]
               3          ]
               2          ndat = ndat+1;
               2          nb_xdata(ndat,i,medium) = 1;
               2          nb_fdata(ndat,i,medium) = exp(csx(kmix));
               2          "
               2          " Now expand the arrays by filling intermediate points
               2          " at the positions that show the maxium relative error
               2          " when using linear interpolation in x.
               2          " If arrays were allocated dynamically one could use
               2          " a certain condition to stop the iteration but in our case
               2          " memory is allocated anyway and so we use the maximum
               2          " space provided
               2          "
               2          IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
               2          LOOP [
               3              x_max_error = 0; f_max_error = 0; k_max_error = 0;
               3              max_error = 0;
               3              DO k=0,ndat-1 [
               4                  x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
               4                  f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
               4                  xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
               4                  res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               4                  res = exp(res);
               4                  error = abs(1-f/res);
               4                  IF( error > max_error ) [
               5                      x_max_error = x;
               5                      f_max_error = res;
               5                      max_error = error;
               5                      k_max_error = k;
               5                  ]
               4              ]
               3              ndat = ndat+1;
               3              DO k=ndat,k_max_error+2,-1 [
               4                  nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
               4                  nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
               4              ]
               3              nb_xdata(k_max_error+1,i,medium) = x_max_error;
               3              nb_fdata(k_max_error+1,i,medium) = f_max_error;
               3          ] UNTIL (ndat = $MXBRXS);
               2
               2          :SKIP-LOOP:
               2          "
               2          " Now generate the alias tables for rapid brems sampling
               2          " during run time
               2          "
               2          call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               2                 nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));
               2
               2      ]
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,' ');
               0  return;
               0  " Errors "
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0  return;
               0  end;
               0
1              0  %E
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine init_nrc_pair;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  character     nrcp_file*256, endianess*4;
               0  integer       egs_get_unit;
               0  $INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
               0  $INTEGER      i, lnblnk1;
               0  $REAL         tmp, ddx, xx, Z;
               0  real*4        emin, emax;
               0  integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
               0  REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
               0  character     endian, cdum($cdum_size);
               0  $LOGICAL      swap;
               0  real*4        tmp_4, tarray($NRC-PAIR-NXX);
               0  integer*4     itmp_4;
               0  character     c_4(4), ic_4(4);
               0  equivalence   (tmp_4,c_4), (itmp_4, ic_4);
               0
               0  $set_string(nrcp_file,' ');
               0  nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
               0  want_nrcp_unit = 62;
               0  nrcp_unit = egs_get_unit(want_nrcp_unit);
               0  IF( nrcp_unit < 1 ) [
               1      $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
               1  ]
               0
               0  rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
               0  open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
               0          status='old',recl=rec_length,err=:nrcp-open-error:);
               0  read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
               0  IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
               1      tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
               1      itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
               1      itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
               0  $egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
               0  IF( nb ~= $NRC-PAIR-NXX ) [
               1      $egs_fatal(*,'Inconsistent x-grid size');
               1  ]
               0  IF( ne ~= $NRC-PAIR-NEE ) [
               1      $egs_fatal(*,'Inconsistent energy grid size');
               1  ]
               0  nrcp_emin = emin; nrcp_emax = emax;
               0  nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;
               0
               0  nbb = nb/2; ddx = sqrt(0.5)/nbb;
               0  DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
               0  do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO ie=1,$NRC-PAIR-NEE [
               2          DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
               2      ]
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*Z;
               2          irec = (iz-1)*ne + 2;
               2          DO ie=1,$NRC-PAIR-NEE [
               3              read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
               3              DO ix=1,$NRC-PAIR-NXX [
               4                  tmp_4 = tarray(ix);
               4                  IF( swap ) [ call egs_swap_4(c_4); ]
               4                  nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
               4              ]
               3              irec = irec + 1;
               3          ]
               2      ]
               1      DO ie=1,$NRC-PAIR-NEE [
               2          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
               2                  nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
               2      ]
               1
               1      $egs_info('(a)',' done');
               1
               1  ]
               0  $egs_info(*,' ');
               0  close(nrcp_unit);
               0  return;
               0
               0  :nrcp-open-error:;
               0  $egs_fatal(*,'Failed to open NRC pair data file');
               0
               0  :nrcp-read-error:;
               0  $egs_fatal(*,'I/O error while reading NRC pair data file');
               0
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  "                                                                  "
               0  subroutine vmc_electron(ircode);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   This subroutine performs condensed history simulation of       "
               0  "   electron/positron transport according to VMC                   "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Initial coding               "
               0  "                                     coding is in EGSnrc style    "
               0  "                                     for maximum compatibility    "
               0  "                                     with EGSnrc user codes       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  $INTEGER ircode;
               0  $egs_fatal('(//a//)',
               0  ' ********* VMC Transport option not in this distribution ****** ');
               0  end;
               0
               0  " Subroutine versions of the random number generator "
               0  " Included here because it makes life easier for using the EGSnrc RNG"
               0  " from within the C-interface. "
               0  subroutine egs_init_default_rng;
               0  ;COMIN/RANDOM/;
               0  $RNG-DEFAULT-INITIALIZATION;
               0  return; end;
               0
               0  subroutine egs_init_rng(arg1,arg2);
               0  $INTEGER arg1,arg2;
               0  ;COMIN/RANDOM/;
               0  $declare_write_buffer;
               0  $INITIALIZE RNG USING arg1 AND arg2;
               0  return; end;
               0
               0  subroutine egs_get_rndm(ran);
               0  $REAL ran;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET ran;
               0  return; end;
               0
               0  subroutine egs_get_rndm_array(n,rarray);
               0  $INTEGER n;
               0  $REAL    rarray(*);
               0  ;COMIN/RANDOM/;
               0  $REAL    rtmp;
               0  $INTEGER i;
               0  IF( n < 1 ) return;
               0  DO i=1,n [
               1      $RANDOMSET rtmp; rarray(i) = rtmp;
               1  ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "**************************************************************************"
               0  "Init EII. This subroutine is called from HATCH after all media are known, "
               0  "threshold energies and interpolation data have been initialized.          "
               0  "**************************************************************************"
               0  subroutine eii_init;
               0  "**************************************************************************"
               0  implicit none;
               0  $COMIN-EII-INIT;
               0  $INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
               0  $INTEGER jj,jjj;
               0  integer*4 lnblnk1;
               0  $INTEGER tmp_array($MXELEMENT);
               0  $INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
               0  integer  egs_get_unit;
               0  $REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
               0  $REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
               0  $REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
               0  $REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
               0  $REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
               0  $REAL    sigma,sigma_old,wbrem_old,sig_j,de;
               0  $INTEGER lloge;
               0  $LOGICAL check_it,is_monotone,getd;
               0  $REAL    sigma_max;
               0  character eii_file*128;
               0  character*512 toUpper;
               0  $INTEGER occn_numbers(4);
               0  $declare_write_buffer;
               0  $REAL    cons;
               0  parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
               0  data     occn_numbers/2,2,2,4/;
               0
               0  DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
               0  DO j=1,$MXMED [ eii_nsh(j) = 0; ]
               0  IF( eii_flag = 0 ) [ return; ]
               0
               0  $need_relaxation_data(getd);
               0  IF( ~getd )[
               1    $egs_fatal('(/a,/a,/a,/a)',
               1            ' In subroutine eii_init: ',
               1            '   Scattering off bound electrons creates atomic vacancies,',
               1            '   potentially starting an atomic relaxation cascade. ',
               1            '   Please turn ON atomic relaxations.');
               1  ]
               0
               0
               0
               0
               0  e_eii_min = 1e30;
               0  DO imed = 1,nmed [
               1      IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
               1      IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      DO iele = 1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          IF( eii_nshells(iZ) = 0 ) [
               3              nsh = 0;
               3              DO ish=1,4 [
               4                  IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
               4              ]
               3              eii_nshells(iZ) = nsh;
               3          ]
               2      ]
               1  ]
               0
               0
               0  nsh = 0;
               0  DO iZ=1,$MXELEMENT [
               1      nsh = nsh + eii_nshells(iZ);
               1  ]
               0  IF( nsh = 0 ) [
               1      $egs_info(*,'*** EII requested but no shells with binding energies ');
               1      $egs_info(*,'    above the specified threshold found');
               1      $egs_info(*,'    => turning off EII');
               1      eii_flag = 0;
               1  ]
               0  IF( nsh > $MAX_EII_SHELLS ) [
               1      $egs_info(*,'*** Number of shells with binding energies greater than ');
               1      $egs_info(*,'    the specified thresholds is ',nsh);
               1      $egs_info(*,'    This is more than the allocated arrays can hold');
               1      $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
               1  ]
               0  $egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
               0  nsh_tot = nsh;
               0  tmp_array(1) = 0;
               0  DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]
               0
               0
               0  DO imed=1,nmed [
               1      nsh = 0;
               1      DO iele=1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          eii_no(imed,iele) = eii_nshells(iZ);
               2          nsh = nsh + eii_nshells(iZ);
               2          IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
               2          ELSE [ eii_first(imed,iele) = 0; ]
               2      ]
               1      eii_nsh(imed) = nsh;
               1  ]
               0
               0
               0  $set_string(eii_file,' ');
               0  eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
               0             $cstring(eii_xfile) //'.data';
               0  want_eii_unit = 62;
               0  eii_unit = egs_get_unit(want_eii_unit);
               0  IF( eii_unit < 1 ) [
               1      $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
               1  ]
               0  open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
               0  $egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
               0  $egs_info('(a,$)',' eii_init: reading EII data ... ');
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
               0  DO j=1,nskip [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
               1  ]
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
               0  IF( nbin ~= $N_EII_BINS ) [
               1      $egs_fatal(*,'Inconsistent EII data file');
               1  ]
               0  IF (xsec_out = 1)[
               1     eii_out = egs_open_file(93,0,1,'.eiixsec');
               1  ]
               0  ii = 0;
               0  DO j=1,$MXELEMENT [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
               1      IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
               2       write(eii_out,*) '=================================';
               2       write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
               2       write(eii_out,*) '=================================';
               2      ]
               1      IF( nsh < eii_nshells(iZ) ) [
               2          $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
               2          $egs_info(*,iZ,' but according');
               2          $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
               2          $egs_info(*,'shells are required');
               2          $egs_fatal(*,'This is a fatal error.');
               2      ]
               1      DO ish=1,nsh [
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
               2             aux_array;
               2          "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
               2          IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
               2          IF( ish <= eii_nshells(iZ) ) [
               3              IF (xsec_out = 1)[
               4                IF(ish = 1)[
               5                 write(eii_out,'(a,f10.2,a)')
               5                 'K-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 2)[
               5                 write(eii_out,'(a,f9.2,a)')
               5                 '=> LI-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 3)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 4)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LIII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
               4                write(eii_out,*) '   E/keV     sigma/(b/atom)';
               4                write(eii_out,*) '---------------------------';
               4              ]
               3              ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
               3              eii_a(ii) = nbin;
               3              eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
               3              eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
               3              DO k=1,nbin [
               4                  IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
               4                  ELSE [ sigo = 0; ]
               4                  loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
               4                  eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
               4                  eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
               4                  IF (xsec_out = 1)[
               5                     write(eii_out,'(f12.2,2X,10f9.2)')
               5                     Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
               5                  ]
               4              ]
               3          ]
               2      ]
               1      IF( ii = nsh_tot ) [ EXIT; ]
               1  ]
               0  close(eii_unit);
               0  IF (xsec_out = 1)[ close(eii_out); ]
               0  $egs_info(*,' OK '); $egs_info(*,' ');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
               1      /sum_z,sum_pz,sum_a,sum_wa/=0;
               1      DO iele=1,nne(imed) [
               2          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
               2          sum_pz = sum_pz + pz(imed,iele);
               2          sum_wa = sum_wa + rhoz(imed,iele);
               2          sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
               2      ]
               1      con_med = rho(imed)/1.6605655/sum_a;
               1      eii_cons(imed) = con_med;
               1      IF( eii_nsh(imed) > 0 ) [
               2          is_monotone = .true.;
               2          sigma_max = 0;
               2          DO j=1,meke(imed) [
               3              loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
               3              tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              p2 = 2*rm*tau*(tau+2);
               3              lloge = j;
               3              medium = imed;
               3              $EVALUATE dedx USING ededx(loge);
               3              IF( e > ap(medium) | e > 2*Ec ) [
               4                  $EVALUATE sig USING esig(loge);
               4              ] ELSE [ sig = 0; ]
               3              IF( e > 2*Ec ) [
               4                  $EVALUATE wbrem USING ebr1(loge);
               4                  sigm = sig*(1-wbrem);
               4              ] ELSE [ sigm = 0; wbrem = 1; ]
               3              /sum_occn,sum_sigma,sum_dedx/=0;
               3              DO iele=1,nne(imed) [
               4                  iZ = int(zelem(imed,iele)+0.5);
               4                  sum_sh = 0;
               4                  DO ish = 1,eii_no(imed,iele) [
               5                      "jj is the shell index in the list of EII shells "
               5                      jj = eii_first(imed,iele) + ish - 1;
               5                      "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
               5                      jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
               5                      Wmax = (e+U)/2; uwm = U/Wmax;
               5                      "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
               5                      IF( U < e & U > Ecc ) [
               6                          " At this energy interactions with this shell will "
               6                          " be done using the EII differential x-section "
               6                          sum_sh = sum_sh + occn_numbers(jjj);
               6                          ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
               6                            (beta2+0.833333)*(1-uwm**3))/3/U;
               6                          sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
               6                            - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
               6                          ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
               6                            (beta2+1)*(1-uwm**2);
               6                          sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
               6                            +(Wmax**2-U**2)/(e+rm)**2/2
               6                            -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
               6                          av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
               6                            "av_E is the average energy lost in a collision"
               6                            "with this shell"
               6                          i = eii_a(jjj)*loge + eii_b(jjj);
               6                          i = (jj-1)*$N_EII_BINS + i;
               6                          sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
               6                          sig_j = sig_j*pz(imed,iele)*con_med;
               6                          sum_sigma = sum_sigma + sig_j;
               6                          sum_dedx = sum_dedx + sig_j*av_E;
               6                      ]
               5                  ]
               4                  sum_occn = sum_occn + sum_sh*pz(imed,iele);
               4              ]
               3              sigm = sigm + sum_sigma;
               3              dedx = dedx - sum_dedx;
               3              aux = Ec/e;
               3              IF( e > 2*Ec ) [
               4                  sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
               4                          (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
               4                          (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
               4                  de = cons*sum_occn*rho(imed)/beta2*(
               4                    log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
               4                    (tau/(tau+1))**2*(1-4*aux*aux)/8-
               4                    (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
               4                  sigm = sigm - sigo;
               4                  "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
               4                  dedx = dedx + de;
               4              ]
               3              sigma = sigm + wbrem*sig;
               3              IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
               3              IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
               3              ELSE [ wbrem = 1; ]
               3              IF( j > 1 ) [
               4                  ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
               4                  ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
               4                  esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
               4                  esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
               4                  ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
               4                  ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
               4                  IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
               4              ]
               3              dedx_old = dedx; sigm_old = sigm;
               3              sigma_old = sigma; wbrem_old = wbrem;
               3          ]
               2          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
               2          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
               2          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
               2          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
               2          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
               2          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
               2          $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
               2                  sigma_max,' monotone = ',is_monotone);
               2          sig_ismonotone(0,imed) = is_monotone;
               2          esig_e(imed) = sigma_max;
               2      ]
               1  ]
               0  return;
               0
               0  :eii-reading-error:
               0  $egs_fatal(*,'I/O error while reading EII data');
               0
               0  :no-eii-file:
               0  $egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
               0            'Make sure file exists in your $HEN_HOUSE/data directory!',
               0            '****BEWARE of case sensitive file names!!!');
               0
               0  return; end;
               0
               0  "*****************************************************************************"
               0
               0  subroutine eii_sample(ish,iZ,Uj);
               0  implicit none;
               0  $INTEGER ish,iZ;
               0  $REAL    Uj;
               0
               0  $COMIN-EII-SAMPLE;
               0
               0  $REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
               0  $REAL r1,r2,r3,wx,wxx,aux,frej;
               0  real*8 peie,pese1,pese2,dcosth,h1;
               0  $INTEGER iarg;
               0  $REAL    eta,cphi,sphi;
               0  $INTEGER np_save,ip,j;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0
               0  peie = e(np);
               0  T = peie - rm; tau = T/rm; tau1 = tau+1;
               0  tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
               0  beta2 = p2/tau12;
               0  "c1 = tau2/tau12; "
               0  Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
               0  c1 = (Wmax/peie)**2;
               0  c2 = (2*tau+1)/tau12;
               0  fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
               0  prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
               0  "fm_h = 1 + c1 - c2;"
               0  fm_h = 2 + c1 - c2;
               0  IF( fm_h < 1 ) fm_h = 1;
               0  prob = fm_h + prob_s;
               0
               0  LOOP [
               1      $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
               1      IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
               2          wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
               2          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
               2      ] ELSE [               "Use the soft collision cross section "
               2          wx = 1/(r2*xmax**3+1-r2)**0.333333333;
               2          frej = 1 - log(wx)/fm_s;
               2      ]
               1  ] UNTIL ( r3 < frej );
               0
               0  wx = wx*Uj;
               0
               0
               0  h1 = (peie + prm)/T; pese1 = peie - wx;
               0  e(np) = pese1;
               0  dcosth = h1*(pese1-prm)/(pese1+prm);
               0  sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               0  call uphi(2,1);
               0
               0  pese2 = wx - Uj + prm;
               0  edep_local = 0;
               0  IF( pese2 > ae(medium) ) [
               1      $CHECK-STACK(np+1,'eii_sample');
               1      np = np+1; e(np) = pese2;
               1      dcosth = h1*(pese2-prm)/(pese2+prm);
               1      sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               1      iq(np) = -1; call uphi(3,2);
               1      edep = 0;
               1  ] ELSE [
               1      edep = wx - Uj;
               1      edep_local = edep;
               1      $AUSCALL($SELECTRONA);
               1  ]
               0  "ish ranges from 1 to 4 for K,L1,L2,L3 shells"
               0  call relax(Uj,ish,iZ);
               0
               0  IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_scale_photon_xsection(imed,fac,which);
               0  "============================================================================"
               0  "
               0  "  Scale the photon cross section 'which' by factor fac for medium imed.
               0  "  which = 0 for all cross sections
               0  "        = 1 for Rayleigh scattering
               0  "        = 2 for Compton scattering
               0  "        = 3 for Pair production
               0  "        = 4 for photo-absorption
               0  "  If imed = 0, scaling is done for all media.
               0  "============================================================================"
               0  implicit none;
               0  $INTEGER imed,which;
               0  $REAL    fac;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,PHOTIN,EGS-IO/;
               0  $INTEGER ifirst,ilast,medium,j;
               0  $LOGICAL has_r;
               0  $REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
               0  character*8 strings(5);
               0  data       strings/'photon','Rayleigh','Compton','pair','photo'/;
               0
               0  IF( which < 0 | which > 4 ) [ return; ]
               0  IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
               0  ELSE [ ifirst = 1; ilast = nmed; ]
               0  IF( which = 1 ) [
               1      has_r = .false.;
               1      DO medium = ifirst, ilast [
               2          IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
               2      ]
               1      IF( ~has_r ) return;
               1  ]
               0  $egs_info(*,' ');
               0  DO medium = ifirst,ilast [
               1
               1      $egs_info('(a,a,a,i3,a,f9.5)',
               1              'Scaling ',strings(which+1),' x-section data for medium',
               1              medium,' with ',fac);
               1
               1      DO j = 1,mge(medium) [
               2
               2          gle = (j - ge0(medium))/ge1(medium);
               2          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
               2          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
               2          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
               2          IF( iraylm(medium) = 1 ) [
               3              cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
               3          ] ELSE [ cohfac = 1; ]
               2          IF( which = 0 ) [ gmfp = gmfp/fac; ]
               2          ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
               2          ELSE [
               3              IF( which = 2 ) [
               4                  aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
               4                  gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
               4              ]
               3              ELSE IF( which = 3 ) [
               4                  aux = fac*gbr1 + 1 - gbr1;
               4                  gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
               4              ]
               3              ELSE [
               4                  aux = gbr2 + fac*(1-gbr2);
               4                  gbr1 = gbr1/aux; gbr2 = gbr2/aux;
               4              ]
               3              gmfp = gmfp/aux;
               3              cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
               3          ]
               2          IF( j > 1 ) [
               3              gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
               3              gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
               3              gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
               3              cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
               3              cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;
               2
               2      ]
               1      gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
               1      gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
               1      gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
               1      gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
               1      gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
               1      gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
               1      cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
               1      cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$OPEN-UNIT(#,#,#);} WITH {
            {  0      {P1} = {P2};
            {  0      {P1} = egs_get_unit({P1});
            {  0      IF( {P1} < 1 ) [
            {  0          $egs_fatal(*,
            {  0           'egs_init_user_photon: failed to get a free Fortran I/O unit');
            {  0      ]
            {  0      tmp_string = {P3};
            {  0      open({P1},file={P3},status='old',err=:no-user-data-file:);
            {  0  };
               0
               0  REPLACE {$MXINPUT} WITH {2000};
               0  REPLACE {$MXBCINP} WITH {183};
               0
               0  "============================================================================="
               0  "Ali:photonuc, 1 line"
               0   subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
               0  "subroutine egs_init_user_photon(prefix,comp_prefix,out);"
               0  "============================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  character*(*) prefix, comp_prefix,
               0  "Ali:photonuc, 1 line"
               0                photonuc_prefix;
               0  $INTEGER      out;
               0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
               0  $INTEGER   lnblnk1,egs_get_unit,medium,
               0             photo_unit,pair_unit,rayleigh_unit,triplet_unit,
               0             ounit,egs_open_file,compton_unit,
               0  "Ali:photonuc, 1 line"
               0             photonuc_unit;
               0  $INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
               0  $REAL      z_sorted($MXEL),pz_sorted($MXEL);
               0  $REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
               0             sig_rayleigh($MXGE),sig_compton($MXGE);
               0  $REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
               0  $REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
               0  "Ali:photonuc, 3 lines"
               0             sig_photonuc($MXGE),
               0             photonuc,
               0             photonuc_old;
               0
               0  $REAL      etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
               0  $REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
               0  $INTEGER   bc_ne;
               0  $LOGICAL   input_compton_data,
               0  "Ali:photonuc, 1 line"
               0             input_photonuc_data;
               0  character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
               0             triplet_file*142,tmp_string*144,compton_file*144,
               0  "Ali:photonuc, 1 line"
               0             photonuc_file*144;
               0
               0  $egs_info('(/a$)','(Re)-initializing photon cross sections');
               0  $egs_info('(a,a/)',' with files from the series: ',
               0        prefix(:lnblnk1(prefix)));
               0
               0  $egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   $egs_info('(a,a)',' Photonuclear cross sections: ',
               1   $cstring(photonuc_prefix));
               1   input_photonuc_data = .false.;
               1   IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
               2     input_photonuc_data = .true.;
               2   ]
               1  ]
               0
               0  input_compton_data = .false.;
               0  IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
               1      IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
               1  ]
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
               0  pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
               0  triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
               0  rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
               0  IF( input_compton_data ) [
               1      compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
               1                     '_compton.data';
               1  ]
               0  ELSE [
               1      compton_file = $cstring(data_dir) // 'compton_sigma.data';
               1  ]
               0  "Ali: I moved this info line from inside the IF statement
               0  " because it's useful to print the cross section file either way
               0  $egs_info('(a,a)',' Using Compton cross sections from ',
               0            $cstring(compton_file));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   IF( input_photonuc_data ) [
               2      photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
               2                      '_photonuc.data';
               2   ]
               1   ELSE [
               2      photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
               2   ]
               1   $egs_info('(a,a)',' Using photonuclear cross sections from ',
               1    $cstring(photonuc_file));
               1  ]
               0
               0  $OPEN-UNIT(photo_unit,83,photo_file);
               0  $OPEN-UNIT(pair_unit,84,pair_file);
               0  $OPEN-UNIT(triplet_unit,85,triplet_file);
               0  $OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
               0  IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
               0  " Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
               0  "       without rejections. For this we have to use the actual bound   "
               0  "       Compton scattering cross section, which is now available in a  "
               0  "       file called bound_compton.data (the file actually contains the "
               0  "       ratio of the Bound Compton to the KN cross section).           "
               0  "       Because this option is not available on a region by region     "
               0  "       basis, we just need to check ibcmp(1)                          "
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]
               0
               0  IF( out = 1 ) [
               1      ounit = egs_open_file(87,0,1,'.xsections');
               1      write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
               1         $cstring(prefix),' data files';
               1      write(ounit,'(a,/)')
               1  '============================================================================';
               1      write(ounit,'(a,/)') 'Grid energies and cross sections are output';
               1  "Ali:photonuc, 1 block"
               1      IF(iphotonuc = 1) [
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
               2           'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
               2           ' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
               2           '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
               2           'w/ Ray + photnuc';
               2      ]
               1      ELSE[
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
               2              'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
               2              '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
               2     ]
               1  ]
               0
               0  DO iz=1,100 [
               1      read(photo_unit,*) ndat;
               1      read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
               1      k = 0;
               1      DO j=ndat,2,-1 [
               2          IF( etmp(j)-etmp(j-1) < 1e-5 ) [
               3              k = k+1;
               3              IF ( k <= $MXSHXSEC )[
               4                 binding_energies(k,iz) = exp(etmp(j));
               4              ]
               3              ELSE[
               4                $egs_fatal('(i3,a,i3,//a)',
               4                           k,' binding energies read exceeding array size of',
               4                           $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
               4              ]
               3              IF( ~eadl_relax & k >= 4 ) EXIT;
               3          ]
               2      ]
               1  ]
               0
               0  IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]
               0
               0  DO medium = 1,nmed [
               1
               1      mge(medium) = $MXGE; nge = $MXGE;
               1      ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
               1      ge0(medium) = 1 - ge1(medium)*log(ap(medium));
               1
               1      $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
               1      IF( out = 1 ) [
               2          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
               2            (media(k,medium),k=1,24);
               2      ]
               1      /sumZ,sumA/ = 0;
               1      DO i=1,nne(medium) [
               2          z_sorted(i) = zelem(medium,i);
               2          sumZ = sumZ + pz(medium,i)*zelem(medium,i);
               2          sumA = sumA + pz(medium,i)*wa(medium,i);
               2      ]
               1      con1 = sumZ*rho(medium)/(sumA*1.6605655);
               1      con2 = rho(medium)/(sumA*1.6605655);
               1      call egs_heap_sort(nne(medium),z_sorted,sorted);
               1      DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]
               1
               1      IF (mcdf_pe_xsections)[
               2         call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
               2                                  ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      ELSE[
               2         call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                         ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_rayleigh);
               1      call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_pair);
               1      call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_triplet);
               1  "Ali:photonuc, 1 block"
               1      IF( iphotonuc = 1 ) [
               2        call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                          ge1(medium),ge0(medium),sig_photonuc);
               2      ]
               1
               1      IF( ibcmp(1) > 1 ) [
               2          "Get the bound compton cross section data"
               2          IF( input_compton_data ) [
               3              call egsi_get_data(0,compton_unit,nge,nne(medium),
               3                      z_sorted,pz_sorted,ge1(medium),ge0(medium),
               3                      sig_compton);
               3          ]
               2          ELSE [
               3              rewind(compton_unit);
               3              read(compton_unit,*) bc_emin,bc_emax,bc_ne;
               3              IF( bc_ne > $MXBCINP ) [
               4                $egs_fatal(*,'Number of input Compton data exceeds array size');
               4              ]
               3              "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
               3              bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
               3              DO j=1,bc_ne [ bc_data(j) = 0; ]
               3              iz_old = 1;
               3              DO i=1,nne(medium) [
               4                  iz = int(z_sorted(i)+0.5);
               4                  "write(6,*) ' reading bc data for ',iz;
               4                  DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
               4                  DO j=1,bc_ne [
               5                      bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
               5                  ]
               4                  iz_old = iz+1;
               4              ]
               3              DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
               3          ]
               2      ]
               1
               1
               1      call egs_init_rayleigh(medium,sig_rayleigh);
               1
               1      DO i=1,nge [
               2
               2          gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
               2          sig_KN = sumZ*egs_KN_sigma0(e);
               2          IF( ibcmp(1) > 1 ) [
               3              IF( input_compton_data ) [
               4                  sig_KN = sig_compton(i);
               4              ]
               3              ELSE [
               4                  "Apply the bound Compton correction to sig_KN"
               4                  IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
               4                  ELSE IF( e < bc_emax ) [
               5                      aj = 1 + log(e/bc_emin)/bc_dle;
               5                      j = int(aj); aj = aj - j;
               5                      bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
               5                  ]
               4                  ELSE [ bcf = 1; ]
               4                  sig_KN = sig_KN*bcf;
               4                  "write(6,*) 'e = ',e,' bcf = ',bcf;
               4              ]
               3          ]
               2          sig_p  = sig_pair(i) + sig_triplet(i);
               2          sigma  = sig_KN + sig_p + sig_photo(i);
               2          gmfp   = 1/(sigma*con2);
               2          gbr1   = sig_p/sigma;
               2          gbr2   = gbr1 + sig_KN/sigma;
               2          cohe   = sigma/(sig_rayleigh(i) + sigma);
               2  "Ali:photonuc, 1 line"
               2          photonuc = sigma/(sig_photonuc(i) + sigma);
               2
               2          IF( out = 1 ) [
               3  "Ali:photonuc, 1 block"
               3             IF(iphotonucm(medium) = 1) [
               4                write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
               4                gmfp*cohe,gmfp*cohe*photonuc;
               4             ]
               3             ELSE[
               4                write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
               4             ]
               3          ]
               2          IF( i > 1 ) [
               3              gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
               3              gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
               3              gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
               3              cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
               3              cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
               3  "Ali:photonuc, 2 lines"
               3              photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
               3              photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
               2  "Ali:photonuc, 1 line"
               2          photonuc_old = photonuc;
               2      ]
               1
               1      gmfp1(nge,medium) = gmfp1(nge-1,medium);
               1      gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
               1      gbr11(nge,medium) = gbr11(nge-1,medium);
               1      gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
               1      gbr21(nge,medium) = gbr21(nge-1,medium);
               1      gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
               1      cohe1(nge,medium) = cohe1(nge-1,medium);
               1      cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
               1  "Ali:photonuc, 2 lines"
               1      photonuc1(nge,medium) = photonuc1(nge-1,medium);
               1      photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;
               1
               1      $egs_info('(a)','OK');
               1  ]
               0
               0  close(photo_unit); close(pair_unit);
               0  close(triplet_unit); close(rayleigh_unit);
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ close(photonuc_unit);]
               0  IF( ibcmp(1) > 1 ) [ close(compton_unit);]
               0  IF( out = 1 )      [ close(ounit); ]
               0  return;
               0
               0  :no-user-data-file:;
               0  $egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh(medium,sig_rayleigh);
               0
               0
               0
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
               0  DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
               0  DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
               2     ff_file = iray_ff_file(i);
               2  ];]
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0
               0
               0
               0
               0
               0  IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
               1       open(ff_unit,file=$cstring(ff_file),
               1            status='old',err=:no-ff-file:);
               1       GOTO :read-ff:;
               1       :no-ff-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
               1               $cstring(ff_file));
               1       :read-ff:
               1       $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
               1       " read Rayleigh molecular form factor data from a file"
               1       " which is given as Fmol/sqrt(MW) hence no need to compute"
               1       " MW to get the xsections in cm-1. See conv variable below"
               1       j = 0;
               1       LOOP [
               2         j = j + 1;
               2         read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
               2         IF (EOF < 0) EXIT;
               2         IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
               2       ] REPEAT
               1       nff = j-1;
               1       IF (nff > $MXRAYFF)[
               2          $egs_fatal('(a,/,a,i5,a,i5,/,a)',
               2          'subroutine egs_init_rayleigh: form factors size too small!!',
               2          '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
               2          ' and try again!!!');
               2       ]
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
               1
               1       "Since MW already included in the molecular FF,"
               1       "must multiply by sumA which is MW for compound"
               1       "or unity for mixtures."
               1       sumA = 0.0;
               1       DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
               1       DO j=1,MGE(medium) [
               2         gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
               2         sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
               2                         xgrid(1,medium),ff(1,medium))*sumA;
               2       ]
               1  ]
               0  ELSE[
               1       $set_string(afac_file,' ');
               1       afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               1       open(ff_unit,file=$cstring(afac_file),
               1         status='old',err=:no-afac-file:);
               1       GOTO :read-afac:;
               1       :no-afac-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
               1               $cstring(afac_file));
               1       :read-afac:
               1       " read Rayleigh atomic form factor data from a file"
               1       read(ff_unit,*) xval, aff;
               1       "calculate form factor using independent atom model"
               1       DO i=1,$MXRAYFF[
               2         ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               2         DO j=1,nne(medium)[
               3          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               3         ]
               2         ff(i,medium) = sqrt(ff(i,medium));
               2       ]
               1       nff = $MXRAYFF;
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               1  ]
               0  close(ff_unit);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
               0  dlei=1/dle;
               0  DO i=1,ne-1 [
               1
               1
               1
               1
               1
               1
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh_sampling(medium);
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0  $set_string(afac_file,' ');
               0  afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               0  open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
               0  GOTO :read-afac:;
               0  :no-afac-file:
               0  $egs_fatal('(2a)',
               0          'egs_init_rayleigh_sampling: failed to open atomic ff file ',
               0          $cstring(afac_file));
               0  :read-afac:
               0  " read Rayleigh atomic form factor data from a file"
               0  read(ff_unit,*) xval, aff;
               0  "calculate form factor using independent atom model"
               0  DO i=1,$MXRAYFF[
               1    ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               1    DO j=1,nne(medium)[
               2     ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               2    ]
               1    ff(i,medium) = sqrt(ff(i,medium));
               1  ]
               0  nff = $MXRAYFF;
               0  "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               0  "and much less for higher energies"
               0  IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               0  "write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
               0  $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               0
               0  close(ff_unit);
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);
               0  DO i=1,ne-1 [
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0
               0
               0  $REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
               0  $IMPLICIT-NONE;
               0  $INTEGER i, j, k,imed, ndat;
               0  $REAL hc2,conv,b,hc;
               0  parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
               0             hc2 = 0.0001537222280); "h*c squared"
               0  $REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
               0  real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
               0  C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
               0  egs_rayleigh_sigma = 0.0;
               0  DO i=1,ndat-1[
               1     IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
               1     IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
               1     b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
               1     x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
               1     pow_x1=x1**(2*b);pow_x2=x2**(2*b);
               1     raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
               1     raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
               1     raysig = raysig*f(i)*f(i)/pow_x1;
               1     egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
               1     IF(x(i+1)>xmax)[EXIT;]"exit loop"
               1  ]
               0
               0
               0
               0  egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
               0  return;
               0  end;
               0
               0
               0
               0  subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  real*8 e;
               0  $REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
               0  $REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
               0  parameter(hc_i=80.65506856998,      "h*c inverse"
               0            twice_hc2=0.000307444456);"2*(hc)^2"
               0            "h*c=0.0123984768438 [Armstrong]*[MeV]"
               0  $INTEGER lgle,ib,ibin,medium, trials;
               0  ;COMIN/RANDOM,rayleigh_sampling/;
               0  dwi = $RAYCDFSIZE-1;
               0  $EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
               0  LOOP [
               1      $RANDOMSET rnnray1;
               1      LOOP [
               2          $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
               2          ibin = 1 + rnnray0*dwi;
               2          ib = i_array(ibin,medium);
               2          IF( i_array(ibin+1,medium) > ib ) [
               3            LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
               3          ]
               2          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
               2          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
               2      ] UNTIL (xv < xmax);
               1      xv = xv/e;
               1      costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
               1  ] UNTIL ( 2*rnnray1 < 1 + csqthe );
               0  sinthe=sqrt(1.0-csqthe);
               0  return;
               0  end;
               0
               0
               0
               0  subroutine prepare_rayleigh_data(ndat,x,f,
               0                                   ne,emin,emax,pe_array,
               0                                   ncbin,fcum,i_array,
               0                                   b_array,c_array);
               0  $IMPLICIT-NONE;
               0
               0
               0  $INTEGER    ndat;         " number of F data points "
               0  $REAL       x(ndat),      " x values of F data "
               0              f(ndat);      " F data "
               0
               0
               0  $INTEGER    ne;           " number of energy bins "
               0  $REAL       emin,         " minimum photon energy (i.e. AP(medium))"
               0              emax,         " maximum photon energy (i.e. UP(medium))"
               0              pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
               0                            " i.e., pe_array(E) = fcum(xmax(E))      "
               0
               0
               0
               0  $INTEGER    ncbin;          " number of cumulative bins (input)"
               0  $REAL       fcum(ndat);     " cumulative distribution (output)"
               0  $INTEGER    i_array(ncbin); " original data bin in which the i'th "
               0                              " cumulative bin edge falls.          "
               0
               0
               0  $REAL       b_array(ndat),  " F interpolation coefficient "
               0              c_array(ndat);  " needed for sampling at run time "
               0
               0  $REAL zero;
               0
               0  real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
               0         anorm,anorm1,anorm2,w,dw,xold,t,aux;
               0  $INTEGER i,j,k,ibin;
               0
               0  ;COMIN/USEFUL/;
               0
               0  write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';
               0
               0
               0  DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]
               0
               0
               0
               0
               0
               0
               0  sum0=0; fcum(1)=0;
               0  DO i=1,ndat-1 [
               1      b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
               1      x1 = x(i); x2 = x(i+1);
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1      fcum(i+1) = sum0;
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0  dle = log(emax/emin)/(ne-1); i = 1;
               0  DO j=1,ne [
               1      e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
               1      DO k=i,ndat-1 [
               2          IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
               2      ]
               1      i = k; b = b_array(i);
               1      x1 = x(i); x2 = xmax;
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      pe_array(j) = fcum(i) +
               1        f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1  ]
               0  i_array(ncbin) = i;
               0
               0
               0
               0
               0
               0
               0
               0
               0  anorm = 1d0/sqrt(pe_array(ne));
               0  anorm1 = 1.005d0/pe_array(ne);
               0  anorm2 = 1d0/pe_array(ne);
               0  DO j=1,ne [
               1      pe_array(j) = pe_array(j)*anorm1;
               1      IF( pe_array(j) > 1 ) pe_array(j) = 1;
               1  ]
               0  DO j=1,ndat [
               1      f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
               1      c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
               1  ]
               0
               0
               0
               0
               0
               0
               0  dw = 1d0/(ncbin-1);
               0  xold = x(1); ibin = 1;
               0  b = b_array(1);
               0  pow_x1 = x(1)**(2*b);
               0  i_array(1) = 1;
               0  DO i=2,ncbin-1 [
               1      w = dw;
               1      LOOP [
               2          x1 = xold; x2 = x(ibin+1);
               2          t = x1*x1*x1**(2*b);
               2          pow_x2 = x2**(2*b);
               2          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
               2          IF( aux > w ) [
               3              xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
               3              i_array(i) = ibin;
               3              EXIT;
               3          ]
               2          w = w - aux; xold = x2; ibin = ibin+1;
               2          b = b_array(ibin); pow_x1 = xold**(2*b);
               2      ]
               1  ]
               0
               0
               0
               0
               0
               0
               0  DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]
               0
               0
               0  write(*,'(a /)') 'done';
               0
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma0(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm;
               0  IF( ko < 0.01 ) [
               1      egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
               1      return;
               1  ]
               0  c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
               0                  eps1*(c3+0.5*eps1))/e*con;
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma1(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma1 = c1*(1./eps1-1./eps2);
               0  egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
               0  egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
               0  egs_KN_sigma1 = egs_KN_sigma1 +
               0           (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
               0  egs_KN_sigma1 = egs_KN_sigma1*con;
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL    eth;
               0  $INTEGER flag,iunit,n,ne;
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL    gle,sig,p,e;
               0  $INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;
               0
               0  ;COMIN/USEFUL/;
               0
               0  "Ali:photonuc. The whole routine is commented out and re-written
               0  "to accommodate reading photonuclear cross sections. A copy of the
               0  "commented original routine is at the bottom.
               0  " flag = 0: photoelectric, Rayleigh, Compton
               0  " flag = 1: pair
               0  " flag = 2: triplet
               0  " flag = 3: photonuclear
               0
               0  rewind(iunit);
               0  iz_old = 0;
               0  DO k=1,n [ data(k) = 0; ]
               0  DO i=1,ne [
               1      iiz = int(zsorted(i)+0.5);
               1      DO iz=iz_old+1,iiz [
               2          read(iunit,*,err=:user-data-failure:) ndat;
               2          IF( ndat > $MXINPUT ) [
               3              $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
               3          ]
               2          IF( flag = 0 | flag = 3) [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
               3          ]
               2          ELSE [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
               3                  k=1,ndat);
               3              IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
               3              ndat = ndat + 1;
               3              DO k=2,ndat [
               4                  ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
               4              ]
               3              ftmp(1) = ftmp(2); etmp(1) = log(eth);
               3          ]
               2      ]
               1      iz_old = iiz;
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1; e = exp(gle);
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              IF( flag = 0 ) [
               4                  $egs_fatal(*,'Energy ',exp(gle),
               4                     ' is outside the available data range of ',
               4                     exp(etmp(1)),exp(etmp(ndat)));
               4              ]
               3              ELSEIF (flag = 1 | flag = 2) [
               4                  IF( gle < etmp(1) ) [ sig = 0; ]
               4                  ELSE [ sig = exp(ftmp(ndat)); ]
               4              ]
               3              ELSE [ "photonuclear, zero it before and after
               4               sig = 0;
               4              ]
               3          ] ELSE [
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              IF( flag ~= 3) ["log/log interpolation"
               4                 p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               4                 sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               4              ]
               3              ELSE["lin/lin interpolation for photonuc"
               4                 p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               4                 sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
               4              ]
               3          ]
               2          IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2      ]
               1  ]
               0
               0  return;
               0
               0  :user-data-failure:;
               0  $egs_fatal(*,'Error while reading user photon cross sections from unit ',
               0       iunit);
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0  "============================================================================="
               0  subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
               0  $INTEGER n,   "number of data points requested"
               0           ne,  "number of elements in medium"
               0           ndat;"number of data points from original grid"
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    sigma($MXNE),sigmaMedium;
               0  "$INTEGER sorted(*);
               0  real*4    etmp($MXINPUT),ftmp($MXINPUT);
               0  real*4    gle,sig,p;
               0  $INTEGER i,j,k,kk,iz,zpos,imed;
               0
               0  DO k=1,n  [ data(k)  = 0;]
               0  DO k=1,ne [ sigma(k) = 0;]
               0  DO i=1,ne [
               1      iz = int(zsorted(i)+0.5);
               1      zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1      "Total cross sections for a given element"
               1      "on initial energy grid"
               1      DO k=1,ndat[
               2         pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
               2         "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
               2         etmp(k) = pe_energy(k,zpos);
               2         ftmp(k) = log(pe_xsection(k,zpos,0));
               2      ]
               1      "Total cross sections for a given element"
               1      "on requested energy grid"
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1;
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
               3                           ' is outside the available data range of ',
               3                           exp(etmp(1)),exp(etmp(ndat)));
               3          ] ELSE [
               3              "Find energy interval gle falls in"
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              "log/log interpolation"
               3              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               3              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               3          ]
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2          "data(k) = data(k) + pz(imed,sorted(i))*sig;
               2      ]
               1  ]
               0  "Normalize elemental cross section to medium cross section"
               0  "Prepare for log/log interpolation"
               0  DO i=1,ne [
               1     iz = int(zsorted(i)+0.5);
               1     zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1     DO k=1,ndat[
               2        sig = sigmaMedium(imed,pe_energy(k,zpos));
               2        pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
               2     ]
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0  $REAL function sigmaMedium(imed, logE);
               0
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,PE-SHELL-DATA/;
               0  $REAL logE, slope, sigma;
               0  $INTEGER k,imed,Z,zpos,m,ibsearch;
               0
               0  sigmaMedium = 0;
               0  DO k=1,nne(imed) [
               1     Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
               1     m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               1     slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
               1     slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
               1     sigma = log(pe_xsection(m,zpos,0));
               1     sigma += slope*(logE - pe_energy(m,zpos));
               1     sigma = exp(sigma);
               1     sigmaMedium += pz(imed,k)*sigma;
               1  ]
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egs_heap_sort(n,rarray,jarray);
               0  "************************************************************************
               0  "  egs_heap_sort will sort the real array rarray of dimension n in
               0  "  ascending order and at the same time put into the integer array
               0  "  jarray the original position of the elements, e.g.
               0  "  if rarray was on input (5,14,8,2), it will be after completion
               0  "  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
               0  "  heap_sort uses the heap sort algorithm, the implementation is
               0  "  based  on hpsort from Numerical Recipies with a couple of
               0  "  modifications.
               0  "
               0  "  Iwan Kawrakow, NRC, July 2001
               0  "*************************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER n,jarray(*);
               0  $REAL    rarray(*);
               0  $INTEGER i,ir,j,l,ira;
               0  $REAL    rra;
               0
               0  DO i=1,n [ jarray(i)=i; ]
               0  IF (n < 2) return;
               0  l=n/2+1; ir=n;
               0
               0  LOOP [
               1     IF (l > 1)  [
               2         l=l-1; rra=rarray(l); ira=l;
               2     ]
               1     ELSE [
               2         rra=rarray(ir); ira=jarray(ir);
               2         rarray(ir)=rarray(1); jarray(ir)=jarray(1);
               2         ir=ir-1;
               2         IF (ir = 1) [
               3             rarray(1)=rra; jarray(1)=ira; return;
               3         ]
               2     ]
               1     i=l; j=l+l;
               1     LOOP [
               2         IF( j > ir ) EXIT;
               2         IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
               2         IF (rra < rarray(j)) [
               3             rarray(i)=rarray(j); jarray(i)=jarray(j);
               3             i=j; j=j+j;
               3         ] ELSE [ j=ir+1; ]
               2     ]
               1     rarray(i)=rra; jarray(i)=ira;
               1  ]
               0  return; end;
               0
1              0  %E
               0  "Ali:photonuc, 1 subroutine"
               0  "******************************************************************"
               0  SUBROUTINE PHOTONUC;
               0  "******************************************************************"
               0  " Placeholder for photonuclear modelling. Currently the photon is
               0  " discarded and its energy is thrown away (i.e. not deposited).
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-PHOTONUC; "current default replacement is:
               0                   "COMIN/STACK,EPCONT,USEFUL/"
               0  $DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"
               0
               0  npold = np; "set the old stack counter"
               0  edep = pzero; e(np) = pzero; wt(np) = 0;
               0
               0  return;
               0  end;
               0  "******************************************************************"
               0
          END OF MORTRAN INPUT
  55      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
