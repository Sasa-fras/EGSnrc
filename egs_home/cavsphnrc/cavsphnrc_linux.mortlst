Mortran 3.2 Mon Feb  5 23:07:12 2024
               0  %L                                                                     ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0                                        "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0                                        "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0    {SETR F=$FORTVER}
            {  0     [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0    }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0     WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0              [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0      "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0   WITH {;{SETR X=NEWLABEL}
            {  0   WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0   [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0   WRITE(IUECHO,{P4}){P5};]
            {  0   [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0   WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0   }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0    WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0     {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0    {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0    {{EMIT;{P1}}={WAIT {P1}};
            {  0    IF QDEBUG [OUTPUT{P1};
            {  0    (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0    {{SETR A=NEWLABEL}
            {  0      REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0         WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0             IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0                  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0                      (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0                         G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0    {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0    {;IF (QDEBUG)[OUTPUT;
            {  0      (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0           {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0      {;{SETR A=NEWLABEL}
            {  0           V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0           [IF] {EXIST 2} [$DUMP{P2};] ;}
               0     "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0     "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  REPLACE {$CONFIG_TIME} WITH {'unknown'}
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0     { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0     {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0     {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0      {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0      {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0      {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0      {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0      {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0      {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0              {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0      ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0       $REAL         ECUT,   "Minimum electron transport energy"
            {  0                     PCUT,   "Minimum photon transport energy"
            {  0                     VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0      ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0    ;COMMON/BREMPR/
            {  0               $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0               $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0               $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0               PWR2I($MXPWR2I),
            {  0               $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0               IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0               ASYM($MXMED,$MXEL,2);
            {  0     $TYPE     ASYM;
            {  0     $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0                                      "rejection function, eq. (2.7.14 and 15)"
            {  0               ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0               BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0               DELPOS, "maximum delta, eq. (2.7.31)"
            {  0               WA,     "atomic weight"
            {  0               PZ,     "atomic fraction of an element in a compound"
            {  0               ZELEM,  "Z for a given component"
            {  0               RHOZ,   "density of an element in a compound"
            {  0               PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0               DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0               ZBRANG, "composite factor for angular distributions"
            {  0               LZBRANG;"-Log(ZBRANG)"
            {  0     $INTEGER  NNE,    "number of elements/compound"
            {  0               IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0               IPRDST, "flag to switch on pair angular distributions"
            {  0               ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0               itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0               pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0                          "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0    common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_emin($MXMED),nb_emax($MXMED),
            {  0                       nb_lemin($MXMED),nb_lemax($MXMED),
            {  0                       nb_dle($MXMED),nb_dlei($MXMED),
            {  0                       log_ap($MXMED);
            {  0    $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0             nb_dle,nb_dlei,log_ap;
            {  0    $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0      common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_xdata($NRC-PAIR-NXX),
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0          common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0                               b_triplet($MAX_TRIPLET,$MXMED),
            {  0                               dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0          $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0                               bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0    ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0                          be_array($MXTOTSH), "Shell binding energies      "
            {  0                          Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0                          erfJo_array($MXTOTSH),"needed for the calculation"
            {  0                                              "of the incoherent scattering"
            {  0                                              "function                    "
            {  0                          ne_array($MXTOTSH), "Occupation number           "
            {  0                          shn_array($MXTOTSH),"shell type                  "
            {  0                                              "(=1     for K,              "
            {  0                                              " =2,3,4 for L1,L2,L3        "
            {  0                                              " =5     for M               "
            {  0                                              " =6     for N               "
            {  0                                              " =7     for all others      "
            {  0                          shell_array($MXMDSH,$MXMED),
            {  0                          eno_array($MXMDSH,$MXMED),
            {  0                          eno_atbin_array($MXMDSH,$MXMED),
            {  0                          n_shell($MXMED),
            {  0                          radc_flag,          "flag for radiative corrections"
            {  0                          ibcmp($MXREG);      "flag to turn on binding effects"
            {  0     $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0                          shell_array,n_shell,radc_flag;
            {  0     $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0     $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0     COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0                 interaction_prob($MXSHELL,$MXELEMENT),
            {  0                 relaxation_prob($MXTRANS,$MXELEMENT),
            {  0                 edge_energies($MXEDGE,$MXELEMENT),
            {  0                 edge_number($MXELEMENT),
            {  0                 edge_a($MXEDGE,$MXELEMENT),
            {  0                 edge_b($MXEDGE,$MXELEMENT),
            {  0                 edge_c($MXEDGE,$MXELEMENT),
            {  0                 edge_d($MXEDGE,$MXELEMENT),
            {  0                 IEDGFL($MXREG),IPHTER($MXREG);
            {  0     $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0                 interaction_prob, " prob. for interaction with one of"
            {  0                                   " the above shells (provided photon"
            {  0                                   " energy is above be)              "
            {  0                 relaxation_prob,  " relaxation probabilities         "
            {  0                 edge_energies,    " photo-absorption edge energies   "
            {  0                 edge_a,edge_b,edge_c,edge_d;
            {  0                                   " photo cross section fit parameters "
            {  0     $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0                 IPHTER;  "flag for switching on photo-electron angular distr."
            {  0     $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0     COMMON/ELECIN/
            {  0     esig_e($MXMED),psig_e($MXMED),
            {  0     esige_max, psige_max,
            {  0     range_ep(0:1,$MXEKE,$MXMED),
            {  0     E_array($MXEKE,$MXMED),
            {  0     $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0          blcce($MXEKE,$MXMED)/0,1/),
            {  0     $LGN(EKE($MXMED)/0,1/),
            {  0     $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0     $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0     expeke1($MXMED),
            {  0     IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0     sig_ismonotone(0:1,$MXMED);
            {  0     $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0                             "for each medium"
            {  0              psig_e,        "maximum positron cross section per energy loss"
            {  0                             "for each medium"
            {  0              esige_max,     "maximum electron cross section per energy loss"
            {  0              psige_max,     "maximum electron cross section per energy loss"
            {  0              range_ep,      "electron (0) or positron (1) range"
            {  0              E_array,       "table energies"
            {  0              etae_ms0,etae_ms1,
            {  0                             "for interpolation of screening parameter (e-)"
            {  0              etap_ms0,etap_ms1,
            {  0                             "for interpolation of screening parameter (e+)"
            {  0              q1ce_ms0,q1ce_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e-)"
            {  0              q1cp_ms0,q1cp_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e+)"
            {  0              q2ce_ms0,q2ce_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e-)"
            {  0              q2cp_ms0,q2cp_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e+)"
            {  0              blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0                            "necessary to account for scattering already taken  "
            {  0                            "into account in discrete Moller/Bhabha             "
            {  0              expeke1,       "Exp(1/eke1)-1"
            {  0              $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0              XR0,           "unused, but read in HATCH"
            {  0              TEFF0,         "unused, but read in HATCH"
            {  0              BLCC,          "b lower case sub c"
            {  0              XCC,           "chi sub-c-c"
            {  0              ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0              PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0              EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0              PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0              EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0              PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0              PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0              TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0     $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0              EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0              IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0     $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0                             "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0                                        "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0                                        "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0      common/eii_data/
            {  0          eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_cons($MXMED),
            {  0          eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0          eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0          eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0          eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0          eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0          eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0          eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0          eii_flag;                      "EII flag                          "
            {  0                                         "         = 0 => no EII            "
            {  0                                         "         = 1 => simple EII        "
            {  0                                         "         > 1 => future use        "
            {  0      $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0      $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0      $INTEGER  eii_first,eii_no;
            {  0      $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0      ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0             UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0      ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0      common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0                       EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0                       BxIN, ByIN, BzIN,       "B field: initial region"
            {  0                       Bx, By, Bz,             "B field: current region"
            {  0                       Bx_new, By_new, Bz_new, "B field: in new region"
            {  0                       emfield_on;             "true if EM fields not null"
            {  0
            {  0     $REAL    ExIN,EyIN,EzIN,
            {  0              EMLMTIN,
            {  0              BxIN,ByIN,BzIN,
            {  0              Bx,By,Bz,
            {  0              Bx_new,By_new,Bz_new;
            {  0     $LOGICAL emfield_on;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0     common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0     $REAL              u_relax;
            {  0     $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}     "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}  "max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000} "max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}     "max. number of vacancies"
               0  REPLACE {$MAXTRANS} WITH {300}   "max. number of transitions per element"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0    common/shell_data/
            {  0      shell_be($MAXSHELL),      "binding energies"
            {  0      shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0      shell_num($MAXSHELL),     "the shell position in the element"
            {  0      shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0      shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0      shell_ntot;               "total number of shells in the list"
            {  0    $REAL    shell_be;
            {  0    $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0    common/relax_data/
            {  0      relax_first($MAXSHELL),    "first transition"
            {  0      relax_ntran($MAXSHELL),    "number of transitions"
            {  0      relax_state($MAXRELAX),    "final state of the transition"
            {  0      relax_prob($MAXRELAX),     "probability"
            {  0      relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0      relax_ntot;                "total number of transitions in the list"
            {  0    $REAL     relax_prob;
            {  0    $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0      common/relax_for_user/
            {  0       rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0       rfu_E,  "binding energy of current vacancy"
            {  0       rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0       rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0       rfu_n0, "same but number is shell number in the element"
            {  0       rfu_t0, "same but number is shell type according to EADL notation"
            {  0       rfu_j,  "shell number of current vacancy"
            {  0       rfu_n,  "same but number is shell number in the element"
            {  0       rfu_t;  "same but number is shell type according to EADL notation"
            {  0      $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0      $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001D0"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0    common/pe_shell_data/
            {  0      pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0      pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0                                             "element of a medium"
            {  0      pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0      pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0      pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0      pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0      pe_zpos($MXELEMENT),       "position of each Z element"
            {  0      pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0      pe_ne;                    "number of elements in the simulation"
            {  0    $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0    $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0      PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0    ;common/ET_control/
            {  0                smaxir($MXREG),estepe,ximax,
            {  0                "ximin_for_bca,"
            {  0                skindepth_for_bca,transport_algorithm,
            {  0                bca_algorithm,exact_bca,spin_effects;
            {  0      $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0                estepe,             "global energy loss constrain"
            {  0                ximax,              "max. first GS moment per step"
            {  0                                    "(roughly half the average MS angle squared"
            {  0                "ximin_for_bca,"
            {  0                                    "min. first GS moment per step for boundary"
            {  0                                    "crossing in VMC mode"
            {  0                skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0                                    "to switch to one of the BCAs "
            {  0      $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0                bca_algorithm;      "will be used if other inexact BCAs"
            {  0                                    "implemented in the future"
            {  0      $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0                spin_effects;       "if .true. electron/positron spin effects"
            {  0                                    "are taken into account in the single and"
            {  0                                    "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0    common/ms_data/
            {  0                ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    real*4      ums_array,fms_array,wms_array,
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0    common/spin_data/
            {  0                spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0                espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0                fool_intel_optimizer;
            {  0    real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0    $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0    common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0    real*8           count_pII_steps,count_all_steps;
            {  0    $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0    COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0                  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0                  x_final,y_final,z_final,
            {  0                  u_final,v_final,w_final,
            {  0                  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0      $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0                        EDEP_LOCAL; "local energy deposition in MeV"
            {  0      $REAL             TSTEP,  "distance to a discrete interaction"
            {  0                        TUSTEP, "intended step length, befor check with geometry"
            {  0                        USTEP,  "transport distance calculated from TUSTEP"
            {  0                        VSTEP,  "transport distance after truncation by HOWFAR"
            {  0                        TVSTEP, "curved path-length calculated from TVSTEP"
            {  0                        RHOF,   "mass density ratio"
            {  0                        EOLD,   "energy before deduction of energy loss"
            {  0                        ENEW,   "energy after  deduction of energy loss"
            {  0                        EKE,    "kinetic energy"
            {  0                        ELKE,   "Log(EKE)"
            {  0                        GLE,    "Log(energy) in PHOTON"
            {  0                        E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0                        x_final,y_final,z_final, "position at end of step"
            {  0                        u_final,v_final,w_final; "direction at end of step"
            {  0                                                 "only set (and relevant) "
            {  0                                                 "for electrons"
            {  0      $INTEGER          IDISC,  "flag indicating user discard"
            {  0                        IROLD,  "region before transport"
            {  0                        IRNEW,  "region after transport"
            {  0                        IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0     COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0         $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0              IRAYLM,IPHOTONUCM($MXMED)),
            {  0              MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0              photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0     $TYPE    MEDIA;"media names"
            {  0     $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0              RLDU, "radiation length after user scaling over-ride"
            {  0              RHO,  "mass density of a given medium"
            {  0              apx, upx;"new photon xsection data thresholds"
            {  0     $INTEGER MSGE, "??? "
            {  0              MGE,  "number of photon mapped energy intervals for a given medium"
            {  0              MSEKE,"??? "
            {  0              MEKE, "number of e mapped energy intervals for a given medium"
            {  0              MLEKE,"??? "
            {  0              MCMFP,"??? "
            {  0              MRANGE,"??? "
            {  0              IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0              IPHOTONUCM,"photonuclear switch for a given medium"
            {  0              IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0              NMED;  "number of media"
            {  0     character*16 eii_xfile;
            {  0              "Defaults to eii_ik.data if On or Off options selected"
            {  0              "which is the EII implemented by Iwan for EGSnrc"
            {  0              "else, following options available: "
            {  0              "  eii_'casnati'.data    "
            {  0              "  eii_'kolbenstvedt'.data "
            {  0              "  eii_'gryzinski'.data"
            {  0              "these must be in $HEN_HOUSE/data"
            {  0     character*16 photon_xsections;
            {  0              "If photon_xsections is not empty, photon cross sections will be"
            {  0              "re-initialized using data files  "
            {  0              "  'photon_xsection'_photo.data   "
            {  0              "  'photon_xsection'_pair.data    "
            {  0              "  'photon_xsection'_triplet.data "
            {  0              "  'photon_xsection'_rayleigh.data"
            {  0              "that must be placed in $HEN_HOUSE/data"
            {  0     character*16 comp_xsections;
            {  0              "If comp_xsections is not empty or not set to 'default' and"
            {  0              "bound Compton scattering is On, then total Compton cross sections"
            {  0              "will be taken from 'comp_xsections'_compton.data"
            {  0              "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0     character*16 photonuc_xsections;
            {  0              "If photonuc_xsections is not empty or not set to 'default',"
            {  0              "the photonuclear cross sections will be taken from"
            {  0              "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0              "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0    COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0             DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0    $REAL    DUNIT,   "unit scaling factor"
            {  0             RHOR;    "density of a given region"
            {  0    $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0             KMPO;    "fortran unit number of pegs4 echo file"
            {  0    $SHORT_INT MED,   "medium number for a given region"
            {  0               IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0               IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0      COMMON/PHOTIN/
            {  0         EBINDA($MXMED),
            {  0         $LGN(GE($MXMED)/0,1/),
            {  0         $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0         $LGN(RCO($MXMED)/0,1/),
            {  0         $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0         $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0         $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0         DPMFP,
            {  0         MPGEM($MXSGE,$MXMED),
            {  0         NGR($MXMED);
            {  0      $REAL
            {  0         EBINDA,      "energy of the K-edge for a given medium"
            {  0         GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0         GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0         GBR10,GBR11, "used for branching into pair interpolation"
            {  0         GBR20,GBR21, "used for branching into Compton interpolation"
            {  0         RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0         RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0         COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0         PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0         DPMFP;       "number of MFP's to go to the next interaction"
            {  0      $INTEGER
            {  0         MPGEM,       "??? "
            {  0         NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0     COMMON/STACK/
            {  0         $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0         LATCHI,NP,NPold;
            {  0     $ENERGY PRECISION
            {  0         E;     "total particle energy"
            {  0     $REAL
            {  0         X,Y,Z, "particle co-ordinates"
            {  0         U,V,W, "particle direction cosines"
            {  0         DNEAR, "perpendicular distance to nearest boundary"
            {  0         WT;    "particle weight"
            {  0     $INTEGER
            {  0         IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0         IR,    "current region"
            {  0         LATCH, "extra phase space variable"
            {  0         LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0         NP,    "stack pointer"
            {  0         NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0     COMMON/THRESH/RMT2,RMSQ,
            {  0                   $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0     $REAL         RMT2,  "2*electron mass in MeV"
            {  0                   RMSQ,  "electron mass squared in MeV**2"
            {  0                   AP,    "photon creation threshold energy"
            {  0                   AE,    "electron creation threshold energy (total)"
            {  0                   UP,    "upper photon energy in PEGS4 data set"
            {  0                   UE,    "upper electron energy in PEGS4 data set"
            {  0                   TE,    "electron creation threshold energy (kinetic)"
            {  0                   THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0     COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0     $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0     COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0                   COSPHI,PI,TWOPI,PI5D2;
            {  0     $REAL         THETA,  "polar scattering angle"
            {  0                   SINTHE, "sin(THETA)"
            {  0                   COSTHE, "cos(THETA)"
            {  0                   SINPHI, "sine of the azimuthal scattering angle"
            {  0                   COSPHI, "cosine of the azimuthal scattering angle"
            {  0                   PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0     COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0     $ENERGY PRECISION PZERO,   "precise zero"
            {  0                       PRM,     "precise electron mass in MeV"
            {  0                       PRMT2;   "2*PRM"
            {  0     $REAL             RM;      "electron mass in MeV"
            {  0     $INTEGER          MEDIUM,  "medium index of current region"
            {  0                       MEDOLD;  "medium index of previous region"
            {  0     " The rest mass value is as recommended by CODATA 2014"
            {  0     " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0     DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0           ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0      ;
            {  0    common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0                     mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0    $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0       ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0      ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0      ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0             EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0      ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0             EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0     ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0     ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0     ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0     ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0            STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0    ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0    ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0    EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0    THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0    ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0         EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0    ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0    ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0    ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0    ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0           BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0      IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0      [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0      [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0    [IF] '{P2}'=SNAME1
            {  0    [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0    [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0    {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0    {P2}2(L{P3},L{P4})*
            {  0    {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0      X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0      WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0     "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0     "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0     "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0     "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0     "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0    ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0    ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0                                    "energy dependent quantities"
            {  0    $CALCULATE-XI(tustep);
            {  0    IF ( xi < 0.1 )
            {  0      [
            {  0        ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        ustep = tustep*(1 - Exp(-xi))/xi;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0    p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0    chia2 = xccl/(4*blccl*p2);
            {  0                                  "Note that our chia2 is Moliere chia2/4"
            {  0                                  "Note also that xcc is now old egs xcc**2"
            {  0    xi = 0.5*xccl/p2/beta2*{P1};
            {  0    IF( spin_effects ) [
            {  0        elkems = Log(ekems);
            {  0        $SET INTERVAL elkems,eke;
            {  0        IF(lelec < 0) [
            {  0            $EVALUATE etap USING etae_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0        ]
            {  0        ELSE          [
            {  0            $EVALUATE etap USING etap_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0        ]
            {  0        chia2 = chia2*etap; xi = xi*xi_corr;
            {  0        $EVALUATE ms_corr USING blcce(elkems);
            {  0        blccl = blccl*ms_corr;
            {  0    ]
            {  0    ELSE [ xi_corr = 1; etap = 1; ]
            {  0    xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0      ;IF ( vstep < ustep0 )
            {  0      [
            {  0        ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0           "This estimates the energy loss to the boundary."
            {  0           "tustep was the intended curved path-length,"
            {  0           "ustep0 is the average transport distance in the initial direction"
            {  0           "       resulting from tustep"
            {  0           "vstep = ustep is the reduced average transport distance in the "
            {  0           "              initial direction due to boundary crossing"
            {  0        $CALCULATE-XI(vstep);
            {  0        IF ( xi < 0.1 )
            {  0        [
            {  0          tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0        ]
            {  0        ELSE
            {  0        [
            {  0
            {  0          IF ( xi < 0.999999 )
            {  0          [
            {  0             tvstep = -vstep*Log(1 - xi)/xi;
            {  0          ]
            {  0          ELSE
            {  0          [
            {  0             "This is an error condition because the average transition "
            {  0             "in the initial direction of motion is always smaller than 1/Q1"
            {  0             $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0             $egs_info(*,' Medium: ',medium);
            {  0             $egs_info(*,' Initial energy: ',eke);
            {  0             $egs_info(*,' Average step energy: ',ekems);
            {  0             $egs_info(*,' tustep: ',tustep);
            {  0             $egs_info(*,' ustep0: ',ustep0);
            {  0             $egs_info(*,' vstep:  ',vstep);
            {  0             $egs_info(*,' ==> xi = ',xi);
            {  0             $egs_fatal(*,'This is a fatal error condition');
            {  0          ]
            {  0        ]
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        tvstep = tustep;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0              "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0              "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-8}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-8}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0      ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0      $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0     ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0     $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0    IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0     ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0     IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0     (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0     4E14.6);
            {  0     IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0     USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0      IF(ustep <= 0) [
            {  0          "Negative ustep---probable truncation problem at a"
            {  0          "boundary, which means we are not in the region we think"
            {  0          "we are in.  The default macro assumes that user has set"
            {  0          "irnew to the region we are really most likely to be"
            {  0          "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0          IF(ustep < -1e-4) [
            {  0              ierust = ierust + 1;
            {  0              OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0                     ir(np),irnew,irold,x(np),y(np),z(np);
            {  0              (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0               ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0              IF(ierust > 1000) [
            {  0                  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0                  $CALL_EXIT(1);
            {  0              ]
            {  0          ]
            {  0          ustep = 0;
            {  0      ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0           $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0     WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0          $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0           DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0         $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0           DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0    ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0        IF(tperp >= range) ["particle cannot escape local region"
            {  0            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0            go to :USER-ELECTRON-DISCARD: ;
            {  0        ]
            {  0    ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0                              fcum($MXRAYFF,$MXMED),
            {  0                             b_array($MXRAYFF,$MXMED),
            {  0                             c_array($MXRAYFF,$MXMED),
            {  0                             i_array($RAYCDFSIZE,$MXMED),
            {  0                             $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0       ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0      GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0        ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0     $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0     Q2=X2*RMSQ/(20.60744*20.60744);
            {  0     COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0     IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0     CSQTHE=COSTHE*COSTHE;
            {  0     REJF=(1.0+CSQTHE)/2.0;
            {  0     $RANDOMSET RNNORJ;
            {  0     ] UNTIL (RNNORJ <= REJF);
            {  0     SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0    }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0     ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0     CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0       ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0      GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0     ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0        $RANDOMSET RNNO39;
            {  0        IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0          $AUSCALL($PHOTONUCAUSB);
            {  0          call PHOTONUC;
            {  0          $AUSCALL($PHOTONUCAUSA);
            {  0          GOTO :PNEWENERGY:;
            {  0        ]
            {  0      ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0  REPLACE {$EMFIELD_INITIATE_SET_TUSTEP;} WITH {;}
               0  REPLACE {;COMIN/EM/;} WITH {;}
               0  REPLACE {$EMFIELD_PII;} WITH {;}
               0  REPLACE{$EMFIELD_PI;}WITH{;}
               0  REPLACE{$EM_FIELD_SS;}WITH{;}
               0  REPLACE{$ADD_WORK_EM_FIELD;}WITH{;}
               0  REPLACE{$EMFieldInVacuum;}WITH{;}
               0  REPLACE{$EM_MACROS_ACTIVE}WITH{.false.}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0        ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0        $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0   UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0   V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0   IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0   [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0   (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0   (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0   (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0   [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0   [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0      $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0     $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0     IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0     ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0     $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0     IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0     BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0     -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0     IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0     {P4}=-2.0*BCYL/ACYL;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0     [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0     ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0     ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0   $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0     ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0     $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0     {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0     CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0     WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0     CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0     DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0     ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0     BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0     CCON=DCON1*CPCON-ZNP*ZNP;
            {  0     IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0     [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0     IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0     TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0     [{P4}=TCON1;{P3}=1;]]]]]
            {  0     ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0     IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0     [BPRIM=BCON1-WNP*DCON2;
            {  0     IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0     IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0     [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0     IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0     IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0     ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0     IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0     ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0     IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0     IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0     ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0     TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0     IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0     ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0     [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0     ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0     $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0     BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0     +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0     IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0     {P4}=-2.0*BSPH/ASPH;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0     [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0     [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0   $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0      ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0     {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0     {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0    EELEC=E(NP);
            {  0    IF(EELEC.GT.ECUT(IR(NP)))[
            {  0      BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0      GAMMA=EELEC/RM;
            {  0      ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0      RATIO=BETA/ALPHA;
            {  0      LOOP[
            {  0        $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0        IF(RATIO.LE.0.2)[
            {  0          FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0          IF( gamma < 100 ) [
            {  0              COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0          ]
            {  0          ELSE [
            {  0              IF( fkappa > 0 ) [
            {  0                  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0              ]
            {  0              ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0          ]
            {  0          "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0          "                            at high energies, IK"
            {  0          xi = (1+beta*fkappa)*gamma*gamma;
            {  0        ]
            {  0        ELSE[
            {  0          XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0          COSTHE=(1.-1./XI)/BETA;
            {  0        ]
            {  0        SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0        $RANDOMSET RNPHT2;
            {  0        ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0      SINTHE=SQRT(SINTH2);
            {  0      CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0                  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0      IF( iprdst > 0 ) [
            {  0          IF( iprdst = 4 ) [
            {  0              $RANDOMSET rtest;
            {  0              "gbeta = (1-rmt2/eig)**8;"
            {  0              gbeta = PESE1/(PESE1+10);
            {  0              IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0              ELSE [ iprdst_use = 4; ]
            {  0          ]
            {  0          ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0          ELSE [ iprdst_use = iprdst; ]
            {  0          DO ichrg = 1,2 [
            {  0              IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0                  ESE=ESE2;
            {  0                  IF( iprdst = 4 ) [
            {  0                      gbeta = ESE/(ESE+10);
            {  0                      $RANDOMSET rtest;
            {  0                      IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0                      ELSE [ iprdst_use = 4; ]
            {  0                  ]
            {  0              ]
            {  0              IF( iprdst_use = 1 ) [
            {  0                  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0                  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 2 ) [
            {  0                  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0                  ZTARG=ZBRANG(MEDIUM);
            {  0                  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTEIG=EIG/RM;
            {  0                  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTESE=ESE/RM;
            {  0                  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0                  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0                  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0                  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0                  ESEDER=1.0/ESEDEI;
            {  0                  "DETERMINE THE NORMALIZATION "
            {  0                  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0                  YA=(2.0/TTEIG)**2;
            {  0                  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0                  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0                  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0                  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0                  XIMID=GALPHA/(3.0*GBETA);
            {  0                  IF(GALPHA.GE.0.0)[
            {  0                      XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  ELSE[
            {  0                      XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0                  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0                  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0                  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0                  LOOP[
            {  0                      $RANDOMSET XITST;
            {  0                      $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0                      $RANDOMSET RTEST;
            {  0                      "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0                      THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0                      "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0                      REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0                  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0                  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 3 ) [
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0              ]
            {  0              ELSE [
            {  0                  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0                  "$RANDOMSET costhe;"
            {  0                  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0                  $RANDOMSET costhe;
            {  0                  costhe=1-2*sqrt(costhe);
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0              ]
            {  0              IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0              ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0          ]
            {  0          iq(np) = iq2; iq(np-1) = iq1; return;
            {  0      ]
            {  0      ELSE[
            {  0          THETA=0; "THETA=RM/EIG; "
            {  0      ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0          4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0              1.0+0.25*LOG(
            {  0                  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0                  )
            {  0              )
            {  0          ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0    $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0    PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0    elktmp = elke + Log(1 - {P1});
            {  0    $SET INTERVAL elktmp,eke;
            {  0    lelktmp = max(1,lelktmp);
            {  0    IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0    ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0    dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0                     "0.17408298 is 2/3*m**2"
            {  0    {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0    "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0    "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0                                          "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Uniform Run Control (URC) is false by default"
               0  REPLACE {$URC-DEFAULT} WITH {.false.}
               0  ;
               0  "SLEEP INTERVAL for URC (1 s by default)"
               0  "Time to wait for jobs to complete after last job finished"
               0  REPLACE {$URC-SLEEP} WITH {1}
               0  "Times to check for jobs to complete after last job finished"
               0  REPLACE {$URC-INTERVALS} WITH {1}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0              "This macro sets the minimum step size for a condensed"
               0              "history (CH) step. When the exact BCA is used, the minimum"
               0              "CH step is determined by efficiency considerations only"
               0              "At about 3 elastic MFP's single scattering becomes more"
               0              "efficient than CH and so the algorithm switches off CH"
               0              "If one of the various inexact BCA's is invoked, this macro"
               0              "provides a simple way to include more sophisticated"
               0              "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0     $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0     skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0      blccl = rhof*blcc(medium);
            {  0      xccl  = rhof*xcc(medium);
            {  0      p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0      IF ( spin_effects ) [
            {  0        IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0        ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0        $EVALUATE ms_corr USING blcce({P3});
            {  0        blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0      ]
            {  0      {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0      $SET-SCREENING-ANGLE({P1});
            {  0      call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0      chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0    IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0    IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0      (
            {  0          ' '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' PRESTA-II is aborting execution because you have not defined   '/
            {  0          ' the HOWNEAR macro for your geometry.                           '/
            {  0          ' '/
            {  0          ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0          ' which does not attempt the refined boundary crossing or lateral'/
            {  0          ' correlation features of the algorithm.                         '/
            {  0          ' '/
            {  0          ' If you include the following macro in your usercode:           '/
            {  0          ' '/
            {  0          ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0          ' '/
            {  0          ' you can choose between single scattering mode (very slow) and  '/
            {  0          ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0          ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0          ' manual)                                                        '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' '/
            {  0      );
            {  0      stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0                                          "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0      $RANDOMSET xphi;
            {  0      xphi  = 2*xphi - 1;
            {  0      xphi2 = xphi*xphi;
            {  0      $RANDOMSET yphi;
            {  0      yphi2  = yphi*yphi;
            {  0      rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0    $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PAVIP,    "precise total energy in the laboratory frame"
            {  0        PESG1,    "precise energy of 1st annihilation photon"
            {  0        PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0        A,        "total energy in units of the electron's rest energy"
            {  0        G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0        POT,      "P/T"
            {  0        EP0,      "minimum fractional energy"
            {  0        WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0        RNNO01,   "random numbers"
            {  0        RNNO02,
            {  0        EP,       "fractional energy of the more energetic photon"
            {  0        REJF,     "rejection function"
            {  0        ESG1,     "energy of the more energetic photon"
            {  0        ESG2,     "energy of the less energetic photon"
            {  0        aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0                  "for inline rotations"
            {  0  $INTEGER
            {  0        ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIP,     "precise total energy of incident positron"
            {  0        PEKIN,    "precise kinetic energy of incident positron"
            {  0        PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0        PESE1,    "precise total energy of first 'electron'"
            {  0        PESE2,    "precise total energy of second 'electron'"
            {  0        H1,       "used in direction cosine calculations"
            {  0        DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0        EKIN,     "kinetic energy of incident positron"
            {  0        T0,       "kinetic energy of incident positron in units of RM"
            {  0        E0,       "total energy of incident positron in units of RM"
            {  0        E02,      "E0**2"
            {  0        YY,       "1/(T0+2)"
            {  0        Y2,YP,YP2,"various functions of YY"
            {  0        BETA2,    "incident positron velocity in units of c"
            {  0        EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0        EP0C,     "1-EP0"
            {  0        B1,B2,B3,B4,  "used in rejection function calculation"
            {  0        RNNO03,RNNO04,"random numbers"
            {  0        BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0        REJF2,    "rejection function"
            {  0        ESE1,     "total energy of 1st 'electron'"
            {  0        ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0    PEIE,   "precise incident electron energy"
            {  0    PESG,   "presice energy of emitted photon"
            {  0    PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0    EIE,    "total incident electron energy"
            {  0    EKIN,   "kinetic incident energy"
            {  0    brmin,  " ap(medium)/ekin"
            {  0    waux,   "for faster sampling of 1/br"
            {  0    aux,    "ese/eie"
            {  0    r1,     "a random number"
            {  0    ajj,    "for energy bin determination if alias sampling is employed"
            {  0    alias_sample1,
            {  0    RNNO06, "random number"
            {  0    RNNO07, "random number"
            {  0    BR,     "energy fraction of secondary photon"
            {  0    ESG,    "energy of secondary photon"
            {  0    ESE,    "total energy of secondary electron"
            {  0    DELTA,  "scaled momentum transfer"
            {  0    phi1,   "screening function"
            {  0    phi2,   "screening function"
            {  0    REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0    a,b,c,  "direction cosines of incident `electron'"
            {  0    sinpsi, sindel, cosdel, us, vs,
            {  0            "all used for rotations"
            {  0    ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0    tteie,  "total energy in units of rest energy"
            {  0    beta,   "electron velocity in units of speed of light"
            {  0    y2max,  "maximum possible scaled angle"
            {  0    y2maxi, "inverse of the above"
            {  0    ttese,  "new electron energy in units of rm"
            {  0    rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0            "all of them used for angle rejection function calcs"
            {  0    esedei, "new total energy over old total energy"
            {  0    y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0    y2tst1,
            {  0    rtest,  "random number for rejection"
            {  0    xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0            "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0    L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIE,  "total incident electron energy in units of RM"
            {  0        TTESE,  "total scattered electron energy in units of RM"
            {  0        ESEDEI, "TTESE/TTEIE"
            {  0        beta,   "electron speed in units of c"
            {  0        Y2MAX,  "maximum value of the scaled angle"
            {  0        RJARG1,RJARG2,RJARG3,
            {  0                "arguments for which the rejection function is calculated"
            {  0        REJMIN,REJMID,REJMAX,
            {  0                "corresponding values of the rejection function"
            {  0        REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0        Y2TST,  "random number and candidate for a scaled angle"
            {  0        REJTST, "rejection function at Y2TST"
            {  0        Y2TST1, "aux. variable for rejection function calculation"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        Jo,     "the Compton profile parameter"
            {  0        br2,    "br*br"
            {  0        fpz,fpz1,"used for limited pz-range rejection"
            {  0        qc,     "momentum transfer corresponding to the Compton line energy"
            {  0        qc2,    "qc squared"
            {  0        af,     "for calculating F"
            {  0        Fmax,   "maximum of F"
            {  0        frej,   "used for F-rejection"
            {  0        eta_incoh, eta, "random numbers"
            {  0        aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0        pzmax,  "max. possible z-component of the initial electron momentum"
            {  0        pz,     "initial electron momentum projection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        br2,    "br*br"
            {  0        aux,aux1,aux2,"aux. variables"
            {  0        pzmax2, "max. possible momentum transfer squared"
            {  0        pz,     "momentum transfer prejection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0      demfp,        "differential electron mean free path"
            {  0      peie,         "precise energy of incident electron"
            {  0      total_tstep,  "total path-length to next discrete interaction"
            {  0      total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0      ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0      elkems,     "Log(ekems)"
            {  0      chia2,      "Multiple scattering screening angle"
            {  0      etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0      lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0      blccl,      "blcc(medium)*rhof"
            {  0      xccl,       "xcc(medium)*rhof"
            {  0      xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0      xi_corr,    "correction to xi due to spin effects"
            {  0      ms_corr,
            {  0      p2,         "electron momentum times c, squared"
            {  0      beta2,      "electron speed in units of c, squared"
            {  0      de,         "energy loss to dedx"
            {  0      save_de,    "de saved before $DE-FLUCTUATION"
            {  0      dedx,       "stopping power after density scaling"
            {  0      dedx0,      "stopping power before density scaling"
            {  0      dedxmid,    "stopping power at mid-step before density scaling"
            {  0      ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      aux,        "aux. variable"
            {  0      ebr1,       "e- branching ratio into brem"
            {  0      eie,        "energy of incident electron"
            {  0      ekef,       "kinetic energy after a step"
            {  0      elkef,      "Log(ekef)"
            {  0      ekeold,     "kinetic energy before a step"
            {  0      eketmp,     "used to evaluate average kinetic energy of a step"
            {  0      elktmp,     "log(eketmp)"
            {  0      fedep,      "fractional energy loss used in stopping power calculation"
            {  0      tuss,       "sampled path-length to a single scattering event"
            {  0      pbr1,       "e+ branching ratio into brem"
            {  0      pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0      range,      "electron range"
            {  0      rfict,      "rejection function for fictitious cross section"
            {  0      rnne1,      "random number"
            {  0      rnno24,     "random number"
            {  0      rnno25,     "random number"
            {  0      rnnotu,     "random number"
            {  0      rnnoss,     "random number"
            {  0      sig,        "cross section after density scaling but before a step"
            {  0      sig0,       "cross section before density scaling but before a step"
            {  0      sigf,       "cross section before density scaling but after a step"
            {  0      skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0      ssmfp,      "distance of one single elastic scattering mean free path"
            {  0      tmxs,       "electron step-size restriction"
            {  0      tperp,      "perpendicular distance to the closest boundary"
            {  0      ustep0,     "temporary storage for ustep"
            {  0      uscat,      "x-axis direction cosine for scattering"
            {  0      vscat,      "y-axis direction cosine for scattering"
            {  0      wscat,      "z-axis direction cosine for scattering"
            {  0      xtrans,     "final x-axis position after transport"
            {  0      ytrans,     "final y-axis position after transport"
            {  0      ztrans,     "final z-axis position after transport"
            {  0      cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0      iarg,      "calling code for ausgab"
            {  0      idr,       "calling code for ausgab"
            {  0      ierust,    "error counter for negative ustep errors"
            {  0      irl,       "region number"
            {  0      lelec,     "charge of electron"
            {  0      qel,       " = 0 for electrons, = 1 for positrons "
            {  0      lelke,     "index into the energy grid of tabulated functions"
            {  0      lelkems,   "index into the energy grid of tabulated functions"
            {  0      lelkef,    "index into the energy grid of tabulated functions"
            {  0      lelktmp,   "index into the energy grid of tabulated functions"
            {  0      ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0      "BCA = boundary crossing algorithm"
            {  0      callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0                  "= .false. => BCA does not require a call to howfar"
            {  0      domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0      dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0                  "= .false. => exact BCA requires no single scattering"
            {  0      callmsdist, "= .true.  => normal condensed-history transport"
            {  0                  "= .false. => one of the BCA's will be invoked"
            {  0      findindex,  "used for mscat"
            {  0      spin_index, "used for mscat with spin effects"
            {  0      compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0      ACD   , "used to test goodness of sine-table look-up"
            {  0      ADEV  , "absolute deviation in sine-table look-up"
            {  0      ASD   , "used to test goodness of sine-table look-up"
            {  0      COST  , "cos(theta) from instrinsic library function"
            {  0      CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0      DEL   , "leat squares delta for sine-table look-up"
            {  0      DFACT , "converts rl to dunits"
            {  0      DFACTI, "converts rl**-1 to dunits**-1"
            {  0      DUNITO, "units scaling varable"
            {  0      DUNITR, "saved value of dunit"
            {  0      FNSSS , "real form of integer nsinss"
            {  0      P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0      PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0      RDEV  , "relative deviation in sine-table look-up"
            {  0      S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0      S2C2MN, "min(s2c2)"
            {  0      S2C2MX, "max(s2c2)"
            {  0      SINT  , "sin(theta) from instrinsic library function"
            {  0      SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0      SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0      SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0              "table errors"
            {  0      SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0              "errors"
            {  0      WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0      XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0      XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0      WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0      YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0      ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0      I     , "generic do-loop variable"
            {  0      I1ST  , "flag = 0 on first pass"
            {  0      IB    , "do-loop variable used for reading the medium type"
            {  0      ID    , "integer value of -dunit, when dunit is negative"
            {  0      IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0      IL    , "do-loop variable used for reading the medium type"
            {  0      IM    , "do-loop variable looping over nmed, number of media"
            {  0      IRAYL , "Rayleigh switch read in from PEGS"
            {  0      IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0      ISTEST, "flag that switches on test of sine function fit"
            {  0      ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0      ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0      IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0              "sine-table look-up"
            {  0      IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0      J     , "do-loop variable looping over nmed, number of media"
            {  0      JR    , "do-loop variable looping over number of regions"
            {  0      LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0      LMDL  , "character width of medium header ' MEDIUM='"
            {  0      LMDN  , "character width of medium description"
            {  0      LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0      MD    , "temporary storage for the medium number"
            {  0      MXSINC, "number of intervals approximating the sine function"
            {  0      NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be cumulative electron mean free path. Presently unused."
            {  0      NEKE  , "array size input from PEGS."
            {  0              "Number of electron mapped energy intervals."
            {  0      NGE   , "array size input from PEGS."
            {  0              "Number of photon mapped energy intervals."
            {  0      NGRIM , "Rayleigh cross section array size."
            {  0      NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0      NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron energy intervals below threshold."
            {  0              "Presently unused."
            {  0      NM    , "number of media found in the "
            {  0      NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of intervals in an array giving the electron range."
            {  0              "Presently unused."
            {  0      NRNA  , "number of random angles testing sine function fit"
            {  0      NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron small energy intervals. Presently unused."
            {  0      NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of gamma small energy intervals. Presently unused."
            {  0      NSINSS, "number of sub-intervals for each sine function interval"
            {  0      LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0                   "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0       PEIE,   "precise total energy of incident electron"
            {  0       PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0       PESE1,  "precise total energy of 1st secondary electron"
            {  0       PESE2,  "precise total energy of 2nd secondary electron"
            {  0       PEKIN,  "precise kinetic energy of incident electron"
            {  0       H1,     "used for polar scattering angle calculation"
            {  0       DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0       EKIN,   "kinetic energy of incident electron"
            {  0       T0,     "kinetic energy of incident electron in units of RM"
            {  0       E0,     "total energy of incident electron in units of RM"
            {  0       EXTRAE, "energy above the Moller threshold"
            {  0       E02,    "E0**2"
            {  0       EP0,    "minimum alowed kinetic energy fraction"
            {  0       G2,G3,  "used for rejection function calculation"
            {  0       GMAX,   "maximum value of the rejection function"
            {  0       BR,     "kinetic energy fraction to lowew energy electron"
            {  0       R,      "(1-BR)/BR"
            {  0       REJF4,  "rejection function"
            {  0       RNNO27, "random number for BR sampling"
            {  0       RNNO28, "random number for rejection"
            {  0       ESE1,   "energy of 1st secondary electron"
            {  0       ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,      "precise energy of incident photon"
            {  0        PESE1,     "precise energy of 1st 'electron'"
            {  0        PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0        ESE2,      "total energy of lower energy 'electron'"
            {  0        RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0                   "random numbers"
            {  0        DELTA,     "scaled momentum transfer"
            {  0        REJF,      "screening rejection function"
            {  0        rejmax,    "the maximum of rejf"
            {  0        aux1,aux2, "auxilary variables"
            {  0        Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0        Bmax,      "Maximum of the screening function used with the uniform part"
            {  0        del0,      "delcm*eig"
            {  0        br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0                   "lower energy `electron'"
            {  0        Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0        L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0        PSE,   "momentum corresponding to ESE"
            {  0        ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIG, "incident photon energy in units of RM"
            {  0        TTESE, "energy of one of the 'electrons' in units of RM"
            {  0        TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0        ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0        ESEDER,"1/ESEDEI"
            {  0        XIMIN, "1st argument where rejection function might have a maximum"
            {  0        XIMID, "2nd argument where rejection function might have a maximum"
            {  0        REJMIN,"rejection function at XIMIN"
            {  0        REJMID,"rejection function at XIMID"
            {  0        REJTOP,"max(REJMIN,REJMID)"
            {  0        YA,XITRY,GALPHA,GBETA,
            {  0               "aux. variables for XIMID calculation"
            {  0        XITST, "random number for pair angle sampling"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        REJTST,"rejection function at XITST"
            {  0        RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0        ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0        PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0        sigma,        "elemental cross section"
            {  0        aux,aux1,     "aux. variables"
            {  0        probs($MXEL), "probability for an interaction with a given element"
            {  0        sigtot,       "total cross section"
            {  0        e_vac,        "shell binding energy"
            {  0        rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0        IARG,         "AUSGAB calling switch"
            {  0        iZ,           "Atomic number of the element the photon is "
            {  0                      "interactiong with"
            {  0        irl,          "local region number"
            {  0        ints($MXEL),  "energy interval number for a given element"
            {  0        j,ip,         "loop variables"
            {  0        n_warning,    "a warning counter"
            {  0        k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0        do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0        BETA,  "velocity of electron in units of c"
            {  0        GAMMA, "total energy of photo-electron in units of RM"
            {  0        ALPHA, "kinematic factor"
            {  0        RATIO, "=BETA/ALPHA"
            {  0        RNPHT, "random number"
            {  0        FKAPPA,"aux. variable for COSTHE calculation"
            {  0        XI,    "used in rejection function calculation"
            {  0        SINTH2,"SINTHE**2"
            {  0        RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0        "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0      PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0      EIG,    "photon energy"
            {  0      RNNO35, "random number for default MFP selection"
            {  0      GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0      GMFP,   "photon MFP after density scaling"
            {  0      COHFAC, "Rayleigh scattering correction"
            {  0      RNNO37, "random number for Rayleigh scattering selection"
            {  0      XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0      X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0      Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0      CSQTHE, "COSTHE**2"
            {  0      REJF,   "Rayleigh scattering rejection function"
            {  0      RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0      RNNO36, "random number for interaction branching"
            {  0      GBR1,   "probability for pair production"
            {  0      GBR2,   "probability for pair + compton"
            {  0      T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0      PHOTONUCFAC, "photonuclear correction"
            {  0      RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0      IARG,   "parameter for AUSGAB"
            {  0      IDR,    "parameter for AUSGAB"
            {  0      IRL,    "region number"
            {  0      LGLE,   "index for GMFP interpolation"
            {  0      LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0     IF( sig_ismonotone(qel,medium) ) [
            {  0         $EVALUATE-SIGF; sig0 = sigf;
            {  0     ]
            {  0     ELSE [
            {  0         IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0         ELSE            [sig0 = psig_e(medium);]
            {  0     ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0    IF(lelec < 0)
            {  0    [
            {  0        $EVALUATE sigf USING esig(elke);
            {  0        $EVALUATE dedx0 USING ededx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0    ELSE
            {  0    [
            {  0        $EVALUATE sigf USING psig(elke);
            {  0        $EVALUATE dedx0 USING pdedx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0      $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0      $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0      $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0     sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0    IF( compute_tstep ) [
            {  0      total_de = demfp/sig; fedep = total_de;
            {  0      ekef  = eke - fedep;
            {  0      IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0      ELSE
            {  0      [
            {  0        elkef = Log(ekef);
            {  0        $SET INTERVAL elkef,eke;
            {  0        IF( lelkef = lelke )
            {  0        [       " initial and final energy are in the same interpolation bin "
            {  0            $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0        ]
            {  0        ELSE
            {  0        [   " initial and final energy are in different interpolation bins, "
            {  0            " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0            " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0            ekei = E_array(lelke,medium);
            {  0            elkei = (lelke - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0            ekei = E_array(lelkef+1,medium);
            {  0            elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0            tstep=tstep+tuss+
            {  0                    range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0        ]
            {  0      ]
            {  0      total_tstep = tstep;
            {  0      compute_tstep = .false.;
            {  0    ]
            {  0    tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0    fedep = 1 - {P2}/{P1};
            {  0    elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0             " the above evaluates the logarithm of the midpoint energy"
            {  0    lelktmp = {P3};
            {  0    IF(lelec < 0) [
            {  0        $EVALUATE dedxmid USING ededx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = ededx1(lelktmp,medium)*dedxmid;
            {  0        "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0        "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0    "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0    {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0    ekei = E_array(lelke,medium);
            {  0    elkei = (lelke - eke0(medium))/eke1(medium);
            {  0    $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0    range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0    demfp = demfp - save_de*sig;
            {  0    total_de = total_de - save_de;
            {  0    total_tstep = total_tstep - tvstep*rhof;
            {  0    IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0    IF( lelec < 0 ) [
            {  0        $EVALUATE dedxmid USING ededx({P3});
            {  0        aux = ededx1({P4},medium)/dedxmid;
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx({P3});
            {  0        aux = pdedx1({P4},medium)/dedxmid;
            {  0    ]
            {  0
            {  0
            {  0
            {  0    {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0                              "rhof scaling must be done here and NOT in "
            {  0                              "$COMPUTE-ELOSS-G below!"
            {  0    fedep = {P5}/{P2};
            {  0    {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0               0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0    tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0      " here tuss is the range between the initial energy and the next lower "
            {  0      " energy on the interpolation grid "
            {  0    IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0        $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0        "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0        "    $COMPUTE-ELOSS above!                                  "
            {  0    ]
            {  0    ELSE [ " Must find first the table index where the step ends using "
            {  0           " pre-calculated ranges                                     "
            {  0        lelktmp = {P4};
            {  0        tuss = (range - {P1})*rhof;
            {  0           " now tuss is the range of the final energy electron "
            {  0           " scaled to the default mass density from PEGS4      "
            {  0        IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0          " i.e., if the step we intend to take is longer than the particle "
            {  0          " range, the particle energy goes down to the threshold "
            {  0          "({P2} is the initial particle energy)  "
            {  0          "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0          "to deal with such large eloss fractions => changed July 2005."
            {  0        ELSE [
            {  0            WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0                lelktmp = lelktmp - 1; ]
            {  0            elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0            eketmp = E_array(lelktmp+1,medium);
            {  0            "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0            "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0            "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0            tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0            $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0            {P5} = {P5} + {P2} - eketmp;
            {  0        ]
            {  0    ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0    ;COMMON/GetInput/
            {  0          ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0                                     "array index(0:4) for a value sought"
            {  0          VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0          CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0          VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0          DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0          VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0          VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0          NVALUE($NMAX),             "Number of values per value sought  "
            {  0          TYPE($NMAX),               "Type of the value sought           "
            {  0                                     "0 for integer                      "
            {  0                                     "1 for real                         "
            {  0                                     "2 for character                    "
            {  0                                     "3 for character with allowed_inputs"
            {  0          ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0                                     "attempted inputs                   "
            {  0          i_errors,                  "Unit no. for .errors output file   "
            {  0          NMIN, NMAX,                "Minimum and maximum index number of"
            {  0                                     "the values sought                  "
            {  0          ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0          DELIMETER;                 "Name of the delimeter              "
            {  0     character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0               CHAR_VALUE*$STRING256,DELIMETER*$STRING32;
            {  0     $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0     $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0                          "Suppresses warnings from Intel compiler on Windows"
               0                     "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0    common/egs_vr/
            {  0      e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0      prob_RR,          "probability for survival in R. Roulette"
            {  0      nbr_split,        "do brems splitting if > 1"
            {  0      i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0      i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0                        "eliminated by RR in this interaction"
            {  0      n_RR_warning,     "a counter for user errors"
            {  0      i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0    $REAL          e_max_rr,prob_RR;
            {  0    $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0    $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0    i_survived_RR = 0;   "flag all survive"
            {  0    ;IF( i_play_RR = 1 ) [
            {  0        IF( prob_RR <= 0 ) [
            {  0            IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0              n_RR_warning = n_RR_warning + 1;
            {  0              OUTPUT prob_RR;
            {  0    ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0            ]
            {  0        ]
            {  0        ELSE [
            {  0            ip = {P1};
            {  0            LOOP [     "handle all particles from p1 to np"
            {  0                IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0                    $RANDOMSET rnno_RR;
            {  0                    IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0                        wt(ip) = wt(ip)/prob_RR;
            {  0                        ip = ip + 1; "increase local pointer"
            {  0                    ]
            {  0                    ELSE [                    "particle killed"
            {  0                        ;i_survived_RR = i_survived_RR + 1;
            {  0                        ;IF(ip < np) [
            {  0                            "=>replace it with last particle on stack"
            {  0                            e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0                        ]
            {  0                        np = np-1; "reduce stack by one=> particle gone"
            {  0                    ] "end of kill particle block"
            {  0                ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0            ] UNTIL (ip > np);
            {  0            "loops until either np is decreased to ip, or ip increased to np"
            {  0            IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0                           " so that the transport routines can exit properly"
            {  0                np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0            ]
            {  0        ] "end of russian roulette block"
            {  0    ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0      IF( radc_flag = 1 ) [
            {  0          $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0          $egs_info(*,'without having included rad_compton1.mortran');
            {  0          $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0          radc_flag = 0;
            {  0      ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0          ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0          ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0    DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0    $warning('(/a)','***************** Warning: ');
            {  0    $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0  "****************************************************************"
               0  " Useful output macros that do not rely on standard output unit. "
               0  " Useful for debugging code after egs_finish call which closes   "
               0  " all open units (for instance after a parallel job finishes).   "
               0  "****************************************************************"
               0  REPLACE {$egs_track2(#,#,#,#);} WITH {
            {  0        open({P1},file={P2},action='write',position='append');
            {  0        write({P1},{P3}) {P4};
            {  0        $FLUSH_UNIT({P1});
            {  0        close({P1});
            {  0  };
               0  REPLACE {$egs_track1(#,#,#);} WITH {
            {  0        open(666,file={P1},action='write',position='append');
            {  0        write(666,{P2}) {P3};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  REPLACE {$egs_track0(#,#);} WITH {
            {  0        open(666,file='track.log',action='write',position='append');
            {  0        write(666,{P1}) {P2};
            {  0        $FLUSH_UNIT(666);
            {  0        close(666);
            {  0  };
               0  "************************************************************"
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0    common /egs_io/ file_extensions($mx_units),
            {  0                    file_units($mx_units),
            {  0                    user_code,  "The name of the user code"
            {  0                    input_file, "The input file name with path but no extension"
            {  0                    output_file,"Same as above but for output"
            {  0                    pegs_file,  "The pegs file name with path and extension"
            {  0                    hen_house,  "The HEN_HOUSE directory"
            {  0                    egs_home,   "The EGS_HOME directory"
            {  0                    work_dir,   "The working directory within the user code dir."
            {  0                    host_name,  "The name of the host"
            {  0                    n_parallel, "if >0, number of parallel jobs"
            {  0                    i_parallel, "if >0, parallel job number"
            {  0                    first_parallel,"first parallel job (default is 1)"
            {  0                    n_max_parallel,"if parallel run, max. number of running jobs"
            {  0                    n_chunk,    "Histories per calculation chunk"
            {  0                    n_files,
            {  0                    i_input,    "unit no. for .egsinp if required"
            {  0                    i_log,      "unit no. for .egslog if required"
            {  0                    i_incoh,    "unit no. for Compton data"
            {  0                    i_nist_data, "unit no. for NIST data"
            {  0                    i_mscat,     "unit no. for multiple scattering data"
            {  0                    i_photo_cs,  "unit no. for photon cross-section data"
            {  0                    i_photo_relax,  "unit no. for photon relaxation data"
            {  0                    xsec_out,       "switches on/off xsection file output"
            {  0                    is_batch,       "True for batch mode"
            {  0                    is_uniform_run, "True for uniform parallel run control"
            {  0                    is_pegsless;    "true if you are running without pegs file"
            {  0    character input_file*256, output_file*256, pegs_file*256,
            {  0              file_extensions*$max_extension_length,
            {  0              hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0              host_name*64;
            {  0    $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0              n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0              i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0    $LOGICAL  is_batch, is_pegsless, is_uniform_run;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0    $set_string(egs_home,' ');
            {  0    call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0      ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0      ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0      iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0      iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0      smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0      i_do_rr(i) = 0;               "range rejection flag"
            {  0      e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0      med(i) = 1;                   "default medium"
            {  0      rhor(i) = 0;                  "default mass density"
            {  0      iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0      iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0          "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0          IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0      ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        medium = med(j);
            {  0        IF( medium > 0 & medium <= nmed) [
            {  0            IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0    ecutmn = 1e30;
            {  0    DO i=1,$MXREG [
            {  0        IF( med(i) > 0 & med(i) <= nmed ) [
            {  0                  ecutmn = Min(ecutmn,ecut(i));
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0      IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc timing macros                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$DECLARE_TIMING_VARIABLES;} WITH {;
            {  0    real  CPUT0,CPUT1,CPUT2,TDUM;
            {  0    real egs_tot_time, egs_etime;}
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_CPU_TIME;} WITH {;}
               0  ;
               0  REPLACE {$SET_ELAPSED_CPUTIME(#);} WITH { {P1}=egs_etime(); }
               0  ;
               0  REPLACE {$INITIALIZE_ELAPSED_TOTAL_TIME;} WITH
               0    { tdum = egs_tot_time(1); }
               0  ;
               0  REPLACE {$SET_ELAPSED_TOTAL_TIME(#);} WITH
               0    { {P1} = egs_tot_time(0); }
               0  ;
               0  REPLACE {$CONVERSION_TO_SECONDS} WITH {1.0}
               0  ;
               0  REPLACE {$TIME_RESOLUTION} WITH {0.01}
               0  ;
1              0  %E
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on Mon Feb  5 11:05:46 PM EST 2024         "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/home/public/EGSnrc/HEN_HOUSE/specs/linux.conf'};
               0
               0  REPLACE {$CONFIG_TIME} WITH
               0  {'2024-02-06 04:05:46 UTC'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for ranmar random number generator                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Implementation for EGSnrc of the RANMAR random number generator (RNG),     "
               0  "  proposed by Marsaglia and Zaman.                                           "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  To use this set of macros, you need to initialize the RNG by a call to     "
               0  "  init_ranmar (in ranmar.mortran) or read-in a valid RNG state using the     "
               0  "  macro $RETRIEVE RNG STATE FROM UNIT #;                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$NRANMAR} WITH {128}
               0  REPLACE {;COMIN/RANDOM/;} WITH
               0  {;
            {  0  common/randomm/ rng_array($NRANMAR), urndm(97), crndm, cdrndm, cmrndm,
            {  0  i4opt, ixx, jxx, fool_optimizer, twom24, rng_seed;
            {  0  integer*4       urndm, crndm, cdrndm, cmrndm, i4opt,
            {  0  ixx, jxx, fool_optimizer,rng_seed,rng_array;
            {  0  real*4          twom24;
            {  0  }
               0  "in the above, rng_seed is typed and part of common because it is"
               0  " initialized in BLOCK DATA for the ranlux rng.                  "
               0  " It is not actually used by ranmar."
               0
               0  " The following is the $RANDOMSET macro for EGSnrc."
               0  " Found that using integers it is faster by about 30% on a PIII CPU"
               0  " (which is the NRC computer environment                           "
               0
               0  " Found that when the RNG is not inlined, code runs faster "
               0  " Presumambly because the executable shrinks by a significant amount "
               0  " Iwan Kawrakow, May 2003 "
               0
               0  REPLACE {$RANDOMSET#;} WITH {;
            {  0  IF( rng_seed > $NRANMAR ) call ranmar_get;
            {  0  {P1} = rng_array(rng_seed)*twom24; rng_seed = rng_seed + 1;
            {  0  };
               0
               0  "REPLACE {$RANDOMSET#;} WITH
               0  "{
               0  "    i4opt = urndm(ixx) - urndm(jxx);
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    urndm(ixx) = i4opt;
               0  "    ixx = ixx - 1; jxx = jxx - 1;
               0  "    IF(ixx = 0)        [ ixx = 97; ]
               0  "    ELSE IF( jxx = 0 ) [ jxx = 97; ]
               0  "    crndm = crndm - cdrndm;
               0  "    IF(crndm < 0) crndm = crndm + cmrndm;
               0  "    i4opt = i4opt - crndm;
               0  "    IF(i4opt < 0) i4opt = i4opt + 16777216;
               0  "    {P1} = twom24*i4opt;
               0  "}
               0  ;
               0
               0  REPLACE {$RNG-INITIALIZATION;} WITH { ;call init_ranmar; }
               0
               0  REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;
            {  0  ixx=0; jxx=0; call init_ranmar;
            {  0  };
               0
               0  REPLACE {$INITIALIZE RNG USING # AND #; } WITH {;
            {  0  ixx = {P1}; jxx = {P2};
            {  0  call init_ranmar;
            {  0  };
               0
               0  "**************************************************************************"
               0  " The macros below are not essential for the operation of the RNG,         "
               0  " they are defined for convinience in our NRC user codes                   "
               0  "**************************************************************************"
               0
               0  REPLACE {$STORE RNG STATE ON UNIT #;} WITH
               0  {
            {  0  rewind({P1});
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$PUT RNG STATE ON UNIT #;} WITH
               0  {
            {  0  write({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  }
               0
               0  REPLACE {$RETRIEVE RNG STATE FROM UNIT #;} WITH {;
            {  0  read({P1},*) urndm,crndm,cdrndm, cmrndm, ixx, jxx, rng_seed,
            {  0  rng_array;
            {  0  twom24 = 1./16777216.;  "just in case it is not initialized in rmarin"
            {  0  };
               0
               0  REPLACE {$SHOW-RNG-STATE(#);} WITH {;
            {  0  write({P1},'(a,2i4,$)') ' ixx jxx = ',ixx,jxx;
            {  0  };
               0
               0  REPLACE {$PRINT-RNG-STATE(#,#);} WITH {;
            {  0  write({P1},{P2}) ixx,jxx;
            {  0  };
               0
               0  REPLACE {$RNG-INPUTS(#,#,#,#);} WITH {;
            {  0  ival = ival + 1;
            {  0  VALUES_SOUGHT(IVAL)={P1};
            {  0  nvalue(ival) = 2;
            {  0  type(ival)   = 0;
            {  0  value_min(ival) = 1;
            {  0  value_max(ival) = 30081;
            {  0  default(ival)   = 9373;
            {  0  delimeter = {P2};
            {  0  nmin = ival; nmax = ival;
            {  0  call get_input;
            {  0  IF( error_flags(ival) = 0 ) [
            {  0  {P3} = value(ival,1);
            {  0  {P4} = value(ival,2);
            {  0  ]
            {  0  ELSE [ {P3} = 0; {P4} = 0; ]
            {  0  };
               0
               0  REPLACE {$RNG-STRING-1} WITH {' 1st initial random number seed: '}
               0  REPLACE {$RNG-STRING-2} WITH {' 2nd initial random number seed: '}
               0
               0  "            end of ranmar.macros         "
1              0  %E
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros for ranmar correlated sampling                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The following macros can be used for correlated sampling, together with    "
               0  "  the RANMAR random number generator (rng).                                  "
               0  "                                                                             "
               0  "  $MXRNGDIM      gives the maximum number of different rng states that       "
               0  "                 can be simultaneously held in the memory.                   "
               0  "                                                                             "
               0  "  $STORE-RNG(#)  is used to store the current rng state into dimension {P1}  "
               0  "                                                                             "
               0  "  $RESET-RNG(#)  is used to re-set the rng state from a previous state       "
               0  "                                                                             "
               0  "  In order to use these macros, include this file before your user code via  "
               0  "  the configuration file.                                                    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$MXRNGDIM} WITH {5};  "to store up to five rng states"
               0
               0  APPEND {;
            {  0
            {  0  common/random_extra/ extra_urndm(97,$MXRNGDIM), extra_crndm($MXRNGDIM),
            {  0  extra_cdrndm($MXRNGDIM), extra_cmrndm($MXRNGDIM),
            {  0  extra_ixx($MXRNGDIM), extra_jxx($MXRNGDIM),
            {  0  extra_rng_seed($MXRNGDIM),
            {  0  extra_rng_array($NRANMAR,$MXRNGDIM);
            {  0  integer*4            extra_urndm,extra_crndm,extra_cdrndm,extra_cmrndm,
            {  0  extra_ixx,extra_jxx,extra_rng_seed,extra_rng_array;
            {  0
            {  0  } TO { ;COMIN/RANDOM/; }
               0
               0  REPLACE {$STORE-RNG(#);} WITH {;
            {  0
            {  0  IF( {P1} < 1 | {P1} > $MXRNGDIM ) [
            {  0  OUTPUT {P1};
            {  0  (//' ******* Attempt to store rng state into an illegal dimension: ',
            {  0  i4//);
            {  0  stop;
            {  0  ]
            {  0  DO i4opt = 1, 97 [ extra_urndm(i4opt,{P1}) = urndm(i4opt); ]
            {  0  extra_crndm({P1})  = crndm;
            {  0  extra_cdrndm({P1}) = cdrndm;
            {  0  extra_cmrndm({P1}) = cmrndm;
            {  0  extra_ixx({P1}) = ixx; extra_jxx({P1}) = jxx;
            {  0  extra_rng_seed({P1}) = rng_seed;
            {  0  DO i4opt = 1,$NRANMAR [ extra_rng_array(i4opt,{P1}) = rng_array(i4opt); ]
            {  0  };
               0
               0  REPLACE {$RESET-RNG(#);} WITH {;
            {  0
            {  0  IF( {P1} < 1 | {P1} > $MXRNGDIM ) [
            {  0  OUTPUT {P1};
            {  0  (//' ******* Attempt to reset rng state from an illegal dimension: ',
            {  0  i4//);
            {  0  stop;
            {  0  ]
            {  0  DO i4opt = 1, 97 [ urndm(i4opt) = extra_urndm(i4opt,{P1}); ]
            {  0  crndm  = extra_crndm({P1});
            {  0  cdrndm = extra_cdrndm({P1});
            {  0  cmrndm = extra_cmrndm({P1});
            {  0  ixx = extra_ixx({P1}); jxx = extra_jxx({P1});
            {  0  rng_seed = extra_rng_seed({P1});
            {  0  DO i4opt = 1,$NRANMAR [ rng_array(i4opt) = extra_rng_array(i4opt,{P1}); ]
            {  0  };
               0  "       end of ranmar.correlations   "
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc transport parameter macros                                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These macros are used in conjunction with the get_inputs.mortran routines  "
               0  "  to read in EGSnrc transport physics parameters. Specifically with          "
               0  "  subroutine get_transport_parameter.                                        "
               0  "                                                                             "
               0  "  The following are definitions of code words (values sought) for the        "
               0  "  various transport parameters that can be set. I hope they are              "
               0  "  self-explanatory. If you don't like them:                                  "
               0  "                                                                             "
               0  "  - include this file via the configuration file BEFORE your user code.      "
               0  "                                                                             "
               0  "  - Replace the macros in your user code with code words that you prefer.    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
               0  REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
               0  REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
               0  REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
               0  REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
               0  REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
               0  REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
               0  REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
               0  REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
               0  REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
               0  REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
               0  REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
               0  REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
               0  REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
               0  REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
               0  REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
               0  REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
               0  REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
               0  REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
               0  REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
               0  REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
               0  REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
               0  REPLACE {$IN_REGIONS}             WITH {'Regions'}
               0  REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
               0  REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
               0  REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
               0  REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
               0  REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
               0  "Ali:photonuc, 2 lines"
               0  "Cannot use $PHOTONUC; it clashes with other variables"
               0  REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
               0  REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
               0  REPLACE {$B_FIELD} WITH {'Magnetic Field'}
               0  REPLACE {$E_FIELD} WITH {'Electric Field'}
               0  REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
               0  ;
               0
               0  REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
               0  {;
            {  0  aux_inregions = .false.;
            {  0  IF( error_flags({P1}) = 0 ) [
            {  0  write(i_log,*) {P2};
            {  0  itmp = value({P1},1);
            {  0  IF( itmp = 2 | itmp = 3 ) [
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P2};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P3};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  Nmin = ival-1; Nmax = ival;
            {  0  CALL GET_INPUT;
            {  0  IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            {  0  IF( nvalue(ival) = nvalue(ival-1) ) [
            {  0  iitmp = itmp-2;
            {  0  DO j=1,$MXREG [ {P4}(j) = iitmp; ]
            {  0  "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
            {  0  iitmp = 1 - iitmp;
            {  0  "and then re-set in the specified regions"
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  "Ali:photonuc, 2 lines to crudely print start/stop regions"
            {  0  write(i_log,*) {P2},istart;
            {  0  write(i_log,*) {P3},iend;
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P4}(j) = iitmp; ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [
            {  0  IF( itmp > 3 ) itmp = itmp-2;
            {  0  write(i_log,*) ' Setting all to ',itmp;
            {  0  DO j=1,$MXREG [ {P4}(j) = itmp; ]
            {  0  ]
            {  0  ]
            {  0  ELSE ["Use default value"
            {  0  "Check if default is other than ON or Off"
            {  0  "and shift as no input by regions requested"
            {  0  IF({P4}(1) = 2 | {P4}(1) = 3)[
            {  0  value({P1},1) = {P4}(1)+2;
            {  0  ]
            {  0  ELSE[
            {  0  value({P1},1) = {P4}(1);
            {  0  ]
            {  0  ]
            {  0
            {  0  };
               0
               0  REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
               0  {;
            {  0
            {  0  aux_inregions = .false.;
            {  0  ival                = ival + 1;
            {  0  {P2}                = ival;
            {  0  values_sought(ival) = {P6};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 1;
            {  0  value_min(ival)     = {P3};
            {  0  value_max(ival)     = {P4};
            {  0  default(ival)       = {P5};
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P7};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P8};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
            {  0  CALL GET_INPUT;
            {  0
            {  0  IF( error_flag = 0 ) [
            {  0  IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P1}(j) = value({P2},k); ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros to read and write phase space files                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Blake Walters, 1999                                       "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  This code was originally part of the BEAM code system for Monte Carlo      "
               0  "  simulation of radiotherapy treatments units. It was developed at the       "
               0  "  National Research Council of Canada as part of the OMEGA collaborative     "
               0  "  research project with the University of Wisconsin. The system was          "
               0  "  originally described in:                                                   "
               0  "                                                                             "
               0  "  BEAM: A Monte Carlo code to simulate radiotherapy treatment units,         "
               0  "  DWO Rogers, BA Faddegon, GX Ding, C-M Ma, J Wei and TR Mackie,             "
               0  "  Medical Physics 22, 503-524 (1995).                                        "
               0  "                                                                             "
               0  "  BEAM User Manual                                                           "
               0  "  DWO Rogers, C-M Ma, B Walters, GX Ding, D Sheikh-Bagheri and G Zhang,      "
               0  "  NRC Report PIRS-509A (rev D)                                               "
               0  "                                                                             "
               0  "  As well as the authors of this paper and report, Joanne Treurniet of NRC   "
               0  "  made significant contributions to the code system, in particular the GUIs  "
               0  "  and EGS_Windows. Mark Holmes, Brian Geiser and Paul Reckwerdt of Wisconsin "
               0  "  played important roles in the overall OMEGA project within which the BEAM  "
               0  "  code system was developed.                                                 "
               0  "                                                                             "
               0  "  There have been major upgrades in the BEAM code starting in 2000 which     "
               0  "  have been heavily supported by Iwan Kawrakow, most notably: the port to    "
               0  "  EGSnrc, the inclusion of history-by-history statistics and the development "
               0  "  of the directional bremsstrahlung splitting variance reduction technique.  "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Macros required to read from and write to phase space files. These macros  "
               0  "  replace the old calls to the subroutine rw_ph_sp.mortran and any           "
               0  "  manipulations of phase space files that were hard-coded. Currently, these  "
               0  "  macros are used by BEAM, DOSXYZ, BEAMDP, and readphsp. The beam            "
               0  "  configuration script looks for this file in the following directories, in  "
               0  "  this order                                                                 "
               0  "                                                                             "
               0  "  $HOME/egs4/BEAM_accelerator                                                "
               0  "  $HOME/egs4/beam                                                            "
               0  "  $OMEGA_HOME/beam                                                           "
               0  "                                                                             "
               0  "  All other configuration or compile scripts only use the version of this    "
               0  "  file in $OMEGA_HOME/beam. These macros can be used with any code provided  "
               0  "  that this file is concatenated before any codes that use the macros.       "
               0  "  Detailed description of what each macro does is provided at the top of     "
               0  "  the macro.                                                                 "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  ;
               0  REPLACE {;COMIN/RWPHSP/;} WITH {
            {  0  "RWPHSP must be included in the common block of main in any code that uses"
            {  0  "any of these phase space macros and also in the common block of"
            {  0  "any subroutine that uses any phase space macros.  Note that the macro"
            {  0  "$MAX_SC_PLANES(=the max. number of scoring planes) must have been defined"
            {  0  "somewhere in the code before the first use of COMIN/RWPHSP.  In the case of"
            {  0  "DOSXYZ, BEAMDP and readphsp, $MAX_SC_PLANES is a dummy value, set to 1,"
            {  0  "at the beginning of main.  Note that, since, IHSTRY_PHSP is a $LONG_INT"
            {  0  "variable, you must have the macro REPLACE {$LONG_INT} WITH {INTEGER*8} at"
            {  0  "the top of any code that uses these macros.  If your compiler has trouble"
            {  0  "with INTEGER*8, use INTEGER*4 in the $LONG_INT macro."
            {  0
            {  0  ;COMMON/RWPHSP/
            {  0  STRING_TEMP_ZLAST_OUT,
            {  0  "holds output phsp data for up to 1000 particles, with ZLAST"
            {  0  STRING_TEMP_OUT, "holds output phsp data for up to 1000 particles, no ZLAST"
            {  0  IHSTRY_PHSP, "history number (from primary non-phase space source) of"
            {  0  "particle being scored"
            {  0  iaea_dummy_long, "used to store INTEGER*8 values temporarily"
            {  0  NHSTRY_DOS, "passed to NHSTRY in beam when this actually comes from"
            {  0  "dosxyznrc source 20"
            {  0  ESHORT,    "single precision E read from/written to phsp"
            {  0  WEIGHTTMP, "modified version of WT to be written to phsp"
            {  0  WT_PHSP_SHORT, "single precision wt read from phsp"
            {  0  X_PHSP_SHORT, "single precision x read from phsp"
            {  0  Y_PHSP_SHORT, "single precision y read from phsp"
            {  0  Z_PHSP_SHORT, "single precision Z--for iaea format only"
            {  0  U_PHSP_SHORT, "single precision u read from phsp"
            {  0  V_PHSP_SHORT, "single precision v read from phsp"
            {  0  W_PHSP_SHORT, "single precision w--for iaea format only"
            {  0  ZLAST_PHSP_SHORT, "single precision zlast read from phsp"
            {  0  MUIDX_PHSP_SHORT, "MU_INDEX--iaea phsp files only"
            {  0  EKMAX_PHSP_SHORT, "max ke of particles in phsp file"
            {  0  EKMINE_PHSP_SHORT, "min ke of electrons in phsp file"
            {  0  NINC_PHSP_SHORT, "no. of particles from original primary source"
            {  0  dosxyz2beam_index, "stores MU index passed to beam from dosxyz"
            {  0  iaea_extra_floats, "array of extra floats in IAEA phsp file"
            {  0  NUM_PHSP_TOT, "tot no of particles in phsp file"
            {  0  PHOT_PHSP_TOT,"no. of photons in phsp file"
            {  0  iaea_result,  "<0 if an error finding an available array index for IAEA"
            {  0  "phsp file"
            {  0  iaea_n_stat,  ">=1 if a new primary history is scoring, 0 otherwise"
            {  0  iaea_q_typ,    "array to convert from charge to IAEA type"
            {  0  iaea_typ_q,   "array to convert from IAEA type to charge"
            {  0  iaea_q_index, "array index"
            {  0  I_PHSP,    "loop counter"
            {  0  IERR_PHSP, "=0 if open/read okay ~=0 if not okay"
            {  0  LATCHTMP,  "modified version of LATCH to be written to phsp"
            {  0  WRITE_PHSP_COUNTER, "counter up to 1000 used for group write"
            {  0  WRITE_PHSP_SOFAR, "how many particles written so far to file"
            {  0  PHSP_RESTART, "set to 1 if this is a restart"
            {  0  PHSP_RECL, "the record length"
            {  0  PHSP_RECL_OLD, "saves record length"
            {  0  iaea_extra_ints, "array in which LATCH will be stored for iaea format"
            {  0  iaea_extra_int_types,iaea_extra_float_types, "returns the types of"
            {  0  "extra int and float variables in an IAEA phsp file"
            {  0  iaea_i_zlast,"index of iaea_extra_floats in which Zlast is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_latch,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp files read IN"
            {  0  iaea_i_muidx,"index of iaea_extra_floats in which MU_INDEX is stored for"
            {  0  "IAEA phsp files read IN"
            {  0  iaea_n_extra_ints, "no. of extra ints stored in IAEA phsp file read IN"
            {  0  iaea_n_extra_floats, "no. of extra floats stored in IAEA phsp file read IN"
            {  0  i_iaea_open_for_write, "set to 1 if the macro IAEA_OPEN_FOR_WRITE"
            {  0  "was used"
            {  0  iaea_i_zlast_out,"index of iaea_extra_floats in which Zlast is stored for"
            {  0  " IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_latch_out,"index of iaea_extra_int in which LATCH is stored for IAEA"
            {  0  "phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  iaea_i_muidx_out,"index of iaea_extra_floats in which MU_INDEX is stored"
            {  0  " for IAEA phsp written OUT by BEAMnrc or DOSXYZnrc"
            {  0  dosxyz2beam_izscore, "set to 1 if Z scored for each particle (IAEA only)"
            {  0  MODE_RW;   "mode of phsp file (0 with ZLAST, 2 without), writing only"
            {  0
            {  0  CHARACTER*32000 STRING_TEMP_ZLAST_OUT($MAX_SC_PLANES);
            {  0  CHARACTER*28000 STRING_TEMP_OUT($MAX_SC_PLANES);
            {  0  $LONG_INT IHSTRY_PHSP($MAX_SC_PLANES),iaea_dummy_long,NHSTRY_DOS;
            {  0  REAL*4 ESHORT,WEIGHTTMP,WT_PHSP_SHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  Z_PHSP_SHORT,U_PHSP_SHORT, V_PHSP_SHORT,W_PHSP_SHORT,ZLAST_PHSP_SHORT,
            {  0  MUIDX_PHSP_SHORT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT,dosxyz2beam_index,
            {  0  iaea_extra_floats(10);
            {  0  INTEGER NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  iaea_result,iaea_n_stat,iaea_q_typ(3),iaea_typ_q(3),iaea_q_index,I_PHSP,
            {  0  IERR_PHSP,LATCHTMP,
            {  0  WRITE_PHSP_COUNTER($MAX_SC_PLANES),WRITE_PHSP_SOFAR($MAX_SC_PLANES),
            {  0  PHSP_RESTART,PHSP_RECL,PHSP_RECL_OLD,iaea_extra_ints(10),
            {  0  iaea_extra_int_types(10),iaea_extra_float_types(10),iaea_i_zlast,
            {  0  iaea_i_latch,iaea_i_muidx,iaea_n_extra_ints,iaea_n_extra_floats,
            {  0  i_iaea_open_for_write,iaea_i_zlast_out,iaea_i_latch_out,
            {  0  iaea_i_muidx_out,dosxyz2beam_izscore;
            {  0  CHARACTER*5 MODE_RW;
            {  0
            {  0  "variables below are not part of the common block but are used locally"
            {  0  "by the $WRITE_PHSP, $WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros"
            {  0
            {  0  INTEGER LATCH_TEMP_OUT,NUM_PHSP_TOFLUSH,TEMP_PHSP_COUNTER,REM_PHSP;
            {  0  REAL*4 REAL_TEMP_OUT(7);
            {  0  CHARACTER*32 REC_TEMP_OUT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$INITIALIZE_PHSP_VARIABLES;} WITH{;
            {  0  "Must be placed after the variable declarations in any subroutine"
            {  0  "where $WRITE_PHSP and/or $WRITE_PHSP_RECORD is used.  Note, though, that"
            {  0  "it does not necessarily have to be put at the top of main, unless one or"
            {  0  "both of these macros are used in main."
            {  0  "It equivalences the character string REC_TEMP_OUT with the phase space data"
            {  0  "for 1 particle. REC_TEMP_OUT is then used to fill the character array"
            {  0  "STRING_TEMP_(ZLAST_)OUT, which holds the phase space data in blocks of 1000"
            {  0  "particles before writing."
            {  0
            {  0  EQUIVALENCE(REC_TEMP_OUT(1:4),LATCH_TEMP_OUT);
            {  0  EQUIVALENCE(REC_TEMP_OUT(5:8),REAL_TEMP_OUT(1));
            {  0  EQUIVALENCE(REC_TEMP_OUT(9:12),REAL_TEMP_OUT(2));
            {  0  EQUIVALENCE(REC_TEMP_OUT(13:16),REAL_TEMP_OUT(3));
            {  0  EQUIVALENCE(REC_TEMP_OUT(17:20),REAL_TEMP_OUT(4));
            {  0  EQUIVALENCE(REC_TEMP_OUT(21:24),REAL_TEMP_OUT(5));
            {  0  EQUIVALENCE(REC_TEMP_OUT(25:28),REAL_TEMP_OUT(6));
            {  0  EQUIVALENCE(REC_TEMP_OUT(29:32),REAL_TEMP_OUT(7));
            {  0  }
               0  ;
               0
               0  REPLACE {$INIT_PHSP_COUNTERS;} WITH {;
            {  0  "This macro initializes counters and flags that are used by the"
            {  0  "$WRITE_PHSP/$WRITE_PHSP_RECORD and $PHSP_BUFFER_FLUSH macros.  It is only"
            {  0  "used once and should be placed after the variable declarations in main."
            {  0
            {  0  DO I_PHSP=1,$MAX_SC_PLANES[
            {  0  WRITE_PHSP_COUNTER(I_PHSP)=0;
            {  0  WRITE_PHSP_SOFAR(I_PHSP)=0;
            {  0  IHSTRY_PHSP(I_PHSP)=0;
            {  0  ]
            {  0  PHSP_RESTART=0;
            {  0  PHSP_RECL_OLD=0;
            {  0
            {  0  iaea_q_typ(1)=2;iaea_q_typ(2)=1;iaea_q_typ(3)=3;
            {  0  iaea_typ_q(1)=0;iaea_typ_q(2)=-1;iaea_typ_q(3)=1;
            {  0
            {  0  iaea_n_extra_ints=0;iaea_n_extra_floats=0;
            {  0
            {  0  iaea_i_zlast=-99;iaea_i_latch=-99;iaea_i_muidx=-99;
            {  0
            {  0  i_iaea_open_for_write=0;
            {  0
            {  0  iaea_i_zlast_out=-99;iaea_i_latch_out=-99;iaea_i_muidx_out=-99;
            {  0
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$GET_E_NPASS_IQ(#,#,#,#);} WITH {;
            {  0  "Macro gets NPASS, IQ from the LATCH value read in and then restores LATCH"
            {  0  "by clearing the bits that store this information.  It also puts the"
            {  0  "single precision energy, ESHORT, read in into double precision form."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0
            {  0  {P4}=ESHORT;
            {  0
            {  0  IF($BTEST({P3},31)) [ {P1} = 1; {P3} = $IBCLR({P3},31); ]
            {  0  ELSE [ {P1} = 0; ]
            {  0
            {  0  IF($BTEST({P3},30)) [
            {  0  {P2} = -1;
            {  0  {P3} = $IBCLR({P3},30); {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [
            {  0  IF($BTEST({P3},29)) [
            {  0  {P2} = 1; {P3} = $IBCLR({P3},29);
            {  0  ]
            {  0  ELSE [ {P2} = 0; ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_W_WT(#,#,#,#,#,#);} WITH {;
            {  0  "This macro calculates W, based on U and V and the sign of WT as read in from"
            {  0  "the phase space file.  Once the sign of WT is determined, WT is set equal"
            {  0  "to its absolute value, since there cannot be a negative particle weight."
            {  0  "This macro is called by $READ_PHSP."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=W"
            {  0  "{P2}=WT"
            {  0  "{P3}=X"
            {  0  "{P4}=Y"
            {  0  "{P5}=U"
            {  0  "{P6}=V"
            {  0
            {  0  {P1} = min( 1., {P5}**2 + {P6}**2);
            {  0  {P1} = sqrt(1. - {P1});
            {  0  {P1} = SIGN({P1},{P2});  "This transfers sign of WT to W"
            {  0
            {  0  {P2}=ABS({P2}); "WT is always positive"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_RECORD(#,#,#,#);} WITH {;
            {  0  "macro used by READ_PHSP_RECORD to put single precision x, y, u, v"
            {  0  "read from phase space file into (potentially) double precision"
            {  0  "x, y, u, v passed to READ_PHSP_RECORD macro"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=X"
            {  0  "{P2}=Y"
            {  0  "{P3}=U"
            {  0  "{P4}=V"
            {  0
            {  0  {P1}=X_PHSP_SHORT;
            {  0  {P2}=Y_PHSP_SHORT;
            {  0  {P3}=U_PHSP_SHORT;
            {  0  {P4}=V_PHSP_SHORT;
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD(#,#,#:#,#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required  ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro actually reads the phase space data for a single particle."
            {  0  "It is called by $READ_PHSP, but can also be used as a stand-alone macro."
            {  0  "If the energy, E, is < 0.0, then this is the first particle scored"
            {  0  "from a new primary (ie non-phsp source) history, and NHSTRY is incremented"
            {  0  "and E is set to ABS(E)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=NHSTRY"
            {  0  "{P5}=ZLAST"
            {  0  "{P6}=LATCH"
            {  0  "{P7}=E"
            {  0  "{P8}=WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT,ZLAST_PHSP_SHORT;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P6},ESHORT,X_PHSP_SHORT,Y_PHSP_SHORT,
            {  0  U_PHSP_SHORT,V_PHSP_SHORT,WT_PHSP_SHORT;
            {  0  ]
            {  0
            {  0  IF({P3}=76695869)[
            {  0  write(*,*)' x,y,u,v,wt,eshort,latch',
            {  0  X_PHSP_SHORT,Y_PHSP_SHORT,U_PHSP_SHORT,V_PHSP_SHORT,
            {  0  WT_PHSP_SHORT,ESHORT,{P6};
            {  0  ]
            {  0
            {  0  "first particle from new primary history"
            {  0  IF(ESHORT<0.0)[
            {  0  {P4}={P4}+1;
            {  0  ESHORT=ABS(ESHORT);
            {  0  ]
            {  0
            {  0  {P7}=ESHORT;
            {  0  {P8}=WT_PHSP_SHORT;
            {  0  $PARSE_PHSP_RECORD({P9});
            {  0
            {  0  IF({P1}~=0) {P5}=ZLAST_PHSP_SHORT;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_RECORD_ENEGATIVE(#,#,#:#,#,#,#,#);} WITH {;
            {  0  "Note that a colon is required            ^  between the third and fourth"
            {  0  "input parameters."
            {  0  "This macro is the similar to $READ_PHSP_RECORD above, but it preserves"
            {  0  "the -E marker in the phase space file and does not advance NHSTRY"
            {  0  "It is only used in readphsp before byte swapping"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=record number"
            {  0  "{P4}=ZLAST"
            {  0  "{P5}=LATCH"
            {  0  "{P6}=E"
            {  0  "{P7}=WT"
            {  0  "{P8}=X,Y,U,V"
            {  0
            {  0  IF({P1}~=0)["must read in ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7},{P4};
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  READ({P2},REC={P3},IOSTAT=IERR_PHSP) {P5},{P6},{P8},{P7};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP(#:#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Note colon          ^  required between the first and second"
            {  0  "input parameters (third and fourth input variables)"
            {  0
            {  0  "This macro reads the phase space data for a single particle.  It finds"
            {  0  "the value of IQ and NPASS from the LATCH variable read in and then"
            {  0  "restores the LATCH variable.  It calculates W from U, V and the sign"
            {  0  "of WT and then restores WT to its absolute value.  And it puts the"
            {  0  "single-precision energy, ESHORT, read in into double-precision format."
            {  0  "If ESHORT is < 0, it sets E=ABS(ESHORT) and increments NHSTRY, taking"
            {  0  "this as the first particle scored from a new primary history."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,record number reading from"
            {  0  "{P2}=NHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E"
            {  0  "{P9}=WT,X,Y,U,V"
            {  0
            {  0  $READ_PHSP_RECORD({P1}:{P2},{P6},{P7},{P8},{P9});
            {  0
            {  0  IF(IERR_PHSP=0)[
            {  0  $GET_E_NPASS_IQ({P3},{P4},{P7},{P8});
            {  0  $GET_W_WT({P5},{P9});
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_LATCHTMP_ESHORT_WEIGHTTMP(#,#,#,#,#,#);} WITH {;
            {  0  "This macro converts LATCH into LATCHTMP, which stores NPASS and IQ"
            {  0  "for a particle and is the form of LATCH written to the phase space file."
            {  0  "It puts double precision energy, E, into single precision format, ESHORT,"
            {  0  "for writing to the phase space file.  This macro is called from $READ_PHSP"
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=NPASS"
            {  0  "{P2}=IQ"
            {  0  "{P3}=W"
            {  0  "{P4}=LATCH"
            {  0  "{P5}=E"
            {  0  "{P6}=WT"
            {  0
            {  0  LATCHTMP={P4};
            {  0
            {  0  IF({P1} = 0) [ LATCHTMP = $IBCLR(LATCHTMP,31); ]
            {  0  ELSE [ LATCHTMP = $IBSET(LATCHTMP,31); ]
            {  0
            {  0  IF({P2} = -1) [ LATCHTMP = $IBSET(LATCHTMP,30);]
            {  0  ELSEIF({P2} = 0) [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBCLR(LATCHTMP,29);
            {  0  ]
            {  0  ELSE [
            {  0  LATCHTMP = $IBCLR(LATCHTMP,30);
            {  0  LATCHTMP = $IBSET(LATCHTMP,29);
            {  0  ]
            {  0
            {  0  ESHORT={P5};
            {  0
            {  0  WEIGHTTMP=SIGN({P6},{P3});"transfer sign of W to WEIGHTTMP"
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$SET_NEGATIVE_E(#,#,#,#);} WITH {;
            {  0  "Macro to set E to -E if this is the first particle scored from a new"
            {  0  "primary (non-phsp source) history.  This macro is called from"
            {  0  "$WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters"
            {  0  "{P1}=phase space scoring plane no."
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=E"
            {  0  "{P4}=WT,X,Y,U,V"
            {  0
            {  0  IF({P2}~=IHSTRY_PHSP({P1}))[
            {  0  {P3}=-{P3};
            {  0  IHSTRY_PHSP({P1})={P2};
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_TEMP_FOR_WRITE(#,#,#,#,#,#,#,#,#);} WITH {;
            {  0  "Macro to store the output phase space data for one particle in the"
            {  0  "variables LATCH_TEMP_OUT and REAL_TEMP_OUT.  These variables are"
            {  0  "equivalenced to the string variable REC_TEMP_OUT, which stores the"
            {  0  "phase space for one particle in string form and which, in turn, is"
            {  0  "used to transfer the data to the string variable STRING_TEMP(_ZLAST)_OUT"
            {  0  "which stores output phase space data for up to 1000 particles at a time."
            {  0  "This macro is called from $WRITE_PHSP_RECORD."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=ZLAST"
            {  0  "{P3}=LATCH"
            {  0  "{P4}=E"
            {  0  "{P5}=WT"
            {  0  "{P6}=X"
            {  0  "{P7}=Y"
            {  0  "{P8}=U"
            {  0  "{P9}=V"
            {  0
            {  0  LATCH_TEMP_OUT={P3};
            {  0  REAL_TEMP_OUT(1)={P4};
            {  0  REAL_TEMP_OUT(2)={P6};
            {  0  REAL_TEMP_OUT(3)={P7};
            {  0  REAL_TEMP_OUT(4)={P8};
            {  0  REAL_TEMP_OUT(5)={P9};
            {  0  REAL_TEMP_OUT(6)={P5};
            {  0  IF({P1}~=0) REAL_TEMP_OUT(7)={P2};
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP_RECORD(#,#,#,#,#:#,#,#,#);} WITH {;
            {  0  "Note that a colon is required       ^  between the fifth and sixth"
            {  0  "input parameters"
            {  0
            {  0  "This macro is used to output phase space data 1000 particles at a time."
            {  0  "For every particle, the phase space data to be output is stored in"
            {  0  "the string variable STRING_TEMP(_ZLAST)_OUT.  If it is the 1000th particle"
            {  0  "STRING_TEMP(_ZLAST)_OUT is written to the phase space file.  The phase"
            {  0  "space header info is considered to occupy the space of 1 particle in the"
            {  0  "first block of 1000 particles, however, it will be overwritten with nulls."
            {  0  "This is fine since the header info should be recalculated and rewritten at"
            {  0  "the top of the file after all data has been written out anyway."
            {  0  "Also note that restarting with this writing scheme requires that any"
            {  0  "blocks of N (N<1000) particles at the end of a phase space file from"
            {  0  "the previous run must immediately be read into the first N spaces of"
            {  0  "STRING_TEMP(_ZLAST)_OUT before continuing on with outputting the data"
            {  0  "for new particles.  Finally, after all phase space data has been output,"
            {  0  "there will probably be info for M (M<1000) particles still in"
            {  0  "STRING_TEMP(_ZLAST)_OUT that has not been written to the phase space file"
            {  0  "because the write counter did not reach 1000.  These are output using"
            {  0  "the $PHSP_BUFFER_FLUSH macro described below."
            {  0
            {  0  "Group writing reduces network traffic and saves a lot of time when the"
            {  0  "one of the main CPU-intensive activities is the writing of phase space data."
            {  0  "Group reading has also been considered, but preliminary studies have shown"
            {  0  "that it does not reduce CPU time significantly."
            {  0
            {  0  "Using the macro $SET_NEGATIVE_E, $WRITE_PHSP_RECORD also takes care of setting"
            {  0  "E to -E if this is the first particle scored from a new primary"
            {  0  "(non-phsp source) history."
            {  0
            {  0  "This macro is called by $WRITE_PHSP, but can also be used as a stand-"
            {  0  "alone macro.  However, use of $WRITE_PHSP_RECORD, will always require"
            {  0  "use of $PHSP_BUFFER_FLUSH (see below)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=name of phase space file"
            {  0  "{P4}=record number writing to"
            {  0  "{P5}=scoring plane number"
            {  0  "{P6}=IHSTRY"
            {  0  "{P7}=ZLAST"
            {  0  "{P8}=LATCH"
            {  0  "{P9}=E,WT,X,Y,U,V"
            {  0
            {  0  IF({P4}>2 & WRITE_PHSP_COUNTER({P5})=0 & WRITE_PHSP_SOFAR({P5})=0)[
            {  0  "we have a restart or its the start of a new batch"
            {  0  IF(({P4}-1)-1000*(({P4}-1)/1000)~=0)[
            {  0  "make what was the buffer flush part of the first record of the restart"
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*(I_PHSP-1)+1:32*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  DO I_PHSP=1,({P4}-1)-1000*(({P4}-1)/1000)[
            {  0  READ({P2},REC=1000*INT(dble({P4}-1)/1000)+I_PHSP)
            {  0  STRING_TEMP_OUT({P5})(28*(I_PHSP-1)+1:28*I_PHSP);
            {  0  ]
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=1000*INT(dble({P4}-1)/1000);
            {  0  IF(WRITE_PHSP_SOFAR({P5})>0)[
            {  0  PHSP_RESTART=1;
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-1)-1000*(({P4}-1)/1000);
            {  0  ]
            {  0  ELSE[
            {  0  WRITE_PHSP_COUNTER({P5})=({P4}-2)-1000*(({P4}-2)/1000);
            {  0  ]
            {  0  ]
            {  0
            {  0  $SET_NEGATIVE_E({P5},{P6},{P9});
            {  0
            {  0  $PARSE_TEMP_FOR_WRITE({P1},{P7},{P8},{P9});
            {  0
            {  0  IF({P4}<=1000 & PHSP_RESTART=0)["do not use first 7/8 elements"
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+33:
            {  0  32*WRITE_PHSP_COUNTER({P5})+64)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+29:
            {  0  28*WRITE_PHSP_COUNTER({P5})+56)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  IF({P1}~=0)[
            {  0  STRING_TEMP_ZLAST_OUT({P5})(32*WRITE_PHSP_COUNTER({P5})+1:
            {  0  32*WRITE_PHSP_COUNTER({P5})+32)=REC_TEMP_OUT(1:32);
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  STRING_TEMP_OUT({P5})(28*WRITE_PHSP_COUNTER({P5})+1:
            {  0  28*WRITE_PHSP_COUNTER({P5})+28)=REC_TEMP_OUT(1:28);
            {  0  ]
            {  0  ]
            {  0
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0
            {  0  IF({P4}=1000|WRITE_PHSP_COUNTER({P5})=1000)[
            {  0  IF({P1}~=0 & PHSP_RECL=$RECL-FACTOR*8)[
            {  0  CLOSE({P2});
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  ELSEIF({P1}=0 & PHSP_RECL=$RECL-FACTOR*7)[
            {  0  PHSP_RECL_OLD=PHSP_RECL;
            {  0  CLOSE({P2});
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  IF({P1}~=0)[
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_ZLAST_OUT({P5});
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  WRITE({P2},REC=INT(dble({P4})/1000)) STRING_TEMP_OUT({P5});
            {  0  ]
            {  0  IF(PHSP_RECL_OLD~=0)[
            {  0  "have to do this in case the output file=input file"
            {  0  PHSP_RECL=PHSP_RECL_OLD;
            {  0  CLOSE({P2});
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  ]
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+1000;
            {  0  ]
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$PHSP_BUFFER_FLUSH(#,#,#,#,#);} WITH {;
            {  0  "This macro outputs the data for the M (M<1000) remaining particles still"
            {  0  "stored in STRING_TEMP(_ZLAST)_OUT after all calls to $WRITE_PHSP_RECORD."
            {  0  "The macro does not flush all of the data at once, but in blocks that"
            {  0  "divide exactly into the number of particles already in the phase space"
            {  0  "file.  For each block that is flushed, the phase space file is re-opened"
            {  0  "with a record length (RECL) equal to the size of the block.  Since RECL"
            {  0  "divides exactly into the number of particles already in the file, the"
            {  0  "block to be flushed can be appended onto the data that already exists in"
            {  0  "the file with no overwrites and/or blank space."
            {  0  "The other alternative was to flush STRING_TEMP(_ZLAST)_OUT one particle at"
            {  0  "a time, which is more time-consuming."
            {  0  "$PHSP_BUFFER_FLUSH must exist in a code that uses $WRITE_PHSP or"
            {  0  "$WRITE_PHSP_RECORD.  It should be placed on its own outside the loop in which"
            {  0  "phase space data is output.  In the case of BEAM, it is placed at the end"
            {  0  "of each batch, so that, if the simulation crashes, phase space information"
            {  0  "from the last batch is not lost."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number for phase space file"
            {  0  "{P3}=file name"
            {  0  "{P4}=particle number +1"
            {  0  "{P5}=scoring plane number"
            {  0  TEMP_PHSP_COUNTER=0;
            {  0  NUM_PHSP_TOFLUSH=WRITE_PHSP_COUNTER({P5});
            {  0  IF(NUM_PHSP_TOFLUSH>0)[
            {  0  IF(WRITE_PHSP_SOFAR({P5})=0)[
            {  0  WRITE_PHSP_COUNTER({P5})=WRITE_PHSP_COUNTER({P5})+1;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH+1; "account for header"
            {  0  ]
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=NUM_PHSP_TOFLUSH+1;
            {  0  LOOP[
            {  0  TEMP_PHSP_COUNTER=TEMP_PHSP_COUNTER-1;
            {  0  REM_PHSP=MOD(WRITE_PHSP_SOFAR({P5}),TEMP_PHSP_COUNTER);
            {  0  ]UNTIL(REM_PHSP=0);
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["write ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_ZLAST_OUT({P5})
            {  0  (32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  32*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7*TEMP_PHSP_COUNTER;
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,
            {  0  ACCESS='DIRECT',FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  WRITE({P2},REC=WRITE_PHSP_SOFAR({P5})/TEMP_PHSP_COUNTER+1)
            {  0  STRING_TEMP_OUT({P5})
            {  0  (28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH)+1:
            {  0  28*(WRITE_PHSP_COUNTER({P5})-NUM_PHSP_TOFLUSH+TEMP_PHSP_COUNTER));
            {  0  ]
            {  0  WRITE_PHSP_SOFAR({P5})=WRITE_PHSP_SOFAR({P5})+TEMP_PHSP_COUNTER;
            {  0  NUM_PHSP_TOFLUSH=NUM_PHSP_TOFLUSH-TEMP_PHSP_COUNTER;
            {  0  ] UNTIL(NUM_PHSP_TOFLUSH=0);
            {  0  WRITE_PHSP_COUNTER({P5})=0;
            {  0  WRITE_PHSP_SOFAR({P5})=0;
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$WRITE_PHSP(#:#,#,#,#,#,#,#:#);} WITH {;
            {  0  "Note that colons     ^             ^  are required between the first and"
            {  0  "second input parameters (5th and 6th input variables) and the"
            {  0  "8th and 9th input parameters (13th and 14th input variables)"
            {  0
            {  0  "This outputs phase space data in blocks of 1000 particles at a time."
            {  0  "In preparation for output, LATCH is modified to hold NPASS and IQ,"
            {  0  "energy (E) is placed into a single precision variable, ESHORT, and"
            {  0  "weight (WT) is given the sign of W.  If this is the first particle"
            {  0  "scored from a new primary (non-phase space source) history, then"
            {  0  "ESHORT is set to -ESHORT and IHSTRY_PHSP is set to IHSTRY."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST,unit number for phase space file,name of phase space file,"
            {  0  "     record number writing to, scoring plane number"
            {  0  "{P2}=IHSTRY"
            {  0  "{P3}=NPASS"
            {  0  "{P4}=IQ"
            {  0  "{P5}=W"
            {  0  "{P6}=ZLAST"
            {  0  "{P7}=LATCH"
            {  0  "{P8}=E,WT"
            {  0  "{P9}=X,Y,U,V"
            {  0
            {  0  $GET_LATCHTMP_ESHORT_WEIGHTTMP({P3},{P4},{P5},{P7},{P8});
            {  0
            {  0  $WRITE_PHSP_RECORD({P1}:{P2},{P6},LATCHTMP,ESHORT,WEIGHTTMP,{P9});
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$READ_PHSP_HEADER(#,#,#,#,#,#,#);} WITH {;
            {  0  "This macro reads the info from the header of a phase space file."
            {  0  "It is called from $OPEN_PHSP_FILE_FOR_WRITE, but can also be used"
            {  0  "as a stand-alone macro."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=unit number"
            {  0  "{P2}=MODE0 or MODE2"
            {  0  "{P3}=total number of particles"
            {  0  "{P4}=no. of photons"
            {  0  "{P5}=max k.e. of particles"
            {  0  "{P6}=min. k.e. of electrons"
            {  0  "{P7}=no. of particles incident from original source"
            {  0
            {  0  READ({P1},REC=1,IOSTAT=IERR_PHSP){P2},NUM_PHSP_TOT,PHOT_PHSP_TOT,
            {  0  EKMAX_PHSP_SHORT,EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  {P3}=NUM_PHSP_TOT;
            {  0  {P4}=PHOT_PHSP_TOT;
            {  0  {P5}=EKMAX_PHSP_SHORT;
            {  0  {P6}=EKMINE_PHSP_SHORT;
            {  0  {P7}=NINC_PHSP_SHORT;
            {  0
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(//' ***ERROR READING HEADER OF PHASE SPACE FILE*** '//);
            {  0  STOP;
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$OPEN_PHSP_FOR_READ(#,#,#,#,#);} WITH {;
            {  0  "Macro to open a phase space file in preparation for reading it."
            {  0  "The macro opens the file in one of 3 modes, as a file that is known"
            {  0  "to have ZLAST (IZLAST>0), as a file that is known not to have ZLAST"
            {  0  "(IZLAST=0), or with no prior knowledge of whether the file has"
            {  0  "ZLAST or not (IZLAST<0)."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  IF({P1}>0)["with ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  "error above on file opening when assumed it was MODE2"
            {  0  OUTPUT;(/' ***error opening file as MODE2 ****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE2 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE3 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE3')[
            {  0  OUTPUT;(//' That file does not start with MODE3,',
            {  0  ' as all old compressed files (with ZLAST) must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE3 file! '/
            {  0  ' Please convert it into a MODE2 file using [readphsp] ',
            {  0  ' and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}=0)["without ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  "$RECL-FACTOR = 4 for SUN SPARC and =1 for SILICON GRAPHICS "
            {  0  "this factor is machine-dependent and stored in machine.mortran"
            {  0  "check file is MODE0 -ie standard compressed"
            {  0  IF(IERR_PHSP~=0)[
            {  0  "come here if error opening file assumed MODE0"
            {  0  OUTPUT;(/' ***ERROR opening file as MODE0****'
            {  0  /' *** THE FILE FORMAT MAY BE WRONG (I.E., NOT A MODE0 FILE) ***'/
            {  0  /' *** WE NOW TRY TO OPEN IT AS A MODE1 FILE ***'//);
            {  0  OPEN(UNIT={P2},STATUS='OLD',FILE={P3},
            {  0  FORM='UNFORMATTED', IOSTAT=IERR_PHSP);
            {  0  "if on error, cannot find file/directory, then stop"
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  STOP;
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE1')[
            {  0  OUTPUT;(//' That file does not start with MODE1,',
            {  0  ' as all old compressed files must'/
            {  0  '  Check it out and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ELSE[
            {  0  OUTPUT;(//' This is a MODE1 file! '/
            {  0  ' Please convert it into a MODE0 file using [readphsp] ',
            {  0  'and try again!'///);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4} ~= 'MODE0')[
            {  0  OUTPUT;
            {  0  (/' Does not start with MODE0 as files without ZLAST must'/
            {  0  '  Try again!'//);
            {  0  IERR_PHSP=1;
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSEIF({P1}<0)["open with no assumptions about whether ZLAST is there or not"
            {  0  OUTPUT;(/' First, try to open it as a MODE0 file');
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE FOUND. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  {P1}=0;
            {  0  IF({P4}~='MODE0')[
            {  0  OUTPUT;(/' The file does not start with MODE0 as it supposed to');
            {  0  CLOSE({P2});
            {  0  OUTPUT;(/' Now try to open it as a MODE2 file');
            {  0  {P1}=1;
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  OPEN(UNIT={P2},FILE={P3},FORM='UNFORMATTED',ACCESS='DIRECT',
            {  0  RECL=PHSP_RECL,STATUS='OLD',IOSTAT=IERR_PHSP);
            {  0  IF(IERR_PHSP~=0)[
            {  0  ;OUTPUT;(//' *** PHASE SPACE FILE CANNOT BE OPENED. ***');
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER({P2},{P4},{P5});
            {  0  IF({P4}~='MODE2')[
            {  0  OUTPUT;(//' That file does not start with MODE2,',
            {  0  ' as standard compressed files with ZLAST must'/
            {  0  '  Check it out and try again!'///);
            {  0  CLOSE({P2});
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  REPLACE {$PARSE_PHSP_HEADER_FOR_WRITE(#,#,#,#,#);} WITH {;
            {  0  "Puts max ke of particles, min ke of electrons, and no. of particles"
            {  0  "incident from original source--all of which may be double precision"
            {  0  "into real*4 variables"
            {  0  "{P1}=tot. no. of particles"
            {  0  "{P2}=no. of photons"
            {  0  "{P3}=max ke of particles"
            {  0  "{P4}=min ke of electrons"
            {  0  "{P5}=no. of particles incident from primary source"
            {  0  IF({P1}>2147483647)[
            {  0  write(*,*)' Warning while writing phase space file:';
            {  0  write(*,*)' No. of particles > 2^31-1.';
            {  0  write(*,*)' Total no. of particles (and photons) written';
            {  0  write(*,*)' to header may be nonsense.';
            {  0  ]
            {  0  NUM_PHSP_TOT={P1};
            {  0  PHOT_PHSP_TOT={P2};
            {  0  EKMAX_PHSP_SHORT={P3};
            {  0  EKMINE_PHSP_SHORT={P4};
            {  0  NINC_PHSP_SHORT={P5};
            {  0  }
               0
               0  REPLACE {$WRITE_PHSP_HEADER(#,#,#,#,#);} WITH {;
            {  0  "Macro to write the header information into a phase space file."
            {  0  "Files must be closed and re-opened with record length (RECL) for"
            {  0  "a single particle in order to prevent over-writing any particle data."
            {  0  "Once the header info is written, the file is closed again and re-opened"
            {  0  "with the RECL for 1000 particles."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE0 or MODE2"
            {  0  "{P5}=total number of particles, no. of photons, max k.e. of particles,"
            {  0  "      min. k.e. of electrons, no. of particles incident from original source"
            {  0
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $PARSE_PHSP_HEADER_FOR_WRITE({P5});
            {  0  WRITE({P2},REC=1){P4},NUM_PHSP_TOT,PHOT_PHSP_TOT,EKMAX_PHSP_SHORT,
            {  0  EKMINE_PHSP_SHORT,NINC_PHSP_SHORT;
            {  0  CLOSE({P2});
            {  0  IF({P1}~=0)["have ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},RECL=PHSP_RECL,ACCESS='DIRECT',
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  }
               0  ;
               0
               0
               0  REPLACE {$OPEN_PHSP_FOR_WRITE(#,#,#,#);} WITH {;
            {  0  "This macro opens a phase space file for writing.  The file is opened with"
            {  0  "a record length that will hold phase space data for 1000 particles in 1"
            {  0  "record.  This is to to enable writing phase space data for 1000 particles"
            {  0  "at a time (see the $WRITE_PHSP_RECORD macro above).  The macro also uses"
            {  0  "$WRITE_PHSP_HEADER to output a dummy header to the file."
            {  0
            {  0  "Input parameters:"
            {  0  "{P1}=IZLAST"
            {  0  "{P2}=unit number"
            {  0  "{P3}=file name"
            {  0  "{P4}=MODE_RW"
            {  0  IF({P1}~=0)["with ZLAST"
            {  0  {P4}='MODE2';
            {  0  PHSP_RECL=$RECL-FACTOR*8000;
            {  0  ]
            {  0  ELSE["no ZLAST"
            {  0  {P4}='MODE0';
            {  0  PHSP_RECL=$RECL-FACTOR*7000;
            {  0  ]
            {  0  OPEN(UNIT={P2},FILE={P3},ACCESS='DIRECT',RECL=PHSP_RECL,
            {  0  FORM='UNFORMATTED',STATUS='UNKNOWN');
            {  0  $WRITE_PHSP_HEADER({P1},{P2},{P3},{P4},0,0,0,0,0);
            {  0  }
               0  ;
               0
               0  REPLACE {$CLOSE_PHSP(#);} WITH {;
            {  0  "Macro to close a phase space file."
            {  0
            {  0  "Input parameter:"
            {  0  "{P1}=the unit number of the phase space file"
            {  0
            {  0  CLOSE(UNIT={P1});
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_WRITE(#,#,#,#,#,#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0
               0  REPLACE {$IAEA_OPEN_PHSP_FOR_READ(#,#);} WITH {;
            {  0
            {  0  OUTPUT; (//' Sorry, this code has not been compiled with the IAEA phase'/
            {  0  ' space handling macros.'//);
            {  0  }
               0  ;
               0  REPLACE {$IAEA_WRITE_PHSP_RECORD(#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_HEADER(#,#,#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_PHSP_RECORD(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_READ_PHSP_RECORD(#,#,#,#,#,#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_DESTROY_PHSP_FILE(#);} WITH {;}
               0
               0  REPLACE {$IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(#,#);} WITH {;}
               0
               0  REPLACE {$IAEA_UPDATE_PHSP_HEADER(#);} WITH {;}
               0
               0  REPLACE {$IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(#);} WITH {;}
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE                  [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  "AUNIT is a character variable"
            {  0  "construct phase space file name."
            {  0  "part of this--the part that determines the directory and"
            {  0  "file prefix--is done in beam"
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,0,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $OPEN_PHSP_FOR_WRITE(IZLAST,IOUTFLU(I),$cstring(phsp_fn),MODE_RW);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_OPEN_PHSP_FOR_READ;} WITH {;
            {  0  OUTPUT;
            {  0  (/' Restarting after previous run, will read old data & phase-space',
            {  0  ' files');
            {  0  DO I=1,NSC_PLANES [
            {  0  OUTPUT IOUTFLU(I);(//' Checking ph-sp file on logical unit ',I4);
            {  0  :OPEN_MODE0:;
            {  0  IF(IOUTFLU(I)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I)-43;]
            {  0  IF(IO_OPT=4)[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.' //AUNIT//char(0);
            {  0  Z_SCORE_SHORT=Z_min_CM(IPLANE_to_CM(I)+1);
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(IOUTFLU(I),$cstring(phsp_fn),
            {  0  IZLAST,1,Z_SCORE_SHORT,I_MU_PHSP,0);
            {  0  ]
            {  0  ELSE[
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0
            {  0  $OPEN_PHSP_FOR_READ(IZLAST,IOUTFLU(I),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_WRITE_PHSP;} WITH {;
            {  0  IF(IOUTFLU(ISCORE)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(ISCORE)-43;]
            {  0  ELSE                       [WRITE(AUNIT,'(I1)') IOUTFLU(ISCORE)-43;]
            {  0
            {  0  "output directory and file prefix are defined in beam.mortran"
            {  0
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_WRITE_PHSP_RECORD(IOUTFLU(ISCORE),NPASS(NP,ISCORE),
            {  0  ISCORE,NHSTRY,LATCH(NP),IQ(NP),E(NP),WT(NP),
            {  0  X(NP),Y(NP),Z(NP),U(NP),V(NP),W(NP),ZLAST(NP),
            {  0  BEAM_MU_INDEX);
            {  0  ]
            {  0
            {  0  ELSE[
            {  0
            {  0  IF( i_parallel > 0 ) ["add an _w"
            {  0  phsp_fn=$cstring(phsp_fn)// '_w';
            {  0  call egs_itostring(phsp_fn,i_parallel,.false.);
            {  0  ]
            {  0  phsp_fn=$cstring(phsp_fn)// '.egsphsp'//AUNIT;
            {  0  $WRITE_PHSP(IZLAST,IOUTFLU(ISCORE),$cstring(phsp_fn),NPPHSP(ISCORE)+1,
            {  0  ISCORE:NHSTRY,NPASS(NP,ISCORE),IQ(NP),W(NP),ZLAST(NP),
            {  0  LATCH(NP),E(NP),WT(NP):X(NP),Y(NP),U(NP),V(NP));
            {  0  ]
            {  0  IF(IZLAST = 2)[
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
            {  0  JHSTRY=JHSTRY+1;
            {  0  WRITE(IOUTGPH,:GRAPHICS_FORMAT2:) NP,IQ(NP),0,
            {  0  XLAST(NP),YLAST(NP),ZLAST(NP),0;
            {  0  :GRAPHICS_FORMAT2:FORMAT(3I4,4G15.8,I12);
            {  0  ]
            {  0  "Check only needed when actually writting to a phsp file"
            {  0  IF(NPPHSP(ISCORE)=phsp_upper_limit)[
            {  0  $egs_fatal('(//a,i19,4(a/))',
            {  0  ' *** WHILE WRITING PHASE SPACE FILE:',
            {  0  NPPHSP(ISCORE), ' particles in file.',
            {  0  ' Due to the fact that the counter for the number',
            {  0  ' of particles in the file cannot be larger than this,',
            {  0  ' no more particles will be written to the phsp file.'
            {  0  );
            {  0  ]
            {  0  };
               0
               0  REPLACE {$BEAM_PHSP_BUFFER_FLUSH;} WITH {;
            {  0  IF(IO_OPT=4)["update no. of primary histories in header"
            {  0  DO I1=1,NSC_PLANES[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(IOUTFLU(I1),NINCPHSP);
            {  0  $IAEA_UPDATE_PHSP_HEADER(IOUTFLU(I1));
            {  0  ]
            {  0  ]
            {  0  ELSE["standard BEAMnrc format"
            {  0  IF(MODE_RW='MODE0' | MODE_RW='MODE2')[
            {  0  NINCPHSP=NINCSRC*(IHSTRY+(NRCYCL+1)*(NPASS_ph_sp+NFAT_ph_sp))/NNPHSP;
            {  0  DO I1=1,NSC_PLANES[
            {  0  NPPHSPSP=NPPHSP(I1);
            {  0  IF(IOUTFLU(I1)-43 > 9) [WRITE(AUNIT,'(I2)') IOUTFLU(I1)-43;]
            {  0  ELSE               [WRITE(AUNIT,'(I1)') IOUTFLU(I1)-43;]
            {  0
            {  0  "output directory and file prefix defined in beam.mortran"
            {  0
            {  0  phsp_fn=$cstring(phsp_fn_base)// '.egsphsp'//AUNIT;
            {  0  $PHSP_BUFFER_FLUSH(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),NPPHSPSP,I1);
            {  0  IF(NPPHSPSP=NPHOTPHSP(I1))[
            {  0  "no electrons"
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), 0.0, NINCPHSP);
            {  0  ]
            {  0  ELSE[
            {  0  $WRITE_PHSP_HEADER(IZLAST,IOUTFLU(I1),$cstring(phsp_fn),
            {  0  MODE_RW,NPPHSPSP,NPHOTPHSP(I1),
            {  0  EKMAXPHSP(I1), EKMINPHSPE(I1), NINCPHSP);
            {  0  ]
            {  0  ]
            {  0  "we store the total particle number in the 1st record of the ph-sp file"
            {  0  ]
            {  0  ]"end of standard BEAMnrc format"
            {  0  };
               0
               0  REPLACE {$BEAM_READ_PHSP_FOR_RESTART;} WITH {;
            {  0  DO I=1,NSC_PLANES[
            {  0  OUTPUT I,NPPHSP(I);
            {  0  (//' PH-SP FILE',I4,': '/
            {  0  '               TOTAL NO. OF PARTICLES =',I12);
            {  0  IF(IO_OPT=0 | IO_OPT=3)["check to see that the user has not"
            {  0  "added phase space files before restarting"
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_READ_PHSP_HEADER(IOUTFLU(I),NPPHSP(I),NPHOTPHSP(I),
            {  0  EKMAXPHSP(I),NINCPHSP,Z_SCORE,IZLAST1,I_MU_PHSP,IZSCORE);
            {  0  EKMINPHSPE(I)=99999.; "info unavailable"
            {  0  IF(IZLAST=0 & IZLAST1=1)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored with ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=0.  Restart with'/
            {  0  ' IZLAST=1.'//);
            {  0  STOP;
            {  0  ]
            {  0  ELSEIF(IZLAST=1 & IZLAST1=0)[
            {  0  OUTPUT;
            {  0  (//' Error: Phase space file was scored  without ZLAST in previous run '/
            {  0  ' but you have restarted this run with IZLAST=1.  Restart with'/
            {  0  ' IZLAST=0.'//);
            {  0  STOP;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_HEADER(IOUTFLU(I),MODE_RW,NPPHSPSP,
            {  0  NPHOTPHSP(I),EKMAXPHSP(I),EKMINPHSPE(I),NINCPHSP);
            {  0  NPPHSP(I)=NPPHSPSP;
            {  0  ]
            {  0  IF(NINCPHSP>
            {  0  NINCSRC*(NCASEO+(NRCYCL+1)*(NPASS_ph_spO+NFAT_ph_spO))/NNPHSP)[
            {  0  "files have been added"
            {  0  OUTPUT I;(//' ***ERROR:'/
            {  0  ' Phase space file',I4,' has been added to (using beamdp?) before restarting.'/
            {  0  ' The code currently does not support this.  Please add phase space'/
            {  0  ' files only after all runs, including restarts, are complete.'//);
            {  0  "STOP;"
            {  0  ]
            {  0  ]
            {  0  IF(NPPHSP(I) > 0)[
            {  0  CALL DATETIME(1);
            {  0  OUTPUT TIMEN;(/' READ PH-SP FILE AT ',$TIMEN_FORMAT);
            {  0  "Read last particles to check whether it is right"
            {  0  IF(IO_OPT=4)[
            {  0  "just check that file size=checksum"
            {  0  $IAEA_CHECK_PHSP_SIZE_BYTE_ORDER(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  $READ_PHSP_RECORD(IZLAST,IOUTFLU(I),NPPHSP(I)+1:
            {  0  NHSTRYM,ZLAST(1),LATCHM,EINM,WTM,XINM,YINM,UINM,VINM);
            {  0  "binary read"
            {  0  OUTPUT NPPHSP(I),LATCHM,EINM,XINM,YINM,UINM,VINM,WTM;(//
            {  0  ' (LATCHM,EINM,XINM,YINM,UINM,VINM,WTM) FOR PARTICLE No.',
            {  0  I12,' IN THIS FILE:'/' ',I12,6F12.5);
            {  0  "CALL TIME(TIMEN);"
            {  0  "OUTPUT TIMEN;"
            {  0  "(/' FINISHED READING PH-SP FILE AT ',$TIMEN_FORMAT);"
            {  0  ]
            {  0  OUTPUT; (/' FINISHED READING PH-SP FILE AT ',$);
            {  0  call egs_time(6); OUTPUT; (' ');
            {  0  ]
            {  0  ]"end of loop over planes"
            {  0  };
               0
               0  REPLACE {$BEAM_CLOSE_PHSP;} WITH {;
            {  0  IF(n_parallel=0 | ~is_finished) [
            {  0  "do not close phsp files that have already been closed"
            {  0  "after individual parallel jobs have ended"
            {  0  IF (IO_OPT =  0)|((IO_OPT =  3)&(IHSTRY <= 100000))|(IO_OPT=4) [
            {  0  "phase-space output"
            {  0  DO I=1,NSC_PLANES [
            {  0  IF(IO_OPT=4)[
            {  0  $IAEA_DESTROY_PHSP_FILE(IOUTFLU(I));
            {  0  ]
            {  0  ELSE[
            {  0  CLOSE(IOUTFLU(I));
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_OPEN_PHSP_FOR_WRITE;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps."
            {  0  "Some mods by BW."
            {  0  IF(IRESTART=0) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,0,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  ELSEIF(IRESTART=1) [
            {  0  $IAEA_OPEN_PHSP_FOR_WRITE(i_unit_out,$cstring(phsp_out_fn),
            {  0  0,1,z_score_tmp,i_muidx_out,1);
            {  0  ]
            {  0  };
               0
               0  REPLACE {$DOSXYZ_WRITE_PHSP;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  $IAEA_WRITE_PHSP_RECORD(i_unit_out,0,
            {  0  1,nhist,latch(np),iq(np),e(np),
            {  0  wt(np), x(np),y(np),z(np),u(np),v(np),w(np),zlast_tmp,
            {  0  frMU_indx); "added MU index (JL 2013)"
            {  0  "zlast not used in dosxyz so this is a dummy variable"
            {  0
            {  0  };
               0
               0  REPLACE {$DOSXYZ_SET_OUT_PHSP_HEADER;} WITH {;
            {  0  "Added by T. popescu and J.Lobo to write phsps in dosxyz."
            {  0  "only done for IAEAphsps"
            {  0  IF(isource = 0 |  isource = 1 | isource = 3 | isource = 7)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss-nmissm);
            {  0  ]
            {  0  ELSEIF(isource = 2 | isource = 8 )[
            {  0  ainflu=dble(IHSTRY+ncaseold+nsmiss+
            {  0  (NRCYCL+1)*(nsrjct+nsoutside+ndbsrjct))/float(nshist)*NINCSRC;
            {  0  ]
            {  0  ELSEIF(isource=4)[
            {  0  ainflu=dble(IHSTRY+ncaseold-nsmiss);
            {  0  ]
            {  0  ELSEIF(isource=6)[
            {  0  ainflu=dble(IHSTRY+ncaseold);
            {  0  ]
            {  0  ELSEIF(isource=9|isource=10|isource=21)[
            {  0  ainflu=dble(nhist);
            {  0  ]
            {  0  ELSEIF(isource=20)[
            {  0  ainflu = dble((NRCYCL+1)*(nnread))/dble(nshist)*NINCSRC;
            {  0  ]
            {  0  $IAEA_SET_ORIGINAL_PARTICLES_IN_PHSP(i_unit_out,ainflu);
            {  0  $IAEA_UPDATE_PHSP_HEADER(i_unit_out);
            {  0
            {  0  };
               0
               0  " The following are null macros that will be overwritten by the library "
               0  " version of BEAM "
               0  REPLACE {$DECLARE-PARTICLE-CONTAINER;} WITH {;};
               0
               0  "End of phsp_macros.mortran"
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros required by srcsph.mortran                                   "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Ernesto Mainegra-Hing, 2002                               "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Derived from srcrz.macros.                                                 "
               0  "                                                                             "
               0  "  These are macros used by srcsph.mortran which need to be defined before    "
               0  "  the user code because values are input to it.                              "
               0  "                                                                             "
               0  "  This code was stripped out of the user codes and out of srcsph.mortran,    "
               0  "  since having it defined twice could lead to errors.                        "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  ;
               0  REPLACE {;COMIN/SOURCE/;} WITH {
            {  0  "       ================="
            {  0  ;
            {  0  COMMON/SOURCE/
            {  0  RCDFIN($MXRDIST,2),RDISTF(100),RPDF(100),RCDF(100),
            {  0  AINFLU,RBEAM,RBEAM2,ABEAM,UINC,VINC,WINC,DISTR,DISTR2,
            {  0  SVTMP1,SVTMP2,SVTMP3,SVTMP4,
            {  0  ISRCTY, NRDIST, IDSTON;
            {  0
            {  0  DIMENSION SRCEQ(23),SRCPAR(23),SRCPT(23),ISRCEQ(2),ISRCPR(2),ISRCPT(2);
            {  0
            {  0  $INTEGER ENFLAG,IMODE,NPHSPN,NCASE_PHSP,
            {  0  NRDIST,NSRCRG,ISRPT,ISRPAR,NSHIST,NSLEFT,NPASS,NNREAD,
            {  0  ISRCTY, IDSTON;
            {  0
            {  0  $REAL    RCDFIN,RDISTF,RPDF,RCDF,AINFLU,RBEAM,RBEAM2,ABEAM,
            {  0  UINC,VINC,WINC,DISTR,DISTR2,
            {  0  SVTMP1,SVTMP2,SVTMP3,SVTMP4;
            {  0
            {  0  $REAL    SRCEQ,SRCPAR,SRCPT;
            {  0  $INTEGER ISRCEQ,ISRCPR,ISRCPT;
            {  0  EQUIVALENCE (SRCEQ(1), AINFLU),(ISRCEQ(1),NRDIST);
            {  0  "Adapted type declarations from cavrznrc, EMH January 2002"
            {  0  }
               0  "COMMON USED FOR PASSING INFORMATION SPECIFIC TO SOURCES
               0  "RCDFIN   INVERSE OF THE RADIAL CUMULATIVE PROBABILITY FUNCTION (ISOURC=20)
               0  "RDISTF   RADIAL MESH POINTS FOR THE RADIAL PROBABILITY FUNCTION (ISOURC=20)
               0  "RPDF     RADIAL PROBABILITY FUNCTION (ISOURC=20)
               0  "RCDF     RADIAL CUMULATIVE PROBABILITY FUNCTION (ISOURC=20)
               0  "AINFLU   INCIDENT FLUENCE
               0  "RBEAM    RADIUS OF THE BEAM AT THE FRONT OF THE TARGET
               0  "RBEAM2   = RBEAM**2
               0  "ABEAM    AREA OF THE BEAM ON THE SURFACE
               0  "UINC     INCIDENT X-AXIS DIRECTION COSINE (ISOURC=0)
               0  "VINC     INCIDENT Y-AXIS DIRECTION COSINE (ISOURC=0)
               0  "WINC     INCIDENT Z-AXIS DIRECTION COSINE (ISOURC=0)
               0  "XBEAM    HALF-HEIGHT OF THE BEAM AT THE CENTER OF THE TARGET
               0  "ZBEAM    HALF-WIDTH OF THE BEAM AT THE CENTER OF THE TARGET
               0  "DISTR   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
               0  "DISTR2   = DISTR**2
               0  "ISRCTY   = 0 => PARALLEL SOURCE (ISOURC=0,10)
               0  "         = 1 => POINT    SOURCE (ISOURC=1,11)
               0  "NRDIST   # RADIAL BINS IN DISTRIBUTION HISTOGRAM (ISOURC=10,11)
               0  "IDSTON   = 0 RADIAL DISTRIBUTION OFF, = 1 ON (ISOURC=10,11)
               0  "Last line in srcsph.macros "
               0
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc cavsphnrc application                                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Alex Bielajew, 1988                                       "
               0  "                                                                             "
               0  "  Contributors:    Joanne Treurniet                                          "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Iwan Kawrakow                                             "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This code was originally adapted from CAVRZ V0.09 by Alex Bielajew         "
               0  "  in 1988.                                                                   "
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The cavsphnrc application simulates the passage of an electron or photon   "
               0  "  beam in a finite, spherical-conical geometry. It is intended for use in    "
               0  "  calculating quantities of interest for thick-walled ion chambers exposed   "
               0  "  to photon beams although it may be used simply to score dose in a          "
               0  "  spherical-conical geometry.                                                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %L TURN ON LISTING IN CASE IT WAS OFF FOR EGS                                  ;
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  ;
               0  REPLACE {$VERSION} WITH {,' ',};
               0
               0  REPLACE {$MXMDSH} WITH {200};
               0
               0  "This line is 80 characters long, use it to set up the screen width
               0  "23456789|123456789|123456789|123456789|123456789|123456789|123456789|123456789|
               0  "******************************************************************************
               0  "
               0  "
               0  "                               *********************
               0  "                               *                   *
               0  "                               * CAVSPHnrc.mortran *
               0  "                               *                   *
               0  "                               *********************
               0  "
               0  "
               0  "       INTRODUCTION:
               0  "       THIS CODE SIMULATES THE PASSAGE OF AN ELECTRON OR PHOTON BEAM IN A
               0  "       FINITE, SHPERICAL-CONICAL GEOMETRY.
               0  "       IT IS INTENDED FOR USE IN CALCULATING QUANTITIES OF INTEREST FOR
               0  "       THICK-WALLED ION CHAMBERS EXPOSED TO PHOTON BEAMS ALTHOUGH IT MAY
               0  "       BE USED SIMPLY TO SCORE DOSE IN A SPHERICAL-CONICAL GEOMETRY. IN
               0  "       ADDITION TO SCORING DOSE, THE FOLLOWING QUANTITIES MAY ALSO BE
               0  "       SCORED:
               0  "
               0  "          1)THE Aatt  CORRECTION FACTOR    (attenuation of primary beam),
               0  "          2)THE Ascat CORRECTION FACTOR    (photon scatter),
               0  "          3)THE Apn   CORRECTION FACTOR    (for point-source beams, obtained
               0  "                                             by correlated sampling),
               0  "          4)THE Afl   CORRECTION FACTOR    (obtained by correlated sampling),
               0  "          5)<s>g,w STOPPING POWER RATIO    (obtained by correlated sampling)
               0  "
               0  "       FOR A DERIVATION OF THE ABOVE FACTORS, CONSULT
               0  "       `Correction factors for thick-walled ionisation chambers in
               0  "        point source photon beams' by AF Bielajew PMB 35(1990)501-516.
               0  "
               0  "       STARTING WITH VERSION 4.0 OF cavsphnrc, CONVERTING TO SPHERICAL
               0  "       COORDINATES (R, THETA). -- APRIL 1999, JT
               0  "
               0  "******************************************************************************
               0  "
               0  "       ADAPTED FROM AN EARLIER VERSION OF CAVSPHnrc AND INTRODUCING MANY OF
               0  "       THE CURRENT IMPROVEMENTS IN CAVRZnrc.
               0  "
               0  "       - only IFULL=0 and 1 are currently available,i.e.,only Dgas, Dgas/Awall,
               0  "         Ascat, Aatt and Awall are currently calculated.
               0  "
               0  "       - Scoring is performed on a hist/hist basis parallel to the usual batch
               0  "         scoring mode.
               0  "
               0  "       - Although most ion chambers are modeled with pure spherical geometries,
               0  "         one could use this code to just score the dose in a spherical-conical
               0  "         geometry.
               0  "
               0  "       - Sources available : parallel (0) and point source (1) from any angle.
               0  "         One can also select ISOURC=4 to have photons starting at origin moving
               0  "         along the z-axis and forcing the first interaction, but it hasn't been
               0  "         tested here. A code for point spread function calculations is also
               0  "         available: PSFnrc.mortran
               0  "
               0  "                                                       EMH, October, 2003
               0  ;
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "                                TITLE
               0  "                                *****
               0  "*******************************************************************************
               0  "
               0  "CARD TI1
               0  "
               0  "       TITLE          (C)  TITLE OF THE INPUT FILE (FORMAT= '80A1')
               0  ;
               0  "*******************************************************************************
               0  "
               0  " I/O DELIMETERS:    :start I/O control:
               0  "                    :stop I/O control:
               0  "
               0  "*******************************************************************************
               0  "                       INPUT/OUTPUT CONTROL INPUT
               0  "                       **************************
               0  "*******************************************************************************
               0  "
               0  "CARD IO1
               0  "
               0  "  IWATCH= off         (0)  FOR NORMAL OUTPUT
               0  "        = interactions(1)  OUTPUT ON EVERY DISCRETE INTERACTION
               0  "        = steps       (2)  OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
               0  "        = deposited   (3)  PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
               0  "        = graph       (4)  PRINTS OUT FILE FOR GRAPHICS
               0  "
               0  "  STORE INITIAL RANDOM NUMBERS
               0  "        = no          (0)  DO NOT STORE THE INITIAL RANDOM NUMBERS
               0  "        = last        (1)  STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
               0  "        = all deposited (2)STORE THE INITIAL RANDOM NUMBER FOR ALL
               0  "                           THAT DEPOSIT ENERGY IN THE CAVITY
               0  "        = all         (3)  STORE ALL THE INITIAL RANDOM NUMBERS
               0  "
               0  "  IRESTART
               0  "        = first       (0)  FIRST RUN FOR THIS DATA SET
               0  "        = restart     (1)  RESTART OF A PREVIOUS RUN
               0  "        = make        (2)  JUST CREATE THE INPUT FILE AND EXIT
               0  "        = analyze     (3)  JUST READ IN THE RAW DATA AND DO THE STATISTICAL
               0  "                           ANALYSIS
               0  "        = for graphics(4)  READ STARTING RANDOM NUMBERS FROM A FILE (e.g. FOR
               0  "                           OUTPUT TO A GRAPHICS PACKAGE)
               0  "
               0  "  OUTPUT OPTIONS
               0  "        = short              (0)  SHORT OUTPUT -JUST THE CAVITY SUMMARY
               0  "                                  AND THE DOSE GRID.
               0  "        = cavity details     (1)  ABOVE PLUS DETAILS FOR EACH CAVITY ZONE
               0  "
               0  "  STORE DATA ARRAYS
               0  "        = yes             (0) Store data arrays for re-use
               0  "        = no              (1) don't store them
               0  ;
               0  "*******************************************************************************
               0  "
               0  " MONTE CARLO DELIMETERS:    :start Monte Carlo inputs:
               0  "                            :stop Monte Carlo inputs:
               0  "
               0  "*******************************************************************************
               0  "                       MONTE CARLO CONTROL INPUT
               0  "                       *************************
               0  "*******************************************************************************
               0  "
               0  "CARD MC1
               0  "
               0  "  NUMBER OF HISTORIES         (I)  # HISTORIES TO RUN
               0  "                                   (MIN:100, DEFAULTS TO 20 000)
               0  "
               0  "  INITIAL RANDOM NO. SEEDS    (M2) IXX, JXX
               0  "               IXX   RANDOM NUMBER INITIAL SEED, MUST BE AN ODD INTEGER
               0  "               JXX   0 OR EVEN INTEGER
               0  "
               0  "  MAX CPU HOURS ALLOWED       (I)  MAX CPU TIME ALLOWED IN HOURS, DEFAULT=0.99
               0  "
               0  "  IFULL
               0  "         = dose and stoppers         (0) just calculate total dose and that due
               0  "                                         to stoppers and discards.
               0  "         = Aatt and Ascat            (1) Above plus Aatt, Ascat
               0  "         = Ap                        (2) Above plus Ap as well
               0  "         = Afl and <s>g w            (3) Above plus Afl and <s>g,w as well
               0  "
               0  "  NOTE THAT IFULL>=2 DOES NOT WORK YET -- JT
               0  "
               0  "  STATISTICAL ACCURACY SOUGHT        (R) % statistical accuracy of the total
               0  "                                         dose in the peak region that is sought
               0  "                                         The program executes until this
               0  "                                         accuracy is obtained ot the CPU time
               0  "                                         runs out.
               0  "
               0  "  PHOTON REGENERATION
               0  "         = yes (ifano = 1) the calculation is performed with regeneration
               0  "                           of the parent photon after they have interacted. A
               0  "                           typical setting when FANO conditions are examined.
               0  "         = no (ifano = 0)  a normal calculation.
               0  "
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "
               0  " GEOMSPH DELIMETERS:    :start geometrical inputs:
               0  "                       :stop geometrical inputs:
               0  "
               0  "*******************************************************************************
               0  "                  SPHERICAL GEOMETRY & MATERIAL INPUT
               0  "                  *************************************
               0  "
               0  "CARD CGM1
               0  "
               0  "  NUMBER OF CONES        (M)   number of cones (individual or by group)
               0  "                               If omitted or ZERO, pure spherical geometry
               0  "                               assumed.
               0  "
               0  "  ANGLES                 (M)   ANGLES defining the geometry (reals)
               0  "                               No needed in pure spherical geometries.
               0  "
               0  "                               For group input there must be as many entries
               0  "                               as for the NUMBER OF CONES, i.e. :
               0  "                               NCON1,NCON2,...,NCONn
               0  "                               DANG1,DANG2,...,DANGn
               0  "
               0  "                               For individual input, ncones must be equal
               0  "                               to the number of entries, i.e.:
               0  "                               ncones
               0  "                               DANG1, DANG2,...,DANGncones
               0  "
               0  "  NUMBER OF SPHERES      (M)   number of spheres (individual or by group)
               0  "
               0  "                               For individual inputs, number of spheres
               0  "                               can be omitted
               0  "
               0  "
               0  "  RADII                  (M)   radii of spheres defining the geometry (reals)
               0  "
               0  "                               For group input there must be as many entries
               0  "                               as for the NUMBER OF SPHERES, i.e. :
               0  "                               NSPH1,NSPH2,...,NSPHn
               0  "                               DRAD1,DRAD2,...,DRADn
               0  "
               0  "  CAVITY ZONES           (M)   geometrical zone numbers in the cavity (reals)
               0  "
               0  "*******************************************************************************
               0  "                                MATERIAL INPUT
               0  "                                **************
               0  "*******************************************************************************
               0  "
               0  "CARD M1
               0  "
               0  "  MEDIA                  (M)   TYPE OF MATERIAL (FMT='24A1')
               0  "                               BY CONVENTION THE PRIMARY WALL
               0  "                               MATERIAL IS FIRST, THE CAVITY MATERIAL
               0  "                               IS SECOND AND THE REST FOLLOWS
               0  "
               0  "*******************************************************************************
               0  "
               0  "CARD M3-A  (CHOICE OF CARD M3-A AND CARD M3-B)
               0  "
               0  "  MEDNUM                 (M)   THE MATERIAL NUMBER (INTEGERS)
               0  "                               (MEDNUM=0 TO SKIP)
               0  "  START REGION           (M)   INITIAL GEOMETRICAL ZONE(IRL) (INTEGERS)
               0  "  STOP REGION            (M)   FINAL GEOMETRICAL ZONE(IRL) (INTEGERS)
               0  "                               ( >NREGLO TO INPUT MORE THAN ONE ZONE)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "
               0  ;
               0  "*******************************************************************************
               0  "
               0  " SOURCE DELIMETERS:    :start source inputs:
               0  "                       :stop source inputs:
               0  "
               0  "*******************************************************************************
               0  "                             SOURCE INPUT
               0  "                            **************
               0  "*******************************************************************************
               0  "CARD SC1       FOR ALL SOURCES
               0  "                                      CHARGE OF THE INCIDENT BEAM
               0  "  INCIDENT PARTICLE= electron   (-1)  ELECTRONS
               0  "                     photon     (0)   PHOTONS
               0  "                     positron   (1)   POSITRONS
               0  "
               0  "  (IF SOURCE 21)     all        (2)   INCLUDE ALL OF THE PARTICLES
               0  "                                      IN THE PHASE SPACE FILE
               0  "
               0  "  SOURCE NUMBER                 (I)   NUMBER OF THE SOURCE
               0  "
               0  " SOURCE DELIMETERS:    :start source inputs:
               0  "                       :stop source inputs:
               0  "
               0  "FOR ALL SOURCES
               0  "                                      Charge of the incident beam
               0  "  INCIDENT PARTICLE= electron   (-1)  electrons
               0  "                     photon     (0)   photons
               0  "                     positron   (1)   positrons
               0  "
               0  "  SOURCE NUMBER                 (I)   number of the source
               0  "                                      [ISOURC]
               0  "
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 0:    FOR PARALLEL BEAM FROM ANY ANGLE
               0  "              RBEAM,UINC,VINC,WINC
               0  "               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
               0  "                               DEFAULTS TO MAX RADIUS
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 1:   FOR POINT SOURCE INCIDENT FROM ANY ANGLE
               0  "             DISTR,RBEAM,UINC,VINC,WINC
               0  "               DISTR   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
               0  "                       IN CM (DEFAULTS TO 100.)
               0  "               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
               0  "                               DEFAULTS TO MAX RADIUS
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and default parameters assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  You can change this by including the statement
               0  "
               0  "  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
               0  "
               0  "  in your input file.
               0  "
               0  "  Currently, the following options are available (except for a few entries,
               0  "  case does not matter):
               0  "
               0  "       Global ECUT=     Set a global (in all regions) electron transport
               0  "                        cut off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Set a global (in all regions) photon transport
               0  "                        cut off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Set a global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions will
               0  "                        be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Set the maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%)
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        even in `well conditioned' situations (e.g. depth
               0  "                        dose curves for RTP energy range electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If On, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but signifficant in the keV energy range.
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski or penelope.  If set to On or ik, then
               0  "                        use Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then use the cross-sections of
               0  "                        Casnati (from file ($HEN_HOUSE/data/eii_casnati.data).
               0  "                        Similar for kolbenstvedt, gryzinski and penelope.
               0  "                        This is only of interest in kV X-ray calculations.
               0  "                        Note that the user can supply their own EII
               0  "                        cross-section data as well. The requirement is that
               0  "                        the file eii_suffix.data exists in the $HEN_HOUSE/data
               0  "                        directory, where suffix is the name specified.
               0  "                        Entry case-sensitive except for Off, On or ik.
               0  "                        [ eii_flag ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impuls approximation. Default is On.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to turn on for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Pair angular sampling= Off, Simple or KM
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.
               0  "                        Default is Simple, make sure you always use Simple or
               0  "                        KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel--the default), epdl (Evaluated Photon
               0  "                        Data Library), xcom and pegs4.  Allows the use of
               0  "                        photon cross-sections other than from the PEGS4 file
               0  "                        unless the pegs4 option is specified.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is On
               0  "                        [ IPHTER ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turn on coherent (Rayleigh) scattering,
               0  "                        even if no Rayleigh data in PEGS4 file.
               0  "                        Default is Off. Should be turned on for low energy
               0  "                        applications. If custom, user must provide media names
               0  "                        and form factor files for each medium.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "       Atomic relaxations= Off, On
               0  "                        Default is On. The effect of using On is twofold:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross seections
               0  "                        - Shell vacancies created in photo-absorption events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         Make sure to turn this option on for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "                         can also be turned On/Off on a region-by-region
               0  "                         basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn off in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0  "
               0  "                    VARIANCE REDUCTION
               0  "                    ******************
               0  "
               0  "  Delimeter:       :start variance reduction:
               0  "                   :stop variance reduction:
               0  "
               0  "  ELECTRON RANGE REJECTION
               0  "         = off        (0)  No electron range rejection
               0  "         = on         (1)  Do electron range rejection.
               0  "                           There are 2 components to range rejection.
               0  "                           One uses the EGSnrc range rejection below ESAVEIN
               0  "                           and terminates any charged particle which cannot get
               0  "                           out of its local region.
               0  "                           The second component terminates any charged particle
               0  "                           which cannot reach the cylinder which encloses the
               0  "                           cavity region and any other region of the same
               0  "                           material as the cavity.  This cylinder is determined
               0  "                           automatically.
               0  "                           The parameter ESAVEIN also plays a role (see below)
               0  "                           [IREJCT]
               0  "
               0  "  ESAVEIN             (R)  If ELECTRON RANGE REJECTION is on, discard an
               0  "                           electron  when E< ESAVEIN and RANGE < CDIST
               0  "                           where CDIST is closest distance to region of
               0  "                           interest specified below. This ignores brem
               0  "                           losses below ESAVEIN.
               0  "                           This parameter must be input even if not used.
               0  "                           Note - ESAVEIN is total energy (with 511 keV)
               0  "
               0  "  EXPONENTIAL TRANSFORM C     (R)
               0  "                           PARAMETER FOR PATHLENGTH BIASING <0 FOR SHORTENING
               0  "                           IF 0.0, NO BIASING DONE
               0  ;
               0  "
               0  "  PHOTON FORCING
               0  "        = Off         (0)    NORMAL PHOTON TRANSPORT (NO FORCING)
               0  "        = On          (1)    FORCE PHOTON INTERACTIONS EXPLICITLY
               0  "                             MUST SET START AND STOP FORCING IN THIS CASE
               0  "
               0  "  START FORCING       (I)    NUMBER OF PHOTON INTERACTION/HISTORY AT WHICH
               0  "                             TO START FORCING PHOTON INTERACTIONS
               0  "
               0  "  STOP FORCING AFTER  (I)    NUMBER OF PHOTON INTERACTION/HISTORY AFTER WHICH
               0  "                             TO STOP FORCING PHOTON INTERACTIONS
               0  "
               0  "                             STOP FORCING AFTER > OR = START FORCING
               0  "
               0  "*****************************************************************************"
               0  "
               0  "                       USER DEFINED MACROS
               0  "                       *******************
               0  "
               0  ;
               0  "******************************************************************************
               0  ;
               0  REPLACE {$ONE-EPS} WITH {0.9999} "USED TO KEEP THE BEAM INSIDE THE TARGET"
               0  REPLACE {$NSWTCH} WITH {8}       "# OF NRC SWITCHES FOR CONTROLLING SCATTERING"
               0  REPLACE {$MXMED} WITH {3}        "MAX # OF MEDIA"
               0  REPLACE {$MXREG} WITH {50}       "#REGIONS, $MAXRADII*$MAXCDOSE+1(VAC)"
               0  REPLACE {$STAT} WITH {10}        "# BINS FOR UNCERTAINTY ANALYSIS"
               0  REPLACE {$NBATCH} WITH {10}      "OUTPUT BATCHES                 "
               0  REPLACE {$MXDATA} WITH {490}     "MAXIMUM DATA POINTS FOR ANALYSIS (i.e."
               0  "                                     ($MXREG-1)*$STAT)"
               0  REPLACE {$MXSTACK} WITH {900000} "MAXIMUM STACK"
               0  REPLACE {$MAXCDOSE} WITH {7}     "MAX # OF DOSE SCORING CONICAL ZONES"
               0  REPLACE {$MAXCANGLE} WITH {6}    "MAX # OF CONICAL BOUNDARIES (i.e.$MAXCDOSE-1)"
               0  REPLACE {$MAXRADII} WITH {7}     "MAX # OF DOSE SCORING RADIAL ZONES"
               0  REPLACE {$MAXRADII+1} WITH {8}   "MAX # OF DOSE SCORING RADIAL ZONES + 1"
               0  REPLACE {$MAXRC} WITH {7}        "MAX(MAXRADII,MAXCDOSE)"
               0  REPLACE {$MXRDIST} WITH {1000}   "# OF POINTS IN RADIAL DISTRIBUTION FIT"
               0  REPLACE {$MAXIT} WITH {6}        "MAX # OF PARAMETERS TO BE SCORED"
               0  "                                (1) PRIMARY EDEP TO GAS"
               0  "                                (2) SECONDARY EDEP TO GAS"
               0  "                                (3) UNATTENUATED PRIMARY EDEP TO GAS"
               0  "                                     - PRIMARY EDEP TO GAS"
               0  "                                (4) (R**2-R0**2)(UNATTENUATED PRIMARY"
               0  "                                     EDEP TO GAS)"
               0  "                                (5) UNSOURCED UNATTENUATED PRIMARY EDEP TO"
               0  "                                     GAS WITH GAS MATERIAL REPLACED BY WALL"
               0  "                                     MATERIAL"
               0  "                                (6) UNSOURCED UNATTENUATED PRIMARY EDEP TO"
               0  "                                     WALL MATERIAL WITH GAS MATERIAL REPLACED"
               0  "                                     BY WALL MATERIAL"
               0  REPLACE {$MAXCMPTS} WITH {$MAXIT}  "FOR THE GRID OUTPUTS"
               0  ;
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH
               0  {;
            {  0  DO J=1,$MXREG
            {  0  [
            {  0  IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  LATCHI=0.0;
            {  0  ;}
               0  "  IF(ESTEPR(J)<=0.0) [ESTEPR(J)=1;] <=== removed this since ESTEPR is not used"
               0  ;
               0  "THIS APPENDS COMIN/GEOM/ TO $COMIN-PHOTON;"
               0  "THIS IS NECESSARY SO THAT THE CORRELATIONS CAN BE PROPERLY HANDLED."
               0  "Found a better idea to use APPEND instead of REPLACE, IK Oct 97"
               0  APPEND {;COMIN/GEOM,SCORE/;} TO {$COMIN-PHOTON;}
               0  ;
               0
               0  "Define variables used in $SELECT-PHOTON-MFP in order to "
               0  "use implicit data types, IK Nov 97"
               0  APPEND
               0  {;
            {  0  $REAL DUMU,DUMX,DUMY,DUMZ,PATHL,DELTAP,EPSLON,ARG;
            {  0  $INTEGER IRODUM,IRNDUM,IRDUM,MEDDUM,IDUM,MEDTMP;
            {  0  $REAL    d_eta,eta_prime,dpmfp_old,
            {  0  x_save,y_save,z_save,u_save,v_save,w_save,
            {  0  e_save,wt_save,wt_start,a_survive;
            {  0  real*8   ftmp;
            {  0  $INTEGER ir_save,ip,i_split,np_start,latch_save,i_survive,i_survive_s;
            {  0  ;} TO
               0  {$DEFINE-LOCAL-VARIABLES-PHOTON;}
               0  ;
               0
               0  "MACRO USED FOR FORCING INTERACTIONS IN THE GEOMETRY"
               0  "USED BY EGS4 FOR VARIANCE REDUCTION"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {;
            {  0
            {  0  IF( n_split > 1 ) [  "we use photon splitting instead of interaction"
            {  0  "forcing. This is much more efficient as it "
            {  0  "always gives interactions in the chamber "
            {  0  "(provided n_split is large enough) and does"
            {  0  "not lead to varying weights"
            {  0  np_start = np; wt_start = wt(np);
            {  0  :START-MFP-LOOP:;
            {  0
            {  0  $RANDOMSET RNNO35;
            {  0  rnno35 = rnno35/n_split;
            {  0  d_eta = 1./n_split;
            {  0  x_save = x(np); y_save = y(np); z_save = z(np);
            {  0  u_save = u(np); v_save = v(np); w_save = w(np);
            {  0  e_save = e(np); wt_save = wt(np)/n_split; ir_save = ir(np);
            {  0  latch_save = latch(np);
            {  0  np = np-1;
            {  0  i_survive = -1;
            {  0  IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [
            {  0  $RANDOMSET xxx; a_survive = xxx*n_split;
            {  0  i_survive = 1 + a_survive;
            {  0  ]
            {  0  IF( iifano = 1 | latch_save = 2 ) [ i_survive_s = -1; ]
            {  0  ELSE [
            {  0  $RANDOMSET xxx; a_survive = xxx*n_split;
            {  0  i_survive_s = 1 + a_survive;
            {  0  ]
            {  0
            {  0  dpmfp_old = 0;
            {  0  eta_prime = 1 - rnno35 + d_eta;
            {  0  DO i_split = 1,n_split [
            {  0  eta_prime = eta_prime - d_eta;
            {  0  IF(eta_prime <= 0 ) goto :END-MFP-LOOP:;
            {  0  dpmfp = -log(eta_prime) - dpmfp_old;
            {  0  dpmfp_old = dpmfp_old + dpmfp;
            {  0  np = np+1;
            {  0  IF( np > $MXSTACK ) [
            {  0  write(6,*) ' Stack overflow in $SELECT-PHOTON-MFP ';
            {  0  stop;
            {  0  ]
            {  0  x(np) = x_save; y(np) = y_save; z(np) = z_save;
            {  0  u(np) = u_save; v(np) = v_save; w(np) = w_save;
            {  0  wt(np) = wt_save; e(np) = e_save; iq(np) = 0; ir(np) = ir_save;
            {  0  latch(np) = latch_save;
            {  0  irl = ir(np); irold = irl; medium = med(irl);
            {  0  LOOP [
            {  0  IF( medium ~= 0 ) [
            {  0  $SET INTERVAL GLE,GE;
            {  0  $EVALUATE GMFPR0 USING GMFP(GLE);
            {  0  $SET-RHOF;
            {  0  GMFP=GMFPR0/RHOF;
            {  0  $RAYLEIGH-CORRECTION;
            {  0  TSTEP=GMFP*DPMFP;
            {  0  ]
            {  0  ELSE [ TSTEP=VACDST; ]
            {  0  irnew = irl; idisc = 0; ustep = tstep; tustep = ustep;
            {  0  call howfar;
            {  0  x(np) = x(np) + u(np)*ustep;
            {  0  y(np) = y(np) + v(np)*ustep;
            {  0  z(np) = z(np) + w(np)*ustep;
            {  0  IF( idisc > 0 ) [
            {  0  np = np-1;
            {  0  IF( np = 0 ) [
            {  0  ircode = 2; return;
            {  0  ]
            {  0  goto :END-MFP-LOOP:;
            {  0  ]
            {  0  IF( medium ~= 0 ) dpmfp = dpmfp - ustep/gmfp;
            {  0  IF( irnew ~= irold ) [
            {  0  ir(np) = irnew; irl = irnew; irold = irnew;
            {  0  medium = med(irl);
            {  0  ]
            {  0  ] UNTIL (medium ~= 0 & dpmfp < $EPSGMFP);
            {  0  x_save = x(np); y_save = y(np); z_save = z(np);
            {  0  ir_save = ir(np);
            {  0  IF(IRAYLR(IRL).EQ.1) [
            {  0  $RANDOMSET RNNO37;
            {  0  IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0  IF( i_split ~= i_survive_s ) [
            {  0  np = np-1; goto :JUST-RAYLEIGH-EVENT:;
            {  0  ]
            {  0  wt(np) = wt(np)*n_split; latch(np) = 3;
            {  0  :RAYLEIGH-SAMPLING-LOOP: LOOP [
            {  0  $RANDOMSET XXX;
            {  0  $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0  Q2=X2*RMSQ/(20.60744*20.60744);
            {  0  COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0  IF (ABS(COSTHE).GT.1.0) GO TO :RAYLEIGH-SAMPLING-LOOP:;
            {  0  CSQTHE=COSTHE*COSTHE;
            {  0  REJF=(1.0+CSQTHE)/2.0;
            {  0  $RANDOMSET RNNORJ;
            {  0  ] UNTIL (RNNORJ <= REJF);
            {  0  SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0  goto :JUST-RAYLEIGH-EVENT:;
            {  0  ]
            {  0  ]
            {  0  $RANDOMSET RNNO36;
            {  0  $EVALUATE GBR1 USING GBR1(GLE);
            {  0  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )[
            {  0  call pair;
            {  0  ]
            {  0  ELSE [
            {  0  $EVALUATE GBR2 USING GBR2(GLE);
            {  0  IF (RNNO36.LT.GBR2) [ call compt; ]
            {  0  ELSE                [ call photo; ]
            {  0  ]
            {  0  "If ifano is on, we traw away all scattered photons"
            {  0  "if the latch of the photons is 2, it is a regenerated"
            {  0  "primary photon => we need to remove resulting scatter"
            {  0  "as well. To save some time, we also discard on the spot"
            {  0  "all electrons that can not get into the cavity, if"
            {  0  "rejection is on"
            {  0  ip = NPold;
            {  0  LOOP [
            {  0  IF( iq(ip) = 0 ) [
            {  0  IF( i_split ~= i_survive_s ) [
            {  0  IF( ip < np ) [
            {  0  e(ip) = e(np); iq(ip) = iq(np);
            {  0  u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0  wt(ip) = wt(np); latch(ip) = latch(np);
            {  0  ]
            {  0  np = np-1;
            {  0  ]
            {  0  ELSE [
            {  0  wt(ip) = wt(ip)*n_split; latch(ip) = 3; ip = ip+1;
            {  0  ]
            {  0  ]
            {  0  ELSE [
            {  0  IF( irejct = 1 ) [
            {  0  edep = e(ip) - prm;
            {  0  elke = log(edep);
            {  0  call range_rejection(elke,x(ip),y(ip),z(ip),
            {  0  ir(ip),iq(ip),idisc);
            {  0  IF( idisc = 0 ) [ ip = ip+1; ]
            {  0  ELSE [
            {  0  IF( ip < np ) [
            {  0  e(ip) = e(np); iq(ip) = iq(np);
            {  0  u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0  wt(ip) = wt(np); latch(ip) = latch(np);
            {  0  ]
            {  0  np = np-1;
            {  0  ]
            {  0  ] ELSE [ ip = ip+1; ]
            {  0  ]
            {  0  ] UNTIL (ip > np);
            {  0
            {  0  :JUST-RAYLEIGH-EVENT:
            {  0
            {  0  "IF( iifano = 1 | (ifull = 1 & latch_save ~= 3) ) [ "
            {  0  IF( i_split = i_survive ) [
            {  0  "Re-generate the original photon with prob."
            {  0  "1/n_split, so that we get back the original"
            {  0  "weight. This is necessary when ifano is set "
            {  0  "(i.e. dose calculation with attenuation and scatter removed)"
            {  0  "or ifull is 1 (i.e. user wants to get Awall in addition to"
            {  0  "the dose)"
            {  0  "$RANDOMSET xxx;"
            {  0  " IF(xxx*n_split < 1) ["
            {  0  np = np + 1;
            {  0  x(np) = x_save; y(np) = y_save; z(np) = z_save;
            {  0  u(np) = u_save; v(np) = v_save; w(np) = w_save;
            {  0  e(np) = e_save; ir(np) = ir_save;
            {  0  IF( ifull = 1 ) [ latch(np) = 2; ]
            {  0  ELSE            [ latch(np) = 0; ]
            {  0  wt(np) = wt_save*n_split; iq(np) = 0;
            {  0  "]"
            {  0  ]
            {  0
            {  0  ]
            {  0  :END-MFP-LOOP:;
            {  0
            {  0  IF( np <= 0 ) [ ircode = 2; return; ]
            {  0  IF( iq(np) = 0 ) [
            {  0  peig = e(np); eig = peig; irl = ir(np); medium = med(irl);
            {  0  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
            {  0  gle = log(eig);
            {  0  goto :START-MFP-LOOP:;
            {  0  ]
            {  0  return;
            {  0  ]
            {  0  NFTIME=NFTIME+1;
            {  0  $RANDOMSET RNNO35;
            {  0
            {  0  "------------------------------------------------------------"
            {  0  "CHANGE: J.S. Aug 95                                         "
            {  0  "FOLLOWING CHANGE IS JUST TO PREVENT FAKE TRANSPORT IN CASE  "
            {  0  "OF CORRELATED Afl CALCULATIONS.                             "
            {  0  "PREVIOUSLY THERE WAS:                                       "
            {  0  "IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN))["
            {  0  "NOW THE WT(NP)==0 IS INCLUDED TO PREVENT THE FORCING MACRO  "
            {  0  "FROM INFINITE LOOPING DURING FAKE TRANSPORT FOR CORRELATED  "
            {  0  "Afl CALCULATIONS WHEN SWITCHED TO PARALLEL BEAMS            "
            {  0  "------------------------------------------------------------"
            {  0  IF((IFORCE.EQ.0).OR.(NFTIME.GT.NFMAX).OR.(NFTIME.LT.NFMIN).
            {  0  OR.(WT(NP).EQ.0))[
            {  0  "------------------------------------------------------------"
            {  0  "END OF CHANGE                                               "
            {  0  "------------------------------------------------------------"
            {  0  IF(RNNO35 = 0.0)[RNNO35=1.E-30;]
            {  0  DPMFP=-LOG(RNNO35);
            {  0  ]
            {  0  ELSE[
            {  0  IF (ISOURC.EQ.4) [
            {  0  DPMFP = 0.0;
            {  0  GOTO :SKIPFORCING:;
            {  0  ]
            {  0  DUMU=USTEP;
            {  0  DUMX=X(NP);DUMY=Y(NP);DUMZ=Z(NP);
            {  0  IRODUM=IROLD;IRNDUM=IRNEW;IRDUM=IR(NP);MEDDUM=MEDIUM;
            {  0  IDUM=IDISC;
            {  0  PATHL=0.0;MEDTMP=0;
            {  0  LOOP[
            {  0  USTEP=VACDST;
            {  0  IROLD=IR(NP);
            {  0  IF(NTRACK(IROLD).EQ.1)INEED2=1;
            {  0  MEDIUM=MED(IROLD);
            {  0  IF(MEDTMP.NE.MEDIUM)[
            {  0  MEDTMP=MEDIUM;
            {  0  $SET INTERVAL GLE,GE;
            {  0  $EVALUATE DELTAP USING GMFP(GLE);
            {  0  ]
            {  0  IF(IRAYLR(IROLD).EQ.1)[
            {  0  $EVALUATE COHFAC USING COHE(GLE);
            {  0  ]
            {  0  ELSE[
            {  0  COHFAC=1.0;
            {  0  ]
            {  0  CALL HOWFAR;
            {  0  IF(DELTAP~=0) PATHL=PATHL+USTEP/(DELTAP*COHFAC);
            {  0  "only add to pathl if not a vacuum"
            {  0  IF(IRNEW.EQ.1) EXIT;
            {  0  IR(NP)=IRNEW;
            {  0  X(NP)=X(NP)+USTEP*U(NP);
            {  0  Y(NP)=Y(NP)+USTEP*V(NP);
            {  0  Z(NP)=Z(NP)+USTEP*W(NP);
            {  0  ]
            {  0  USTEP=DUMU;
            {  0  X(NP)=DUMX;Y(NP)=DUMY;Z(NP)=DUMZ;
            {  0  IROLD=IRODUM;IRNEW=IRNDUM;IR(NP)=IRDUM;MEDIUM=MEDDUM;
            {  0  IDISC=IDUM;
            {  0  IF(PATHL.LE.1.0E-3)[GWAIT=PATHL*(1.-0.5*PATHL);]
            {  0  ELSE[GWAIT=1.-EXP(-PATHL);]
            {  0  GWTOLD=WT(NP);
            {  0  WT(NP)=GWTOLD*GWAIT;
            {  0  :FASTSTEP:;EPSLON=RNNO35*GWAIT;
            {  0  IF(EPSLON.LE.1.0E-3)[
            {  0  IF(NFTIME.EQ.1)EXPMFP=EPSLON*(1.+EPSLON);
            {  0  DPMFP=EPSLON*(1.+0.5*EPSLON);
            {  0  ]
            {  0  ELSE[
            {  0  ARG=1./(1.-EPSLON);
            {  0  DPMFP=LOG(ARG);
            {  0  IF(NFTIME.EQ.1)EXPMFP=EPSLON*ARG;
            {  0  ]
            {  0  :SKIPFORCING:;
            {  0  ]
            {  0  }
               0  ;
               0
               0  "THIS MACRO SETS THE PARAMETERS FOR FORCING THE INITIAL INCIDENT PHOTON TO
               0  "INTERACT IN THE GEOMETRY FOR THE FRONTAL PARALLEL BEAM CASE. IT IS MUCH
               0  "FASTER THAN THE GENERALIZED CODING IN THE $SELECT-MEAN-FREE-PATHS MACRO
               0  " ***removed******
               0
               0  "MACRO THAT GETS CONE AND RADIUS NUMBERS FROM THE REGION NUMBER
               0  REPLACE {$GET-IX-IC(#);} WITH {;IX=({P1}-2)/NC+1; IC={P1}-1-NC*(IX-1);}
               0
               0  ;
               0  "MACRO THAT GETS THE GEOMETRY NUMBER FROM THE CONICAL AND RADIAL ZONES
               0  REPLACE {$GET-IRL(#,#);} WITH {;IRL={P1}+NC*({P2}-1)+1;}
               0
               0  ;
               0  "  In the new version of ELECTR, range is calculated prior "
               0  "  $USER-RANGE-DISCARD ==> no necessity to calculate range "
               0  "  IK, Dec 1998                                            "
               0  "  **** RANGE REJECTION MACRO****"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH
               0  {
            {  0  ;
            {  0  IF (irejct = 1)
            {  0  [
            {  0  "As tperp and range already known, check first for a simple"
            {  0  "range rejection in the present region                     "
            {  0  IF(tperp >= range)
            {  0  [
            {  0  idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0  go to :USER-ELECTRON-DISCARD:
            {  0  ]
            {  0  "The following implements the original CAVRZ range rejection    "
            {  0  "but has a better range calculation (not just range in graphite)"
            {  0  "Note that initialize_range_rejection() must have been called   "
            {  0  call range_rejection(elke,x(np),y(np),z(np),ir(np),iq(np),idisc);
            {  0  IF( idisc ~= 0 ) [
            {  0  go to :USER-ELECTRON-DISCARD:
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0  "THE FOLLOWING FIVE MACROS ARE FOR STATISTICAL ANALYSIS.
               0
               0  "STATS ANALYSIS FOR A 3-D ARRAY
               0  REPLACE {$ANALYZE3 #(#;#;#) USING MODE #;} WITH {
            {  0  $ANALYZE3 {P1}(1,{P2}/1,{P3}/1,{P4}) USING MODE {P5};}
               0  ;
               0  REPLACE {$ANALYZE3 #(#,#/#,#/#,#) USING MODE #;} WITH {
            {  0  ;
            {  0  NDATA=0;
            {  0  DO I1={P6},{P7}[
            {  0  DO I2={P4},{P5}[
            {  0  DO I3={P2},{P3}[
            {  0  NDATA=NDATA+1;
            {  0  DO IS=1,$STAT[
            {  0  DATA(NDATA,IS)={P1}IS(I3,I2,I1,IS);
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  CALL SIGMA(NDATA,$STAT,{P8},IERR);
            {  0  NDATA=0;
            {  0  DO I1={P6},{P7}[
            {  0  DO I2={P4},{P5}[
            {  0  DO I3={P2},{P3}[
            {  0  NDATA=NDATA+1;
            {  0  {P1}(I3,I2,I1)=DATA(NDATA,1);
            {  0  {P1}UN(I3,I2,I1)=DATA(NDATA,2);
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ;}
               0
               0  ;
               0  "STATS ANALYSIS FOR A 1-D ARRAY
               0  REPLACE {$ANALYZE1 #(#;) USING MODE #;} WITH {
            {  0  ;
            {  0  $ANALYZE1 {P1}(1,{P2}) USING MODE {P3};
            {  0  }
               0  ;
               0  REPLACE {$ANALYZE1 #(#,#) USING MODE #;} WITH {
            {  0  ;
            {  0  NDATA=0;
            {  0  DO I1={P2},{P3}[
            {  0  NDATA=NDATA+1;
            {  0  DO IS=1,$STAT[
            {  0  DATA(NDATA,IS)={P1}IS(I1,IS);
            {  0  ]
            {  0  ]
            {  0  CALL SIGMA(NDATA,$STAT,{P4},IERR);
            {  0  NDATA=0;
            {  0  DO I1={P2},{P3}[
            {  0  NDATA=NDATA+1;
            {  0  {P1}(I1)=DATA(NDATA,1);
            {  0  {P1}UN(I1)=DATA(NDATA,2);
            {  0  ]
            {  0  ;}
               0
               0  ;
               0  "STATS ANALYSIS FOR A REAL NUMBER
               0  REPLACE {$ANALYZE0 # USING MODE #;} WITH {
            {  0  ;
            {  0  NDATA=1;
            {  0  DO IS=1,$STAT[
            {  0  DATA(NDATA,IS)={P1}IS(IS);
            {  0  ]
            {  0  CALL SIGMA(NDATA,$STAT,{P2},IERR);
            {  0  {P1}=DATA(NDATA,1);
            {  0  {P1}UN=DATA(NDATA,2);
            {  0  }
               0
               0
               0  REPLACE {$CLEAN-STACK;} WITH {
            {  0  ;
            {  0  NPSAVE=NP;
            {  0  DO NP=1,$MXSTACK [
            {  0  U(NP)=0.0;V(NP)=0.0;W(NP)=0.0;
            {  0  X(NP)=0.0;Y(NP)=0.0;Z(NP)=0.0;
            {  0  WT(NP)=0.0;IQ(NP)=0;LATCH(NP)=0;]
            {  0  NP=NPSAVE;
            {  0  ;
            {  0  }
               0
1              0  %E     "cavsphnrc.mortran"
               0  "                       COMMON BLOCK DEFINITIONS
               0  "                       ************************
               0
               0  ;
               0  "CHARACTERS BLANK,*,A,B,C,D,I,M,R,S,T,U,V IN I*4(F4) OR CHARACTER(F77) FORM"
               0  REPLACE {;COMIN/CHARS/;} WITH
               0  "       ================
               0  {;
            {  0  $TYPE BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,
            {  0  TCHAR,UCHAR,VCHAR;
            {  0  COMMON/CHARS/
            {  0  BLANK,ASTER,ACHAR,BCHAR,CCHAR,DCHAR,ICHAR,MCHAR,RCHAR,SCHAR,TCHAR,UCHAR,VCHAR;
            {  0  }
               0
               0  ;
               0  "COMMON FOR THE ERROR ROUTINE"
               0  REPLACE {;COMIN/ERROR/;} WITH {
            {  0  ;COMMON/ERROR/DATA($MXDATA,$STAT);
            {  0  $REAL DATA;
            {  0  }
               0  "       ================                                            "
               0  "THE DATA ARRAY IS A GENERAL PURPOSE ARRAY TO TRANSPORT DATA BETWEEN"
               0  "THE MAIN PROGRAM AND THE STATISTICS SUBROUTINE. ASSINGMENTS TO     "
               0  "THE ARRAY ARE MADE IN THE $ANALYZE MACROS                          "
               0
               0  ;
               0  REPLACE {;COMIN/GEOM/;} WITH
               0  "       ===============          "
               0  {;
            {  0  COMMON/GEOM/
            {  0  TANALP(0:$MAXCANGLE),TANAL2(0:$MAXCANGLE),
            {  0  COSALP(0:$MAXCANGLE),SINALP(0:$MAXCANGLE),
            {  0  ALPHA(0:$MAXCANGLE),RSPH(0:$MAXRADII),
            {  0  RSPH2($MAXRADII+1),
            {  0  NTRACK($MXREG),NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
            {  0  $REAL TANALP, TANAL2, COSALP, SINALP, ALPHA, RSPH, RSPH2;
            {  0  $INTEGER NTRACK,NC,NR,NREG,NPLAN1,NPLAN2,IDNEAR;
            {  0  }
               0  "
               0  "GEOMETRICAL INFORMATION"
               0  "TANALP(IC)    TANGENT OF THE OPENING ANGLE OF THE IC'TH CONE
               0  "TANAL2(IC)    TANALP(IC)**2
               0  "COSALP(IC)    COSINE OF THE OPENING ANGLE OF THE IC'TH CONE
               0  "SINALP(IC)    SINE   OF THE OPENING ANGLE OF THE IC'TH CONE
               0  "ALPHA(IC)     CONTAINS THE REAL VALUED COORDINATE OF THE IC'TH CONE
               0  "RSPH(IX)      CONTAINS THE REAL VALUED COORDINATE OF THE IX'TH SPHERE
               0  "RSPH2(IX)     =RSPH(IX)**2
               0  "NTRACK(IRL)   =1 IF CAVITY REGION ELSE =0
               0  "NC/NR         NUMBER OF CONICAL SLABS/SPHERICAL REGIONS DEFINING THE TARGET
               0  "NREG          =NC*NR+1 (+1 FOR THE SURROUNDING VACUUM)
               0  "NPLAN1        CONE REGION THAT HAS THE 90 DEGREE CONE AS THE GREATER CONE
               0  "NPLAN2        NPLAN1+1
               0
               0  ;
               0  "FOUR COMMONS FOR INPUT AND OUTPUT"
               0  REPLACE {;COMIN/IODAT1/;} WITH
               0  "       =================
               0  {;
            {  0  LOGICAL*1 TITLE(80);
            {  0  COMMON/IODAT1/TITLE;
            {  0  }
               0  "
               0  "TITLE       : 80 CHARACTER MAX, INPUT BY USER FOR DESCRIPTIVE PURPOSES
               0  "DATEN,TIMEN : MACHINE VARIABLES FOR TIME AND DATE
               0
               0  ;
               0  REPLACE {;COMIN/IODAT2/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/IODAT2/
            {  0  AMASS($MAXCDOSE,$MAXRADII),TMCPUO,TIMMAX,STATLM,EIN,ECUTIN,PCUTIN,
            {  0  RHOSAV($MXREG),cavreg($MXREG),MEDSAV($MXREG),
            {  0  NCASE,NCASEO,NCASET,IDAT,IDORAY,IDOPES,IRESTART,IQIN,IVAL,
            {  0  numcavreg,datcount;
            {  0  $REAL     AMASS,TMCPUO,TIMMAX,STATLM,EIN,ECUTIN,PCUTIN,
            {  0  RHOSAV;
            {  0  $INTEGER  cavreg,MEDSAV,IDAT,IDORAY,IDOPES,IRESTART,IQIN,IVAL,datcount;
            {  0  $LONG_INT NCASE,NCASEO,NCASET;
            {  0  $INTEGER  numcavreg; "moved from IODAT3 to IODAT2"
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0  }
               0  "
               0  "AMASS(IC,IX)  MASS OF ZONE WITH COORDINATES (IC,IX)
               0  "TMCPUO        CPU TIME USED IN PREVIOUS SESSIONS
               0  "TIMMAX        MAXIMUM ALLOWED CPU HOURS FOR A GIVEN CALCULATION
               0  "STATLM        TARGET STATISTICS IN CAVITY USED FOR AN EARLY EXIT
               0  "EIN           KINETIC ENERGY OF THE EXTERNAL BEAM
               0  "ECUTIN        GLOBAL ECUT FOR THIS SIMULATION
               0  "PCUTIN        GLOBAL PCUT FOR THIS SIMULATION
               0  "cavreg(NREG)  THE ARRAY OF ZONES COMPRISING THE CAVITY REGION
               0  "MEDSAV(NREG)  SAVES MEDIUM NUMBERS FOR CORRELATION SCORING
               0  "RHOSAV(NREG)  SAVES DENSITIES  FOR CORRELATION SCORING
               0  "IDAT          = 0 STORE DATA ARRAYS FOR RE-USE
               0  "              = 1 DON'T STORE THEM
               0  "IDORAY        = 1 INCLUDES RAYLEIGH SCATTERING
               0  "              = 0 DOES NOT INCLUDE RAYLEIGH SCATTERING
               0  "IDOPES        = 1 INCLUDES PHOTOELECTRON ANGLE SELECTION
               0  "              = 0 DOES NOT INCLUDE PHOTOELECTRON ANGLE SELECTION
               0  "NCASE         NUMBER OF HISTORIES REMAINING TO BE DONE
               0  "NCASEO        NUMBER OF HISTORIES DONE IN PREVIOUS SESSIONS
               0  "NCASET        NUMBER OF HISTORIES ALREADY DONE
               0  "IRESTART        = 0 => INITIAL RUN
               0  "              = 1 => RESTARTED RUN
               0  "              = 2 => CREATION OF INPUT FILE ONLY
               0  "              = 3 => DATA ANALYSIS ONLY
               0  "              = 4 => READ STARTING RANDOM NUMBERS FROM A FILE
               0  "IQIN          CHARGE OF THE EXTERNAL BEAM
               0  "numcavreg     NUMBER OF GEOMETRICAL ELEMENTS IN THE CAVITY
               0
               0  ;
               0  REPLACE {;COMIN/IODAT3/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/IODAT3/
            {  0  DOSE($MAXCDOSE,$MAXRADII,$MAXIT),
            {  0  DOSEUN($MAXCDOSE,$MAXRADII,$MAXIT),
            {  0  SCAV($MAXIT),SCAVUN($MAXIT),
            {  0  TDA($MAXCDOSE,$MAXRADII,4),
            {  0  TDAUN($MAXCDOSE,$MAXRADII,4),
            {  0  TTDA(4),TTDAUN(4),
            {  0  FMS,FMSUN,FMSC,FMSCUN,FN,FNUN,FD,FDUN,FCN,FCNUN,FCD,FCDUN,
            {  0  FMM,FMMUN,FMMC,FMMCUN,FSM,FSMUN,FTM,FTMUN,FSMC,FSMCUN,FTMC,FTMCUN;
            {  0  "numcavreg;"
            {  0  "$INTEGER numcavreg;"
            {  0  $REAL    DOSE,DOSEUN,SCAV,SCAVUN,TDA,TDAUN,TTDA,TTDAUN,
            {  0  FMS,FMSUN,FMSC,FMSCUN,FN,FNUN,FD,FDUN,FCN,FCNUN,FCD,FCDUN,
            {  0  FMM,FMMUN,FMMC,FMMCUN,FSM,FSMUN,FTM,FTMUN,FSMC,FSMCUN,FTMC,FTMCUN;
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0  }
               0
               0  "
               0  "DOSE                 THE SCORED QUANTITIES BY REGION AND MODE (IE. VALUE OF IT)
               0  "DOSEUN               UNCERTAINTY IN DOSE
               0  "SCAV                 TOTALS OF THE DOSE ARRAY FOR THE CAVITY REGION
               0  "SCAVUN               UNCERTAINTY OF SCAV
               0  "TDA                  DOSE/CORRECTIONS BY REGION AND CATEGORY.
               0  "TDAUN                UNCERTAINTY IN TDA
               0  "TTDA                 TOTALS OF THE TDA ARRAY FOR THE CAVITY REGION
               0  "TTDAUN               UNCERTAINTY OF TTDA
               0  "FMS                  AVERAGE RATIO OF NUMBER OF TIMES MULTIPLE SCATTERING
               0  "                     SWITCHED OFF TO THE NUMBER OF STEPS TAKEN
               0  "                     (FMSC FOR RATIO IN CAVITY REGION)
               0  "FMS(C)UN             UNCERTAINTY IN THE RATIO FMS(C)
               0  "FN                   AVERAGE NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF
               0  "FD                   AVERAGE NUMBER OF STEPS TAKEN
               0  "FCUN/FNUN            UNCERTAINTIES IN FN AND FD RESPECTIVELY
               0  "FCN/FCD/FCNUN/FCDUN  CORRESPONDING QUANTITIES FOR CAVITY REGION
               0  "
               0  "FMM                  AVERAGE RATIO OF NUMBER OF TIMES MULTIPLE SCATTERING
               0  "                     SWITCHED OFF TO THE NUMBER OF STEPS TAKEN
               0  "                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "                     (FMMC FOR RATIO IN CAVITY REGION)
               0  "FMM(C)UN             UNCERTAINTY IN THE RATIO FMM(C)
               0  "                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "FSM                  AVERAGE NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF
               0  "                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "FTM                  AVERAGE NUMBER OF STEPS TAKEN
               0  "                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "FSMUN/FTMUN          UNCERTAINTIES IN FSM AND FTM RESPECTIVELY
               0  "                     IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "FSMC/FTMC/...        CORRESPONDING QUANTITIES FOR CAVITY REGION
               0  "  .. FSMCUN/FTMCUN   IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  "
               0  ;
               0  REPLACE {;COMIN/IODAT4/;} WITH
               0  "       =================   "
               0  {;
            {  0  COMMON/IODAT4/
            {  0  DOSEIS($MAXCDOSE,$MAXRADII,$MAXIT,$STAT),SCAVIS($MAXIT,$STAT),
            {  0  TDAIS($MAXCDOSE,$MAXRADII,4,$STAT),TTDAIS(4,$STAT),
            {  0  ISTIS($STAT),ISTCIS($STAT),
            {  0  IMSIS($STAT),IMSCIS($STAT),
            {  0  ISMIS($STAT),ISMCIS($STAT),
            {  0  IMMIS($STAT),IMMCIS($STAT);
            {  0  $LONG_INT ISTIS,ISTCIS,IMSIS,IMSCIS,ISMIS,ISMCIS,IMMIS,IMMCIS;
            {  0  DOUBLE PRECISION DOSEIS;
            {  0  $REAL    SCAVIS,TDAIS,TTDAIS;
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0  }
               0  "JAN CHANGE: DOUBLE PRECISION ON DOSEIS IS AN EXTENSION"
               0  "
               0  "DOSEIS    SAME AS DOSE BUT BY STATISTICAL BIN (IE. DOSE = AVERAGE OF DOSEIS)
               0  "SCAVIS    SAME AS SCAV BUT BY STATISTICAL BIN (IE. SCAV = AVERAGE OF SCAVIS)
               0  "TDAIS     SAME AS TDA BUT BY STATISTICAL BIN (IE. TDA = AVERAGE OF TDAIS)
               0  "TTDAIS    SAME AS TTDA BUT BY STATISTICAL BIN (IE. TTDA = AVERAGE OF TTDAIS)
               0  "IST(C)IS  NUMBER OF STEPS (IN CAVITY REGION) BY STATISTICAL BIN
               0  "IMS(C)IS  NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF (IN CAVITY REGION)
               0  "          BY STATISTICAL BIN
               0  "ISM(C)IS  NUMBER OF STEPS (IN CAVITY REGION) IN A CORRELATED RUN WITH THE
               0  "          CAVITY FILLED WITH WALL MATERIAL BY STATISTICAL BIN
               0  "IMM(C)IS  NUMBER OF TIMES MULTIPLE SCATTERING TURNED OFF (IN CAVITY REGION)
               0  "          IN A CORRELATED RUN WITH THE CAVITY FILLED WITH WALL MATERIAL
               0  "          BY STATISTICAL BIN
               0
               0  ;
               0  "PRINTER CONTROLS"
               0  REPLACE {;COMIN/PRINTC/;} WITH {
            {  0  ;COMMON/PRINTC/ICHPIN,ILPIN,IOUT,IPAGE;
            {  0  $INTEGER ICHPIN,ILPIN,IOUT,IPAGE;
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0  }
               0  "       =================
               0  "ICHPIN  NUMBER OF CHARACTERS PER INCH
               0  "ILPIN   NUMBER OF LINES PER INCH
               0  "IOUT    OUTPUT UNIT (IOUT=1, FORTRAN UNIT 1)
               0  "IPAGE   =1 => PAGE THROW
               0
               0  ;
               0  REPLACE {;COMIN/RUSROU/;} WITH
               0  "       =================
               0  {;
            {  0  LOGICAL RUSROU;
            {  0  COMMON/RUSROU/RRZ,RRCUT,RUSROU;
            {  0  $REAL RRZ,RRCUT;
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0  }
               0  "
               0  "COMMON USED FOR RUSSIAN ROULETTE
               0  "RRZ      COORDINATE OF PLANE AT WHICH RUSSIAN ROULETTE IS PLAYED
               0  "RRCUT    SURVIVAL PROBABILITY AFTER CROSSING THE PLANE
               0  "RUSROU   = .FALSE. => RUSSIAN ROULETTE WILL NOT BE PLAYED
               0  "         = .TRUE.  => RUSSIAN ROULETTE WILL BE PLAYED
               0
               0  ;
               0  REPLACE {;COMIN/SCORE/;} WITH
               0  "       ================
               0  {;
            {  0  COMMON/SCORE/
            {  0  SCDOSE,OMEGIS($STAT),IST,ISTC,ISM,ISMC,IHSTRY,
            {  0  IS,MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano;
            {  0  REAL*8    SCDOSE($MAXCDOSE,$MAXRADII,$MAXIT);
            {  0  $LONG_INT IST,ISTC,ISM,ISMC,IHSTRY;
            {  0  $INTEGER  IS,MXNP,IFULL,ISTORE,IWATCH,IOOPTN,IOUTSP,ifano;
            {  0  $REAL     OMEGIS;
            {  0  "Added type declarations from cavrznrc, EMH January 9 2002"
            {  0
            {  0
            {  0  " The following common is for an alternative calculation of   "
            {  0  " D/Awall and D using cross section enhancement. If turned on "
            {  0  " (by setting cs_enhance > 1), the photon cross section is    "
            {  0  " multiplied with cs_enhance (this is accomplished via a      "
            {  0  " modifcation of the $RAYLEIGH-CORRECTION nacro, see below).  "
            {  0  " When an interaction occurs, the "
            {  0  " electrons set in motion are given the weight 1/cs_enhance.  "
            {  0  " The scattered photons are killed with probability           "
            {  0  " 1/cs_enhance. If they survive, their latch variable is set  "
            {  0  " to 3 so that they contribute only to the calculation of the "
            {  0  " real dose. The original photons get their latch set to 1 or "
            {  0  " 2 with the probability 1/cs_enhance and 1-1/cs_enhance, resp. "
            {  0  " All brems and annihilation photons as well as relaxation    "
            {  0  " particles get latch 3. The real dose to the cavity is then  "
            {  0  " scored from particles with latch 0,1,3, the dose with       "
            {  0  " attenuation and scatter removed from latch 0,1,2. That dose "
            {  0  " is simply D/Awall, so that                                  "
            {  0  "   Awall = dose(latch=0,1,3)/dose(latch=0,1,2)               "
            {  0  "                                                             "
            {  0  " <D> and <D^2> is scored in cav_dose and cav2_dose,          "
            {  0  " <D/Awall> and <(D/Awall)^2> in cav_dose1 and cav2_dose1,    "
            {  0  " <D*(D/Awall)> (the correlation) in cavc_dose. Scoring is    "
            {  0  " done on a history-by-history basis using the technique first"
            {  0  " proposed by the Barcelona group. To do so, last_case is the "
            {  0  " last history that scored into the cavity, the_case is the   "
            {  0  " current history.                                            "
            {  0  "                                                             "
            {  0  " I. Kawrakow, April 2001.                                    "
            {  0  "                                                             "
            {  0  common/score1/ cs_enhance,cav_dose,cav_dose1,cav2_dose,cav2_dose1,
            {  0  cav_dosec,tmp_dose,tmp_dose1,
            {  0  cav_dose0, cav2_dose0, cav_dosec01, tmp_dose0,
            {  0  cav_dose2, cav2_dose2, cav_dosec02, tmp_dose2,
            {  0  corr_02,
            {  0  the_case,last_case,cav_case,use_enhance;
            {  0
            {  0  real*8         cs_enhance,cav_dose,cav_dose1,cav2_dose,cav2_dose1,
            {  0  tmp_dose,tmp_dose1,cav_dosec,
            {  0  cav_dose0, cav2_dose0, cav_dosec01, tmp_dose0,
            {  0  cav_dose2, cav2_dose2, cav_dosec02, tmp_dose2,
            {  0  corr_02;
            {  0
            {  0  $LONG_INT      the_case,last_case,cav_case;
            {  0  logical        use_enhance;
            {  0
            {  0  }
               0
               0  "extra scoring components to obtain Aatt and Ascat besides Awall"
               0  "                                              EMH,January 2002"
               0  "cav_dose     => total dose
               0  "cav_dose0    => primary dose
               0  "cav_dose1    => primary dose corrected for attenuation
               0  "cav_dose2    => secondary dose
               0
               0  "cav2_dose    => total dose squared
               0  "cav2_dose0   => primary dose squared
               0  "cav2_dose1   => unattenuated primary  dose squared
               0  "cav2_dose2   => secondary dose squared
               0
               0  "tmp_dose     => temporay arrays for scoring the different
               0  "tmp_dose0       dose components using a history by history
               0  "tmp_dose1       scoring scheme
               0  "tmp_dose2
               0
               0  "cav_dosec    => correlation total - primary(unatttenuated)
               0  "cav_dosec01  => correlation primary - primary (unattenuated)
               0  "cav_dosec02  => correlation secondary - primary
               0
               0  "corr_02      => correlation primary - secondary
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0  ;
            {  0  IF(IRAYLR(IRL).EQ.1) [
            {  0  $EVALUATE COHFAC USING COHE(GLE);
            {  0  GMFP=GMFP*COHFAC
            {  0  ];
            {  0  IF( use_enhance ) [ gmfp = gmfp/cs_enhance; ]
            {  0  " the above is for the cross section enhancement technique, see "
            {  0  " description around definition of common score1                "
            {  0  };
               0
               0
               0  "JAN CHANGE: HAVE CHANGED SCDOSE TO DOUBLE PRECISION"
               0
               0  "
               0  "COMMON USED FOR SCORING IN AUSGAB
               0  "SCDOSE  ACCUMULATES DOSE SCORED BY REGION OVER EACH BIN OF EACH BATCH
               0  "OMEGIS  ACCUMULATES THE SOLID ANGLE OF THE TARGET
               0  "IST(C)  NUMBER OF STEPS TAKEN (IN CAVITY REGION)
               0  "ISM(C)  NUMBER OF STEPS TAKEN (IN CAVITY REGION) IN A CORRELATED RUN WITH
               0  "        WALL MATERIAL IN THE CAVITY
               0  "MXNP    MAXIMUM LEVEL TO WHICH THE STACK OF DAUGHTER PARTICLES FROM AN
               0  "        INCIDENT PARTICLE RISES (STACK MAY INCLUDE INCIDENT PARTICLE)
               0  "IFULL   = 0 JUST CALCULATE TOTAL DOSE AND THAT DUE TO STOPPERS
               0  "            AND DISCARDS (THE DEFAULT)
               0  "        = 1 ABOVE PLUS Aatt, Ascat
               0  "        = 2 ABOVE PLUS Ap AS WELL
               0  "        = 3 ABOVE PLUS Afl and <s>g,w AS WELL
               0  "ISTORE  = 0 DO NOT STORE THE INITIAL RANDOM NUMBERS (THE DEFAULT)
               0  "        = 1 STORE THE INITIAL RANDOM NUMBER FOR THE LAST HISTORY
               0  "        = 2 STORE THE INITIAL RANDOM NUMBER FOR ALL HISTORIES
               0  "            THAT DEPOSIT ENERGY IN THE CAVITY
               0  "        = 3 STORE ALL THE INITIAL RANDOM NUMBERS
               0  "IWATCH  = 0 FOR NORMAL OUTPUT (THE DEFAULT)
               0  "        = 1 OUTPUT ON EVERY DISCRETE INTERACTION
               0  "        = 2 OUTPUT ON EVERY ELECTRON/PHOTON STEP AS WELL
               0  "        = 3 PRINTS OUT ONLY WHEN ENERGY IS DEPOSITED
               0  "        = 4 PRINTS OUT FILE FOR GRAPHICS
               0  "IHSTRY  COUNTER FOR TOTAL NUMBER OF HISTORIES SUCCESSFULLY SIMULATED
               0  "IOOPTN  = 0 SHORT OUTPUT (THE DEFAULT) -JUST CAVITY SUMMARY
               0  "            AND THE MATERIAL GRID
               0  "        = 1 ABOVE PLUS OUTPUT GRID
               0  "IOUTSP  = 0 NO SPECTRUM DATA IN OUTPUT SUMMARY
               0  "        = 1 INCLUDE SPECTRUM DATA IN OUTPUT SUMMARY
               0
               0  ;
               0  REPLACE{$SWITCH-TO-PARALLEL-BEAM-SOURCE;} WITH {;
            {  0  DO I=1,23[SRCEQ(I)=SRCPAR(I);]DO I=1,2[ISRCEQ(I)=ISRCPR(I);];
            {  0  ISOURC=ISRPAR;
            {  0  }
               0  ;
               0  ;
               0  REPLACE{$RECOVER-POINT-SOURCE;} WITH {;
            {  0  DO I=1,23[SRCEQ(I)=SRCPT(I);]DO I=1,2[ISRCEQ(I)=ISRCPT(I);];
            {  0  ISOURC=ISRPT;
            {  0  "JAN CHANGE: ADDED FOR RECOVERY OF POINT SOURCE, AFTER SWITCH"
            {  0  "            TO PARRALEL BEAM SOURCE                         "
            {  0  IFPB=1;
            {  0  "END OF JAN CHANGE"
            {  0  }
               0
               0  ;
               0  "COMMONS USED FOR NON-MONOENERGETIC BEAM DATA                             "
               0  "       NOTE MONOEN IS PASSED IN USER                                     "
               0  "                                                                         "
               0  REPLACE {$NENSRC} WITH {300}     "MAX # OF POINTS IN ENERGY DISTRIBUTION  "
               0  "        =======                                                          "
               0  REPLACE {$INVDIM} WITH {1000}    "DIMENSION CONTROLS GRID SIZE FOR INVERSE"
               0  "        =======                                                          "
               0  ;
               0  REPLACE {;COMIN/SPECTR/;} WITH
               0  "       ================="
               0  {;
            {  0  COMMON/SPECTR/
            {  0  CDFINV($INVDIM,2),ENSRCD(0:$NENSRC),SRCPDF($NENSRC),SRCCDF($NENSRC),
            {  0  NENSRC;
            {  0  $INTEGER NENSRC;
            {  0  $REAL    CDFINV,ENSRCD,SRCPDF,SRCCDF;
            {  0  "Added type declarations from cavrznrc, EMH January, 2002"
            {  0  }
               0  "CDFINV   INVERSE OF THE CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "ENSRCD   ENERGY MESH POINTS FOR THE ENERGY PROBABILITY FUNCTION
               0  "SRCPDF   ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "SRCCDF   CUMULATIVE ENERGY PROBABILITY DISTRIBUTION FUNCTION
               0  "NENSRC   # OF ENERGY BINS USED TO DEFINE THE DISTRIBUTION
               0
               0  " IK changed USER-MISC to USER for prestaII and included USERVR"
               0  ;
               0  REPLACE {;COMIN/USER/;} WITH
               0  "       ===================="
               0  {
            {  0  ;
            {  0  common/uservr/ cexptr,gwait,
            {  0  iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
            {  0  n_split,iifano;
            {  0  $REAL cexptr,gwait;
            {  0  $INTEGER iforce,nfmin,nfmax,nftime,isourc,ifpb,iqinc,monoen,
            {  0  n_split,iifano;
            {  0
            {  0  REPLACE {$MXRANGE} WITH {500}  "for range arrays used in range_rejection()"
            {  0
            {  0  COMMON/USERRR/
            {  0  rangerr0($MXRANGE),rangerr1($MXRANGE),eker0,eker1,
            {  0  r_cavity_min,r_cavity_max,ESAVEIN,IREJCT;
            {  0  "CRANGE(2,2),ERANGE,ZMINR,ZMAXR,RMINR,RMAXR,"
            {  0  "MINZ,MAXZ,MINR,MAXR;"
            {  0  $REAL rangerr0,rangerr1,eker0,eker1,r_cavity_min,r_cavity_max;
            {  0  $REAL ESAVEIN;
            {  0  $INTEGER IREJCT;
            {  0  "                                                                            "
            {  0  "COMMON USED FOR RANGE REJECTION                                             "
            {  0  "ERANGE        ENERGY BOUNDARY FOR TWO-PIECE RANGE FIT USED FOR RANGE DISCARD"
            {  0  "Z/RMINR/MAX   PLANE/CYLINDER COORDINATES OF THE MIN/MAX PLANES/CYLINDERS    "
            {  0  "              FOR RANGE REJECTION                                           "
            {  0  "ESAVEIN        UPPER ENERGY FOR ZONAL RANGE REJECTION                        "
            {  0  "MIN/MAX/Z/R   MIN/MAX PLANE/CYLINDER NUMBERS OF RANGE REJECTION REGION      "
            {  0  "IREJCT        = 0 => NO ELECTRON RANGE REJECTION                            "
            {  0  "              = 1 => DO ELECTRON RANGE REJECTION OUTSIDE CAVITY             "
            {  0  "              = 2 => ON SECOND PASS, DO IT IN THE CAVITY AS WELL            "
            {  0  "FOR THE REMAINING VARIABLES SEE DOCUMENTATION IN SUBROUTINE INPUTS          "
            {  0  ;
            {  0  COMMON/USERMI/
            {  0  EXPMFP,GWTOLD,IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
            {  0  $REAL EXPMFP,GWTOLD;
            {  0  $INTEGER IDECAV,INEED2,IPASS,INOCAV,NOSCT2,INOMED,IPTSRC,icsda;
            {  0  }
               0
               0  "                                                                        "
               0  "COMIN/USER-MISC/USERMI  EXTRA USER COMMON FOR CAVITY                    "
               0  "EXPMFP   EXPONENTIAL MEAN-FREE-PATH USED FOR INTERACTION FORCING
               0  "GWTOLD   OLD WEIGHT
               0  " change for presta-II "
               0  "ICSDA    CSDA CALCULATION ON(1) OR OFF(0)                              "
               0  "                      "
               0  "IDECAV   FLAG SET BY AUSGAB, CLEARED BY MAIN
               0  "         = 0 => NO ENERGY DEPOSITED IN THE CAVITY
               0  "         = 1 => ENERGY DEPOSITED IN THE CAVITY IN ANY FASHION        (IFULL<=1)
               0  "         = 1 => PRIMARY ENERGY DEPOSITED IN THE CAVITY               (IFULL>=2)
               0  "         = 2 => SECONDARY ENERGY DEPOSITED IN THE CAVITY             (IFULL>=2)
               0  "         = 3 => PRIMARY AND SECONDARY ENERGY DEPOSITED IN THE CAVITY (IFULL>=2)
               0  "INEED2   FLAG SET BY AUSGAB INDICATING NEED FOR A SECOND PASS IF Afl
               0  "         IS TO BE CALCULATED
               0  "         = 0 => NO NEED FOR THIRD PASS
               0  "         = 1 => A SECOND PASS IS NEED (A PRIMARY ELECTRON HAS HIT THE CAVITY
               0  "                OR A PRIMARY PHOTON IS DIRECTED AT THE CAVITY)
               0  "IPASS    FLAG USED FOR CORRELATED SAMPLING
               0  "         = 0 => PRESENTLY EXECUTING THE FIRST PASS
               0  "         = 1 => PRESENTLY EXECUTING THE SECOND PASS (TO CALCULATE Apn)
               0  "         = 2 => PRESENTLY EXECUTING THE THIRD  PASS (TO CALCULATE Afl)
               0  "                (NOTE: FOR PARALLEL BEAMS THERE IS NO SECOND PASS)
               0  "INOCAV   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
               0  "NOSCT2   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN A CORRELATED
               0  "         RUN WITH THE CAVITY REPLACED BY WALL MATERIAL (THIRD PASS ONLY)
               0  "INOMED   COUNTER USED BY MSCAT TO ACCUMULATE MS SWITCH OFFS IN THE CAVITY
               0  "         REGION IN A CORRELATED RUN WITH THE CAVITY REPLACED BY WALL MATERIAL
               0  "         (THIRD PASS ONLY)
               0  "IPTSRC   FLAG USED TO INDICATE A POINT SOURCE DISTRIBUTION WAS USED
               0  "         = 0 => BROAD PARALLEL OR UNIFORM BEAM SOURCE DISTRIBUTION
               0  "         = 1 => POINT SOURCE DISTRIBUTION
               0
               0  " The following is an addition taken from dosrzII (Apr, 23,97)         "
               0  " for PRESTA-II                                                        "
               0  "THIS MACRO ALLOW THE USER TO SWITCH ON CSDA CALCULATIONS.             "
               0  "THE MEAN FREE PATH IS SET TO INFINITY AND THE PROPER CSDA STOPPING    "
               0  "POWERS SHOULD BE USED HAVING BEEN CREATED BY PEGS4 VIA IUNRST = N.    "
               0  ;
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {;
            {  0  IF(ICSDA.EQ.0)[
            {  0  ;$RANDOMSET RNNE1;IF(RNNE1.EQ.0.0)[RNNE1=1.E-30;]
            {  0  "DEMFP=AMAX1(-ALOG(RNNE1),$EPSEMFP);"
            {  0  DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);
            {  0  ]
            {  0  ELSE[
            {  0  DEMFP=VACDST;
            {  0  ]
            {  0  ;}
               0
               0  "END OF MACRO DEFINITIONS
               0
               0  "                       DATA DECLARATIONS
               0  "                       *****************
               0
               0  $IMPLICIT-NONE;
               0
               0  "***************************************************************************"
               0  "*             Variables passed to the subroutine GET_INPUTS               *"
               0  "***************************************************************************"
               0  REPLACE {$NMAX} WITH {100}  "max number of inputs"
               0  REPLACE {$NVALUE} WITH {100}  "max number of values per input"
               0
               0  COMIN/GetInput/;
               0  INTEGER MAKE_IT_AN_INT;
               0  "******************************************************* ADDED BY JT, DEC.98"
               0  "*                Variables for post-processing parallel run               *"
               0  "***************************************************************************"
               0  "$INTEGER   DATCOUNT;                      T>number of .egs4dat files
               0  "datcount used to be a local variable that holds the number of parallel"
               0  "jobs if irestart=5. As now data file reading from parallel runs is done"
               0  "in a separate routine, it must go into a common block as it is used in"
               0  "main."
               0
               0  "extra components added    "
               0  "to obtain Aatt and Ascat  "
               0  "with a history by history "
               0  "scoring scheme            "
               0  "            EMH March 2002"
               0  real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
               0  real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
               0  "***************************************************************************"
               0
               0  $DECLARE_TIMING_VARIABLES;
               0
               0  $LONG_INT ITEMP;
               0  $INTEGER NETADJ,ITMAX,IC,IX,IT,I,J,JJ,LGLE,IRL,MEDNUM,I1,I2,I3,
               0  IBATCH,IBTCH,NOSCAT,ICASE,NPSAVE,ICAV,NDATA,IERR;
               0  $REAL TIMCPU,TIMEB,ETIMETOT,RATIO,BATCHT,TEMP,TEMP1,TEMP2,TEMP3,TEMP4,TEMP5;
               0
               0  $INTEGER NBATCH;"no. of histories per batch, per statistical bin"
               0  "$INTEGER JCASE; no. of histories per batch <=== used in other NRC user-codes"
               0  "                                                Batch and hist/hist scoring"
               0  "                                                still co-exist"
               0
               0  $INTEGER ISTAT;
               0
               0  $REAL XIN,YIN,ZIN,UIN,VIN,WIN;
               0  $INTEGER IRIN,NRCFLG;
               0
               0  $INTEGER IDECV1;
               0
               0  $REAL EI,EKMAX,DEPTH,VOLUME,RLOW2;
               0  $REAL WEIGHT,PATHL,DELTAP,COHFAC;
               0
               0  $REAL DISTRZ,FMASSC,FMASS,AINFLU_CURRENT,FLURAT;
               0  $INTEGER ISUMX,IRNG;
               0
               0  $REAL DCAV,DCAVUN,DCAV_SEC,DCAV_SECUN,DCAV_CURRENT,FR_SEC;
               0
               0  "**********************************************************************"
               0  $REAL    CMINC,SMINC,CMAXC,SMAXC,RMINR2,RMAXR2,DELCOS,RINNER,R2POM0;
               0  $INTEGER MINC, MAXC, ISRCDV;
               0  "Added type declarations, EMH January, 2002"
               0  "**********************************************************************"
               0
               0  REAL*4
               0  GWATE($MAXRADII), "PHOTON INTERACTION FORCING WEIGHTING FACTORS FOR
               0  "NORMALLY INCIDENT PARALLEL BEAMS
               0  "change: DCAVIS is now defined as TOTAL energy deposited, not only
               0  "primary energy (used for display purposes only) (JAN)
               0  DCAVIS($STAT),    "TOTAL ENERGY DEPOSIT PER STATISTICAL BATCH USED TO
               0  "TEST EARLY QUIT
               0  DCAV_SECIS($STAT),"ENERGY DEPOSIT SECONDARIES PER STATISTICAL BATCH ADDED
               0  "TO FRACTION OF SEC DOSE IN THE FLY (FOR DISPLAY
               0  "PURPOSES ONLY)
               0  FMSIS($STAT),     "FRACTION MULTIPLE SCATTERING SWITCHED OFF
               0  FMSCIS($STAT),    "FRACTION MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
               0  FDIS($STAT),      "# OF CHARGED PARTICLE STEPS
               0  FNIS($STAT),      "# TIMES MULTIPLE SCATTERING SWITCHED OFF
               0  FCDIS($STAT),     "# OF CHARGED PARTICLE STEPS IN THE CAVITY
               0  FCNIS($STAT),     "# TIMES MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
               0  FMMIS($STAT),     "FRACTION MULTIPLE SCATTERING SWITCHED OFF
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  FMMCIS($STAT),    "FRACTION MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  FTMIS($STAT),     "# OF CHARGED PARTICLE STEPS
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  FSMIS($STAT),     "# TIMES MULTIPLE SCATTERING SWITCHED OFF
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  FTMCIS($STAT),    "# OF CHARGED PARTICLE STEPS IN THE CAVITY
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0  FSMCIS($STAT);    "# TIMES MULTIPLE SCATTERING SWITCHED OFF IN THE CAVITY
               0  "IN A CORRELATED RUN WITH WALL MATERIAL IN THE CAVITY
               0
               0  ;
               0  COMIN/
               0  BOUNDS,CHARS,EDGE,ELECIN,EPCONT,ERROR,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,
               0  PRINTC,MEDIA,MISC,PHOTIN,RUSROU,SCORE,SOURCE,SPECTR,
               0  STACK,THRESH,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO/;
               0  "                                                       ^    "
               0  "                                                       |    "
               0  "   EGSnrc opens units explicitly, i.e.,    ____________|    "
               0  "   this COMMON block  contains information                  "
               0  "   like extensions, unit numbers, file na-                  "
               0  "   mes, etc.                                                "
               0
               0  "**********************************************************************"
               0  "                EGSnrcMP variables and macros                         "
               0  "**********************************************************************"
               0  " I/O units "
               0  $INTEGER egs_open_file, egs_open_datfile, rng_unit, data_unit;
               0
               0  external combine_results;
               0
               0  "IK: New parallel processing implementation. Only used if there is a
               0  "    working C compiler. The macro $HAVE_C_COMPILER is defined in
               0  "    machine.macros and is either #define HAVE_C_COMPILER;, if a working
               0  "    C compiler was found, or NULL if no working C compiler was found.
               0  "
               0  $HAVE_C_COMPILER(#);
               0
               0  #ifdef HAVE_C_COMPILER;
               0
               0  real*8  last_dose, last2_dose, tmpf;
               0  $REAL   part_dose, part2_dose, current_result, current_uncertainty;
               0  $LONG_INT n_run,n_tot,n_last, n_left;
               0  $INTEGER  n_job;
               0  $LOGICAL first_time;
               0
               0  #endif;
               0
               0  $LOGICAL is_finished;
               0
               0  "**********************************************************************"
               0
               0  "                       START OF EXECUTABLE CODE
               0  "                       ************************
               0
               0
               0  "**********************************************************************"
               0  "            STEP 0 : Initialize the EGSnrc system                     "
               0  "**********************************************************************"
               0  call egs_init;
               0  is_finished = .true.;
               0  "**********************************************************************"
               0
               0  ;
               0  "INITIALIZE THE CHARACTER ARRAY"
               0  BLANK=' ';
               0  ASTER='*';
               0  ACHAR='A';
               0  BCHAR='B';
               0  CCHAR='C';
               0  DCHAR='D';
               0  ICHAR='I';
               0  MCHAR='M';
               0  RCHAR='R';
               0  SCHAR='S';
               0  TCHAR='T';
               0  UCHAR='U';
               0  VCHAR='V';
               0
               0  $SET_ELAPSED_CPUTIME(CPUT0); "OBTAIN THE INITIAL STARTING TIME"
               0
               0  OUTPUT $MAXRADII,$MAXCDOSE;
               0  (//' CAVSPHnrc(EGSnrc) '$VERSION' on '$MACHINE'.'//
               0  T20,'Maximum number of radial and conical zones=',2I4);
               0
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 1 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "READ INPUTS AND CALCULATE ONE-TIME ONLY CONSTANTS
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  IOUT=1; "OUTPUT FORTRAN UNIT NUMBER"
               0
               0  CALL INPUTS;
               0
               0  "CHECK FOR END-OF-FILE AND EXIT IF ENCOUNTERED
               0  "error_flag comes back through common block get_input
               0  IF(ERROR_FLAG=1)[
               1      OUTPUT;
               1      (//' *** END OF FILE IN SUBROUTINE INPUTS WAS REACHED ***'/
               1      ' *** OR A RESTART OF A CALCULATION WAS REQUESTED  ***'/
               1      ' *** WITH NO PREVIOUS DAT FILE                    ***'/
               1      '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'/);
               1      GOTO :END-OF-RUN:;"SIGNAL AN EARLY EXIT"
               1      "IRESTART=2; SIGNAL AN EARLY EXIT"
               1      ]
               0
               0  "OPEN A FILE FOR STORING OR READING RANDOM NUMBERS"
               0  IF( istore > 0 ) [ "We want to store the rng state in a file"
               1      rng_unit = egs_open_file(2,0,1,'.egsrns');
               1      ]
               0  ELSE IF( irestart = 4 ) [
               1      rng_unit = egs_open_datfile(2,0,1,'.egsrns');
               1      ]
               0
               0  IF(IRESTART.EQ.5)[
               1      call egs_combine_runs(combine_results,'.egsdat');
               1
               1      NBATCH=0;      "DON'T WANT IT TO RUN ANY HISTORIES"
               1      NCASET=NCASEO; "To prevent a wrong normalization if some of the "
               1      "parallel runs not available, IK, Jan 21 1999"
               1
               1      ] "end of IRESTART = 5, DISTRIBUTED POST-PROCESSING"
               0  ELSE [
               1      IF(NCASE/$STAT**2=0)[NCASE=$STAT**2;]
               1      NBATCH=NCASE/($STAT**2); "NUMBER OF HISTORIES IN EACH BIN PER BATCH
               1      ]
               0
               0  MXNP=0; "RESET THE MAXIMUM STACK INDICATOR"
               0  IHSTRY=NCASEO; "RESET THE NUMBER OF HISTORIES COUNTER"
               0
               0  "CALCULATE THE NUMBER OF DOSE COMPONENTS"
               0  IF(    IFULL.EQ.0)[ITMAX=2;]      "SCORE DOSE ONLY"
               0  ELSEIF(IFULL.EQ.1)[ITMAX=3;]      "SCORE Ascat, Aatt AS WELL"
               0  ELSEIF(IFULL.EQ.2)[ITMAX=4;]      "SCORE Apn as well"
               0  ELSEIF(IFULL.EQ.3)[ITMAX=$MAXIT;] "SCORE Afl AND <s>g,w AS WELL"
               0
               0
               0  "ZERO THE CAVITY SUMMARY ARRAY"
               0  DO IT=1,ITMAX[DO IS=1,$STAT[SCAVIS(IT,IS)=0.0;]]
               0
               0  "SET UP AUSGAB CALLS"
               0  DO J=1,5[IAUSFL(J)=1;]DO J=6,$MXAUS[IAUSFL(J)=0;] "NORMAL EXECUTION"
               0
               0  IF(IFULL.GE.1)[
               1      "THESE FLAGS ARE THE MINIMUM SET NEEDED TO IDENTIFY PRIMARY AND SECONDARY"
               1      IAUSFL(8) =1; "After BREMSSTRAHLUNG"
               1      IAUSFL(14)=1; "After ANNIHILATION IN FLIGHT"
               1      IAUSFL(15)=1; "After ANNIHILATION AT REST"
               1      IAUSFL(19)=1; "After COMPTON"
               1      IAUSFL(21)=1; "After Photo"
               1      iausfl(25)=1; "After Rayleigh"
               1      ]
               0  "JAN CHANGE: DEBUGGING DIFFERENCES BETWEEN NON-CORR AND CORR RUNS"
               0  "            We now switch off auscall on moller interaction"
               0  "            because it led to differences in 1st pass transport"
               0  "            when corr sampling was requested (ifull .ge. 2)"
               0  "IF(IFULL.GE.2)["
               0  " THIS FLAGS IS NEEDED FOR CORRELATIONS"
               0  " IAUSFL(10) =1; MOLLER"
               0  " ]"
               0
               0  IF(ifano = 1)
               0  [
               1
               1      "AUSGAB will be responsible for making sure that the beam is not"
               1      "attenuated and getting rid of the scattered photons."
               1      iausfl(16) = 1; "Before pair"
               1      iausfl(18) = 1; "Before Compton"
               1      iausfl(19) = 1; "After Compton"
               1      iausfl(20) = 1; "Before photoelectric"
               1      iausfl(21) = 1; "After photoelectric"
               1      iausfl(24) = 1; "Before Rayleigh"
               1      iausfl(25) = 1; "After Rayleigh"
               1      iausfl(30) = 1; "Before photonuclear"
               1      iausfl(31) = 1; "After photonuclear"
               1
               1      "AUSGAB will be responsible for throwing away any photons resulting"
               1      "from a primary electron. ie. True equilibtrium requires that all"
               1      "energy deposition be local to the primary interaction site."
               1      iausfl(8)  = 1; "After bremsstrahlung"
               1      iausfl(14) = 1; "A positron has annihilated in-flight"
               1      iausfl(15) = 1; "A positron has annihilated at rest"
               1      ]
               0
               0  "**************************************"
               0  "taken from cavrznrc, EMH, January 2002"
               0  "**************************************"
               0
               0  IF( n_split > 1 ) [
               1      iausfl(8)  = 1; "After bremsstrahlung"
               1      iausfl(14) = 1; "A positron has annihilated in-flight"
               1      iausfl(15) = 1; "A positron has annihilated at rest"
               1
               1      "With n_split > 1, we don't need the following calls even if ifano = 1"
               1      iausfl(16) = 0;
               1      iausfl(18) = 0;
               1      iausfl(20) = 0;
               1      iausfl(24) = 0;
               1      iausfl(25) = 0;
               1      iausfl(30) = 0;
               1      iausfl(31) = 0;
               1
               1      ]
               0
               0  IF(ifano = 2) [
               1
               1      "AUSGAB will be responsible for discarding energy due to electrons set"
               1      "in motion in the wall"
               1      iausfl(17) = 1; "After pair"
               1      iausfl(19) = 1; "After Compton"
               1      iausfl(21) = 1; "After photoelectric"
               1
               1      ]
               0
               0  IF( use_enhance ) [
               1      iausfl(16) = 1; "Before pair"
               1      iausfl(18) = 1; "Before Compton"
               1      iausfl(19) = 1; "After Compton"
               1      iausfl(20) = 1; "Before photoelectric"
               1      iausfl(21) = 1; "After photoelectric"
               1      iausfl(24) = 1; "Before Rayleigh"
               1      iausfl(25) = 1; "After Rayleigh"
               1      iausfl(30) = 1; "Before photonuclear"
               1      iausfl(31) = 1; "After photonuclear"
               1      iausfl(8)  = 1; "After bremsstrahlung"
               1      iausfl(14) = 1; "A positron has annihilated in-flight"
               1      iausfl(15) = 1; "A positron has annihilated at rest"
               1      ]
               0
               0  write(6,'(/a)')
               0  '************************ IAUSFL ************************** ';
               0  DO j=1,28 [
               1      IF( iausfl(j).ne.0 ) write(6,'(i3,$)') j;
               1      ]
               0  write(6,'(/a//)')
               0  '********************************************************** ';
               0
               0  "*****************************************"
               0
               0
               0  "HATCH CALL PREPARATION AND EXECUTION"
               0  "-------------------------------------
               0
               0  DUNIT=1; "SET LENGTH UNITS TO CMS"
               0
               0  "ELECTRON,PHOTON AND RANGE REJECTION CUTOFFS"
               0  "DO I=2,NREG[ECUT(I)=ECUTIN;PCUT(I)=PCUTIN;ESAVE(I)=ESAVIN;]"
               0  DO I=2,NREG[ECUT(I)=ECUTIN;PCUT(I)=PCUTIN;]
               0  "changed by EMH, January 20002"
               0
               0  OUTPUT; (//'CALL TO HATCH AT  ',$); call egs_time(6); write(6,*);
               0
               0  CALL HATCH; "INPUT THE PEGS GENERATED DATA"
               0
               0  OUTPUT; (//'HATCH COMPLETED AT ',$); call egs_time(6); write(6,*);
               0
               0  IF( irejct = 1 ) [ call initialize_range_rejection; ]
               0
               0  IF(MONOEN.EQ.0) ["MONOENERGETIC INPUT BEAM"
               1      IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]
               1      EKMAX=EIN; "MAXIMUM KINETIC ENERGY"
               1      ]
               0  ELSE[ "ENERGY SPECTRUM"
               1      EKMAX=ENSRCD(NENSRC); "MAXIMUM KINETIC ENERGY IN THE SPECTRUM"
               1      CALL ENSRC1; "NORMALIZE THE ENERGY DISTRIBUTION"
               1      ]
               0
               0  "CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY RANGE REQUIRED"
               0  DO I=1,NMED[
               1      IF((EKMAX.GT.UP(I)).OR.(EKMAX.GT.UE(I)-RM))[
               2          OUTPUT I,EKMAX,UP(I),UE(I);
               2          (//1X,50('*')//
               2          ' FOR MEDIUM',I3,' INCIDENT ENERGY=',F10.1,' MEV'/
               2          ' IS GREATER THAN COVERED BY DATA FILE WHERE UP,UE=',2F10.1,' MEV'/
               2          '     EXECUTION WILL TERMINATE AFTER COMPLETION OF INPUT FILE'//
               2          1X,50('*')//);
               2          IRESTART=2; "SIGNAL AN EARLY EXIT"
               2          ]
               1      ] "END OF LOOP OVER MEDIA"
               0
               0  "CALCULATE THE MASS OF EACH ZONE
               0  DO IC=1,NC[
               1      IF(NC.EQ.1)     [DELCOS=2.0;                    ]
               1      ELSEIF(IC.EQ.1) [DELCOS=1.0-COSALP(1);          ]
               1      ELSEIF(IC.EQ.NC)[DELCOS=COSALP(NC-1)+1;         ]
               1      ELSE            [DELCOS=COSALP(IC-1)-COSALP(IC);]
               1      DO IX=1,NR[
               2          $GET-IRL(IC,IX);
               2          MEDNUM=MED(IRL);
               2          IF(MEDNUM.NE.0)[
               3              IF(IX.EQ.1)[RINNER=0.0;       ]
               3              ELSE       [RINNER=RSPH(IX-1);]
               3              VOLUME=(TWOPI/3.)*DELCOS*(RSPH(IX)**3-RINNER**3);
               3              AMASS(IC,IX)=RHO(MEDNUM)*VOLUME;
               3              ]
               2          ELSE[
               3              AMASS(IC,IX)=0.0;
               3              ]
               2          ]"END OF IX LOOP"
               1      ]"END OF IC LOOP"
               0
               0  "CALCULATE ONE-TIME-ONLY CONSTANTS FOR SOURCE"
               0  CALL SRCOTO(WEIGHT);
               0
               0  "CALCULATE THE SQUARE OF THE DISTANCE TO THE CENTER OF THE GEOMETRY AND"
               0  "RESET THE FLUENCES TO THE CENTER OF THE CHAMBER FOR POINT SOURCES"
               0  IF(ISRCTY.EQ.1)[ "POINT SOURCES"
               1      R2POM0=DISTR2;ISRCDV=1;
               1      ]
               0  ELSE["UNIFORM SOURCE"
               1      ISRCDV=0;
               1      ]
               0
               0  "INITIALIZE DATA ARRAYS FOR FLUORESCENT X-RAYS IF NEEDED"
               0  ISUMX=0;
               0  DO JJ=1,NREG[ISUMX=ISUMX+IEDGFL(JJ); "NON-ZERO IF X-RAYS ANYWHERE"]
               0  IF(ISUMX.NE.0) [CALL EDGSET(2,NREG);]
               0  "NOTE THE ABOVE WILL PRODUCE LOTS OF EXTRA OUTPUT AND SHOULD BE"
               0  "CLEANED UP"
               0
               0  CALL ISUMRY; "PRINT THE SUMMARY OF INPUTS"
               0
               0  "SAVE ORIGINAL MEDIUM NUMBERS AND DENSITIES FOR CORRELATION SCORING"
               0  IF(IFULL.EQ.3)[ "MEDIUM CHANGES WITH THIS CORRELATION RUN"
               1      DO IRL=1,NREG[
               2          MEDSAV(IRL)=MED(IRL);RHOSAV(IRL)=RHOR(IRL);
               2          ]
               1      ]
               0
               0
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 2 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "LOOP THROUGH THE NUMBER OF HISTORIES. CALCULATE CONSTANTS THAT MAY CHANGE FOR
               0  "EACH HISTORY AND DO THE SIMULATION
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  "WRITE THE HEADER"
               0  WRITE(IOUT,100) TITLE; call egs_fdate(iout); write(iout,*);
               0  WRITE(IOUT,200);WRITE(6,200); "PRINT HEADER FOR EXECUTION MESSAGES"
               0
               0  "PRINT EXECUTION MODE"
               0  IF(IRESTART.EQ.0)[WRITE(6,201);WRITE(IOUT,201);]
               0  ELSEIF(IRESTART.EQ.1)["updated from cavrznrc, EMH January, 2002"
               1      WRITE(6,202) NCASE,NCASEO;
               1      write(6,'(21x,a,$)') 'New RNG state: ';
               1      $SHOW-RNG-STATE(6); write(6,*);
               1      write(iout,'(21x,a,$)') 'New RNG state: ';
               1      $SHOW-RNG-STATE(iout); write(iout,*);
               1      ]
               0  ELSEIF(IRESTART.EQ.2)[WRITE(6,203);WRITE(IOUT,203);GO TO :END-OF-RUN:;]
               0  ELSEIF(IRESTART.EQ.3)[WRITE(6,204);WRITE(IOUT,204);GO TO :STATS-ANAL:;]
               0  ELSEIF(IRESTART.EQ.4)[WRITE(6,205);WRITE(IOUT,205);]
               0  ELSEIF(IRESTART.EQ.5)[WRITE(6,206);WRITE(IOUT,206);GO TO :END-SIM:;]
               0
               0  "INITIALIZE IWATCH ROUTINE"
               0  IF(IWATCH.NE.0) CALL WATCH(-99,IWATCH);
               0
               0  "INITIALIZE THE FLAGS THAT CONTROL CORRELATION SAMPLING"
               0  INEED2=0;IPASS=0;
               0
               0  "SET CLOCK AT THE BEGINNING OF SIMULATIONS"
               0  $INITIALIZE_ELAPSED_CPU_TIME;
               0  $SET_ELAPSED_CPUTIME(CPUT1);
               0  $INITIALIZE_ELAPSED_TOTAL_TIME;
               0  ETIMETOT=0;
               0  TIMEB=0;
               0  NETADJ=0;
               0
               0  "dcav_old = 0.0;"
               0
               0  "Calculate the cavity mass for in-flight dose display"
               0  FMASSC=0.0; "TOTAL CAVITY MASS"
               0  DO IX=1,NR[
               1      DO IC=1,NC[
               2          $GET-IRL(IC,IX);
               2          IF(NTRACK(IRL).EQ.1)[
               3              FMASS=AMASS(IC,IX);
               3              FMASSC=FMASSC+FMASS; "SUM THE CAVITY MASS USED LATER"
               3              ]
               2          ]
               1      ]
               0  "end of calculation of cavity mass"
               0
               0  "Initialize variables for the cs_enhance scoring "
               0  tmp_dose = 0;  tmp_dose0 = 0;
               0  tmp_dose1 = 0; tmp_dose2 = 0;
               0  last_case = 0; cav_case = 0;
               0
               0  "Open file for data storage, if requested "
               0  "The file is opened in the temporary working directory"
               0  IF( idat = 0 ) data_unit = egs_open_file(4,0,1,'.egsdat');
               0
               0  "*******************************************************************"
               0  "IK: New parallel processing implementation. Only used if there is a
               0  "    working C compiler.
               0  "*******************************************************************"
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  /last_dose,last2_dose/ = 0;  n_tot = ncaseo;
               0  first_time = .true.; is_finished = .false.;
               0
               0  :start_parallel_loop:;
               0
               0  IF( n_parallel > 0 ) [  "Job is part of a parallel run "
               1
               1      last_dose = cav_dose - last_dose + tmp_dose;
               1      last2_dose = cav2_dose - last2_dose + tmp_dose*tmp_dose;
               1      tmpf = fmassc*ainflu/ncaset/1.602e-10;
               1      part_dose = last_dose/tmpf; part2_dose = last2_dose/(tmpf*tmpf);
               1      last_dose = cav_dose + tmp_dose;
               1      last2_dose = cav2_dose + tmp_dose*tmp_dose;
               1      call egs_pjob_control(ncase,n_run,n_left,n_tot,part_dose,part2_dose,
               1      current_result, current_uncertainty);
               1      IF( n_run = 0 ) [
               2          write(6,'(//a,a//)') '****** No histories left in job control file',
               2          '       => end simulation';
               2          "ainflu = ainflu*dble(IHSTRY)/dble(NCASET);"
               2          goto :END-SIM:;
               2          ]
               1      IF( statlm > 0 & current_uncertainty < statlm ) [
               2          write(6,'(//a,a//)') '****** Desired uncertainty reached',
               2          '       => end simulation';
               2          "ainflu = ainflu*dble(IHSTRY)/dble(NCASET);"
               2          goto :END-SIM:;
               2          ]
               1      NBATCH = n_run/$STAT**2;
               1      IF( NBATCH < 1 ) [ NBATCH = 1; n_run = NBATCH*$STAT**2; ]
               1      IF( first_time ) [
               2          first_time = .false.; n_last = n_run;
               2          write(6,'(//a,i12,a//)') '****** Running ',n_run,' histories';
               2          ]
               1      ELSE [
               2          write(6,'(//a,i12,a)') '***** Finished ',n_last,' histories';
               2          write(6,'(/a/,20x,1pe11.4,a,0pf5.2,a/,a,i12,a//)')
               2          '      current result including previous runs and other parallel jobs: ',
               2          current_result, ' +/- ',current_uncertainty,' %',
               2          '      will run another ',n_run,' histories';
               2          ]
               1      ]
               0  #endif;
               0  "*******************************************************************"
               0
               0  "STATISTICAL BATCHES. STATISTICAL ANALYSIS IS DONE AFTER EACH BATCH. EXECUTION
               0  "STOPS IF THE DESIRED STATISTICAL ACCURACY IS OBTAINED OR THERE IS NOT ENOUGH
               0  "TIME TO DO ANOTHER BATCH.
               0  DO IBATCH=1,$STAT[
               1
               1      IBTCH=IBATCH;
               1      IF(IBATCH.EQ.1)[
               2          OUTPUT;
               2          (/' BATCH',2X,'ELAPSED',2X,'CPUtime',2X,'RATIO',2X,
               2          'time of day',2X,'cavity stats(%)',2X,'cav.dose(Gy.cm^2)'//
               2          2X,'1',5X,'0.0',6X,'0.0',6X,'0.00',3X,' ',$); call egs_time(6);
               2
               2          "IK: it is annoing that for batch runs we don't see the progress"
               2          "    info in the log file until the job is finished. This is because"
               2          "    Fortran uses buffered I/O. The following flushes unit 6 so that"
               2          "    we can see the progress of the calculation. "
               2          $FLUSH_UNIT(6);
               2          ]
               1      ELSE[
               2          $SET_ELAPSED_TOTAL_TIME(TIMEB);
               2          ETIMETOT = ETIMETOT+TIMEB;
               2          $SET_ELAPSED_CPUTIME(CPUT2);
               2          TIMCPU=(CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+$TIME_RESOLUTION;
               2          "*****************************************************************"
               2          OUTPUT IBATCH,ETIMETOT,TIMCPU,ETIMETOT/TIMCPU;
               2          (1X,I2,F8.1,1X,F8.1,2X,F8.2,3X,' ',$);  call egs_time(6);
               2          "*****************************************************************"
               2
               2          "IK: it is annoying that for batch runs we don't see the progress"
               2          "    info in the log file until the job is finished. This is because"
               2          "    Fortran uses buffered I/O. The following flushes unit 6 so that"
               2          "    we can see the progress of the calculation. "
               2          $FLUSH_UNIT(6);
               2          "*****************************************************************"
               2
               2          "CHECK THERE IS TIME LEFT FOR ANOTHER BATCH"
               2          BATCHT=TIMCPU/dble(IBATCH-1);"TIME PER BATCH SO FAR"
               2          IF(TIMCPU+1.1*BATCHT.GT.TIMMAX*3600.)[
               3              "NOT ENOUGH TIME FOR ANOTHER BATCH"
               3              "PRINT MESSAGE AND EXIT SIMULATION LOOP"
               3              WRITE(IOUT,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
               3              WRITE(6,210) TIMMAX,IBATCH-1,IHSTRY-NCASEO,IHSTRY;
               3              "ADJUST THE INCIDENT FLUENCE"
               3              "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
               3              IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
               4                  SRCPT(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
               4                  $SWITCH-TO-PARALLEL-BEAM-SOURCE;
               4                  "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
               4                  SRCPAR(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
               4                  $RECOVER-POINT-SOURCE;
               4                  ]
               3              GO TO :END-SIM:;
               3              ]
               2          ]
               1
               1      "LOOP OVER EACH HISTORY FILLING EACH STATISTICAL BIN. THIS ALLOWS
               1      "STATISTICAL ANALYSIS TO BE DONE EVEN IF ONLY ONE BATCH EXECUTES.
               1      DO IS=1,$STAT[
               2
               2          "ZERO THE SCORING ARRAYS AND VARIABLES USED BY AUSGAB AND MSCAT"
               2          /IST,ISTC,ISM,ISMC,NOSCAT,INOCAV,NOSCT2,INOMED/=0;
               2          DO IC=1,NC[
               3              DO IX=1,NR[
               4                  $GET-IRL(IC,IX);
               4                  IF(NTRACK(IRL).EQ.1)[
               5                      DO IT=1,ITMAX[
               6                          SCDOSE(IC,IX,IT)=0.0
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2
               2          DO ICASE=1,NBATCH["NOW FILL EACH IS BIN"
               3              IHSTRY=IHSTRY+1; "INCREMENT HISTORY COUNTER"
               3              the_case = IHSTRY;
               3
               3              :CORRELATION-RESTART:; "RESTART HERE FOR A CORRELATED HISTORY"
               3
               3              NFTIME = 0; "reset the photon forced interaction counter"
               3
               3              "*****************************************************"
               3              "RNG macros updated from cavrznrc, EMH, January, 2002 "
               3              "*****************************************************"
               3              "retrieve starting random numbers if reading from a file"
               3              IF((IPASS.EQ.0).AND.(IRESTART.EQ.4)) [
               4                  "$RETRIEVE RNG STATE FROM UNIT 2; was $RESET-RNG(2);"
               4                  $RETRIEVE RNG STATE FROM UNIT rng_unit; "was $RESET-RNG(2);"
               4                  ]
               3
               3
               3              IF(IPASS =  0)[
               4                  "store the initial random number, another pass might be needed"
               4                  IRNG = 1;
               4                  $STORE-RNG(IRNG);     "was $STORE-RNG(0);"
               4                  ]
               3              ELSE[ "initialize random number if correlation pass is starting"
               4                  IRNG = 1;
               4                  $RESET-RNG(IRNG);     "was $RESET-RNG(0);"
               4                  ]
               3
               3              "store initial random #s if requested"
               3              IF(ISTORE =  1)[
               4                  IF(IPASS =  0)[ $STORE RNG STATE ON UNIT rng_unit; ]
               4                  ]
               3              ELSEIF(ISTORE =  2)[
               4                  "temporarily store the initial random number seed"
               4                  IRNG = 3;
               4                  $STORE-RNG(IRNG);  "was $STORE-RNG(-2);"
               4                  "clear the flag that signals energy deposit in the cavity"
               4                  IDECAV = 0;
               4                  ]
               3              ELSEIF(ISTORE.EQ.3)[
               4                  IF(IPASS.EQ.0)[
               5                      "STORE THE INITIAL RANDOM NUMBER SEED"
               5                      $PUT RNG STATE ON UNIT rng_unit;
               5                      ]
               4                  ]
               3              "*****************************************************"
               3
               3              "CALCULATE THE SOURCE DEPENDENT VALUES WHICH CHANGE FOR EACH
               3              "HISTORY THESE INCLUDE :
               3              "ENTRY POINT INTO TARGET,
               3              "INITIAL DIRECTION COSINES,
               3              "STATISTICAL WEIGHT,
               3              "ENTRY FLAG(NRCFLG)
               3              CALL SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               3
               3              "CALCULATE THE INITIAL ENERGY IF A DISTRIBUTION IS TO BE USED"
               3              IF(MONOEN.NE.0)["IF EQUAL TO 0, IT IS MONOENERGETIC"
               4                  CALL ENSRCH(EIN);   "RETURNS K.E. FROM DISTRIBUTION"
               4                  IF(IQIN.EQ.0)[EI=EIN;]ELSE[EI=EIN+RM;]  "TOTAL ENERGY"
               4                  " THERE WAS A CHECK THAT THE DATA FILE HAD DATA OVER THE ENERGY
               4                  "RANGE REQUIRED, THE LOCATION OF IT WILL EVENTUALLY BE IN
               4                  "ESRCIN.MOR
               4                  ]
               3              "FOR AN INPUT ENERGY SPECTRUM, DETAILED FORCING MACRO IS USED"
               3              LATCHI=0;
               3              IF((IWATCH.NE.0).AND.(IWATCH.NE.4))[
               4                  "JAN CHANGE: (FOR DEBUGGING)"
               4                  IF(IPASS.EQ.0)[OUTPUT;(/'***** ZEROTH CORRELATION *****'/);]
               4                  "END OF JAN CHANGE"
               4                  IF(IPASS.EQ.1)[OUTPUT;(/'***** FIRST CORRELATION *****'/);]
               4                  IF(IPASS.EQ.2)[OUTPUT;(/'***** SECOND CORRELATION *****'/);]
               4                  OUTPUT 1,EIN,IQIN,IRIN,XIN,YIN,ZIN,UIN,VIN,WIN,LATCHI,WEIGHT;
               4                  (' INITIAL SHOWER VALUES',T36,':',
               4                  I2,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
               4                  ]
               3
               3              "ALL INITIAL SHOWER VARIABLES ARE SET, CALL THE SHOWER ROUTINE"
               3              CALL SHOWER(IQIN,EI,XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT);
               3
               3              "JAN CHANGE:"
               3              "            IF (IFULL.EQ.3).AND.(IPASS.EQ.0)["
               3              "STORE THE FINAL RANDOM NUMBER, TO ENSURE THE SAME FIRST"
               3              "PASS TRANSPORT AS THE IFULL.EQ.1 OPTION"
               3              "                 $STORE-FINAL-IPASS0-RNG;"
               3              "                 ]"
               3              "END OF JAN CHANGE"
               3
               3              "*****************************************************"
               3              "RNG macros updated from cavrznrc, EMH, January, 2002 "
               3              "*****************************************************"
               3              IF(ISTORE.EQ.2)[
               4                  "STORE INITIAL RN SEED IF ENERGY SCORED IN THE CAVITY"
               4                  IF(IFULL.LE.1)[ "UNCORRELATED RUNS"
               5                      IF(IDECAV.EQ.1)[ "ENERGY WAS DEPOSITED IN THE CAVITY"
               6                          IRNG = 1;
               6                          $STORE-RNG(IRNG);              "was $STORE-RNG(0);"
               6                          IRNG = 3;
               6                          $RESET-RNG(IRNG);               "was $RESET-RNG(-2);"
               6                          $PUT RNG STATE ON UNIT rng_unit;"was $STORE-RNG(2);"
               6                          IRNG = 1;
               6                          $RESET-RNG(IRNG);              "was $RESET-RNG(0);"
               6                          ]
               5                      ]
               4                  ELSE[ "CORRELATED RUNS"
               5                      IF((IFULL.EQ.2).AND.(IPASS.EQ.1))[
               6                          "AFTER THE SECOND PASS ONLY"
               6                          IRNG = 3;
               6                          $RESET-RNG(IRNG);           "was $RESET-RNG(-2);"
               6                          $PUT RNG STATE ON UNIT rng_unit;
               6                          WRITE(2,*) IDECV1,IDECAV;
               6                          ]
               5                      IF((IFULL.EQ.3).AND.(IPASS.EQ.2))[
               6                          "AFTER THE THIRD PASS ONLY"
               6                          IRNG = 3;
               6                          $RESET-RNG(IRNG);               "was $RESET-RNG(-2);"
               6                          $PUT RNG STATE ON UNIT rng_unit;"was $STORE-RNG(2);"
               6                          WRITE(2,*) IDECV1,IDECAV;
               6                          ]
               5                      ]
               4                  ]
               3
               3              IF((IFULL.GE.2).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.0))
               3              [
               4                  "FIRST PASS COMPLETED. SET UP FOR SECOND PASS IF"
               4                  "A POINT SOURCE IS BEING USED"
               4                  IRNG = 2;
               4                  $STORE-RNG(IRNG);                       "was $STORE-RNG(-1);"
               4                  IPASS=1; "FLAG FOR SECOND PASS"
               4                  INEED2=0;       "ZERO THIS FLAG"
               4                  IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
               4                  $SWITCH-TO-PARALLEL-BEAM-SOURCE;
               4                  GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
               4                  ]
               3              ELSEIF((IFULL.EQ.3).AND.(IPTSRC.EQ.0).AND.(IPASS.EQ.0)
               3              .AND.(INEED2.EQ.1))[
               4                  "FIRST PASS COMPLETED, NO POINT SOURCE USED"
               4                  "SET UP FOR MATERIAL CORRELATION PASS."
               4                  IRNG = 2;
               4                  $STORE-RNG(IRNG);  "was $STORE-RNG(-1);"
               4                  IPASS=2;       "FLAG NEED FOR THIRD PASS"
               4                  INEED2=0;       "ZERO THIS FLAG"
               4                  "*****************************************************"
               4                  IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
               4                  "JAN CHANGE: FILL ONLY CAVITY NOT OUTER ENVELOPE"
               4                  "I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
               4                  DO IRL=2,NREG[ "SWITCH TO UNIFORM WALL MATERIAL"
               5                      MED(IRL)=1;RHOR(IRL)=RHO(1);
               5                      ]
               4                  GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
               4                  ]
               3              ELSEIF((IFULL.EQ.3).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.1)
               3              .AND.(INEED2.EQ.1))[
               4                  "SECOND PASS COMPLETED. SET UP FOR THIRD PASS IF"
               4                  "A POINT SOURCE IS BEING USED"
               4                  IPASS=2;       "FLAG NEED FOR THIRD PASS"
               4                  INEED2=0;       "ZERO THIS FLAG"
               4                  IF(IDECAV.NE.0) IDECV1=IDECAV; "1ST PASS ENERGY DEPOSITION"
               4                  "JAN CHANGE: FILL ONLY CAVITY NOT OUTER ENVELOPE"
               4                  "I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
               4                  DO IRL=2,NREG[ "SWITCH TO UNIFORM WALL MATERIAL"
               5                      MED(IRL)=1;RHOR(IRL)=RHO(1);
               5                      ]
               4                  GO TO :CORRELATION-RESTART:; "RESTART THE HISTORY"
               4                  ]
               3              "JAN CHANGE: IPASS.EQ.2 to IPASS.GE.1 BECAUSE OTHERWISE NO BACKUP FOR"
               3              " IFULL=3 AND IPASS=1 AND INEED2=0"
               3              ELSEIF(
               3              ((IFULL.EQ.2).AND.(IPASS.EQ.1))
               3              .OR.
               3              ((IFULL.EQ.3).AND.(IPASS.GE.1))
               3              )[
               4                  "THE FINAL CORRELATION PASS WAS JUST COMPLETED"
               4                  IPASS=0;        "RESET THE FLAG"
               4                  IRNG = 2;
               4                  $RESET-RNG(IRNG);                      "was $RESET-RNG(-1);"
               4                  IDECV1=0;       "CLEAR 1ST PASS ENERGY DEPOSITION FLAG"
               4                  INEED2=0;       "ZERO THIS FLAG"
               4                  "JAN CHANGE: DONT RECOVER POINT SOURCE IF PAR BEAM Afl CALC"
               4                  " WAS REQUESTED. CHANGED IFULL.GE.2 to"
               4                  " IFULL.EQ.2 OR IFULL.EQ.3 AND IPTSRC.EQ.1"
               4                  IF(IFULL.EQ.2).OR.((IFULL.EQ.3).AND.(IPTSRC.EQ.1))[
               5                      $RECOVER-POINT-SOURCE;
               5                      ]
               4                  IF(IFULL.EQ.3)[
               5                      "RECOVER THE ORIGINAL MATERIAL CONFIGURATION"
               5                      "JAN CHANGE: RECOVER ONLY CAVITY NOT OUTER ENVELOPE"
               5                      "I.E. MED(IRL)=1 ONLY FOR IRL>1; ie LEAVE MED(1) UNCHANGED"
               5                      DO IRL=2,NREG[
               6                          MED(IRL)=MEDSAV(IRL);RHOR(IRL)=RHOSAV(IRL);
               6                          ]
               5                      ]
               4                  ]
               3              "JAN CHANGE: THIS PASS ONLY FOR DEBUGGING"
               3              ELSE [ IF (IFULL.EQ.2).OR.((IFULL.EQ.3).AND.(INEED2.EQ.1))
               4                  [WRITE(6,*) 'SHOULD NOT GET HERE...';
               5                      write(6,*) 'ipass ',ipass;
               5                      write(6,*) 'ifull ',ifull;
               5                      ]]
               3
               3              "SIGNAL THE END OF A HISTORY IF WATCH MODE IS SET"
               3              "JAN CHANGE: ZERO STACK ELEMENTS TO PREVENT CROSS TALKING"
               3              "$CLEAN-STACK;"
               3              "END OF JAN CHANGE"
               3              IF(IWATCH.GT.0) CALL WATCH(-1,IWATCH);
               3
               3              ] "END OF THE ICASE LOOP"
               2
               2          "LOAD THE RAW DATA INTO THE STATISTICAL ARRAYS"
               2          ISTCIS(IS)=ISTCIS(IS)+ISTC;
               2          ISTIS(IS)=ISTIS(IS)+IST;
               2          IMSIS(IS)=IMSIS(IS)+NOSCAT;
               2          IMSCIS(IS)=IMSCIS(IS)+INOCAV;
               2          ISMCIS(IS)=ISMCIS(IS)+ISMC;
               2          ISMIS(IS)=ISMIS(IS)+ISM;
               2          IMMIS(IS)=IMMIS(IS)+NOSCT2;
               2          IMMCIS(IS)=IMMCIS(IS)+INOMED;
               2
               2          DO IT=1,ITMAX[
               3              DO IX=1,NR[
               4                  DO IC=1,NC[
               5                      $GET-IRL(IC,IX);
               5                      IF(NTRACK(IRL).EQ.1)[
               6                          DOSEIS(IC,IX,IT,IS)=
               6                          DOSEIS(IC,IX,IT,IS)+SCDOSE(IC,IX,IT);
               6
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2
               2          ] "END OF THE IS LOOP"
               1
               1      "SUCCESFUL COMPLETION OF A BATCH. DELETE THE RAW DATA FROM THE LAST BATCH"
               1      "AND RECORD THE NEW BATCH ONLY IF REQUESTED"
               1      IF(IDAT.EQ.0)[
               2          " discard data from previous batches (if any) "
               2          rewind(data_unit);
               2
               2          "******************"
               2          "history by history"
               2          "  EMH, January2002"
               2          "******************"
               2
               2          tcav_dose  = cav_dose  + tmp_dose;
               2          tcav2_dose = cav2_dose + tmp_dose*tmp_dose;
               2
               2          tcav_dose0  = cav_dose0   + tmp_dose0;
               2          tcav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;
               2
               2          tcav_dose1  = cav_dose1  + tmp_dose1;
               2          tcav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
               2
               2          tcav_dose2  = cav_dose2  + tmp_dose2;
               2          tcav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;
               2
               2
               2          tcav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
               2          tcav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
               2          tcav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;
               2
               2          write(data_unit,*) tcav_dose, tcav_dose0, tcav_dose1, tcav_dose2;
               2          write(data_unit,*) tcav2_dose,tcav2_dose0,tcav2_dose1,tcav2_dose2;
               2          write(data_unit,*) tcav_dosec,tcav_dosec01,tcav_dosec02;
               2          "********************"
               2
               2          DO IS=1,$STAT[
               3              WRITE(data_unit,*) ISTIS(IS),ISTCIS(IS),
               3              IMSIS(IS),IMSCIS(IS),
               3              ISMIS(IS),ISMCIS(IS),
               3              IMMIS(IS),IMMCIS(IS);
               3              WRITE(data_unit,*)
               3              (((DOSEIS(IC,IX,IT,IS),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
               3              ]
               2          ]"END OF CONDITIONAL DATA STORAGE"
               1
               1      $SET_ELAPSED_CPUTIME(CPUT2);
               1      TIMCPU=$CONVERSION_TO_SECONDS*(CPUT2-CPUT1)+TMCPUO;
               1      IF(IDAT.EQ.0)[
               2          "$STORE-RNG(4);WRITE(4,*) IHSTRY,TIMCPU;"
               2          $PUT RNG STATE ON UNIT data_unit;
               2          WRITE(data_unit,*) IHSTRY,TIMCPU;
               2          ]
               1      "DO STATISTICAL ANALYSIS ON THE CAVITY REGION TO SEE IF WE QUIT EARLY"
               1      "JAN CHANGE"
               1      "WRITE(6,*) 'Early quit test ??';"
               1      DO IS=1,$STAT[
               2          DCAVIS(IS)=0.0;
               2          DCAV_SECIS(IS)=0.0;
               2          DO ICAV=1,NREG[
               3              IF(NTRACK(ICAV).EQ.1)[
               4                  $GET-IX-IC(ICAV);
               4                  "change: I defined DCAVIS as the TOTAL cavity dose (used to be  "
               4                  "primary dose only) so that the uncertainty is consistent with  "
               4                  "uncertainty printed in the listing file                   (JAN)"
               4                  "DCAV_SEC is the dose solely due to secondary particles         "
               4                  DCAVIS(IS)=DCAVIS(IS)+DOSEIS(IC,IX,1,IS)+DOSEIS(IC,IX,2,IS);
               4                  DCAV_SECIS(IS)=DCAV_SECIS(IS)+DOSEIS(IC,IX,2,IS);
               4                  ]
               3              ]
               2          ]
               1      $ANALYZE0 DCAV USING MODE 2;
               1      "note that DCAV is now TOTAL dose, DCAVUN its uncertainty"
               1      IF(DCAVUN.LE.STATLM)[
               2          "REACHED OBJECTIVE-PRINT MESSAGE AND JUMP OUT OF SIMULATION LOOP"
               2          WRITE(6,230)DCAVUN,IBTCH;WRITE(IOUT,230)DCAVUN,IBTCH;
               2          "FIX NORM ON EARLY EXIT"
               2          "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
               2          IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
               3              SRCPT(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
               3              $SWITCH-TO-PARALLEL-BEAM-SOURCE;
               3              "AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);"
               3              SRCPAR(1)=AINFLU*dble(IHSTRY)/dble(NCASET);
               3              $RECOVER-POINT-SOURCE;
               3              ]
               2          GO TO :END-SIM:;
               2          ]
               1
               1      "the following is to calculate current dose in cavity (JAN)  "
               1      "makes us of variable dcav_secis(is) and dcav_sec to do same "
               1      "for secondary dose                                          "
               1      $ANALYZE0 DCAV_SEC USING MODE 2;
               1      AINFLU_CURRENT=AINFLU*dble(IHSTRY)/dble(NCASET);
               1      DCAV_CURRENT = DCAV*1.602E-10/(FMASSC*AINFLU_CURRENT);
               1      FR_SEC = DCAV_SEC/DCAV*100;
               1      "FR_SEC is not put on output during run "
               1      "**************************************"
               1      "taken from cavrznrc, EMH, January 2002"
               1      "**************************************"
               1      "******************"
               1      "history by history"
               1      "******************"
               1      "we do this always, so remove conditional"
               1      "on a later stage, the above will be removed!!!"
               1      "    IF( use_enhance | n_split > 1 ) ["
               1      dcav_current = cav_dose*1.602E-10/(FMASSC*AINFLU_CURRENT);
               1      dcavun = (cav2_dose*ihstry-cav_dose*cav_dose)/(ihstry-1);
               1      IF( dcavun > 0 ) [ dcavun = sqrt(dcavun); ];
               1      dcavun = dcavun*1.602E-10/(FMASSC*AINFLU_CURRENT);
               1      dcavun = 100*dcavun/dcav_current;
               1      "    ] "
               1
               1      OUTPUT DCAVUN,DCAV_CURRENT;('+',5X,F5.2,10X,1PE11.4,5X,1PE10.3);
               1      "end of change"
               1
               1      ] "END OF SIMULATIONS"
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 ) [ goto :start_parallel_loop:; ]
               0
               0  #endif;
               0
               0  "PRINT INSUFFICIENT STATS WARNING"
               0  WRITE(IOUT,240) STATLM,DCAVUN,IBTCH;WRITE(6,240) STATLM,DCAVUN,IBTCH;
               0
               0  :END-SIM:;
               0
               0  "**************************************"
               0  "taken from cavrznrc, EMH, January 2002"
               0  "**************************************"
               0  "******************"
               0  "history by history"
               0  "******************"
               0  "IF( use_enhance | n_split > 1 ) [ we have to add the temporary scoring"
               0  "variables for the last history      "
               0  cav_dose  = cav_dose  + tmp_dose;
               0  cav2_dose = cav2_dose + tmp_dose*tmp_dose;
               0
               0  cav_dose0  = cav_dose0  + tmp_dose0;
               0  cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;
               0
               0  cav_dose1  = cav_dose1  + tmp_dose1;
               0  cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
               0
               0  cav_dose2  = cav_dose2  + tmp_dose2;
               0  cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;
               0
               0
               0  cav_dosec   = cav_dosec   + tmp_dose*tmp_dose1;
               0  cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
               0  cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;
               0  "]"
               0
               0  write(6,'(/a,$)') '****** FINAL RANDOM NUMBER STATE:';
               0  $SHOW-RNG-STATE(6); write(6,'(a)') '  ******';
               0  write(iout,'(/a,$)') '********* FINAL RANDOM NUMBER STATE:';
               0  $SHOW-RNG-STATE(iout); write(iout,'(a)') '  *********';
               0
               0  $SET_ELAPSED_TOTAL_TIME(TIMEB);
               0  $SET_ELAPSED_CPUTIME(CPUT2);
               0  TIMCPU=(CPUT2-CPUT1)*$CONVERSION_TO_SECONDS+TMCPUO;
               0  "**************************************"
               0  "taken from cavrznrc, EMH, January 2002"
               0  "**************************************"
               0  IF(IRESTART=3)["just analyzing data--no elapsed time"
               1      WRITE(IOUT,250)TMCPUO,TMCPUO/3600;
               1      WRITE(6,250)TMCPUO,TMCPUO/3600;
               1      WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      ]
               0  ELSEIF(IRESTART=5)["output time results for parallel runs"
               1      WRITE(IOUT,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
               1      WRITE(6,255)DATCOUNT,TMCPUO,TMCPUO/3600.,TMCPUO/dble(DATCOUNT);
               1      WRITE(IOUT,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      WRITE(6,280)TMCPUO/dble(IHSTRY),3600.*dble(IHSTRY)/TMCPUO;
               1      ]
               0  ELSE[
               1      IF(TMCPUO.EQ.0)["This is first run"
               2          RATIO=ETIMETOT/TIMCPU;
               2          WRITE(IOUT,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          WRITE(6,260)ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          ]
               1      ELSE[ "There was previous run, but don't have elapsed time for it"
               2          RATIO = ETIMETOT/(TIMCPU-TMCPUO); "ratio this run only"
               2          WRITE(IOUT,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          WRITE(6,261) ETIMETOT,TIMCPU,TIMCPU/3600.,RATIO;
               2          ]
               1      IF(IHSTRY.NE.0 .AND. TIMCPU.NE.0.0) ["this should always happen"
               2          WRITE(IOUT,280) TIMCPU/dble(IHSTRY),3600.*dble(IHSTRY)/TIMCPU;
               2          ]
               1      ]
               0
               0  "**************************************"
               0  ;
               0  "******************************************************************************
               0  "
               0  "                       *** SECTION 3 ***
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  "STATISTICAL AND OTHER DATA HANDLING AND CALL THE OUTPUT SUMMARY ROUTINE"
               0
               0  "------------------------------------------------------------------------------
               0
               0  :STATS-ANAL:;
               0
               0
               0  write(6,'(A,I10)') 'Total number of stories :', IHSTRY;
               0  write(6,'(A,I10)')
               0  'Number of primary stories scoring in the cavity :', cav_case;
               0
               0  FMASSC=0.0; "total cavity mass"
               0  DO IX=1,NR[
               1      DO IC=1,NC[
               2          $GET-IRL(IC,IX);
               2          IF(NTRACK(IRL).EQ.1)[
               3              FMASS=AMASS(IC,IX);
               3              FMASSC=FMASSC+FMASS;
               3              ]
               2          ]
               1      ]
               0
               0  "Adjust incident fluence and total number of histories run"
               0  AINFLU=AINFLU*dble(IHSTRY)/dble(NCASET);
               0  NCASET = IHSTRY;
               0
               0
               0  "IF( use_enhance | n_split > 1 ) ["
               0  "******************"
               0  "history by history"
               0  "    EMH, Jan. 2002"
               0  "******************"
               0
               0  cav2_dose = (cav2_dose*ncaset - cav_dose*cav_dose)/(ncaset-1);
               0  IF( cav2_dose > 0 ) cav2_dose = sqrt(cav2_dose);
               0
               0  IF( ifull = 1 ) [
               1
               1      cav2_dose0 = (cav2_dose0*ncaset - cav_dose0*cav_dose0)/(ncaset-1);
               1      IF( cav2_dose0 > 0 ) cav2_dose0 = sqrt(cav2_dose0);
               1      cav2_dose1 = (cav2_dose1*ncaset - cav_dose1*cav_dose1)/(ncaset-1);
               1      IF( cav2_dose1 > 0 ) cav2_dose1 = sqrt(cav2_dose1);
               1      cav2_dose2 = (cav2_dose2*ncaset - cav_dose2*cav_dose2)/(ncaset-1);
               1      IF( cav2_dose2 > 0 ) cav2_dose2 = sqrt(cav2_dose2);
               1
               1      corr_02=(cav_dosec02*ncaset-cav_dose0*cav_dose2)/(ncaset-1);
               1      corr_02=cav2_dose0**2+cav2_dose2**2+ 2*corr_02;
               1      IF (corr_02 > 0) corr_02 = sqrt(corr_02);
               1
               1      cav_dosec   = (cav_dosec*ncaset   - cav_dose*cav_dose1)/(ncaset-1);
               1      cav_dosec01 = (cav_dosec01*ncaset - cav_dose0*cav_dose1)/(ncaset-1);
               1      cav_dosec02 = (cav_dosec02*ncaset - cav_dose0*cav_dose2)/(ncaset-1);
               1      ]
               0
               0  cav_dose  = cav_dose*1.602e-10/(ainflu*fmassc);
               0  cav_dose0 = cav_dose0*1.602e-10/(ainflu*fmassc);
               0  cav_dose1 = cav_dose1*1.602e-10/(ainflu*fmassc);
               0  cav_dose2 = cav_dose2*1.602e-10/(ainflu*fmassc);
               0
               0  cav2_dose  = cav2_dose*1.602e-10/(ainflu*fmassc);
               0  cav2_dose0 = cav2_dose0*1.602e-10/(ainflu*fmassc);
               0  cav2_dose1 = cav2_dose1*1.602e-10/(ainflu*fmassc);
               0  cav2_dose2 = cav2_dose2*1.602e-10/(ainflu*fmassc);
               0
               0  corr_02    = corr_02*1.602e-10/(ainflu*fmassc);
               0
               0  cav_dosec   = cav_dosec*(1.602e-10/(ainflu*fmassc))**2;
               0  cav_dosec01 = cav_dosec01*(1.602e-10/(ainflu*fmassc))**2;
               0  cav_dosec02 = cav_dosec02*(1.602e-10/(ainflu*fmassc))**2;
               0
               0  IF( use_enhance | n_split > 1 ) [ goto :IGNORE-OTHER-SCORING:;]
               0  "]"
               0
               0
               0  "LOAD THE SUMMATION OVER THE CAVITY ARRAY"
               0  DO IC=1,NC[
               1      DO IX=1,NR[
               2          $GET-IRL(IC,IX);
               2          IF(NTRACK(IRL).EQ.1)[
               3              DO IT=1,ITMAX[
               4                  DO IS=1,$STAT[
               5                      SCAVIS(IT,IS)=SCAVIS(IT,IS)+DOSEIS(IC,IX,IT,IS);
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  "MANIPULATE THE RAW DATA ARRAYS INTO THE DESIRED QUANTITIES PRIOR TO           "
               0  "THE STATISTICAL ANALYSES                                                      "
               0  "BEFOREHAND FOR THE ARRAYS DOSEIS AND SCAVIS:                                  "
               0  "   IT=1 PRIMARY EDEP TO GAS                                                   "
               0  "   IT=2 SECONDARY EDEP TO GAS                                                 "
               0  "   IT=3 UNATTENUATED PRIMARY EDEP TO GAS                                      "
               0  "   IT=4 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS                        "
               0  "   IT=5 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS WITH GAS MATERIAL      "
               0  "        REPLACED BY WALL MATERIAL                                             "
               0  "   IT=6 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO WALL MATERIAL GAS WITH GAS "
               0  "        MATERIAL REPLACED BY WALL MATERIAL                                    "
               0  "AFTERHAND FOR THE ARRAYS DOSEIS AND SCAVIS:                                   "
               0  "   IT=1 TOTAL EDEP TO GAS                                                     "
               0  "   IT=2 Ascat-1                                                               "
               0  "   IT=3 1/Aatt-1                                                              "
               0  "   IT=4 Apn                                                                   "
               0  "   IT=5 Afl                                                                   "
               0  "   IT=6 <s>g,w -1                                                             "
               0  "AFTERHAND FOR THE ARRAYS TDAIS AND TTDAIS:                                    "
               0  "   IT=1 PRIMARY UNATTENUATED EDEP TO GAS                                      "
               0  "   IT=2 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS                        "
               0  "   IT=3 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO GAS WITH GAS MATERIAL      "
               0  "        REPLACED BY WALL MATERIAL                                             "
               0  "   IT=4 PARALLEL BEAM UNATTENUATED PRIMARY EDEP TO WALL MATERIAL GAS WITH GAS "
               0  "        MATERIAL REPLACED BY WALL MATERIAL                                    "
               0  "FIRST FOR THE CAVITY SUMMARY"
               0  DO IS=1,$STAT[
               1      TTDAIS(1,IS)=SCAVIS(1,IS)+SCAVIS(3,IS);
               1      IF(IPTSRC.EQ.1)[TTDAIS(2,IS)=SCAVIS(4,IS);]
               1      ELSE[           TTDAIS(2,IS)=TTDAIS(1,IS);]
               1      TTDAIS(3,IS)=SCAVIS(5,IS);
               1      TTDAIS(4,IS)=SCAVIS(6,IS);
               1      TEMP=SCAVIS(1,IS);
               1      TEMP2=SCAVIS(2,IS);
               1      SCAVIS(1,IS)=TEMP+TEMP2; "TOTAL EDEP"
               1      IF(TEMP.EQ.0.0)[
               2          OUTPUT IS;
               2          (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=1');
               2          DO IT=2,ITMAX[
               3              SCAVIS(IT,IS)=0.0;
               3              ]
               2          ] "END TEST TEMP=0"
               1      ELSE[
               2          IF(IFULL.GE.1)[
               3              "CONSTRUCT Ascat-1"
               3              SCAVIS(2,IS)=TEMP2/TEMP;
               3              "CONSTRUCT 1/Aatt-1"
               3              TEMP3=SCAVIS(3,IS);
               3              SCAVIS(3,IS)=TEMP3/TEMP;
               3              ] "END IFULL>=1
               2          IF(IFULL.GE.2)[
               3              "CONSTRUCT Apn"
               3              TEMP3=TEMP+TEMP3; "PRIMARY UNATTENUATED EDEP"
               3              IF(IPTSRC.EQ.1)[
               4                  FLURAT=AINFLU;
               4                  $SWITCH-TO-PARALLEL-BEAM-SOURCE;
               4                  FLURAT=AINFLU/FLURAT;
               4                  $RECOVER-POINT-SOURCE;
               4                  TEMP4=SCAVIS(4,IS);
               4                  IF(TEMP4.EQ.0.0)[
               5                      OUTPUT IS;
               5                      (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=4');
               5                      SCAVIS(4,IS)=0.0;
               5                      ]
               4                  ELSE[
               5                      SCAVIS(4,IS)=TEMP3/(TEMP4/FLURAT);
               5                      ]
               4                  ]
               3              ELSE[
               4                  TEMP4=0.0;SCAVIS(4,IS)=1.0;
               4                  ]
               3              ] "END IFULL>=2
               2          IF(IFULL.EQ.3)[
               3              TEMP5=SCAVIS(5,IS);
               3              IF(TEMP5.EQ.0.0)[
               4                  OUTPUT IS;
               4                  (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=5');
               4                  DO IT=5,ITMAX[
               5                      SCAVIS(IT,IS)=0.0;
               5                      ]
               4                  ] "END TEST TEMP5=0"
               3              ELSE[
               4                  "CALCULATE PRIMARY UNATTENUATED EDEP WITH SOURCE"
               4                  "DISTRIBUTION FACTORED OUT( i.e. UNSOURCED)"
               4                  TEMP4=TEMP4+TEMP3;
               4                  SCAVIS(5,IS)=TEMP4/TEMP5;
               4                  "CALCULATE THE STOPPING POWER RATIO"
               4                  SCAVIS(6,IS)=(RHO(1)/RHO(2))*TEMP5/SCAVIS(6,IS)-1.;
               4                  ] "END ELSE ON TEST TEMP5=0"
               3              ] "END IFULL=3"
               2          ] "END ELSE ON TEST TEMP=0"
               1      ] "END IS DO"
               0  "THEN FOR EACH CAVITY REGION"
               0  DO IS=1,$STAT[
               1      DO IX=1,NR[
               2          DO IC=1,NC[
               3              $GET-IRL(IC,IX);
               3              IF(NTRACK(IRL).EQ.1)["IN THE CAVITY"
               4                  TDAIS(IC,IX,1,IS)=DOSEIS(IC,IX,1,IS)+DOSEIS(IC,IX,3,IS);
               4                  IF(IPTSRC.EQ.1)[
               5                      TDAIS(IC,IX,2,IS)=
               5                      TDAIS(IC,IX,1,IS)+DOSEIS(IC,IX,4,IS);]
               4                  ELSE[
               5                      TDAIS(IC,IX,2,IS)=TDAIS(IC,IX,1,IS);
               5                      ]
               4                  TDAIS(IC,IX,3,IS)=DOSEIS(IC,IX,5,IS);
               4                  TDAIS(IC,IX,4,IS)=DOSEIS(IC,IX,6,IS);
               4                  TEMP=DOSEIS(IC,IX,1,IS);
               4                  TEMP2=DOSEIS(IC,IX,2,IS);
               4                  DOSEIS(IC,IX,1,IS)=TEMP+TEMP2; "TOTAL EDEP"
               4                  IF(TEMP.EQ.0.0)[
               5                      OUTPUT IS,IX,IC;
               5                      (' ***WARNING. DOSEIS=0. IS,IX,IC=',3I5,'  IT=1');
               5                      DO IT=2,ITMAX[
               6                          DOSEIS(IC,IX,IT,IS)=0.0;
               6                          ]
               5                      ] "END TEST TEMP=0"
               4                  ELSE[
               5                      IF(IFULL.GE.1)[
               6                          "CONSTRUCT THE Ascat-1 ARRAY"
               6                          DOSEIS(IC,IX,2,IS)=TEMP2/TEMP;
               6                          "CONSTRUCT THE 1/Aatt-1 ARRAY"
               6                          TEMP3=DOSEIS(IC,IX,3,IS);
               6                          DOSEIS(IC,IX,3,IS)=TEMP3/TEMP;
               6                          ] "END IFULL>=1
               5                      IF(IFULL.GE.2)[
               6                          "CONSTRUCT THE Apn ARRAY"
               6                          TEMP3=TEMP+TEMP3; "PRIMARY UNATTENUATED EDEP"
               6                          IF(IPTSRC.EQ.1)[
               7                              TEMP4=DOSEIS(IC,IX,4,IS);
               7                              IF(TEMP4.EQ.0.0)[
               8                                  OUTPUT IS;
               8                                  (' ***WARNING. SCAVIS=0. IS=',I5,'  IT=4');
               8                                  DOSEIS(IC,IX,4,IS)=0.0;
               8                                  ]
               7                              ELSE[
               8                                  DOSEIS(IC,IX,4,IS)=TEMP3/(TEMP4/FLURAT);
               8                                  ]
               7                              ]
               6                          ELSE[TEMP4=0.0;DOSEIS(IC,IX,4,IS)=1.0;]
               6                          ] "END IFULL>=2
               5                      IF(IFULL.EQ.3)[
               6                          TEMP5=DOSEIS(IC,IX,5,IS);
               6                          IF(TEMP5.EQ.0.0)[
               7                              OUTPUT IS,IX,IC;
               7                              (' ***WARNING. DOSEIS=0. IS,IX,IC=',3I5,'  IT=5');
               7                              DO IT=5,ITMAX[
               8                                  DOSEIS(IC,IX,IT,IS)=0.0;
               8                                  ]
               7                              ] "END TEST TEMP5=0"
               6                          ELSE[
               7                              "CALCULATE PRIMARY UNATTENUATED EDEP WITH SOURCE"
               7                              "DISTRIBUTION FACTORED OUT( i.e. UNSOURCED)"
               7                              TEMP4=TEMP4+TEMP3;
               7                              DOSEIS(IC,IX,5,IS)=TEMP4/TEMP5;
               7                              "CALCULATE THE STOPPING POWER RATIO"
               7                              DOSEIS(IC,IX,6,IS)=TEMP5/DOSEIS(IC,IX,6,IS)-1.;
               7                              ] "END ELSE ON TEST TEMP5=0"
               6                          ] "END IFULL=3"
               5                      ] "END ELSE ON TEST TEMP=0"
               4                  ] "END IN THE CAVITY TEST"
               3              ] "END IC DO"
               2          ] "END IX DO"
               1      ] "END IS DO"
               0
               0  "LOAD THE STEP COUNTING ARRAYS FOR THE STATISTICAL ANALYSIS"
               0  DO IS=1,$STAT[
               1      ITEMP=ISTIS(IS);
               1      IF(ITEMP.EQ.0)[FMSIS(IS)=0.0;FNIS(IS)=0.0;FDIS(IS)=0.0;]
               1      ELSE[
               2          TEMP1=ISTIS(IS);TEMP2=IMSIS(IS);
               2          FDIS(IS)=TEMP1;FNIS(IS)=TEMP2;
               2          FMSIS(IS)=TEMP2/TEMP1;
               2          ]
               1      ITEMP=ISTCIS(IS);
               1      IF(ITEMP.EQ.0)[FMSCIS(IS)=0.0;FCNIS(IS)=0.0;FCDIS(IS)=0.0;]
               1      ELSE[
               2          TEMP1=ISTCIS(IS);TEMP2=IMSCIS(IS);
               2          FCDIS(IS)=TEMP1;FCNIS(IS)=TEMP2;
               2          FMSCIS(IS)=TEMP2/TEMP1;
               2          ]
               1      ITEMP=ISMIS(IS);
               1      IF(ITEMP.EQ.0)[FMMIS(IS)=0.0;FSMIS(IS)=0.0;FTMIS(IS)=0.0;]
               1      ELSE[
               2          TEMP1=ISMIS(IS);TEMP2=IMMIS(IS);
               2          FTMIS(IS)=TEMP1;FSMIS(IS)=TEMP2;
               2          FMMIS(IS)=TEMP2/TEMP1;
               2          ]
               1      ITEMP=ISMCIS(IS);
               1      IF(ITEMP.EQ.0)[FMMCIS(IS)=0.0;FSMCIS(IS)=0.0;FTMCIS(IS)=0.0;]
               1      ELSE[
               2          TEMP1=ISMCIS(IS);TEMP2=IMMCIS(IS);
               2          FTMCIS(IS)=TEMP1;FSMCIS(IS)=TEMP2;FMMCIS(IS)=TEMP2/TEMP1;
               2          ]
               1      ]
               0
               0  "FOR ISOURC=4 WE NEED THE DATA FOR CIRCLES, NOT RINGS, SO ADD IT UP"
               0  "THIS SHOULD ONLY BE USED IF THE CAVITY HAS AN INFINITE DIAMETER"
               0  IF((ISOURC.EQ.4).AND.(NR.GT.1))[
               1      DO IS=1,$STAT[
               2          DO IT=1,ITMAX[
               3              DO IX=2,NR[
               4                  DO IC=1,NC[
               5                      $GET-IRL(IC,IX);
               5                      IF(NTRACK(IRL).EQ.1)[
               6                          DOSEIS(IC,IX,IT,IS)=
               6                          DOSEIS(IC,IX,IT,IS)+DOSEIS(IC,IX-1,IT,IS);
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      DO IS=1,$STAT[
               2          DO IT=1,4[
               3              DO IX=2,NR[
               4                  DO IC=1,NC[
               5                      $GET-IRL(IC,IX);
               5                      IF(NTRACK(IRL).EQ.1)[
               6                          TDAIS(IC,IX,IT,IS)=
               6                          TDAIS(IC,IX,IT,IS)+TDAIS(IC,IX-1,IT,IS);
               6                          ]
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  "STATISTICAL ANALYSES ON THE RAW DATA"
               0  "THESE MACROS LOAD STATISTICAL ARRAYS, CALL DATA ANALYSIS ROUTINE"
               0  "AND UNLOAD STASTICAL ARRAY INTO MEAN VALUE AND UNCERTAINTY ARRAY"
               0
               0  "CALCULATE THE UNCERTAINTIES"
               0
               0  $ANALYZE0 FMS USING MODE 0;
               0  $ANALYZE0 FMSC USING MODE 0;
               0  $ANALYZE0 FN USING MODE 2;
               0  $ANALYZE0 FD USING MODE 2;
               0  $ANALYZE0 FCN USING MODE 2;
               0  $ANALYZE0 FCD USING MODE 2;
               0  $ANALYZE0 FMM USING MODE 0;
               0  $ANALYZE0 FMMC USING MODE 0;
               0  $ANALYZE0 FSM USING MODE 2;
               0  $ANALYZE0 FTM USING MODE 2;
               0  $ANALYZE0 FSMC USING MODE 2;
               0  $ANALYZE0 FTMC USING MODE 2;
               0
               0  "TOTAL EDEP"
               0  $ANALYZE3 DOSE(NC;NR;1) USING MODE 2;
               0  $ANALYZE1 SCAV(1,1) USING MODE 2;
               0
               0  "Ascat, Aatt"
               0  IF(IFULL.GE.1)[
               1      $ANALYZE3 TDA(1,NC/1,NR/1,1) USING MODE 2;
               1      $ANALYZE1 TTDA(1,1) USING MODE 2;
               1      $ANALYZE3 DOSE(1,NC/1,NR/2,3) USING MODE 0;
               1      $ANALYZE1 SCAV(2,3) USING MODE 0;
               1      ]
               0
               0  "Apn"
               0  IF(IFULL.GE.2)[
               1      $ANALYZE3 TDA(1,NC/1,NR/2,2) USING MODE 2;
               1      $ANALYZE1 TTDA(2,2) USING MODE 2;
               1      $ANALYZE3 DOSE(1,NC/1,NR/4,4) USING MODE 0;
               1      $ANALYZE1 SCAV(4,4) USING MODE 0;
               1      ]
               0
               0  "Afl AND <s>g,w"
               0  IF(IFULL.EQ.3)[
               1      $ANALYZE3 TDA(1,NC/1,NR/3,4) USING MODE 2;
               1      $ANALYZE1 TTDA(3,4) USING MODE 2;
               1      $ANALYZE3 DOSE(1,NC/1,NR/5,ITMAX) USING MODE 0;
               1      $ANALYZE1 SCAV(5,ITMAX) USING MODE 0;
               1      ]
               0
               0  "CONVERT DOSE FROM MEV PER REGION PER BATCH TO GRAYS PER UNIT INCIDENT FLUENCE"
               0  "RECALL 1 MeV = 1.602E-06 erg, 1 rad=100ergs/g, 1 rad=.01 Gys"
               0  "THE UNIT OF DOSE IS GRAYS-CM**2"
               0  "ONLY TOTAL DOSE CATEGORY. THE REST ARE RATIOS"
               0  FMASSC=0.0; "TOTAL CAVITY MASS"
               0  DO IX=1,NR[
               1      DO IC=1,NC[
               2          $GET-IRL(IC,IX);
               2          IF(NTRACK(IRL).EQ.1)[
               3              FMASS=AMASS(IC,IX);
               3              FMASSC=FMASSC+FMASS; "SUM THE CAVITY MASS USED LATER"
               3              IF(FMASS.EQ.0.0)FMASS=1.0; "AVOIDS /0 FOR VACUUM"
               3              IF(DOSE(IC,IX,1).NE.0.0)[
               4                  DOSE(IC,IX,1)=DOSE(IC,IX,1)*1.602E-10/(FMASS*AINFLU);
               4                  ]
               3              TDA(IC,IX,1)=TDA(IC,IX,1)*1.602E-10/(FMASS*AINFLU);
               3              IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
               4                  DO IT=2,4[
               5                      IF(FLURAT = 0.0)[OUTPUT;(' ****FLURAT=0 in divisor****'//);]
               5                      TDA(IC,IX,IT)=TDA(IC,IX,IT)*1.602E-10/(FMASS*AINFLU*FLURAT);
               5                      ]
               4                  ]
               3              "JAN CHANGE: NORMALIZATION IN CASE PARR BEAM, IFULL=3 OPTION"
               3              IF((IFULL.EQ.3).AND.(IPTSRC.EQ.0))[
               4                  DO IT=2,4[
               5                      TDA(IC,IX,IT)=TDA(IC,IX,IT)*1.602E-10/(FMASS*AINFLU);
               5                      ]
               4                  ]
               3              "END OF JAN CHANGE"
               3              TDA(IC,IX,4)=TDA(IC,IX,4)*(RHO(2)/RHO(1));
               3              ]
               2          ]
               1      ]
               0  IF(FMASSC.EQ.0.0)FMASSC=1.0; "AVOIDS /0 FOR VACUUM CAVITY"
               0  SCAV(1)=SCAV(1)*1.602E-10/(FMASSC*AINFLU);
               0  TTDA(1)=TTDA(1)*1.602E-10/(FMASSC*AINFLU);
               0  IF((IFULL.GE.2).AND.(IPTSRC.EQ.1))[
               1      DO IT=2,4[TTDA(IT)=TTDA(IT)*1.602E-10/(FMASSC*AINFLU*FLURAT);]
               1      ]
               0
               0  "JAN CHANGE: NORMALIZATION IN CASE OF PAR BEAM, IFULL=3 OPTION"
               0  IF((IFULL.EQ.3).AND.(IPTSRC.EQ.0))[
               1      DO IT=2,4[TTDA(IT)=TTDA(IT)*1.602E-10/(FMASSC*AINFLU);]
               1      ]
               0  "END OF JAN CHANGE"
               0
               0  TTDA(4)=TTDA(4)*(RHO(2)/RHO(1));
               0
               0  :IGNORE-OTHER-SCORING:
               0
               0  CALL OSUMRY; "PRINT THE OUTPUT SUMRY"
               0
               0  :END-OF-RUN:;
               0
               0  ;"******************************************************************************
               0  "
               0  "                       *** SECTION 4 ***
               0  "
               0  "------------------------------------------------------------------------------
               0  "
               0  "THE CONCLUSION"
               0  "
               0  "------------------------------------------------------------------------------
               0
               0  :END:;
               0  OUTPUT; (//'END OF RUN',9X,' ',$); call egs_fdate(6);
               0  OUTPUT; (//);
               0  write(iout,'(/a,$)') 'END OF RUN          '; call egs_fdate(iout);
               0  write(iout,'(////)');
               0
               0  call egs_finish;
               0
               0  #ifdef HAVE_C_COMPILER;
               0  ;
               0  IF( n_parallel > 0 & ~is_finished ) [
               1      call egs_pjob_finish(n_job);
               1      IF( n_job = 0 ) [
               2          is_finished = .true.;
               2          call egs_combine_runs(combine_results,'.egsdat');
               2          NCASET=NCASEO;  IHSTRY=NCASET;
               2          CALL SRCOTO(WEIGHT);
               2          "ZERO THE CAVITY SUMMARY ARRAY"
               2          DO IT=1,ITMAX[DO IS=1,$STAT[SCAVIS(IT,IS)=0.0;]]
               2          goto :STATS-ANAL:;
               2          ]
               1      ]
               0  #endif;
               0
               0  $CALL_EXIT(0);
               0
               0  "FORTRAN FORMAT STATEMENTS. FORMAT STATEMENT N## IS FIRST USED IN SECTION N."
               0  %I0                                                                            ;
               0  100  FORMAT('1',80A1//'NRCC calculation using CAVSPHnrc(EGSnrc) '$VERSION' ',
               0               /' on '$MACHINE' ',T55,' ',$);
               0  200  FORMAT(//,79('*')/
               0              // ,T20,'EXECUTION INFORMATION AND WARNING MESSAGES'/
               0              // ,79('*')/
               0              //'Using CAVSPHnrc(EGSnrc) '$VERSION' on '$MACHINE' ');
               0  201  FORMAT(/'********* NEW INPUT FILE *********'/);
               0  202  FORMAT(/'********* RESTARTED INPUT FILE ********* '/
               0               ' ',10X,I12,' NEW + ',I12,' OLD HISTORIES'/
               0               ' ',20X,'NEW RN SEEDS=',2(1X,I12)/);
               0  203  FORMAT(/'********* INPUT FILE CREATION ONLY *********'/);
               0  204  FORMAT(/'********* DATA ANALYSIS ONLY *********'/);
               0  205  FORMAT(/'********* RANDOM NUMBERS READ FROM FILE *********'/);
               0  206  FORMAT(/' ********* ANALYZING RESULTS FROM PARALLEL RUNS *******'/);
               0  210  FORMAT(/'********* NOT ENOUGH TIME TO FINISH WITHIN',
               0         ' LIMIT OF',F8.2,' HOURS',I5,' BATCHES USED********'/
               0         ' ',I12,' HISTORIES RUN, ',I12,' HISTORIES ANALYZED'//);
               0  230  FORMAT(/'DESIRED STATISTICAL ACCURACY OBTAINED.'/
               0              ' STATS IN CAVITY= ',F5.2,
               0              ' AFTER ',I2,' BATCHES');
               0  240  FORMAT(/'*********DESIRED STATISTICAL ACCURACY OF ',F5.2,'%',
               0              ' NOT REACHED*********'/
               0              ' STATS IN CAVITY= ',F5.2,' % AFTER ',I2,' BATCHES');
               0  250  FORMAT(/'********* Final random number seeds:',2(1X,I12),' *********');
               0  255  FORMAT(/' FOR PARALLEL RUNS:'/
               0               ' ----------------- '/
               0               ' On ',I5,' machines '/
               0               ' Total cputime =',F8.1,'s (=',F8.2,' hr), cputime/machine =',
               0                F8.1,'s');
               0  260  FORMAT(/'Finished simulations:time elsapsed,CPU',
               0               ',ratio= ',2F8.1,'(=',F5.2,'h)',F8.2);
               0  261  FORMAT(/' Finished: time elapsed this run', F10.1/
               0               '           CPUtime total run    ', F10.1,'(=',F8.2,'hr)'/
               0               '           Ratio elapsed/CPU this run:', F8.3);
               0  280  FORMAT(/'CPUtime/history=',F10.5,'  sec.  Histories/hour=',F12.0);
               0  400  FORMAT(/'End of run',10X,1X////);
               0
               0  END; "END OF MAIN ROUTINE-CAVSPHnrc"
               0  %C80                                                                           ;
               0  %I4                                                                            ;
               0  %Q1                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  "******************************************************************************
               0  "
               0  "
               0  "                               **********
               0  "                               *        *
               0  "                               * AUSGAB *
               0  "                               *        *
               0  "                               **********
               0  "
               0  "
               0  "       AN AUSGAB ROUTINE TO BE USED WITH cavsphnrc.mortran
               0  "
               0  "       THIS ROUTINE SCORES THE DOSE AND OTHER IONISATION CAVITY PARAMETERS
               0  "       IN A FINITE, AZIMUTHALLY SYMMETRIC CYLINDRICAL GEOMETRY WHICH THE
               0  "       USER DEFINES VIA PLANE AND RADIUS COORDINATES. THE USER MUST SPECIFY
               0  "       BOTH THE TARGET GEOMETRY AS WELL AS THE PLANES AND RADII BETWEEN
               0  "       WHICH THE QUANTITIES ARE TO BE SCORED. ALL THE GEOMETRICAL CHECKS FOR
               0  "       CROSSING 'GEOMETRICAL' OR 'DOSE' REGIONS ARE HANDLED BY THE SUBROUTINE
               0  "       HOWFAR.
               0  "
               0  "       FOR IT = 1      THE TOTAL PRIMARY DOSE
               0  "              = 2      THE TOTAL DOSE DOSE LESS THE TOTAL PRIMARY DOSE
               0  "                       (i.e. THE SCATTER FRACTION FOR CALCULATING Ascat)
               0  "              = 3      THE TOTAL PRIMARY UNATTENUATED DOSE LESS THE
               0  "                       TOTAL PRIMARY DOSE (FOR CALCULATING Aatt)
               0  "              = 4      THE TOTAL PRIMARY UNATTENUATED DOSE WITH THE SOURCE
               0  "                       DISTRIBUTION FACTORED OUT LESS THE TOTAL PRIMARY
               0  "                       UNATTENUATED DOSE (FOR CALCULATING Apn)
               0  "              = 5      THE TOTAL PRIMARY UNATTENUATED DOSE TO THE CAVITY
               0  "                       GAS WITH THE SOURCE DISTRIBUTION FACTORED OUT WITH
               0  "                       THE ELECTRON TRANPORT TAKING PLACE IN THE CHAMBER
               0  "                       WITH THE CAVITY FILLED WITH WALL MATERIAL (FOR
               0  "                       CALCULATING Afl AND THE STOPPING POWER RATIO)
               0  "              = 6      THE TOTAL PRIMARY UNATTENUATED DOSE TO THE WALL
               0  "                       MATERIAL WITH THE SOURCE DISTRIBUTION FACTORED OUT WITH
               0  "                       THE ELECTRON TRANPORT TAKING PLACE IN THE CHAMBER
               0  "                       WITH THE CAVITY FILLED WITH WALL MATERIAL (FOR
               0  "                       CALCULATING THE STOPPING POWER RATIO)
               0  "
               0  "
               0  "       VERSION 01      ADAPTED FROM CAVITY(EGS3) AUSGAB      10/87  AFB
               0  "
               0  ;"******************************************************************************
               0  %Q0                                                                            ;
               0  SUBROUTINE AUSGAB(IARG);
               0
               0  $IMPLICIT-NONE;
               0  ;REPLACE {$SCORE-IT-MODE(#,#);} WITH
               0  "        ====================="
               0  {;SCDOSE(IC,IX,{P1})=SCDOSE(IC,IX,{P1})+{P2};}
               0
               0  REAL*8 DEDXC,DEDXM,DELTAC,DELTAM,SRATIO,FTMP;
               0  integer*4 ip;
               0
               0  $INTEGER IRL,IX,IC,IQL,LATCHL,IARG,LELKE,LGLE,IDUMMY;
               0  $REAL WTL,FDUMMY,xsi;
               0  ;COMIN/
               0  ELECIN,EPCONT,GEOM,MEDIA,PHOTIN,RUSROU,SCORE,SOURCE,STACK,USEFUL,USER,
               0  RANDOM,BOUNDS/;
               0  "STACK OVERFLOW CHECK"
               0  MXNP=MAX(MXNP,NP);"KEEP TRACK OF HOW DEEP STACK IS"
               0  IF(NP.GE.$MXSTACK)["STACK AS DEEP AS ALLOWED"
               1      OUTPUT NP,$MXSTACK;(' IN AUSGAB, NP=',I3,' ]= MAXIMUM STACK ALLOWED=',
               1      I3,/1X,80('*')/);STOP;]
               0
               0  "CHECK IF PARTICLE IS LEAVING THE TRANSPORT GEOMETRY"
               0  IRL=IR(NP);  "LOCAL REGION NUMBER"
               0  IF(IRL.EQ.1) RETURN; "OUTSIDE THE CHAMBER"
               0
               0  "OBTAIN FREQUENTLY USED LOCAL VARIABLES"
               0  $GET-IX-IC(IRL);   "LOCAL CONE AND RADIUS NUMBERS"
               0  IQL=IQ(NP);        "LOCAL CHARGE VARIABLE"
               0  WTL=WT(NP);        "LOCAL WEIGHT VARIABLE"
               0  LATCHL=LATCH(NP);  "LATCHL=0 FOR PRIMARIES, 1 OTHERWISE"
               0
               0  IF( use_enhance | n_split > 1 ) [
               1      IF( edep > 0 & wtl > 0 & iarg < 5 & ntrack(irl) = 1 ) [
               2          "If we use cross section enhancement or photon splitting,"
               2          "all energy scoring is done here and the rest of ausgab is ignored  "
               2          "We use the technique proposed by the PENELOPE group for scoring "
               2          "the energy deposition. This results in a much better estimate   "
               2          "of the uncertainty                                              "
               2
               2          ftmp = wtl*edep;
               2          IF( the_case = last_case ) [
               3              " Still the same history scoring into the cavity => update    "
               3              " temporary variables                                         "
               3              IF( latchl ~= 2 ) tmp_dose = tmp_dose + ftmp;
               3              IF( latchl ~= 3 ) tmp_dose1 = tmp_dose1 + ftmp;
               3              ]
               2          ELSE [
               3              " A new history scoring into the cavity. "
               3              last_case = the_case;
               3              cav_dose = cav_dose + tmp_dose;
               3              cav2_dose = cav2_dose + tmp_dose*tmp_dose;
               3              cav_dose1 = cav_dose1 + tmp_dose1;
               3              cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
               3              cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
               3              IF( latchl ~= 2 ) [ tmp_dose = ftmp; ] ELSE [ tmp_dose = 0; ]
               3              IF( latchl ~= 3 ) [ tmp_dose1 = ftmp;] ELSE [ tmp_dose1 = 0; ]
               3              ]
               2          return;
               2          ]
               1      ]
               0
               0  IF( use_enhance ) [ "If we use cross section enhancement, all scoring "
               1      " is done here and the rest of ausgab is ignored  "
               1
               1      IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 | iarg = 29)
               1      [
               2          "Before pair/Compton/photoelectric/Rayleigh/photonuclear event.    "
               2          "As we have increased the photon cross section by a factor of      "
               2          "cs_enhance, we must split the photon into a scattering portion    "
               2          "(1/cs_enhance) and a non-scattering portion (1-1/cs_enhance)      "
               2          "Start with placing an identical photon on the stack               "
               2          np = np + 1;
               2          IF(np + 1 > $MXSTACK) [
               3              OUTPUT;
               3              ( ' Calculation with CS-enhancement: unable to boost stack.'/
               3              ' Stopping.'/ 1x,80('*')/);
               3              stop;
               3              ]
               2          $TRANSFER PROPERTIES TO (np) FROM (np - 1);
               2          e(np)  =  e(np - 1);
               2          u(np)  =  u(np - 1);
               2          v(np)  =  v(np - 1);
               2          w(np)  =  w(np - 1);
               2          iq(np) = iq(np - 1);
               2          IF( latch(np-1)  ~= 2 ) [
               3              " This is either a primary photon that has not yet been attenuated "
               3              " away or a scattered photon. Let's decide what to do with the     "
               3              " unscattered fraction of that photon (which is at np-1)           "
               3              $RANDOMSET xsi;
               3              IF( cs_enhance*xsi < 1 ) [  " The photon doesn't survive. "
               4                  IF( latch(np-1) = 3 ) [ " It is a scattered photon => kill it"
               5                      wt(np-1) = 0; dnear(np-1) = -1;
               5                      ]
               4                  ELSE [ " This is a primary => mark it as attenuated.         "
               5                      " From now on, all descendents of this photon will    "
               5                      " only contribute to the cavity dose with attenuation "
               5                      " and scatter removed                                 "
               5                      latch(np-1) = 2;
               5                      ]
               4                  ]
               3              ]
               2          "Adjust the weight of to be scattered photon"
               2          wt(np) = wt(np)/cs_enhance;
               2          return;
               2          ]
               1
               1
               1      IF( iarg = 18 | iarg = 20 | iarg = 24 | iarg = 30 |
               1      " A Compton/photo-absorption/Rayleigh/photonuclear event just occured"
               1      iarg = 7 | iarg = 13 | iarg = 14 ) [
               2          " A bremas/annihilation event just occured"
               2          " All scattered photons and photons originating in brems/annihilation"
               2          " events contribute to the scattered dose. But because all of them   "
               2          " have a small weight (initial weight/cs_enhance), we will play      "
               2          " Russian Roulette with them, using 1/cs_enhance as a surviving       "
               2          " probability. If they survive, their weight will become equal to the"
               2          " intial photon weight. In addition, we have to set their latch to 3 "
               2          " so that they and rheir descendents only contribute to the scattered"
               2          " dose.                                                              "
               2          $RANDOMSET xsi; xsi = xsi*cs_enhance;
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [
               4                  IF( latch(ip) = 2 ) [ "that's a descendent of a photon that"
               5                      "has been attenuated away => kill it"
               5                      wt(ip) = 0; dnear(ip) = -1;
               5                      ]
               4                  ELSE [
               5                      IF( e(ip) >= pcut(irl) ) [
               6                          IF( xsi < 1 ) [ latch(ip) = 3; wt(ip) = wt(ip)*cs_enhance; ]
               7                              ELSE          [ wt(ip) = 0; dnear(ip) = -1; ]
               6                          ]
               5                      ELSE [ latch(ip) = 3; ]
               5                      " i.e. we don't need the Russian Roulette for photons below"
               5                      " threshold because they will be discarded and their energy"
               5                      " deposited locally anyway                                 "
               5                      ]
               4                  ]
               3              ]
               2          return;
               2          ]
               1      return;
               1      ]
               0
               0  IF( n_split > 1 ) [
               1
               1      IF( iarg = 7 | iarg = 13 | iarg = 14 ) [
               2          IF( iifano = 1 ) [
               3              DO ip=NPold,NP [
               4                  IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
               4                  ]
               3              return;
               3              ]
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [
               4                  $RANDOMSET XSI;
               4                  IF( xsi*n_split > 1) [ wt(ip) = 0; e(ip) = 0; ]
               4                  ELSE [ latch(ip) = 3;  wt(ip) = wt(ip)*n_split; ]
               4                  ]
               3              ]
               2          return;
               2          ]
               1      ]
               0
               0  IF((NTRACK(IRL).EQ.1).AND.(LATCHL.EQ.0))[
               1      "A PRIMARY HAS INTERACTED WITH THE CAVITY"
               1      INEED2=1; "SET FLAG ASKING FOR SECOND PASS"
               1      ]
               0
               0  IF(IARG.EQ.0)["ABOUT TO TRANSPORT A PARTICLE"
               1      IF(IQL.NE.0)[
               2          IF(LATCHL.EQ.0)[ "COUNT PRIMARY CHARGED PARTICLES ONLY"
               3              IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
               4                  IST=IST+1;"COUNT CHARGED PARTICLE STEPS TAKEN"
               4                  IF(NTRACK(IRL).EQ.1) ISTC=ISTC+1;"COUNT STEPS IN CAVITY REGION"
               4                  ]
               3              IF(IPASS.EQ.2)[ "THIRD PASS ONLY"
               4                  ISM=ISM+1;"COUNT CHARGED PARTICLE STEPS TAKEN"
               4                  IF(NTRACK(IRL).EQ.1) ISMC=ISMC+1;"COUNT STEPS IN CAVITY REGION"
               4                  ]
               3              ]
               2          ]
               1      ELSE["PHOTON STEP - PLAY RUSSIAN ROULETTE?"
               2          IF(RUSROU.AND.(W(NP).GT.0.0))["YES, PLAY IF CROSSES RRZ "
               3              IF((Z(NP).LE.RRZ).AND.(Z(NP)+USTEP*W(NP).GE.RRZ))["CROSSES"
               4                  $RANDOMSET XSI;
               4                  IF(XSI.LT.RRCUT)[
               5                      "PARTICLE SURVIVES"
               5                      WT(NP)=WTL/RRCUT;
               5                      ]
               4                  ELSE["DISCARD PARTICLE ON NEXT CALL TO HOWFAR"
               5                      WT(NP)=0.0;
               5                      ]
               4                  ] "END TEST IF CROSSES RUSSIAN ROULETTE PLANE"
               3              ] "END TEST FOR PLAYING RUSSIAN ROULETTE"
               2          ] "END TEST FOR PHOTON STEP"
               1      ] "END TEST FOR IARG = 0"
               0
               0  IF(IWATCH.GT.0) [CALL WATCH(IARG,IWATCH); "SIGNAL WATCH ROUTINE IF ACTIVE"]
               0
               0  IF (ifano = 1)
               0  [
               1      IF (iarg = 15 | iarg = 17 | iarg = 19 | iarg = 23 | iarg = 29)
               1      [
               2          "Just before pair/Compton/photoelectric/Rayleigh/photonuclear event"
               2          np = np + 1; "Boost the stack"
               2          IF(np + 1 > $MXSTACK)
               2          [
               3              OUTPUT;
               3              (
               3              ' Fano calculation unable to boost stack.'/
               3              ' Stopping.'/
               3              1x,80('*')/
               3              );
               3              stop;
               3              ]
               2          "Create an identical photon"
               2          $TRANSFER PROPERTIES TO (np) FROM (np - 1);
               2          e(np)  =  e(np - 1);
               2          u(np)  =  u(np - 1);
               2          v(np)  =  v(np - 1);
               2          w(np)  =  w(np - 1);
               2          iq(np) = iq(np - 1);
               2          return;
               2          ]
               1
               1      "Throw away any scattered photons from the primary interaction site."
               1      " Now there is a stack pointer NPold which points to the particle "
               1      " befor the last discrete interaction. This change was necessary "
               1      " for the implementation of atomic relaxations. So, check all particles"
               1      " between NPold and NP and discard photons "
               1      "IF ( (iarg = 18 & NP > NPold)" " Compton has occured"
               1      IF (  iarg = 18               " Compton has occured"
               1      | iarg = 20               " After photo-absorption "
               1      | iarg = 24               " After Rayleigh "
               1      | iarg = 30               " After photonuclear "
               1      | iarg = 7                " After brems "
               1      | iarg = 13               " After annihilation "
               1      | iarg = 14)              " After annihilation at rest "
               1      [
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [ wt(ip) = 0; e(ip) = 0; ]
               3              ]
               2          ]
               1      ]
               0
               0  IF (ifano = 2)
               0  [
               1      IF (  iarg = 16               " After pair production "
               1      | iarg = 18               " After Compton "
               1      | iarg = 20)              " After photo absorption "
               1      [
               2          IF ( NTRACK(ir(np)) = 0)
               2          [
               3              DO ip=NPold,NP
               3              [
               4                  IF( iq(ip) ~= 0 ) [ wt(ip) = 0; e(ip) = 0; ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0
               0  "SCORE THE ENERGY AS REQUIRED FOR THE DIFFERENT MODES"
               0  "****************************************************"
               0
               0  IF((EDEP.NE.0.0).AND.(WTL.GT.0.0).AND.(IARG.LT.5).AND.(NTRACK(IRL).EQ.1))[
               1      "ENERGY HAS BEEN DEPOSITED IN THE CAVITY REGION"
               1
               1      "SCORE PRIMARY AND SECONDARY ENERGY DEPOSITED"
               1      FTMP=WT(NP)*EDEP;
               1
               1      "***************************************************************************"
               1      "                                                                           "
               1      " Implementation of a history by history scoring scheme for the cavity dose "
               1      " taken from the splitting implementation, January, EMH, 2002               "
               1      "                                                                           "
               1      "         tmp_dose  ==> total dose                                          "
               1      "         tmp_dose1 ==> primary dose multiplied by unweighting factor       "
               1      "                       (i.e., corrected for att. an scatt.)                "
               1      "                                                                           "
               1      "         expmfp = exp(di) - 1 (see macro $SELECT-PHOTON-MFP)               "
               1      "                                                                           "
               1      "***************************************************************************"
               1      IF( the_case = last_case ) [
               2          " Still the same history scoring into the cavity => update    "
               2          " temporary variables                                         "
               2          tmp_dose = tmp_dose + ftmp;
               2          IF( latchl = 0 ) [
               3              tmp_dose0 = tmp_dose0 + ftmp;
               3              tmp_dose1 = tmp_dose1 + ftmp*(expmfp+1);
               3              ]
               2          ELSE [
               3              tmp_dose2 = tmp_dose2 + ftmp;
               3              ]
               2          ]
               1      ELSE [
               2          " A new history scoring into the cavity. "
               2          last_case = the_case;
               2
               2          cav_case = cav_case + 1;
               2
               2          cav_dose  = cav_dose + tmp_dose;
               2          cav2_dose = cav2_dose + tmp_dose*tmp_dose;
               2
               2          cav_dose0  = cav_dose0 + tmp_dose0;
               2          cav2_dose0 = cav2_dose0 + tmp_dose0*tmp_dose0;
               2
               2          cav_dose1  = cav_dose1 + tmp_dose1;
               2          cav2_dose1 = cav2_dose1 + tmp_dose1*tmp_dose1;
               2
               2          cav_dose2  = cav_dose2 + tmp_dose2;
               2          cav2_dose2 = cav2_dose2 + tmp_dose2*tmp_dose2;
               2
               2          cav_dosec = cav_dosec + tmp_dose*tmp_dose1;
               2          cav_dosec01 = cav_dosec01 + tmp_dose0*tmp_dose1;
               2          cav_dosec02 = cav_dosec02 + tmp_dose0*tmp_dose2;
               2
               2          tmp_dose = ftmp;
               2
               2          IF( latchl = 0 ) [
               3              tmp_dose0 = ftmp ;
               3              tmp_dose1 = ftmp*(expmfp+1) ;
               3              tmp_dose2 = 0.0;
               3              ]
               2          ELSE [
               3              tmp_dose0 = 0.0;
               3              tmp_dose1 = 0.0;
               3              tmp_dose2 = ftmp;
               3              ]
               2          ]
               1
               1      "*************************************************************************"
               1      " CONTINUE WITH USUAL SCORING SCHEME ...                                  "
               1      "*************************************************************************"
               1      IF(IFULL.LE.1)[ "NO CORRELATIONS"
               2          "SIGNAL THE MAIN ROUTINE THAT ENERGY HAS BEEN DEPOSITED IN THE CAVITY"
               2          IDECAV=1;
               2          ]
               1      ELSEIF(IFULL.EQ.3)[ "???CORRELATED RUN"
               2          IF(IDECAV.EQ.0)[ "NOTHING HAPPENED YET"
               3              IF(LATCHL.EQ.0)[IDECAV=1; "PRIMARY DEPOSTION"]
               3              ELSE[IDECAV=2; "SECONDARY DEPOSITION"]
               3              ]
               2          ELSEIF(IDECAV.EQ.1)[ "PRIMARY DEPOSTITION OCCURED PREVIOUSLY"
               3              IF(LATCHL.GT.0) IDECAV=3; "PRIMARY AND SECONDARY DEPOSTION"
               3              ]
               2          ELSEIF(IDECAV.EQ.2)[ "SECONDARY DEPOSTITION OCCURED PREVIOUSLY"
               3              IF(LATCHL.EQ.0) IDECAV=3; "PRIMARY AND SECONDARY DEPOSTION"
               3              ]
               2          ]
               1
               1      "SCORE PRIMARY AND SECONDARY ENERGY DEPOSITED"
               1      "FTMP=WT(NP)*EDEP;"
               1
               1      IF(LATCHL.EQ.0)[ "SCORE PRIMARY DOSE"
               2
               2          IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
               3              $SCORE-IT-MODE(1,FTMP);
               3              IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
               4                  "JAN CHANGE Just for debugging"
               4                  "IF (ICASE.EQ.7)["
               4                  "end of change"
               4                  OUTPUT FTMP,IRL,IARG;
               4                  (' ***PRIMARY DOSE SCORED = ',E14.7,' MeV. IRL= ',I3,
               4                  ' IARG= ',I3);
               4                  ]
               3              ]
               2
               2          IF(IFULL.GE.1)[
               3              "ONLY DO THIS SECTION FOR THE FULL CALCULATION.                    "
               3              "SCORE TOTAL ENERGY UNWEIGHTED BY PHOTON SURVIVAL PROBABILITY-1    "
               3              "FOR 1/Aatt-1. EXPMFP IS EXP(# OF MEAN FREE PATHS TRAVERSED)-1     "
               3              "USED TO UNWEIGHT THE ENERGY. EXPMFP IS CALCULATED IN PHOTON VIA   "
               3              "A MACRO DEFINED IN CAVSPHnrc."
               3              IF(IPASS.EQ.0)[ "FIRST PASS ONLY"
               4                  $SCORE-IT-MODE(3,FTMP*EXPMFP);
               4                  ]
               3              FTMP=FTMP*(1.+EXPMFP);
               3              IF((IPASS.EQ.0).AND.(IWATCH.GT.1).AND.(IWATCH.NE.4))[
               4                  OUTPUT FTMP,IRL,IARG;
               4                  (' ***PRIMARY UNATTENUATED DOSE SCORED = ',
               4                  E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
               4                  ]
               3              ] "END OF IFULL>=1 PART"
               2          IF((IFULL.GE.2).AND.(IPTSRC.EQ.1).AND.(IPASS.EQ.1))[
               3              "ON THE SECOND PASS ONLY IF A POINT SOURCE"
               3              $SCORE-IT-MODE(4,FTMP);
               3              IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
               4                  OUTPUT FTMP,IRL,IARG;
               4                  (' ***1st CORRELATION PRIMARY DOSE SCORED = ',
               4                  E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
               4                  ]
               3              ]
               2          IF((IFULL.EQ.3).AND.(IPASS.EQ.2))[ "MATERIAL CORRELATION SCORING"
               3              "CALCULATE EDEP TO CAVITY MATERIAL "
               3              "NOTE THAT FOR IARG=0, EKE AND ELKE ARE ASSUMED TO BE "
               3              "EVALUATED AT THE STEP MID-POINT. THIS IS EFFECTED BY THE"
               3              "$DEDX-RE-EVALUATION MACRO WHICH IS ALWAYS IN FORCE WHEN "
               3              "IEDEP IS 0 AND THE NRCCMACP MACROS ARE LINKED IN. THIS IS"
               3              "THE DEFAULT FOR ALL PRESTA CODES. TRACK ENDS ARE EVALUATED"
               3              " a la Nahum.                                              "
               3              MEDIUM=2;     "CAVITY MATERIAL"
               3              $SET INTERVAL ELKE,EKE; "PREPARE TO INTERPOLATE IN TABLES"
               3              IF(IQL.EQ.-1)[ "ELECTRON"
               4                  $EVALUATE DEDXC USING EDEDX(ELKE);
               4                  MEDIUM=1; "RESET TO WALL MATERIAL"
               4                  $EVALUATE DEDXM USING EDEDX(ELKE);
               4                  SRATIO=DEDXC/DEDXM;
               4                  ]
               3              ELSEIF(IQL.EQ.0)[ "PHOTON TRACK END"
               4                  $SET INTERVAL GLE,GE;
               4                  $EVALUATE DELTAC USING GMFP(GLE);
               4                  MEDIUM=1; "RESET TO WALL MATERIAL"
               4                  $EVALUATE DELTAM USING GMFP(GLE);
               4                  SRATIO=DELTAM/DELTAC;
               4                  ]
               3              ELSE[ "POSITRON"
               4                  $EVALUATE DEDXC USING PDEDX(ELKE);
               4                  MEDIUM=1; "RESET TO WALL MATERIAL"
               4                  $EVALUATE DEDXM USING PDEDX(ELKE);
               4                  SRATIO=DEDXC/DEDXM;
               4                  ]
               3
               3              $SCORE-IT-MODE(5,FTMP*SRATIO); "FACTOR FOR Afl and <s>g,w"
               3              $SCORE-IT-MODE(6,FTMP);        "FACTOR FOR <s>g,w"
               3              IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
               4                  OUTPUT FTMP*SRATIO,IRL,IARG;
               4                  (' ***PRIMARY DOSE SCORED TO GAS IN FILLED CAVITY= ',
               4                  E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
               4                  OUTPUT FTMP,IRL,IARG;
               4                  (' ***PRIMARY DOSE SCORED TO FILLED CAVITY= ',
               4                  E14.7,' MeV. IRL= ',I3,' IARG= ',I3);
               4                  ]
               3              ]  "END OF CORRELATION SCORING"
               2          ] "END OF PRIMARIES SCORING"
               1
               1      ELSEIF(IPASS.EQ.0)[ "SCORE SECONDARY DOSE ON FIRST PASS"
               2          $SCORE-IT-MODE(2,FTMP);
               2          IF((IWATCH.GT.1).AND.(IWATCH.NE.4))[
               3              OUTPUT FTMP,IRL,IARG;
               3              (' ***SECONDARY DOSE SCORED = ',E14.7,' MeV. IRL= ',I3,
               3              ' IARG= ',I3);
               3              ]
               2          ]
               1
               1      ] "END OF ENERGY DEPOSITED IN THE CAVITY"
               0
               0  "SET FLAG FOR SECONDARY INTERACTIONS"
               0  "***********************************"
               0
               0  IF((IFULL.GT.0).AND.(IARG.GT.5).AND.(LATCHL.EQ.0))
               0  [
               1      "ONLY IF PRIMARY PARTICLES HAVE INTERACTED DISCRETELY                 "
               1      "IF A SECONDARY PARTICLE IS CREATED ON THE SECOND PASS, GIVE IT A ZERO"
               1      "WEIGHT SO THAT HOWFAR WILL DISCARD IT.                               "
               1
               1      IF( iarg = 7 ) [  "brem has occured"
               2
               2          IF( iql = 0 ) [ $EXCHANGE-STACK(NP,NP-1); ]
               2          latch(np-1) = 1;  "Flag the photon as a secondary"
               2          IF( ipass >= 1 ) [ wt(np-1) = 0; ] "To save time in correlation runs"
               2
               2          ]
               1      ELSE IF( iarg = 18 ) [ "Compton has occured, with binding effects"
               2          "taken into account, 0, 1, or more particles"
               2          "may have resulted"
               2
               2          "IF( NP > NPold ) [" "Secondaries were produced. We will flag the"
               2          "photons but not exchange them on the stack"
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 ) [
               4                  latch(ip) = 1;
               4                  IF( ipass >=1 ) [ wt(ip) = 0; ] "To save time"
               4                  ]
               3              ]
               2          "]"
               2          " NP = NPold means the interactiopn has been rejected and thus "
               2          " the emerging (unscattered) photon  is still a primary "
               2          ]
               1      ELSE IF( iarg = 9 ) [ "Moller has occured. For now there is only"
               2          "one secondary. When impact ionization is implemented"
               2          "the following should be changed"
               2          IF( e(np) < e(np-1) ) [ $EXCHANGE-STACK(NP,NP-1); ]
               2          ]
               1      ELSE IF( iarg = 13 | iarg = 14 ) ["Annihilation, flag the photons"
               2          latch(np)   = 1;
               2          latch(np-1) = 1;
               2          IF( ipass >= 1 ) [ wt(np) = 0; wt(np-1) = 0; ]
               2          ]
               1      ELSE IF (iarg = 20)
               1      [
               2          DO ip=NPold,NP [
               3              IF( iq(ip) = 0 )
               3              [
               4                  latch(ip) = 1;
               4                  IF( ipass >= 1 ) [ wt(ip) = 0; e(ip) = 0; ]
               4                  ]
               3              ]
               2          ]
               1      ELSE IF( iarg = 24 ) [
               2          latch(np) = 1;
               2          IF( ipass >= 1 ) [ wt(np) = 0; ]
               2          ]
               1
               1      ]
               0
               0  RETURN;
               0
               0  END;  "END OF SUBROUTINE AUSGAB"
               0  "%U11   PICK UP ENSRC.MOR FROM THE HENHOUSE ON UNIT 11"
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  "*****************************************************************************
               0  "
               0  "
               0  "                       ************
               0  "                       *          *
               0  "                       * GRID.MOR *
               0  "                       *          *
               0  "                       ************
               0  "
               0  "
               0  "       A ROUTINE TO DETERMINE WHETHER OR NOT A GRID TYPE OUTPUT WILL
               0  "       FIT ON A SINGLE PAGE WITH A VARIETY OF DIFFERENT CHOICES FOR
               0  "       THE NUMBER OF CHARACTERS/INCH AND LINES/INCH
               0  "
               0  "       VARIABLES
               0  "       =========
               0  "
               0  "       GRIDWD  THE WIDTH OF THE ENTIRE OUTPUT GRID IN CHARACTERS
               0  "       GRIDHT  THE HEIGHT OF THE ENTIRE OUTPUT IN LINES
               0  "       MXLP11  THE MAXIMUM NUMBER OF LINES ALLOWED ON THE FIRST PAGE
               0  "       MXLP12  THE MAXIMUM NUMBER OF LINES ON SUCESSIVE PAGES
               0  "                ABOVE TWO ARE LINES PER PAGE FOR 6 OR 8 LPI ?  D.R.
               0  "
               0  "       VARIABLES SET WITHIN ROUTINE AND RETURNED
               0  "       =========================================
               0  "
               0  "       ICHPIN  CHARACTERS/INCH
               0  "       ILPIN   LINES/INCH
               0  "       FITS    TRUE IF WILL FIT ON A SINGLE PAGE ELSE FALSE
               0  "               IF FALSE, ICHPIN=16 AND ILPIN=6 ARE SET
               0  "
               0  "       VERSION 01      6/84  E.F.
               0  "               02      9/85  D.R. HANDLE CASE GRIDWD>132
               0  "
               0  "****************************************************************************
               0
               0  SUBROUTINE GRID(GRIDWD,GRIDHT,MXLP11,MXLP12,ICHPIN,ILPIN,FITS);
               0
               0  LOGICAL FITS;
               0  INTEGER GRIDWD,GRIDHT,ICHPIN,ILPIN;
               0
               0  FITS=.TRUE.; "ASSUME IT FITS"
               0
               0  IF(GRIDWD.LE.96)[        ICHPIN=12;    "12 VERTICAL LINES PER INCH"]
               0  ELSEIF(GRIDWD.LE.105)[   ICHPIN=13;    "13 VERTICAL LINES PER INCH"]
               0  ELSEIF(GRIDWD.LE.132)[   ICHPIN=16;    "16 VERTICAL LINES PER INCH"]
               0  ELSE[                    FITS=.FALSE.; "DOES NOT FIT, TOO WIDE"]
               0
               0  IF(GRIDHT.LE.MXLP11)[    ILPIN=6;      "6 HORIZONTAL LINES PER INCH"]
               0  ELSEIF(GRIDHT.LT.MXLP12)[ILPIN=8;      "8 HORIZONTAL LINES PER INCH"]
               0  ELSE[                    FITS=.FALSE.; "DOES NOT FIT, TOO LONG"]
               0
               0  RETURN;
               0  END;"END OF SUBROUTINE GRID"
               0
               0  %Q1                                                                            ;
               0  %C80                                                                           ;
               0  %I2                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  ;"******************************************************************************
               0  "
               0  "                               **********
               0  "                               *        *
               0  "                               * HOWFAR *
               0  "                               *        *
               0  "                               **********
               0  "
               0  "       A GENERAL PURPOSE SPHERICAL GEOMETRY ROUTINE FOR USE WITH THE EGS3
               0  "       CODE SYSTEM ADAPTED FOR USE WITH CAVSPHnrc.
               0  "
               0  "       FOR PARTICLE NP ON THE STACK IN REGION IR(NP), THIS ROUTINE
               0  "       DETERMINES IF THE PARTICLE CAN GO A DISTANCE USTEP WITHOUT CHANGING
               0  "       ZONES. IF USTEP CAUSES A ZONE CROSSING, IT IS REDUCED TO PLACE IT ON
               0  "       THE BOUNDRY AND IRNEW IS SET TO THE ZONE NUMBER ON THE FAR SIDE OF
               0  "       THE BOUNDARY. IF IR(NP) IS 1 THEN THE PARTICLE HAS ESCAPED THE REGION
               0  "       OF INTEREST AND THE HISTORY IS TERMINATED.(IDISC IS SET TO 1.)
               0  "
               0  "
               0  "
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  ;"
               0  "OUTEND =       .TRUE.  =>      PARTICLE MAY TRANSMIT OR BACKSCATTER OUT ENDS
               0  "       =       .FALSE. =>      PARTICLE STAYS WITHIN THE END BOUNDARIES
               0  "OUTSID =       .TRUE.  =>      PARTICLE MAY TRANSMIT OUT THE SIDES
               0  "       =       .FALSE. =>      PARTICLE STAYS WITHIN THE SIDE BOUNDARY
               0  "IRL    =       STARTING REGION NUMBER THE PARTICLE IS IN
               0  "IC     =       STARTING CONICAL ZONE NUMBER THE PARTICLE IS IN.
               0  "               THE PARTICLE IS BETWEEN ALPHA(IC) AND ALPHA(IC+1).
               0  "IX     =       STARTING SPHERICAL ZONE NUMBER THE PARTICLE IS IN.
               0  "               THE PARTICLE IS BETWEEN RSPH(IX-1) AND RSPH(IX).
               0  "
               0  "       COMMON/GEOM/
               0  "               ALPHA(IC)       Z VALUES OF CONES
               0  "                               1<=IC<=NC+1
               0  "               RSPH(IRR)       RADII OF SPHERES
               0  "                               1<=IRR<=NR
               0  "               RSPH2(IRR)      =RSPH(IRR)**2
               0  "               NC              # CONICAL GEOMETRICAL ZONES (NCONE+1)
               0  "                               ZONE(I) IS BETWEEN ALPHA(I) AND ALPHA(I+1)
               0  "               NR              # SPHERICAL GEOMETRICAL ZONES
               0  "                               ZONE(I) IS BETWEEN RSPH(I-1) AND RSPH(I)
               0  "               NREG            TOTAL # GEOMETRICAL ZONES =NR*NC +1
               0  "                                       +1 FOR VACUUM ENVELOPE
1              0  %E     "cavsphnrc.mortran"
               0  "       DEFINITIONS OF REGION NUMBER, CONICAL ZONE, SPHERICAL ZONE
               0  "       ===========================================================
               0  "               Z AXIS RUNS ACROSS PAGE SHOWN AS .......
               0  "
               0  "
               0  "                                       1
               0  "
               0  "
               0  "       --------------------------------------------------------- RSPH(NR)
               0  "       |(NR-1) |(NR-1) |(NR-1) |    . . . .    | NR*NC | NR*NC |    IX=NR
               0  "       | *NC+2 | *NC+3 | *NC+4 |               |       |   +1  |
               0  "       --------------------------------------------------------- RSPH(NR-1)
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       --------------------------------------------------------- RSPH(2)
               0  "       |  NC+2 |  NC+3 |  NC+4 |    . . . .    |  2NC  | 2NC+1 |    IX=2
               0  "       --------------------------------------------------------- RSPH(1)
               0  "..1....|...2...|...3...|...4...|...............|...NC..|..NC+1.|....IX=1..1..
               0  ;"      ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       ---------------------------------------------------------
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       |   .   |   .   |   .   |               |   .   |   .   |
               0  "       ---------------------------------------------------------
               0  "       |       |       |       |    . . . .    |       |       |
               0  "       |       |       |       |               |       |       |
               0  "       ---------------------------------------------------------
               0  "         IC=1    IC=2    IC=3                   IC=NC-1  IC=NC
               0  "
               0  "                                       1
               0  "
               0  "
               0  "
               0  "       VERSION 1       ADAPTED FROM CAVITY(EGS3) HOWFAR      10/87  AFB
               0  "                       THE SUBROUTINE CALLS TO CONES AND
               0  "                       SPHERE HAVE BEEN REPLACED BY MACROS
               0  "                       TO SPEED THINGS UP
               0  "
               0  "
               0  "******************************************************************************
               0  "
               0  ;
1              0  %E     "cavsphnrc.mortran"
               0  "THE MACRO REPLACING THE CALL TO SPHERE
               0  "*****************************************************************************
               0  "
               0  "                               ***********
               0  "                               *         *
               0  "                               * $SPHERE *
               0  "                               *         *
               0  "                               ***********
               0  "
               0  "MACRO TO BE CALLED BY SUBROUTINE HOWFAR IN THE EGS CODE SYSTEM
               0  "
               0  "FOR A PARTICLE TRAVELLING INSIDE TWO CONCENTRIC, INFINITE, RIGHT SPHERES,
               0  "THIS SUBROUTINE DETERMINES THE MINIMUM DISTANCE IT MUST GO TO HIT A SPHERE.
               0  "THE SPHERES ARE ASSUMED TO BE CENTERED AT THE ORIGIN.
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  "
               0  "{P1} = IX    = THE NUMBER OF THE OUTER SPHERE
               0  "{P2} = IHITS = 1 => PARTICLE HITS THE OUTER SURFACE
               0  "             = 0 => PARTICLE MISSES THE SURFACES
               0  "             =-1 => PARTICLE HITS THE INNER SURFACE
               0  "{P3} = TSPH  = DISTANCE TO SURFACE IF IT HITS
               0  "RSPH2(IX)    = RADIUS**2 OF SPHERE
               0  "
               0  "FOR PARTICLES NEAR THE SURFACE, A FIRST ORDER APPROXIMATION IS MADE
               0  "FOR EXPRESSIONS LIKE X-SQRT(X**2+EPSILON), WHICH SOMETIMES SETS TSPH=0.
               0  "
               0  "MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
               0  "                                ADAPTED FROM SCASPH (EGS3)
               0  "
               0  "******************************************************************************
               0  "
               0  ;
               0  REPLACE {$SPHERE(#,#,#);} WITH {
            {  0  B=UL*XL+VL*YL+WL*ZL;"projection of particle radio vector"
            {  0  B2=B*B;             "on particle direction"
            {  0  C=XL*XL+YL*YL+ZL*ZL;"distance of particle to origin"
            {  0  :START-SPHERE:;
            {  0  IF({P1}.NE.1)["not inner most sphere"
            {  0  CIN=C-RSPH2({P1}-1);
            {  0  IF(CIN.LT.0.0)["distance to particle smaller than inner radius"
            {  0  IRL=IRL-NC;"reset everything ..."
            {  0  IR(NP)=IRL;"reset to the corresponding zone"
            {  0  {P1}={P1}-1;"reset to correspponding spheres"
            {  0  GEOBUG=1;   "signal a bug"
            {  0  GOTO :START-SPHERE:;"try again"
            {  0  ]
            {  0  IF(B2.LT.CIN)  [{P2}=0;]
            {  0  ELSEIF(B.GE.0.)[{P2}=0;]
            {  0  ELSE["B is negative"
            {  0  {P2}=-1;
            {  0  TEST=CIN/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
            {  0  ELSEIF(TEST.GE.1.)    [BS=B;                   ]
            {  0  ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
            {  0  "{P3}=-CIN/BS; since B is < 0.0"
            {  0  IF (BS.NE.0.0)[
            {  0  {P3}=-CIN/BS;
            {  0  ]
            {  0  ELSEIF (BS.EQ.0.0)[
            {  0  write(6,*) ' exception caught in sphere macro';
            {  0  write(6,*) ' BS= ', BS;
            {  0  stop;
            {  0  ]
            {  0  ELSE [
            {  0  write(6,*) 'BS is undefined!!! BS= ', BS;
            {  0  write(6,*) 'TEST=', TEST, ' B2=', B2, ' COUT=',CIN;
            {  0  stop;
            {  0  ]
            {  0  GOTO :END-SPHERE:;
            {  0  ]
            {  0  ]
            {  0  COUT=C-RSPH2({P1});
            {  0  IF(COUT.GT.0.0)["distance to particle larger than outer radius"
            {  0  IRL=IRL+NC;"reset everything ..."
            {  0  IR(NP)=IRL;"update zone"
            {  0  {P1}={P1}+1;""
            {  0  GEOBUG=1;
            {  0  GOTO :START-SPHERE:;
            {  0  ]
            {  0  {P2}=1;
            {  0  IF(B.EQ.0.)[{P3}=SQRT(-COUT);]
            {  0  ELSE[
            {  0  TEST=COUT/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST); ]
            {  0  ELSEIF(TEST.GE.1.)    [BS=B;                   ]
            {  0  ELSE                  [BS=B*(1.+SQRT(1.-TEST));]
            {  0  IF(B.LE.0.)[{P3}=-BS;]
            {  0  ELSE[
            {  0  IF ((BS.NE.0.0))[
            {  0  {P3}=-COUT/BS;
            {  0  ]
            {  0  ELSEIF (BS.EQ.0.0)[
            {  0  write(6,*) ' exception caught in sphere macro';
            {  0  write(6,*) ' BS= ', BS;
            {  0  ]
            {  0  ELSE [
            {  0  write(6,*) 'BS is undefined!!! BS= ', BS;
            {  0  write(6,*) 'TEST=', TEST, ' B2=', B2, ' COUT=',COUT;
            {  0  stop;
            {  0  ]
            {  0
            {  0  ]
            {  0  ]
            {  0  :END-SPHERE:;
            {  0  }
               0
               0  ;
               0  "THE MACRO REPLACING THE CALL TO CONES
               0  "******************************************************************************
               0  "
               0  "                               **********
               0  "                               *        *
               0  "                               * $CONES *
               0  "                               *        *
               0  "                               **********
               0  "
               0  "PROGRAM TO BE CALLED BY HOWFAR IN THE EGS CODE SYSTEM
               0  "
               0  "FOR A PARTICLE TRAVELLING INSIDE TWO CONES WITH AXES
               0  "ALIGNED ALONG THE Z-AXIS, THIS ROUTINE CALCULATES THE STRAIGHT LINES DISTANCE
               0  "IT MUST GO TO HIT ONE OF THE CONES
               0  "
               0  "       SOME VARIABLES
               0  "       ==============
               0  "
               0  "{P1} = IC    = THE CONE NUMBER OF THE REGION THE PARTICLE IS IN
               0  "{P2} = IHITC = 1  => PARTICLE HITS THE OUTER CONE
               0  "             = 0  => PARTICLE MISSES BOTH CONES
               0  "             = -1 => PARTICLE HITS THE INNER CONE
               0  "{P3} = TCONE = DISTANCE TO THE CONE THAT IT HITS
               0  "TANAL2(IX)   = TANGENT**2 OF CONE OPENING ANGLE
               0  "
               0  "MACRO VERSION 1             A.F.BIELAJEW NRCC             88/03
               0  "                                ADAPTED FROM SCASPH (EGS3)
               0  "
               0  "******************************************************************************
               0  "
               0  "------------------------------------------------------------------------------"
               0  "                                                                              "
               0  "   macro below replaces GOTO statements between IF-BLOCKS avoiding compiler   "
               0  "   warnings.                                                                  "
               0  "                                                                              "
               0  " {P1} => as above, cone number of the region the particle is in               "
               0  " {P2} => +/- depending whether region number is to be increased or decreased  "
               0  "                                                          EMH, June 5, 2002   "
               0  "------------------------------------------------------------------------------"
               0  ;
               0  REPLACE {$RESET REGION # #;} WITH {;
            {  0  IRL = IRL {P2} 1;
            {  0  IR(NP) = IRL;
            {  0  {P1} = {P1} {P2} 1;
            {  0  GEOBUG = 1;
            {  0  GOTO :START-CONE:;
            {  0  }
               0
               0  ;
               0  REPLACE {$CONES(#,#,#);} WITH {;
            {  0  :START-CONE:;
            {  0  IHITCI=0;IHITCO=0;
            {  0  IF({P1}.EQ.NPLAN2)[
            {  0  IF(ZL.GT.0.)[$RESET REGION {P1} -;] "GOTO :BUG1:;"
            {  0  ELSEIF(WL.LE.0.)[;]
            {  0  ELSE[IHITCI=-1;TCONEI=-ZL/WL;]
            {  0  ]
            {  0  ELSEIF({P1}.NE.1)[
            {  0  TANA2=TANAL2({P1}-1);
            {  0  A=UL*UL+VL*VL-TANA2*WL*WL;
            {  0  B=UL*XL+VL*YL-TANA2*WL*ZL;
            {  0  C=XL*XL+YL*YL-TANA2*ZL*ZL;
            {  0  AC=A*C;B2=B*B;
            {  0  IF(C.GE.0)[
            {  0  IF(ZL.LT.0.0)[
            {  0  IF({P1}.LT.NPLAN2)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
            {  0  $RESET REGION {P1} -;
            {  0  ":BUG1:;"
            {  0  "IRL=IRL-1;"
            {  0  "IR(NP)=IRL;"
            {  0  "{P1}={P1}-1;"
            {  0  "GEOBUG=1;"
            {  0  "GOTO :START-CONE:;"
            {  0  ]
            {  0  IF(B2.LT.AC)[;]
            {  0  ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
            {  0  ELSE[
            {  0  IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            {  0  ELSE[TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  IF(B.GT.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            {  0  ]
            {  0  TEST=TANALP({P1}-1)*(ZL+WL*TCONEI);
            {  0  IF(TEST.LT.0.)[;]ELSE[IHITCI=-1;]
            {  0  ]
            {  0  ]
            {  0  ELSEIF(TANALP({P1}-1)*ZL.GE.0.)[
            {  0  IF(ZL.GT.0.0)[$RESET REGION {P1} -;]"GOTO :BUG1:"
            {  0  IF((A.LE.0.).AND.(B.LE.0.))[;]
            {  0  ELSE[
            {  0  IF(B.EQ.0.)[TCONEI=SQRT(-C/A);]
            {  0  ELSE[TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  IF(B.LE.0.)[TCONEI=-BS/A;]ELSE[TCONEI=-C/BS;]
            {  0  ]
            {  0  IHITCI=-1;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  GOTO :SKIP-THIS:;
            {  0  IF((A.LT.0.).AND.(B.GT.0.))[
            {  0  TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  TCONEI=-BS/A;
            {  0  IHITCI=-1;
            {  0  ]
            {  0  ELSE[;]
            {  0  :SKIP-THIS:;
            {  0  ]
            {  0  ]
            {  0  IF({P1}.EQ.NPLAN1)[
            {  0  IF(ZL.LT.0.)[$RESET REGION {P1} +;]"GOTO :BUG4:;"
            {  0  ELSEIF(WL.GE.0.)[;]
            {  0  ELSE[IHITCO=1;TCONEO=-ZL/WL;]
            {  0  ]
            {  0  ELSEIF({P1}.NE.NC)[
            {  0  TANA2=TANAL2({P1});
            {  0  A=UL*UL+VL*VL-TANA2*WL*WL;
            {  0  B=UL*XL+VL*YL-TANA2*WL*ZL;
            {  0  C=XL*XL+YL*YL-TANA2*ZL*ZL;
            {  0  AC=A*C;B2=B*B;
            {  0  IF(C.GE.0)[
            {  0  IF(ZL.GT.0.0)[
            {  0  IF({P1}.GT.NPLAN1)[$RESET REGION {P1} -;]"GOTO :BUG1:"
            {  0  $RESET REGION {P1} +;"GOTO :BUG4:;"
            {  0  ]
            {  0  IF(B2.LT.AC)[;]
            {  0  ELSEIF((A.GE.0.).AND.(B.GE.0.))[;]
            {  0  ELSE[
            {  0  IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            {  0  ELSE[TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  IF(B.GT.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            {  0  ]
            {  0  TEST=TANALP({P1})*(ZL+WL*TCONEO);
            {  0  IF(TEST.LT.0.)[;]ELSE[IHITCO=1;]
            {  0  ]
            {  0  ]
            {  0  ELSEIF(TANALP({P1})*ZL.GE.0.)[
            {  0  IF(ZL.LT.0.0)[
            {  0  $RESET REGION {P1} +;
            {  0  ":BUG4:;"
            {  0  "IRL=IRL+1;"
            {  0  "IR(NP)=IRL;"
            {  0  "{P1}={P1}+1;"
            {  0  "GEOBUG=1;"
            {  0  "GOTO :START-CONE:;"
            {  0  ]
            {  0  IF((A.LE.0.).AND.(B.LE.0.))[;]
            {  0  ELSE[
            {  0  IF(B.EQ.0.)[TCONEO=SQRT(-C/A);]
            {  0  ELSE[TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  IF(B.LE.0.)[TCONEO=-BS/A;]ELSE[TCONEO=-C/BS;]
            {  0  ]
            {  0  IHITCO=1;
            {  0  ]
            {  0  ]
            {  0  ELSE[
            {  0  GOTO :END-CONE:;
            {  0  IF((A.LT.0.).AND.(B.GT.0.))[
            {  0  TEST=AC/B2;
            {  0  IF(ABS(TEST).LT.0.001)[BS=2.*B*(1.-0.25*TEST);]
            {  0  ELSEIF(TEST.GE.1.)[BS=B;]
            {  0  ELSE[BS=B*(1.+SQRT(1.-TEST));]
            {  0  TCONEO=-BS/A;
            {  0  IHITCO=1;
            {  0  ]
            {  0  ELSE[;]
            {  0  ]
            {  0  ]
            {  0  :END-CONE:;
            {  0  IF((IHITCI.EQ.-1).AND.(IHITCO.EQ.1))[
            {  0  IF(TCONEI.LE.TCONEO)[{P2}=IHITCI;{P3}=TCONEI;]
            {  0  ELSE[{P2}=IHITCO;{P3}=TCONEO;]
            {  0  ]
            {  0  ELSEIF(IHITCI.EQ.-1)[{P2}=IHITCI;{P3}=TCONEI;]
            {  0  ELSEIF(IHITCO.EQ.1)[{P2}=IHITCO;{P3}=TCONEO;]
            {  0  ELSE[{P2}=0;]
            {  0  }
               0  ;
               0  "******************************************************************************
               0  "
               0  "The following is the $CALL-HOWNEAR macro for PRESTA-II
               0  "That way, need to modify ELECTR is removed"
               0  "hownear is defined in srcsph.mortran"
               0  REPLACE {$CALL-HOWNEAR(#);} WITH {
            {  0  call hownear({P1},x(np),y(np),z(np),ir(np));
            {  0  }
               0  ;
1              0  %E     "cavsphnrc.mortran"
               0  %Q0                                                                            ;
               0  SUBROUTINE HOWFAR;
               0
               0  $IMPLICIT-NONE;
               0
               0  ;
               0  "MACRO USED LOCALLY TO CHANGE REGIONS, ADJUST USTEP, AND EXIT"
               0  REPLACE {$SET NEW REGION(#,#);} WITH {;
            {  0  IF({P1}.LE.USTEP)[USTEP={P1};IRNEW={P2};]
            {  0  RETURN;
            {  0  }
               0
               0  ;COMIN/EPCONT,STACK,GEOM,SCORE,MISC/;
               0
               0  COMMON/IBUG/ICBUG;
               0
               0  LOGICAL OUTSID;INTEGER GEOBUG,ICBUG;
               0
               0  $INTEGER IRL,IX,IC,IHITS,IHITC,IHITCO,IHITCI;
               0  $REAL    UL,VL,WL,XL,YL,ZL,A,B,B2,C,COUT,CIN;
               0  $REAL    TCONE,TSPH,RL,RHOL,RHOL2,DNTMP;
               0  $REAL    TCONEI,TCONEO,TEST,AC,BS,TANA2;
               0
               0  "DISCARD ZERO WEIGHT PARTICLES"
               0  IF(WT(NP).EQ.0.0)[IDISC=1;RETURN;]
               0
               0  OUTSID=.FALSE.;"INITIALLY ASSUME PARTICLE STAYS IN THE TARGET"
               0
               0  GEOBUG=0; "SET THE GEOMETRY BUG INDICATOR FLAG TO OFF"
               0
               0  IRL=IR(NP); "LOCAL REGION NUMBER"
               0
               0  "DISCARD IF PARTICLE WANTS TO LEAVE THE GEOMETRY"
               0  IF(IRL.EQ.1)[IDISC=1;RETURN;]
               0
               0  $GET-IX-IC(IRL); "GET CONICAL AND SPHERICAL ZONES NUMBERS"
               0
               0  UL=U(NP);VL=V(NP);WL=W(NP);XL=X(NP);YL=Y(NP);ZL=Z(NP); "LOCAL VARIABLES"
               0
               0  IF(NC.GT.1)[
               1    "write(6,*) 'shouldn''t be here, no cones in the problem yet';"
               1    "write(6,*) 'NC= ', NC;"
               1    "SEARCH ONLY IF CONES ARE DEFINED"
               1    $CONES(IC,IHITC,TCONE);"GET DISTANCE TO CONE"
               1    "IHITC  =  1 => HITS OUTER CONE"
               1    "       =  0 => MISSES BOTH CONES"
               1    "       = -1 => HITS INNER CONE"
               1    ]
               0  ELSE[
               1    "NO CONES IN THE PROBLEM"
               1    IHITC=0;
               1    ]
               0
               0  $SPHERE(IX,IHITS,TSPH);"GET DISTANCE TO SPHERE"
               0  "       IHITS   =  1 => HITS OUTER SPHERE"
               0  "               =  0 => MISSES BOTH SPHERES"
               0  "               = -1 => HITS INNER SPHERE"
               0
               0  "QUICK EXIT TO ELECTR IF A GEOMETRY ERROR WAS FOUND"
               0  IF(GEOBUG.EQ.1) [
               1    USTEP=0.0;
               1    IF(IRL.GT.NREG) IRL=1;
               1    IRNEW=IRL;
               1    DNEAR(NP)=0.0;
               1    RETURN;
               1    ]
               0
               0  IF(IX+IHITS.GT.NR) OUTSID=.TRUE.; "FLAG IF LEAVES THE GEOMETRY"
               0
               0  "THIS CODING CAUSES THE DISTANCE TO THE SURFACE TO BE SLIGHTLY INCREASED"
               0  "TO ALLOW SOME PENETRATION INTO THE NEXT REGION. THE AMOUNT OF INCREASE"
               0  "IS SCALED TO E-6 OF THE DISTANCE FROM THE ORIGIN TO MAKE IT EFFECTIVE"
               0  "EVERYWHERE IN THE GEOMETRY. ."
               0  IF(IHITC.NE.0)[TCONE=TCONE*1.000005+0.000005;]
               0  IF(IHITS.NE.0)[TSPH= TSPH *1.000005+0.000005;]
               0
               0  "CALCULATE DNEAR <= this is done in subroutine electr!!!"
               0  "IF((IDNEAR.EQ.0).AND.(IQ(NP).NE.0))["
               0  "    RHOL2 = XL*XL + YL*YL;missing in older version  EMH 01/2002"
               0  "    RL    = SQRT( RHOL2 + ZL*ZL );                             "
               0  "    DNTMP=RSPH(IX)-RL;"
               0  "    IF(IX.NE.1)[DNTMP=AMIN1(DNTMP,RL-RSPH(IX-1));]"
               0  "    IF(NC.NE.1)["
               0  "        RHOL = SQRT( RHOL2 ); missing in old version, EMH 01/2002"
               0  "        IF(IC.NE.NC)["
               0  "           DNTMP=AMIN1(DNTMP,REAL(ABS(COSALP(IC)*(RHOL-TANALP(IC)*ZL))));"
               0  "            ]"
               0  "        IF(IC.NE.1)["
               0  "            DNTMP=AMIN1(DNTMP,REAL(ABS(COSALP(IC-1)*(RHOL-TANALP(IC-1)*ZL))));"
               0  "            ]"
               0  "        ]"
               0  "    DNEAR(NP)=DNTMP;"
               0  "    ]"
               0  "ELSE[DNEAR(NP)=0.0;]"
               0
               0  "DO MOST PROBABLE CASE FIRST WHERE A CONE AND A SPHERE CAN BE HIT"
               0
               0  IF((IHITC.NE.0).AND.(IHITS.NE.0))[
               1    IF(TCONE.LT.TSPH)[
               2      "HITS CONE FIRST"
               2      $SET NEW REGION(TCONE,IRL+IHITC);
               2      ]
               1    ELSEIF(TSPH.LT.TCONE)[
               2      "HITS SPHERE FIRST"
               2      IF(OUTSID)[$SET NEW REGION(TSPH,1);]
               2      ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
               2      ]
               1    ELSE[
               2      "ODD CASE TSPH=TCONE:HITS CONE AND SPHERE TOGETHER"
               2      IF(OUTSID)[$SET NEW REGION(TSPH,1);]
               2      ELSE[$SET NEW REGION(TSPH,IRL+IHITC+NC*IHITS);]
               2      ]
               1    ]
               0
               0  "DO ODD OR NO CONE CASE-PARTICLE CAN HIT SPHERE BUT NOT CONE"
               0
               0  ELSE[
               1    IF(OUTSID)[$SET NEW REGION(TSPH,1);]
               1    ELSE[$SET NEW REGION(TSPH,IRL+NC*IHITS);]
               1    ]
               0
               0  "AT THIS STAGE ALL GEOMETRICAL POSSIBILITIES HAVE BEEN CHECKED AND CONTROL"
               0  "HAS ALREADY BEEN TRANSFERRED TO EGS"
               0
               0  END; "END OF SUBROUTINE HOWFAR"
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  "******************************************************************************
               0  "
               0  "
               0  "                               **************
               0  "                               *            *
               0  "                               * INPUTS.MOR *
               0  "                               *            *
               0  "                               **************
               0  "
               0  "
               0  "       AN INPUT FILE USED WITH CAVSPHnrc. THE INPUTS ARE DEFINED AS THEY ARE
               0  "       INPUT. CONSIDERABLE DEFAULTING AND ERROR CHECKING IS DONE.
               0  "
               0  "       VERSION 1       AFB    10/87            ADAPTED FROM CAVITY(EGS3)
               0  "       VERSION 2       A.M.   04/98            New input routine (get_inputs)
               0  ;
               0  "******************************************************************************
               0  "
               0  SUBROUTINE INPUTS;
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/BOUNDS,
               0  CHARS,EDGE,ELECIN,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,MEDIA,MISC,
               0  RUSROU,SCORE,SOURCE,SPECTR,USEFUL,USER,RANDOM,GetInput,
               0  COMPTON-DATA,ET-Control,EGS-VARIANCE-REDUCTION, EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                         User defined MACROS                             *"
               0  "***************************************************************************"
               0  REPLACE {$SKIP-LINE;} WITH {;OUTPUT;(' ');}  "Line skip"
               0  "REPLACE {$NMAX} WITH {120}"
               0  "REPLACE {$NVALUE} WITH {120}"
               0  REPLACE {$GET_INPUT(#);} WITH  "Used to get only one input"
               0  {
            {  0  "{P1}=Array index of the value_sought"
            {  0  NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT;
            {  0  }
               0  ;
               0  REPLACE {$GET_INPUTS(#,#);} WITH  "Used to get many inputs"
               0  {
            {  0  NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT;
            {  0  }
               0  ;
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0  "INTEGER IDAT,INEXT,IWATCH,ISTORE,IRESTART,IOOPTN;"
               0  INTEGER INEXT;
               0  "REAL TIMMAX;"
               0
               0  INTEGER ITERSE;
               0  "INTEGER NCASE, IFULL;                               Monte Carlo input"
               0  "REAL STATLM;                                        Monte Carlo input"
               0
               0  REAL CAVRAD, ELERAD, CAVLNG, WALLTH;                "Cavity input"
               0
               0  "INTEGER IQIN, comment out this one=>ISOURC, MODEIN;source input"
               0  INTEGER MODEIN;                                     "source input"
               0  REAL TEMP1,TEMP2,TEMP3,TEMP4;                       "source input"
               0
               0  "INTEGER IDORAY, IDOPES;                             transport control"
               0  INTEGER IFLUOR;                                     "transport control"
               0  INTEGER IC, IREGLO, IREGHI;                         "transport control"
               0  INTEGER IFARCE;                                     "transport control"
               0  INTEGER IESTEP;                                     "transport control"
               0  "REAL SMAX, ECUTIN, PCUTIN;                          transport control"
               0  REAL SMAX;                                          "transport control"
               0  REAL FESTEP;                                        "transport control"
               0
               0  "INTEGER MONOEN;"
               0
               0  REAL ADDING;
               0  INTEGER I, J, K, PLN, COUNT, SLENGHT, REGNUM;
               0
               0  INTEGER IZ, JJ;
               0
               0  $INTEGER jrng1,jrng2,ITMAX,IT,IX;
               0
               0  "***************************************************************************"
               0  "*                Variables used to point to the inputs                    *"
               0  "***************************************************************************"
               0  INTEGER NUM_TITLE,
               0
               0  "I/O Contol"
               0  NUM_IWATCH,
               0  NUM_STRAND,
               0  NUM_IRESTART,
               0  NUM_OUTOPTS,
               0  NUM_STORE,
               0
               0  "M-C Input"
               0  NUM_HIST,
               0  NUM_SEEDS,
               0  NUM_MXTIME,
               0  NUM_IFULL,
               0  NUM_STATLM,
               0  NUM_IFANO,
               0
               0  "Cavity inputs"
               0  NUM_ITERSE,
               0  NUM_WALLTH,
               0  NUM_CAVRAD,
               0  NUM_CAVLNG,
               0  NUM_ELERAD,
               0  NUM_WALMAT,
               0  NUM_ELEMAT,
               0  NUM_NCAVREG,
               0  NUM_RNUMCAV,
               0
               0  "Tranport Control"
               0  NUM_SMAX,
               0  NUM_ECUT,
               0  NUM_PCUT,
               0  NUM_RAYLEIGH,
               0  NUM_IREJCT,
               0  NUM_HOWFAR,
               0  NUM_ESAVEIN,
               0  NUM_IDOPES,
               0  NUM_IFLUOR,
               0  NUM_FLUIZ,
               0  NUM_FREGSTART,
               0  NUM_FREGSTOP,
               0  NUM_RRPARAM,
               0  NUM_RRMINPL,
               0  NUM_RRMAXPL,
               0  NUM_RRMINRA,
               0  NUM_RRMAXRA,
               0  NUM_RUSROU,
               0  NUM_RUSFRAC,
               0  NUM_XTRANSF,
               0  NUM_FORCE,
               0  NUM_STRTFRC,
               0  NUM_STPFRC,
               0  NUM_NESTEP,
               0  NUM_NSMAX,
               0  NUM_ADJEREG,
               0  NUM_FRAKESTEP,
               0  num_cs_enhance,
               0  num_compton,i_bound_compton,
               0  num_spin,i_spin;
               0
               0  $INTEGER my_unit, egs_open_datfile;
               0
               0  "---------------------------------------------------------------------------"
               0  IVAL=0;  "number of the value_sought"
               0
               0  ERROR_FLAG=0;   "Initialization of bad input flag"
               0  DO J=1, $NMAX [NVALUE(J)=0;]  "Initialization of Nvalue Array"
               0
               0  "*********************************************************"
               0  "* set up the values_sought(i) and echo inputs to screen *"
               0  "*********************************************************"
               0  "*********"
               0  "* TITLE *"
               0  "*********"
               0  IVAL=IVAL+1;
               0  NUM_TITLE=IVAL;
               0  VALUES_SOUGHT(IVAL)='TITLE';
               0  TYPE(IVAL)=2;
               0  NVALUE(IVAL)=1;
               0
               0  DELIMETER='NONE';
               0  $GET_INPUT(NUM_TITLE);
               0
               0  $SKIP-LINE;$SKIP-LINE;
               0  OUTPUT;(' *** INPUT CARD I01 ***');
               0  READ (CHAR_VALUE(NUM_TITLE,1),FMT='(80A1)') (TITLE(I),I=1,80);
               0  WRITE (*,:FMT:) (TITLE(I),I=1,79);
               0  :FMT: FORMAT ('TITLE: ',79A1);
               0  $SKIP-LINE;
               0
               0  "************************"
               0  "* INPUT/OUTPUT CONTROL *"
               0  "************************"
               0  IVAL=IVAL+1;
               0  NUM_IWATCH=IVAL;
               0  VALUES_SOUGHT(IVAL)='IWATCH';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='INTERACTIONS';
               0  ALLOWED_INPUTS(IVAL,2)='STEPS';
               0  ALLOWED_INPUTS(IVAL,3)='DEPOSITED';
               0  ALLOWED_INPUTS(IVAL,4)='GRAPH';
               0
               0  IVAL=IVAL+1;
               0  NUM_STRAND=IVAL;
               0  VALUES_SOUGHT(IVAL)='STORE INITIAL RANDOM NUMBERS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='NO';
               0  ALLOWED_INPUTS(IVAL,1)='LAST';
               0  ALLOWED_INPUTS(IVAL,2)='ALL DEPOSITED';
               0  ALLOWED_INPUTS(IVAL,3)='ALL';
               0
               0  IVAL=IVAL+1;
               0  NUM_IRESTART=IVAL;
               0  VALUES_SOUGHT(IVAL)='IRESTART';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='FIRST';
               0  ALLOWED_INPUTS(IVAL,1)='RESTART';
               0  ALLOWED_INPUTS(IVAL,2)='MAKE';
               0  ALLOWED_INPUTS(IVAL,3)='ANALYZE';
               0  ALLOWED_INPUTS(IVAL,4)='FOR GRAPHICS';
               0  ALLOWED_INPUTS(IVAL,5)='PARALLEL';       " ADDED BY JT, DEC.98 "
               0
               0  IVAL=IVAL+1;
               0  NUM_OUTOPTS=IVAL;
               0  VALUES_SOUGHT(IVAL)='OUTPUT OPTIONS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='SHORT';
               0  ALLOWED_INPUTS(IVAL,1)='CAVITY DETAILS';
               0
               0  IVAL=IVAL+1;
               0  NUM_STORE=IVAL;
               0  VALUES_SOUGHT(IVAL)='STORE DATA ARRAYS';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='YES';
               0  ALLOWED_INPUTS(IVAL,1)='NO';
               0
               0  DELIMETER='I/O CONTROL';
               0  $GET_INPUTS(NUM_IWATCH,NUM_STORE);
               0
               0  OUTPUT;(' *** INPUT CARD IO2 ***');
               0  IWATCH=VALUE(NUM_IWATCH,1);
               0  ISTORE=VALUE(NUM_STRAND,1);
               0  IRESTART=VALUE(NUM_IRESTART,1);
               0  IOOPTN=VALUE(NUM_OUTOPTS,1);
               0  IDAT=VALUE(NUM_STORE,1);
               0  OUTPUT IWATCH,ISTORE,IRESTART,IOOPTN,IDAT;
               0  (/' DO NOT TRACK(0) OR TRACK(>0) EVERY INTERACTION:',T60,I12/
               0  ' DO NOT STORE(0) OR STORE(1,2,3) INITIAL RANDOM #:',T60,I12/
               0  ' FIRST RUN(0),RESTARTED(1),MAKE(2),ANALYZE(3),GRAPHICS(4):',T60,I12/
               0  ' OUTPUT OPTION: CAVITY SUMMARY(0) PLUS REGION DETAIL(1):',T60,I12/
               0  ' STORE RAW DATA(0) OR NOT(1):',T60,I12/);
               0
               0  $SKIP-LINE;
               0
               0  IF((IRESTART.EQ.2).OR.(IDAT.EQ.1))[INEXT=0;]ELSE[INEXT=1;]
               0  IF(IRESTART.EQ.4) [
               1      IDAT=1;   "DO NOT STORE OUTPUT IN THIS CASE TO AVOID BIASING"
               1      ISTORE=0; "DO NOT STORE THE STARTING RANDOM NUMBERS EITHER"
               1      ]
               0
               0  "                       MONTE CARLO CONTROL INPUT
               0  "                       *************************
               0  IVAL=IVAL+1;
               0  NUM_HIST=IVAL;
               0  VALUES_SOUGHT(IVAL)='NUMBER OF HISTORIES';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=100;
               0  VALUE_MAX(IVAL)=999999999;
               0  DEFAULT(IVAL)=20000;
               0
               0  IVAL=IVAL+1;
               0  NUM_SEEDS=IVAL;
               0  VALUES_SOUGHT(IVAL)='INITIAL RANDOM NO. SEEDS';
               0  NVALUE(IVAL)=2;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=1;
               0  VALUE_MAX(IVAL)=999999999;
               0  DEFAULT(IVAL)=1;
               0
               0  IVAL=IVAL+1;
               0  NUM_MXTIME=IVAL;
               0  VALUES_SOUGHT(IVAL)='MAX CPU HOURS ALLOWED';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=1000;
               0  DEFAULT(IVAL)=0.99;
               0
               0  IVAL=IVAL+1;
               0  NUM_IFULL=IVAL;
               0  VALUES_SOUGHT(IVAL)='IFULL';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='DOSE AND STOPPERS';
               0  ALLOWED_INPUTS(IVAL,1)='AATT AND ASCAT';
               0  ALLOWED_INPUTS(IVAL,2)='AP';
               0  ALLOWED_INPUTS(IVAL,3)='AFL AND <S>G/W';
               0
               0  IVAL=IVAL+1;
               0  NUM_STATLM=IVAL;
               0  VALUES_SOUGHT(IVAL)='STATISTICAL ACCURACY SOUGHT';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.0;
               0  VALUE_MAX(IVAL)=100.0;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_IFANO=IVAL;
               0  VALUES_SOUGHT(IVAL)='PHOTON REGENERATION';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='NO';
               0  ALLOWED_INPUTS(IVAL,1)='YES';
               0
               0  DELIMETER='MONTE CARLO INPUTS';
               0  $GET_INPUTS(NUM_HIST,NUM_IFANO);
               0
               0  "************"
               0  "* CARD MC1 *"
               0  "************"
               0  OUTPUT;(/,' *** INPUT CARD MC1 ***');
               0  NCASE=VALUE(NUM_HIST,1);
               0  TIMMAX=VALUE(NUM_MXTIME,1);
               0  IFULL=VALUE(NUM_IFULL,1);
               0  STATLM=VALUE(NUM_STATLM,1);
               0  ifano=VALUE(NUM_IFANO,1);
               0
               0  " CHECK THAT IFULL<2 UNTIL THIS IS FIXED -- JT "
               0  "IF(IFULL.GE.2)["
               0  IF(IFULL.GE.2)[
               1      OUTPUT; (/' THE IFULL OPTION SELECTED IS NOT YET AVAILABLE',T60/
               1      ' FOR THE SPHERICAL GEOMETRY.  CHOOSE EITHER DOSE',T60/
               1      ' AND STOPPERS OR AATT AND ASCAT.  FOR THIS RUN',T60/
               1      ' IFULL HAS BEEN SET TO THE LATTER.'/);
               1      IFULL=1;
               1      ]
               0
               0  "Random number initializations"
               0  IF( i_parallel > 0 ) jrng2 = jrng2 - 1 + i_parallel;
               0  $RNG-INPUTS('INITIAL RANDOM NO. SEEDS','MONTE CARLO INPUTS',jrng1,jrng2);
               0  $INITIALIZE RNG USING jrng1 AND jrng2;
               0
               0
               0  OUTPUT NCASE,jrng1,jrng2,TIMMAX,IFULL,STATLM,ifano;
               0  (/' # OF HISTORIES:',T60,I12/
               0  $RNG-STRING-1,T60,I12/,$RNG-STRING-2,T60,I12/,
               0  ' MAXIMUM CPU TIME ALLOWED:',T60,F10.2,'HRS'/
               0  ' SCORING OPTION IFULL (0,1,2,3):',T60,I12/
               0  ' STATISTICAL ACCURACY DESIRED:',T60,F10.1,'%'/
               0  ' REGENERATION OPTION IFANO (0,1,2):',T60,I12);
               0
               0  IF (ERROR_FLAG=1) [GOTO :FINISHED:;]
               0
               0  "                SPHERICAL GEOMETRY AND MATERIAL INPUT
               0  "                ***************************************
               0  CALL GEOMSPH;
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE GEOMSPH************';
               1      GOTO :FINISHED:;
               1      ]
               0
               0  "SET THE GEOMETRY FLAG FOR THE CAVITY"
               0  DO J=1,NREG [NTRACK(J)=0;]  "ASSUME IT IS NON-CAVITY EVERYWHERE"
               0
               0
               0  "SET THE CAVITY FLAG FOR THE CAVITY REGIONS"
               0
               0  DO J=1, numcavreg [NTRACK(cavreg(J))=1;]
               0
               0  "                       SOURCE CONFIGURATION INPUT
               0  "                       **************************
               0  "************"
               0  "* CARD SC1 *"
               0  "************"
               0  "EXECUTED FROM SUBROUTINE SRCSPH(ERROR_FLAG)"
               0  CALL SRCSPH;  "Get source data"
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE SRCSPH************';
               1      GOTO :FINISHED:;
               1      ]
               0  "the call to srcsph reads the data into svtmp's (source commonblock) "
               0  "the call to srcini will do the actual initialization               "
               0  "based on the numbers in svtmp (transferred as parameters to srcini)"
               0  "following line is to comply with g77 compiler                      "
               0  "call of an entry in a subroutine was not allowed by g77            "
               0  "see also the few changes in SRCSPH                                  "
               0  "Jan S. Oct 2, 1996                                                 "
               0  CALL SRCINI (SVTMP1,SVTMP2,SVTMP3,SVTMP4,0);
               0
               0
               0  "*********************************************************"
               0  " what follows was taken from cavrznrc, EMH, January, 2002"
               0  "*********************************************************"
               0
               0  "************"
               0  "* CARD TC1 *"
               0  "************"
               0  "EXECUTED FROM SUBROUTINE ENSRC(ERROR_FLAG)"
               0  IF (ISOURC=21.OR.ISOURC=22) [MONOEN=0;]
               0  "no need to input monoen for source 21,22"
               0  ELSE [CALL ENSRC;] "Get data re-source energies"
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) '***********ERROR IN SUBROUTINE ENSRC************';
               1      GOTO :FINISHED:;
               1      ]
               0
               0  $SKIP-LINE;
               0
               0  "*************************************************************************"
               0  "                transport parameters section                             "
               0  "*************************************************************************"
               0
               0  call get_transport_parameter(6); " This will scan the input file for
               0  " transport parameter input and then
               0  " output all settings to unit 6
               0
               0  ECUTIN=ecut(1);
               0  PCUTIN=pcut(1);
               0  SMAX=smaxir(1);
               0
               0  "*************************************************************************"
               0  "                variance reduction section                               "
               0  "*************************************************************************"
               0
               0
               0
               0  IVAL=IVAL+1;
               0  NUM_IREJCT=IVAL;
               0  VALUES_SOUGHT(IVAL)='ELECTRON RANGE REJECTION';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0
               0  IVAL=IVAL+1;
               0  NUM_ESAVEIN=IVAL;
               0  VALUES_SOUGHT(IVAL)='ESAVEIN';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.0;
               0  VALUE_MAX(IVAL)=1.e30;
               0  DEFAULT(IVAL)=0.0;
               0
               0  ival = ival + 1;
               0  num_cs_enhance = ival;
               0  values_sought(ival) = 'CS ENHANCEMENT FACTOR';
               0  nvalue(ival) = 1;
               0  type(ival) = 1;
               0  value_min(ival) = 0;
               0  value_max(ival) = 1e6;
               0  default(ival) = 0.5;
               0
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_IREJCT,num_cs_enhance);
               0
               0  "************"
               0  "* CARD TC2 *"
               0  "************"
               0  OUTPUT;(' *** INPUT CARD TC2 ***');
               0  IREJCT=VALUE(NUM_IREJCT,1);
               0  ESAVEIN=VALUE(NUM_ESAVEIN,1);
               0  cs_enhance = value(num_cs_enhance,1);
               0  IF( cs_enhance > 1 ) [ use_enhance = .true.; ]
               0  ELSE [ use_enhance = .false.; ]
               0
               0  OUTPUT IREJCT; ( / ' Range rejection is On(1) or Off(0):',T60,I12);
               0  IF(IREJCT > 0) [
               1      OUTPUT ESAVEIN;
               1      (' ESAVEIN cutoff value(total) for range rejection:', T60,F10.4,' MeV'/);
               1      IF (ESAVEIN = 0.0 ) [
               2          OUTPUT;(/'**********************************************************'/
               2          '   Have asked for range rejection but left ESAVEIN=0.0    '/
               2          '        There will be no range rejection'/
               2          '**********************************************************'/);
               2          ]
               1      DO i=1,NREG [i_do_rr(i) = 1; e_max_rr(i) = ESAVEIN;]
               1      "note  e_max_r is total energy"
               1      "above two arrays needed for each region for EGSnrc RANGE-DISCARD macro"
               1      ]
               0
               0  IVAL=IVAL+1;
               0  NUM_RUSROU=IVAL;
               0  VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE DEPTH';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e30;
               0  VALUE_MAX(IVAL)=1.e30;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_RUSFRAC=IVAL;
               0  VALUES_SOUGHT(IVAL)='RUSSIAN ROULETTE FRACTION';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e30;
               0  VALUE_MAX(IVAL)=1.e30;
               0  DEFAULT(IVAL)=0.0;
               0
               0  IVAL=IVAL+1;
               0  NUM_XTRANSF=IVAL;
               0  VALUES_SOUGHT(IVAL)='EXPONENTIAL TRANSFORM C';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-1.e30;
               0  VALUE_MAX(IVAL)=1.e30;
               0  DEFAULT(IVAL)=0.0;
               0
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_RUSROU,NUM_XTRANSF);
               0
               0  "*************"
               0  "* CARD TC2C *"
               0  "*************"
               0  OUTPUT;(' *** INPUT CARD TC2C ***');
               0  RRZ=VALUE(NUM_RUSROU,1);
               0  RRCUT=VALUE(NUM_RUSFRAC,1);
               0  CEXPTR=VALUE(NUM_XTRANSF,1);
               0  RUSROU=.FALSE.;IF(RRZ+RRCUT.NE.0.0)RUSROU=.TRUE.;
               0  IF(RUSROU)[
               1      OUTPUT RRZ,RRCUT;
               1      (/' RUSSIAN ROULETTE WILL BE PLAYED'/
               1      ' RUSSIAN ROULETTE PLANE:',T30,E14.7/
               1      ' SURVIVAL PROBABILITY:',T30,E14.7/)
               1      ]
               0  ELSE [OUTPUT;(' RUSSIAN ROULETTE WILL NOT BE PLAYED'/);]
               0  IF (CEXPTR = 0) [OUTPUT;(' NO PATHLENGTH BIASING TO BE DONE'/);]
               0  ELSE [OUTPUT CEXPTR;(' CEXPTR PARAMATER:',T30,E14.7/);]
               0
               0  IVAL=IVAL+1;
               0  NUM_FORCE=IVAL;
               0  VALUES_SOUGHT(IVAL)='PHOTON FORCING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  DEFAULT(IVAL)=0;
               0  ALLOWED_INPUTS(IVAL,0)='OFF';
               0  ALLOWED_INPUTS(IVAL,1)='ON';
               0  IVAL=IVAL+1;
               0  NUM_STRTFRC=IVAL;
               0  VALUES_SOUGHT(IVAL)='START FORCING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0
               0  IVAL=IVAL+1;
               0  NUM_STPFRC=IVAL;
               0  VALUES_SOUGHT(IVAL)='STOP FORCING AFTER';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(NUM_STPFRC)=0;
               0  VALUE_MAX(NUM_STPFRC)=NREG+1;
               0  DEFAULT(NUM_STPFRC)=1;
               0
               0  DELIMETER='VARIANCE REDUCTION';
               0  $GET_INPUTS(NUM_FORCE,NUM_STPFRC);
               0
               0  "************"
               0  "* CARD TC3 *"
               0  "************"
               0  OUTPUT;(' *** INPUT CARD TC3 ***');
               0  IFARCE=VALUE(NUM_FORCE,1);
               0  NFMIN=VALUE(NUM_STRTFRC,1);
               0  NFMAX=VALUE(NUM_STPFRC,1);
               0  IF (IFARCE=0) [
               1      IFORCE=0;NFMIN=0;NFMAX=0;
               1      OUTPUT;(' NO INTERACTION FORCING IS IN EFFECT'/);
               1      ]
               0  ELSEIF (IFARCE=1) [
               1      IFORCE=1;
               1      IF (NFMAX.LT.NFMIN) NFMAX=NFMIN;
               1      OUTPUT NFMIN,NFMAX;
               1      (/' FORCED PHOTON INTERACTIONS IN EFFECT FROM',I3,' TO',I3,
               1      ' # INTERACTIONS'/);
               1      ]
               0  IQINC=IQIN; "NEEDED TO TURN OFF FASTSTEP FOR INCIDENT ELECTRONS"
               0  "WHEN FORCING INTERACTIONS"
               0  $SKIP-LINE;
               0
               0  IVAL=IVAL+1;
               0  VALUES_SOUGHT(IVAL)='PHOTON SPLITTING';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(ival)=1;
               0  VALUE_MAX(ival)=$MXSTACK-2;
               0  DEFAULT(ival)=1;
               0  $GET_INPUT(ival);
               0  IF( error_flags(ival) = 0 ) [
               1
               1      n_split = value(ival,1);
               1      IF( n_split > 1 ) [
               2          IF( ifull > 1 ) [
               3              OUTPUT;
               3              (//' ******** Photon splitting only for ifull = 0,1,4! ******'//);
               3              n_split = 1;
               3              ]
               2          ELSE [
               3              OUTPUT n_split;
               3              (//' ****** Calculation with photon splitting ********** '/
               3              '   n_split = ',i4//);
               3              iifano = ifano;
               3              ]
               2          ]
               1      ]
               0
               0  IF( use_enhance ) [
               1      OUTPUT cs_enhance;
               1      (//' ************** Calculation with CS enhancement *******************'/,
               1      '    photon forcing, exp. transform, etc. input will be ignored! '/,
               1      '    IFULL will be set to 1! (i.e. Ascat and Aatt) '//,
               1      '    Using cs_enhance = ',f10.4,/
               1      ' ******************************************************************'///);
               1      ifull = 1; IFORCE=0;NFMIN=0;NFMAX=0; n_split = 1;
               1      ]
               0
               0
               0
               0  "                        SCORING ARRAY INITIALISATION
               0  "                        ****************************
               0  "
               0
               0  "CALCULATE THE NUMBER OF DOSE COMPONENTS"
               0  IF(    IFULL.EQ.0)[ITMAX=2;]      "SCORE DOSE ONLY"
               0  ELSEIF(IFULL.EQ.1)[ITMAX=3;]      "SCORE Ascat, Aatt AS WELL"
               0  ELSEIF(IFULL.EQ.2)[ITMAX=4;]      "SCORE Apn as well"
               0  ELSEIF(IFULL.EQ.3)[ITMAX=$MAXIT;] "SCORE Afl AND <s>g,w AS WELL"
               0
               0  NCASEO=0;NCASET=0;TMCPUO=0; "SET PREVIOUS RUN COUNTERS"
               0
               0  IF(IRESTART.EQ.0.OR.IRESTART.EQ.5)[ "FRESH START, SET EVERYTHING TO ZERO"
               1      "IRESTART=5 AS WELL, CHANGED BY JT, NOV.98"
               1
               1      /cav_dose, cav_dose0, cav_dose1, cav_dose2/ =0;
               1      /cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2/=0;
               1      /cav_dosec,cav_dosec01,cav_dosec02/         =0;
               1
               1      DO IS=1,$STAT[
               2          /ISTIS(IS),ISTCIS(IS),IMSIS(IS),IMSCIS(IS),IMMIS(IS),IMMCIS(IS)/=0;
               2          /ISMIS(IS),ISMCIS(IS)/=0;  "ADDED BY JT, DEC.98"
               2          DO IT=1,ITMAX[
               3              DO IX=1,NR[
               4                  DO IC=1,NC[
               5                      DOSEIS(IC,IX,IT,IS)=0.0;
               5                      ]
               4                  ]
               3              ]
               2          ]
               1      ]
               0  ELSEIF((IRESTART.NE.2).AND.(IRESTART.NE.4))[
               1      "RESTART OR STATS ANALYSIS ONLY, READ OLD DATA FROM UNIT 4"
               1      "OPEN UNIT 4 AS AN OLD FILE"
               1
               1      OUTPUT;(' About to read the previous .egsdat file');
               1      my_unit = egs_open_datfile(4,0,1,'.egsdat');
               1
               1      read(my_unit,*,end=:EOFA:) cav_dose,  cav_dose0,
               1      cav_dose1, cav_dose2;
               1      read(my_unit,*,end=:EOFA:) cav2_dose, cav2_dose0,
               1      cav2_dose1,cav2_dose2;
               1      read(my_unit,*,end=:EOFA:) cav_dosec, cav_dosec01,
               1      cav_dosec02;
               1      DO IS=1,$STAT[
               2          READ(my_unit,*,END=:EOFA:) ISTIS(IS),ISTCIS(IS),
               2          IMSIS(IS),IMSCIS(IS),
               2          ISMIS(IS),ISMCIS(IS),
               2          IMMIS(IS),IMMCIS(IS);
               2          READ(my_unit,*,END=:EOFA:)
               2          (((DOSEIS(IC,IX,IT,IS),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
               2          ]
               1      $RETRIEVE RNG STATE FROM UNIT my_unit;
               1      READ(my_unit,*,END=:EOFA:)NCASEO,TMCPUO;
               1      CLOSE(UNIT=my_unit);
               1      ]
               0
               0  IF(IRESTART.EQ.3)[NCASE=0;]
               0
               0  NCASET=NCASE+NCASEO;
               0
               0  :FINISHED: CONTINUE;
               0  "************************"
               0  "* Check for any errors *"
               0  "************************"
               0  IF(ERROR_FLAG.EQ.0) [
               1      OUTPUT;(/' ********* SUCCESSFUL INPUT ACCOMPLISHED *********');
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' *************************************************';
               1      WRITE (15,*) ' ********* SUCCESSFUL INPUT ACCOMPLISHED *********';
               1      WRITE (15,*) ' *************************************************';
               1      WRITE (15,*) ' ';
               1      WRITE (15,*) ' ';
               1      DO J=1,5[$SKIP-LINE;]
               1
               1      RETURN; "NORMAL RETURN"
               1      ]
               0
               0  IF (ERROR_FLAG=1) [
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) '************************************************';
               1      WRITE(15,*) '*********** INPUTS NOT ACCOMPLISHED ************';
               1      WRITE(15,*) '************************************************';
               1      WRITE(15,*) ' ';
               1      WRITE(15,*) ' ';
               1      OUTPUT;(/' INPUT DATA IS NOT CORRECT!');
               1      RETURN; "ERROR RETURN"
               1      ]
               0  "BAD DATA FILE, STOP AND PRINT MESSAGE
               0  :EOFA:;OUTPUT;(/' End of  file before all of egsdat file read in');
               0
               0  ERROR_FLAG=1;
               0  RETURN; "END OF DAT FILE RETURN"
               0
               0  END; "END OF SUBROUTINE INPUTS
               0
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
1              0  %E     "cavsphnrc.mortran"
               0  "***************************************************************************
               0  "
               0  SUBROUTINE ISUMRY;
               0  "
               0  "
               0  "                AFB      87/12/11     VAX/IBM COMPATIBLE VERSION CODED
               0  "
               0  "*************************************************************************
               0
               0  ;
               0  REPLACE {$IRL} WITH {IC+1+NC*(IX-1)}
               0
               0  "THIS IS A GENERAL MACRO ROUTINE TO PLOT A NON-ROTATED GRID OF THE INPUT"
               0  "VARIABLES BETWEEN THE CONICAL REGIONS #1 AND #2 AND BETWEEN THE"
               0  "SPHERICAL REGIONS #3 AND #4"
               0  ;
               0  REPLACE {$WRITE-INP(#,#/#,#);} WITH
               0  {
            {  0  ;
            {  0  NR1={P3}-1;NR2={P4};
            {  0  IREPT=NR2-NR1;
            {  0  DO IX=NR1,NR2[
            {  0  IF(IX.EQ.NR1)[WRITE(IOUT,:4110:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+1)[WRITE(IOUT,:4111:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+2)[WRITE(IOUT,:4112:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+3)[WRITE(IOUT,:4113:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+4)[WRITE(IOUT,:4114:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+5)[WRITE(IOUT,:4115:) RSPH(IX);]
            {  0  ELSEIF(IX.EQ.NR1+6)[WRITE(IOUT,:4116:) RSPH(IX);]
            {  0  ]
            {  0  DO IC={P1},{P2}[
            {  0  IF(IC.EQ.1)[WRITE(IOUT,416) 0.0;]ELSE[WRITE(IOUT,416)ALPHA(IC-1);]
            {  0  IXI=1;
            {  0  DO IX=1,IREPT[
            {  0  IXI=IXI+1;
            {  0  IF(IX.EQ.1)[WRITE(IOUT,:4170:);]
            {  0  ELSEIF(IX.EQ.2)[WRITE(IOUT,:4171:);]
            {  0  ELSEIF(IX.EQ.3)[WRITE(IOUT,:4172:);]
            {  0  ELSEIF(IX.EQ.4)[WRITE(IOUT,:4173:);]
            {  0  ELSEIF(IX.EQ.5)[WRITE(IOUT,:4174:);]
            {  0  ELSEIF(IX.EQ.6)[WRITE(IOUT,:4175:);]
            {  0  ]
            {  0  IF(IXI.EQ.1)[WRITE(IOUT,:4180:)IC;]
            {  0  ELSEIF(IXI.EQ.2)[WRITE(IOUT,:4181:)IC;]
            {  0  ELSEIF(IXI.EQ.3)[WRITE(IOUT,:4182:)IC;]
            {  0  ELSEIF(IXI.EQ.4)[WRITE(IOUT,:4183:)IC;]
            {  0  ELSEIF(IXI.EQ.5)[WRITE(IOUT,:4184:)IC;]
            {  0  ELSEIF(IXI.EQ.6)[WRITE(IOUT,:4185:)IC;]
            {  0  ELSEIF(IXI.EQ.7)[WRITE(IOUT,:4186:)IC;]
            {  0  DO IX=1,IREPT[
            {  0  IF(IX.EQ.1)[WRITE(IOUT,:4220:);]
            {  0  ELSEIF(IX.EQ.2)[WRITE(IOUT,:4221:);]
            {  0  ELSEIF(IX.EQ.3)[WRITE(IOUT,:4222:);]
            {  0  ELSEIF(IX.EQ.4)[WRITE(IOUT,:4223:);]
            {  0  ELSEIF(IX.EQ.5)[WRITE(IOUT,:4224:);]
            {  0  ELSEIF(IX.EQ.6)[WRITE(IOUT,:4225:);]
            {  0  ]
            {  0  DO IX={P3},{P4}[
            {  0  MEDIUM=MED($IRL);
            {  0  IF(NTRACK($IRL).EQ.1)[MTYPE(1,IX)=ASTER;]ELSE[MTYPE(1,IX)=BLANK;]
            {  0  IF(MEDIUM.EQ.0)[
            {  0  MTYPE(2,IX)=VCHAR;MTYPE(3,IX)=ACHAR;MTYPE(4,IX)=CCHAR;
            {  0  MTYPE(5,IX)=UCHAR;MTYPE(6,IX)=UCHAR;MTYPE(7,IX)=MCHAR;
            {  0  ]
            {  0  ELSE[DO ICHARS=1,6[MTYPE(ICHARS+1,IX)=MEDIA(ICHARS,MEDIUM);]]
            {  0  ]
            {  0  DO IX={P3},{P4}[
            {  0  IF(IX.EQ.{P3})[WRITE(IOUT,:4270:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ELSEIF(IX.EQ.{P3}+1)[WRITE(IOUT,:4271:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ELSEIF(IX.EQ.{P3}+2)[WRITE(IOUT,:4272:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ELSEIF(IX.EQ.{P3}+3)[WRITE(IOUT,:4273:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ELSEIF(IX.EQ.{P3}+4)[WRITE(IOUT,:4274:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ELSEIF(IX.EQ.{P3}+5)[WRITE(IOUT,:4275:)$IRL,(MTYPE(J,IX),J=1,7);]
            {  0  ]
            {  0  DO IX={P3},{P4}[
            {  0  IF(IX.EQ.{P3})[WRITE(IOUT,:4320:) AMASS(IC,IX);]
            {  0  ELSEIF(IX.EQ.{P3}+1)[WRITE(IOUT,:4321:) AMASS(IC,IX);]
            {  0  ELSEIF(IX.EQ.{P3}+2)[WRITE(IOUT,:4322:) AMASS(IC,IX);]
            {  0  ELSEIF(IX.EQ.{P3}+3)[WRITE(IOUT,:4323:) AMASS(IC,IX);]
            {  0  ELSEIF(IX.EQ.{P3}+4)[WRITE(IOUT,:4324:) AMASS(IC,IX);]
            {  0  ELSEIF(IX.EQ.{P3}+5)[WRITE(IOUT,:4325:) AMASS(IC,IX);]
            {  0  ]
            {  0  ]
            {  0  IF({P2}.EQ.NC)[WRITE(IOUT,416)180.;]ELSE[WRITE(IOUT,416)ALPHA({P2});]
            {  0  IXI=1;
            {  0  DO IX=1,IREPT[
            {  0  IXI=IXI+1;
            {  0  IF(IX.EQ.1)[WRITE(IOUT,:4170:);]
            {  0  ELSEIF(IX.EQ.2)[WRITE(IOUT,:4171:);]
            {  0  ELSEIF(IX.EQ.3)[WRITE(IOUT,:4172:);]
            {  0  ELSEIF(IX.EQ.4)[WRITE(IOUT,:4173:);]
            {  0  ELSEIF(IX.EQ.5)[WRITE(IOUT,:4174:);]
            {  0  ELSEIF(IX.EQ.6)[WRITE(IOUT,:4175:);]
            {  0  ]
            {  0  IF(IXI.EQ.1)[WRITE(IOUT,:4180:)IC;]
            {  0  ELSEIF(IXI.EQ.2)[WRITE(IOUT,:4181:)IC;]
            {  0  ELSEIF(IXI.EQ.3)[WRITE(IOUT,:4182:)IC;]
            {  0  ELSEIF(IXI.EQ.4)[WRITE(IOUT,:4183:)IC;]
            {  0  ELSEIF(IXI.EQ.5)[WRITE(IOUT,:4184:)IC;]
            {  0  ELSEIF(IXI.EQ.6)[WRITE(IOUT,:4185:)IC;]
            {  0  ELSEIF(IXI.EQ.7)[WRITE(IOUT,:4186:)IC;]
            {  0  DO IX=NR1,NR2[
            {  0  IF(IX.EQ.NR1)[WRITE(IOUT,:4720:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+1)[WRITE(IOUT,:4721:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+2)[WRITE(IOUT,:4722:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+3)[WRITE(IOUT,:4723:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+4)[WRITE(IOUT,:4724:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+5)[WRITE(IOUT,:4725:)IX;]
            {  0  ELSEIF(IX.EQ.NR1+6)[WRITE(IOUT,:4726:)IX;]
            {  0  ]
            {  0  WRITE(IOUT,474);
            {  0  WRITE(IOUT,406);
            {  0  }
               0
               0  ;
               0  INTEGER*4 BOXWD,BOXHT;   "WIDTH/HEIGHT IN CHARACTERS/LINES OF EACH DATA"
               0  "BOX, ONE BOX BEING ASSOCIATED WITH ONE GEOMETRICAL"
               0  "REGION"
               0
               0  INTEGER*4 GRIDWD,GRIDHT; "SAME IDEA BUT FOR ENTIRE GRID INCLUDING LABELS"
               0
               0  LOGICAL FITS;                         "IF FITS TRUE THEN THE OUTPUT WILL FIT"
               0  "ON A SINGLE SHEET"
               0  $TYPE MTYPE(7,$MAXRC);   "TEMPORARY STORAGE TO PRINT OUT CHARACTER STRINGS"
               0
               0  COMIN/
               0  BOUNDS,CHARS,EDGE,ELECIN,ET-Control,GEOM,IODAT1,IODAT2,IODAT3,IODAT4,
               0  PRINTC,MEDIA,MISC,RUSROU,SCORE,SOURCE,SPECTR,
               0  THRESH,USEFUL,USER,RANDOM/;
               0  "added ET-control to give proper access to ESTEPR, even though we do not"
               0  "ever use it at this point, we were prining out garbage before"
               0  "Note it is initialized in HATCH to unity via a macro in egsnrc.macros"
               0  "For the grid output defaults"
               0  CHARACTER*4 CDSTBL($MXREG),CTRTBL($MXREG),CABSRB($MXREG);
               0  CHARACTER*4 CAVTRACK($MXREG); "for identifying a cavity region"
               0
               0  "WRITE THE HEADER"
               0  write(iout,110) title;
               0  call egs_fdate(iout);
               0  110  FORMAT(' ',80A1,/1X,79('*')/ ' *',T80, '*'/
               0  ' *',T80, '*'/
               0  ' *',T34,'************',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'* CAVSPHnrc*',T80,'*'/
               0  ' *',T34,'*          *',T80,'*'/
               0  ' *',T34,'************',T80,'*'/
               0  ' *',T80, '*'/
               0  ' *   Spherical-geometry EGSnrc user-code for scoring cavity details',
               0  T80,'*'/
               0  ' *',T80, '*'/
               0  ' *   CAVSPHnrc was developed by the National Research Council of Canada',
               0  T80,'*'/
               0  ' *',T80, '*'/
               0  ' *     It uses the EGSnrc Code System developed at NRC ',T80,'*'/
               0  ' *     (based on the EGS4 Code System Carlo developed by SLAC and NRC)',
               0  T80,'*'/
               0  ' *             running on '$MACHINE' ',T80,'*'/
               0  ' *',T80, '*'/
               0  ' *',  T53,' ',$);
               0  write(iout,111);
               0  111 FORMAT('  *'/1X,79('*'));
               0
               0  "Print info about transport parameter settings"
               0  call show_transport_parameter(iout);
               0
               0  "MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS"
               0  WRITE(IOUT,200) NCASE,NCASET;
               0  IF(IQIN = 0 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''photons'')');
               0  IF(IQIN = -1) WRITE(IOUT,'(T20,''Incident Charge'',T60,''electrons'')');
               0  IF(IQIN = 1 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''positrons'')');
               0  IF(IQIN = 2 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''all'')');
               0  IF(IQIN = 3 ) WRITE(IOUT,'(T20,''Incident Charge'',T60,''e- & e+'')');
               0
               0  IF(MONOEN = 0 & ISOURC ~= 21 & ISOURC ~= 22)[ WRITE(IOUT,201) EIN; ]
               0  ELSE[ CALL ENSRCO;]
               0
               0  IF(IFORCE ~= 0)[WRITE(IOUT,230)NFMIN,NFMAX;]ELSE[WRITE(IOUT,231);]
               0  IF(IREJCT > 0)[
               1      " WRITE(IOUT,242);IF(IREJCT = 2)WRITE(IOUT,243);"
               1      WRITE(IOUT,2421) z_cavity_min, z_cavity_max, r_cavity_max;
               1      2421 FORMAT(T20,'Range rejection on a region by region basis'/
               1      T20,'Also globally to region between z=',F10.4,' &',F10.4,' cm'/
               1      T20,'     and inside radius=', F12.4,' cm');
               1      WRITE(IOUT,2422) ESAVEIN;
               1      2422 FORMAT(T20,'Range rejection only for electrons < ESAVEIN=',
               1      F10.3,' MeV');
               1      ]
               0  ELSE[WRITE(IOUT,244);]
               0  WRITE(IOUT,260) TIMMAX,STATLM;
               0  write(iout,'(19x,a,$)') 'Initial RNG state:    ';
               0  $SHOW-RNG-STATE(iout); write(iout,*);
               0  IF(RUSROU)[WRITE(IOUT,265)RRZ,RRCUT;]
               0  IF(CEXPTR.NE.0)[WRITE(IOUT,266)CEXPTR;]
               0  IF(ifano = 1) [
               1      OUTPUT; ('  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ');
               1      WRITE(iout,*) '  *** REGENERATION REQUESTED (IFANO SET TO 1) ! *** ';
               1      ]
               0  ELSEIF(ifano = 2) [
               1      OUTPUT; ('  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** '/
               1      '  (IFANO SET TO 2) ! *** ');
               1      WRITE(iout,*)'  *** ELECTRONS SET IN MOTION IN WALL WILL BE ELIMINATED *** ';
               1      WRITE(iout,*)'  (IFANO SET TO 2) ! *** ';
               1      ]
               0  ELSE [
               1      OUTPUT; (T20,'  *** NO REGENERATION REQUESTED (IFANO SET TO 0) ! *** ');
               1      WRITE(iout,'(T20,''** No regeneration requested (IFANO set to 0)! ** '')');
               1      ]
               0
               0  "EK0=EIN;"
               0  "$PRESTA-INPUT-SUMMARY; OUTPUT THE PRESTA INPUT VARIABLES"
               0  "taken out input-summary at upgrade to PRESTA-II"
               0  "MATERIAL INPUT SUMMARY"
               0  "====================="
               0
               0  WRITE(IOUT,300) NMED;
               0  DO I=1,NMED[
               1      WRITE(IOUT,310) I,(MEDIA(J,I),J=1,6),RHO(I),AE(I),AP(I),UE(I),UP(I);]
               0
               0  CALL SRCOUT;
               0
               0  "       PRINT A GRID OF THE ZONE DEPENDENT VARIABLES"
               0  "       ============================================"
               0
               0  "SET BOX DIMENSIONS"
               0  BOXWD=18;BOXHT=4;
               0  "SET GRID DIMENSIONS"
               0  GRIDWD=BOXWD*NR+15;
               0  GRIDHT=BOXHT*NC+3;
               0
               0  "DECIDE ON STRAIGHT VERSUS ROTATED OUTPUT AND SET PRINTER CONTROLS"
               0  ICHPIN=12;ILPIN=6;    "INITIALIZATION OF CHARS/INCH AND LINES/INCH"
               0  MXLP11=43;MXLP12=65;  "MAXIMUM GRID HEIGHTS ALLOWABLE FOR 6 AND 8 LINES"
               0  "PER INCH RESPECTIVELY ON FIRST PAGE BELOW TITLES"
               0
               0  "CALL ROUTINE GRID WHICH RETURNS 'FITS' AND 'ICHPIN' AND 'ILPIN'"
               0  CALL GRID (GRIDWD,GRIDHT,MXLP11,MXLP12,ICHPIN,ILPIN,FITS);
               0
               0  "PRINT HEADER AND GLOBAL INFORMATION"
               0  "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"
               0  "WRITE(IOUT,100)TITLE,TIMEN,DATEN;"
               0  WRITE(IOUT,399);
               0
               0  "PICK LEFT MARGIN"
               0  IF(FITS)[ICENTR=4*ICHPIN;ITLEFT=MAX0(ICENTR+1-((NR*18)+15)/2,2);]
               0  ELSE[ITLEFT=3;]
               0
               0  WRITE(IOUT,400);
               0
               0  WRITE(IOUT,406);WRITE(IOUT,406);  "LEAVE TWO BLANK LINES"
               0
               0  IF(FITS)["THE INPUT SUMMARY FITS ON ONE PAGE"
               1      WRITE(IOUT,406);
               1      $WRITE-INP(1,NC/1,NR);
               1      ]
               0  ELSE["THE INPUT SUMMARY WON'T FIT ONTO ONE PAGE => SPLIT GRID"
               1      NHRST=(NR-1)/6+1;      "NUMBER OF HORIZONTAL SHEETS AT 6 RADIAL"
               1      "BINS/PAGE"
               1      NROW1=(41-3)/BOXHT;    "NUMBER OF ROWS THAT WILL FIT ON FIRST PAGE"
               1      NROW=(66-3)/BOXHT;     "NUMBER OF ROWS THAT WILL FIT ON SUBSEQUENT"
               1      "PAGES, I.E, THOSE WITHOUT LIST OF GLOBALS"
               1      NVRST=(NC-NROW1)/NROW; "NUMBER OF VERTICAL PAGES NEEDED AFTER FIRST"
               1      IF(NVRST*NROW+NROW1.LT.NC)[NVRST=NVRST+1;]
               1      ITTOP1=((66-25)-(NROW1*BOXHT+3))/2; ITTOP2=((66-1)-(NROW*BOXHT+3))/2;
               1      "PRECEEDING LINE CENTERS THE OUTPUT VERTICALLY ON THE PAGE"
               1      "INITIALIZE VARIABLES TO KEEP LEFT AND RIGHT MOST SPH. NOS. ON PAGE"
               1      IF(NR.LT.6)[IHRSTR=NR;]ELSE[IHRSTR=6;]
               1      IHRSTL=1;
               1      DO IHRST=1,NHRST[
               2          "IVRSTB, GREATEST CONICAL REGION NUMBER TO APPEAR ON THE PAGE"
               2          IVRSTB=NROW1;
               2          IF(IHRST.EQ.1)[DO L=1,ITTOP1+1[WRITE(IOUT,406);]]
               2          ELSE[
               3              WRITE(IOUT,408);
               3              "WRITE(IOUT,100) TITLE,TIMEN,DATEN;"
               3              WRITE(IOUT,399);
               3              WRITE(IOUT,400);
               3              DO L=1,ITTOP1+1[WRITE(IOUT,406);]
               3              ]
               2          $WRITE-INP(1,IVRSTB/IHRSTL,IHRSTR);
               2          DO IVRST=1,NVRST[
               3              IVRSTT=IVRSTB+1;
               3              IF(IVRST.EQ.NVRST)[IVRSTB=NC;]
               3              ELSE[IVRSTB=IVRSTB+NROW;]
               3              WRITE(IOUT,408);
               3              IF(ITTOP2.GE.1)[DO L=1,ITTOP2[WRITE(IOUT,406);]]
               3              $WRITE-INP(IVRSTT,IVRSTB/IHRSTL,IHRSTR);
               3              ]
               2          IHRSTL=IHRSTR+1;
               2          IF(IHRST+1.EQ.NHRST)[IHRSTR=NR;]
               2          ELSE[IHRSTR=IHRSTR+6;]
               2          ]   "END OF DO LOOP"
               1      ]   "END OF DOESN'T FIT"
               0
               0  "CALL PRNTER(13,6,IOUT,0);"
               0
               0  RETURN;
               0  %I0                                                                            ;
               0  "FORMATS"
               0  "100    FORMAT('1',80A1//'CALN USING CAVSPHnrc(EGSnrc) '$VERSION' ',"
               0  "             /'ON '$MACHINE' ',T60,$TIMEN_FORMAT,1X,$DATEN_FORMAT);"
               0  200    FORMAT(' ',79('*')/
               0               /,T20,'MONTE CARLO, TRANSPORT, AND SCATTER CONTROLS'/
               0               /,79('*')/
               0               //T20,'MAX # OF HISTORIES TO RUN',T58,I12/
               0               ' ',T20,'MAX # OF HISTORIES TO ANALYZE',T58,I12/
               0               ' ',T20,'INCIDENT CHARGE',T63,I2);
               0  201    FORMAT(' ',T20,'INCIDENT KINETIC ENERGY',T57,F9.3,' (MeV)');
               0  210    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,'DEFAULT');
               0  211    FORMAT(' ',T20,'FRACTIONAL ELECTRON ENERGY/STEP',T60,F5.3);
               0  220    FORMAT(' ',T20,'MAXIMUM GLOBAL ELECTRON STEP SIZE',
               0                       T60,1PE10.3,' (cms)'/
               0               ' ',T20,'GLOBAL ELECTRON TRANSPORT CUT-OFF',
               0                       T56,0PF9.3,' (MeV)'/
               0               ' ',T20,'GLOBAL PHOTON TRANSPORT CUT-OFF',
               0                       T56,F9.3,' (MeV)');
               0  230    FORMAT(' ',T20,'MIN/MAX PHOTON STEP FORCED',T60,I6,'/',I6);
               0  231    FORMAT(' ',T20,'PHOTON FORCE INTERACTION SWITCH',T60,'OFF');
               0  242    FORMAT(' ',T20,'RANGE REJECTION SWITCH OUTSIDE CAVITY',T60,'ON');
               0  243    FORMAT(' ',T20,'RANGE REJECTION SWITCH INSIDE CAVITY',T60,'ON');
               0  244    FORMAT(' ',T20,'RANGE REJECTION SWITCH',T60,'OFF');
               0  250    FORMAT(' ',T20,'RANGE REJECTION PARAMETERS:'/
               0               ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7/
               0               ' ',T20,F9.3,' (MeV) TO ',F9.3,' (MeV)',T59,E14.7,'/',E14.7);
               0  255    FORMAT(T20,'CAVITY REGION IS DEFINED INTERIOR TO RADII',I3,' and',I3);
               0  258    FORMAT(' ',T20,' ZONAL DISCARD OF CHARGE PARTICLES BELOW',
               0               T57,F9.3,' (MeV) kinetic energy');
               0  260    FORMAT(' ',T20,'MAXIMUM CPUTIME ALLOWED',T59,F5.2,' (hrs)'/
               0               ' ',T20,'STATS IN CAVITY OBJECTIVE',T59,F6.3,' %'/
               0               ' ',T20,'1ST INITIAL RANDOM NUMBER SEED',T57,I12/
               0               ' ',T20,'2ND INITIAL RANDOM NUMBER SEED',T57,I12);
               0  265    FORMAT(' ',T20,'RUS ROU FOR PHOTONS CROSSING Z = ',T60,F10.3,' cm'/
               0              T25,'WITH PROBABILITY OF SURVIVAL:',T60,F7.4);
               0  266    FORMAT(' ',T20,'PATHLENGTH EXPONENTIAL TRANSFORMATION'/T25,
               0              'VARIABLE FOR FORWARD GOING PHOTNS: ',T60,F10.3);
               0  267    FORMAT(' ',T20,'DISCARD ALL ELECTRONS BELOW:',T60,F7.3/T25,
               0              'IF TOO FAR FROM CLOSEST BOUNDRY');
               0  270    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'OFF');
               0  271    FORMAT(' ',T20,'RAYLEIGH (COHERENT) SCATTERING',T60,'ON');
               0  272    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'OFF');
               0  273    FORMAT(' ',T20,'PHOTOELECTRON ANGULAR SAMPLING',T60,'ON');
               0  288    FORMAT(' ',T20,'*** WARNING *** DNEAR CALLS REDUCTION AND RANGE',
               0              ' REJECTION BOTH INVOKED');
               0  300    FORMAT(' ',79('*')/
               0               // ,T20,'MATERIAL SUMMARY   ',I1,' MATERIALS USED'/
               0               // ,79('*')/
               0               //'# MATERIAL  DENSITY(g/cm**3)',6X,'AE(MeV)',4X,'AP(MeV)',
               0                   9X,'UE(MeV)',4X,'UP(MeV)'/
               0               ' - --------  ----------------',6X,'-------',4X,'-------',
               0                   9X,'-------',4X,'-------');
               0  305  FORMAT(T22,' REGION(',I4,') HAS FLUORESCENT X-RAYS FOR Z=',I3);
               0  306  FORMAT(T20,' REGIONS WITH FLUORESCENT X-RAYS FOLLOW: ');
               0  307  FORMAT(T20,' FLUORESCENT X-RAYS ARE DISCARDED');
               0  310    FORMAT(' ',I1,3X,6A1,4X,1PE10.3,2(7X,0PF9.3,2X,F9.3));
               0  399    FORMAT(// ,' ZONAL VARIABLES-NONROTATED OUTPUT'/' ',
               0              '*********************************');
               0  400    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
               0              ' ',18X,'X = "*" IF CAVITY REGION'/
               0              ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
               0              ' ','MASS',13X,': MASS OF THE REGION IN GRAMS');
               0  401    FORMAT(// ,'#IRL/X/MED/ : #IRL = GEOMETRY REGION NUMBER'/
               0              ' ',18X,'X = "*" IF DOSE SCORING REGION'/
               0              ' ',18X,'MEDIUM, FIRST 6 CHARACTERS ONLY'/
               0              ' ','THICK',12X,': THICKNESS OF REGION IN g/cm**2');
               0  406    FORMAT(' ');
               0  408    FORMAT('1');
               0  :4110: FORMAT(' ',3X,F9.4);
               0  :4111: FORMAT('+',T20,3X,F9.4);
               0  :4112: FORMAT('+',T38,3X,F9.4);
               0  :4113: FORMAT('+',T56,3X,F9.4);
               0  :4114: FORMAT('+',T74,3X,F9.4);
               0  :4115: FORMAT('+',T92,3X,F9.4);
               0  :4116: FORMAT('+',T110,3X,F9.4);
               0  416    FORMAT(' ',F9.4,'|');
               0  :4170: FORMAT('+',T12,17('-'),'|');
               0  :4171: FORMAT('+',T30,17('-'),'|');
               0  :4172: FORMAT('+',T48,17('-'),'|');
               0  :4173: FORMAT('+',T66,17('-'),'|');
               0  :4174: FORMAT('+',T84,17('-'),'|');
               0  :4175: FORMAT('+',T102,17('-'),'|');
               0  :4180: FORMAT(' ',T12,'(',I2,')');
               0  :4181: FORMAT('+',T30,'(',I2,')');
               0  :4182: FORMAT('+',T48,'(',I2,')');
               0  :4183: FORMAT('+',T66,'(',I2,')');
               0  :4184: FORMAT('+',T84,'(',I2,')');
               0  :4185: FORMAT('+',T102,'(',I2,')');
               0  :4186: FORMAT('+',T120,'(',I2,')');
               0  :4220: FORMAT(' ',T11,'|',17X,'|');
               0  :4221: FORMAT('+',T29,'|',17X,'|');
               0  :4222: FORMAT('+',T47,'|',17X,'|');
               0  :4223: FORMAT('+',T65,'|',17X,'|');
               0  :4224: FORMAT('+',T83,'|',17X,'|');
               0  :4225: FORMAT('+',T101,'|',17X,'|');
               0  :4270: FORMAT(' ',T11,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4271: FORMAT('+',T29,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4272: FORMAT('+',T47,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4273: FORMAT('+',T65,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4274: FORMAT('+',T83,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4275: FORMAT('+',T101,'| #',I3,'/',A1,'/',6A1,'/  |');
               0  :4320: FORMAT(' ',10X,'|',T12,' MASS ',1PE10.3,' |');
               0  :4321: FORMAT('+',T30,' MASS ',1PE10.3,' |');
               0  :4322: FORMAT('+',T48,' MASS ',1PE10.3,' |');
               0  :4323: FORMAT('+',T66,' MASS ',1PE10.3,' |');
               0  :4324: FORMAT('+',T84,' MASS ',1PE10.3,' |');
               0  :4325: FORMAT('+',T102,' MASS ',1PE10.3,' |');
               0  :4370: FORMAT(' ',10X,'|',T12,' THICK ',1PE10.3,' |');
               0  :4371: FORMAT('+',T30,' THICK ',1PE10.3,'|');
               0  :4372: FORMAT('+',T48,' THICK ',1PE10.3,'|');
               0  :4373: FORMAT('+',T66,' THICK ',1PE10.3,'|');
               0  :4374: FORMAT('+',T84,' THICK ',1PE10.3,'|');
               0  :4375: FORMAT('+',T102,' THICK ',1PE10.3,'|');
               0  :4720: FORMAT(' ',T10,'(',I2,')',14X);
               0  :4721: FORMAT('+',T28,'(',I2,')',14X);
               0  :4722: FORMAT('+',T46,'(',I2,')',14X);
               0  :4723: FORMAT('+',T64,'(',I2,')',14X);
               0  :4724: FORMAT('+',T82,'(',I2,')',14X);
               0  :4725: FORMAT('+',T100,'(',I2,')',14X);
               0  :4726: FORMAT('+',T118,'(',I2,')');
               0  474    FORMAT(' ');
               0
               0  END; "LAST LINE OF SUBROUTINE ISUMRY"
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
1              0  %E     "cavsphnrc.mortran"
               0  "*************************************************************************
               0  "
               0  SUBROUTINE OSUMRY;
               0  "
               0  "************************************************************************
               0
               0  COMIN/GEOM,IODAT1,IODAT2,IODAT3,IODAT4,PRINTC,SCORE,SOURCE,USER/;
               0  COMIN/CH-Steps/;
               0
               0  REAL*4 KSCT,KATT,KWLL,KPN,KFL,KSCTUN,KATTUN,KWLLUN,KPNUN,KFLUN;
               0
               0  "SET UP THE PRINTER"
               0  ICHPIN=12; "12 CHARACTERS/INCH"
               0  ILPIN=6;   "6 LINES/INCH"
               0  IPAGE=0;   "NO PAGE THROW"
               0  "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"
               0
               0  "WRITE(IOUT,100)TITLE,DATEN,TIMEN; HEADER"
               0
               0  "PRINT # CHARGED PARTICLE STEPS/# TIMES MS SWITCHED OFF/RATIO"
               0  IMS=FN;IST=FD;WRITE(IOUT,200) IST,FDUN,IMS,FNUN,FMS,FMSUN;
               0
               0  "PRINT # CHARGED PARTICLE STEPS IN DOSE REGION/# TIMES MS SWITCHED OFF/RATIO"
               0  IMSC=FCN;ISTC=FCD;WRITE(IOUT,210) ISTC,FCDUN,IMSC,FCNUN,FMSC,FMSCUN;
               0
               0  write(6,*);
               0  write(6,*) ' Total number of p-II steps: ',count_pII_steps;
               0  write(6,*) ' Total number of steps:      ',count_all_steps;
               0  write(6,*);
               0
               0  IF(IFULL.EQ.3)["PRINT STEPS OUTPUT FOR THE CORRELATED PART OF THE RUN"
               1
               1      "PRINT # CHARGED PARTICLE STEPS/# TIMES MS SWITCHED OFF/RATIO"
               1      IMS=FSM;IST=FTM;WRITE(IOUT,220) IST,FTMUN,IMS,FSMUN,FMM,FMMUN;
               1
               1      "PRINT # CHARGED PARTICLE STEPS IN DOSE REGION/# TIMES MS SWITCHED OFF/RATIO
               1      IMSC=FSMC;ISTC=FTMC;WRITE(IOUT,230) ISTC,FTMCUN,IMSC,FSMCUN,FMMC,FMMCUN;
               1
               1      ]
               0
               0  "PRINT WARNING IF IDNEAR WAS SET"
               0  IF(IDNEAR.EQ.0) WRITE(IOUT,150);
               0
               0  "THE CAVITY SUMMARY"
               0  "******************"
               0
               0  IF(numcavreg.EQ.1)[WRITE(IOUT,300);]ELSE[WRITE(IOUT,301)numcavreg;]
               0
               0  "******************"
               0  "history by history"
               0  "     EMH Jan. 2002"
               0  "******************"
               0  "IF( use_enhance | n_split > 1 ) ["
               0
               0  cav2_dose = cav2_dose/cav_dose;
               0  IF (iifano = 1) [
               1      write(iout,'(/t20,a)')
               1      'This calculation was performed using regeneration ';
               1      write(iout,'(t20,a/)')
               1      '================================================= ';
               1      write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
               1      'D/Awall (grays/incident fluence): ',cav_dose,' +/-  ',
               1      100*cav2_dose,'%';
               1      return;
               1      ]
               0
               0  IF( use_enhance ) [
               1      write(iout,'(/t20,a)')
               1      'This calculation was performed using CS enhancement ';
               1      write(iout,'(t20,a,f10.2)')
               1      '  enhancement factor was ',cs_enhance;
               1      write(iout,'(t20,a)')
               1      '=================================================== ';
               1      ]
               0  ELSEIF ( n_split > 1 ) [
               1      write(iout,'(/t20,a)')
               1      'This calculation was performed using photon splitting ';
               1      write(iout,'(t20,a,i6)') '  splitting number was ',n_split;
               1      write(iout,'(t20,a)')
               1      '===================================================== ';
               1      ]
               0  ELSE [
               1      write(iout,'(/t20,a)')
               1      'Results using history by history scoring scheme';
               1      write(iout,'(t20,a)')
               1      '===================================================== ';
               1      ]
               0
               0  write(iout,'(//a,T50,1PE11.4,a,0PF6.3,a)')
               0  'TOTAL DOSE (GRAYS/INCIDENT FLUENCE):',cav_dose,
               0  ' +/-  ',100*cav2_dose,'%';
               0  IF( ifull > 0 ) [
               1      cav2_dose1 = cav2_dose1/cav_dose1;
               1      cav_dosec = cav_dosec/cav_dose/cav_dose1;
               1
               1      write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
               1      'Total dose/Awall (grays/incident fluence): ',cav_dose1,' +/-  ',
               1      100*cav2_dose1,'%';
               1      cav_dosec = cav2_dose*cav2_dose + cav2_dose1*cav2_dose1 - 2*cav_dosec;
               1      IF( cav_dosec > 0 ) cav_dosec = sqrt(cav_dosec);
               1      write(iout,'(a,t50,0pf8.5,a,f6.3,a)')
               1      'Awall: ',cav_dose/cav_dose1,'    +/-  ',100*cav_dosec,'%';
               1
               1      IF( use_enhance | n_split > 1 ) return;
               1
               1      "******************"
               1      "history by history"
               1      "******************"
               1      corr_02 = corr_02/(cav_dose0+cav_dose2);
               1
               1      cav2_dose0 = cav2_dose0/cav_dose0;
               1      cav2_dose2 = cav2_dose2/cav_dose2;
               1
               1      cav_dosec01 = cav_dosec01/cav_dose0/cav_dose1;
               1      cav_dosec02 = cav_dosec02/cav_dose0/cav_dose2;
               1
               1      cav_dosec01 = cav2_dose0*cav2_dose0 + cav2_dose1*cav2_dose1 - 2*cav_dosec01;
               1      cav_dosec02 = cav2_dose0*cav2_dose0 + cav2_dose2*cav2_dose2 - 2*cav_dosec02;
               1
               1      IF( cav_dosec01 > 0 ) cav_dosec01 = sqrt(cav_dosec01);
               1      IF( cav_dosec02 > 0 ) cav_dosec02 = sqrt(cav_dosec02);
               1
               1      "... we had rel.error(x), get now rel.error(1+x)"
               1      cav_dosec02 = cav_dosec02/(1 + cav_dose0/cav_dose2);
               1
               1
               1      write(iout,'(a,t50,f8.5,a,f6.3,a)')
               1      'Aatt: ',cav_dose0/cav_dose1,'    +/-  ',100*cav_dosec01,'%';
               1
               1      write(iout,'(a,t50,f8.5,a,f6.3,a)')
               1      'Ascat: ',1+cav_dose2/cav_dose0,'    +/-  ',100*cav_dosec02,'%';
               1
               1      write(iout,'(a,t50,1PE11.4,a,0PF6.3,a)')
               1      'Dpr + Dsec: ',cav_dose2+cav_dose0,' +/-  ',100*corr_02,'%';
               1
               1      write(iout,'(//t20,a)')
               1      '===================================================== ';
               1      ]
               0  "******************"
               0  "end of changes for"
               0  "inclusion of the  "
               0  "history by history"
               0  "scoring scheme.   "
               0  "    EMH March 2002"
               0  "******************"
               0
               0
               0
               0  IF (ifano.eq.1)
               0  [
               1      write(iout,*) 'This calculation was performed using regeneration ';
               1      ]
               0
               0  IF (ifano.eq.2)
               0  [
               1      write(iout,*) 'This calculation was performed eliminating electrons';
               1      write(iout,*) 'originating in the cavity wall.';
               1      ]
               0
               0
               0  write(iout,'(//)');
               0  write(iout,'(/t20,a)')
               0  'Results using a batch scoring scheme';
               0  write(iout,'(t20,a)')
               0  '===================================================== ';
               0
               0  "THE TOTAL DOSE"
               0  WRITE(IOUT,310)SCAV(1),SCAVUN(1);
               0
               0  IF(IFULL.GE.1)[
               1      "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"
               1
               1      "Ascat: SCAV(2)=Ascat-1"
               1      ASCT=1.+SCAV(2);
               1      IF((SCAV(2).EQ.0.0).OR.(SCAVUN(2).EQ.99.9))["BAD STATS"
               2          ASCTUN=ABS(SCAV(2));
               2          ]
               1      ELSE["CALCULATE FIRST ORDER STATS"
               2          ASCTUN=SCAV(2)*SCAVUN(2)/100.;
               2          ]
               1      WRITE(IOUT,320)ASCT,ASCTUN;
               1
               1      "Aatt: SCAV(3)=1/Aatt-1"
               1      IF(SCAV(3).EQ.-1.0)["HIGHLY IMPROBABLE CASE"
               2          AATT=1.;AATTUN=0.;
               2          ]
               1      ELSE[
               2          AATT=1./(SCAV(3)+1.);
               2          IF((SCAV(3).EQ.0.0).OR.(SCAVUN(3).EQ.99.9))["BAD STATS"
               3              AATTUN=ABS(1.-AATT);
               3              ]
               2          ELSE["CALCULATE FIRST ORDER STATS"
               3              AATTUN=(SCAV(3)*SCAVUN(3)/100.)*AATT**2;
               3              ]
               2          ]
               1      WRITE(IOUT,330)AATT,AATTUN;
               1
               1      "Awall: Awall = Ascat * Aatt"
               1      AWLL=ASCT*AATT;
               1      "CALCULATE FIRST ORDER STATS"
               1      AWLLUN=AWLL*SQRT((ASCTUN/ASCT)**2+(AATTUN/AATT)**2);
               1      WRITE(IOUT,340)AWLL,AWLLUN;
               1
               1      "TOTAL DOSE/Awall"
               1      TDAW=TTDA(1);TDAWUN=TTDAUN(1);
               1      WRITE(IOUT,350)TDAW,TDAWUN;
               1
               1      ] "END OF IFULL >= 1"
               0
               0  IF(IFULL.GE.2)[
               1      "CALCULATE Apn, AND DOSE/(Awall*Apn)"
               1
               1      IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES"
               2          "Apn: SCAV(4)=Apn"
               2          IF(SCAV(4).EQ.0.0)["HIGHLY IMPROBABLE CASE"
               3              APN=1.;APNUN=0.;
               3              ]
               2          ELSE[
               3              APN=SCAV(4);
               3              IF((SCAV(4).EQ.0.0).OR.(SCAVUN(4).EQ.99.9))["BAD STATS"
               4                  APNUN=ABS(SCAV(4));
               4                  ]
               3              ELSE["CALCULATE FIRST ORDER STATS"
               4                  APNUN=ABS(SCAV(4)*SCAVUN(4)/100.);
               4                  ]
               3              ]
               2          WRITE(IOUT,360)APN,APNUN;
               2          "JAN CHANGE: COMMENTED LINES AWAY AND MOVED SECTION TO BELOW"
               2          "ALSO IN CASE OF NON-PT SOURCE UNWEIGHED DOSE MUST BE ACCURATE"
               2          "TOTAL DOSE/(Awall*Apn)"
               2          "TDAA=TTDA(2);TDAAUN=TTDAUN(2);"
               2          "WRITE(IOUT,370)TDAA,TDAAUN;"
               2          ]
               1      ELSE[
               2          TDAA=TDAW;TDAAUN=TDAWUN;
               2          ]
               1      "JAN CHANGE MOVED FROM JUST ABOVE"
               1      "TOTAL DOSE/(Awall*Apn=1)"
               1      TDAA=TTDA(2);TDAAUN=TTDAUN(2);
               1      WRITE(IOUT,370)TDAA,TDAAUN;
               1      "END OF JAN CHANGE"
               1      ] "END OF IFULL >= 2"
               0
               0  IF(IFULL.EQ.3)[
               1
               1      "CALCULATE Afl, TOTAL DOSE/(Awall*Apn*<s>g,w*Afl), AND <s>g,w"
               1      "Afl: SCAV(5)=Afl"
               1      AFL=SCAV(5);
               1      IF((SCAV(5).EQ.0.0).OR.(SCAVUN(5).EQ.99.9))["BAD STATS"
               2          AFLUN=ABS(SCAV(5));
               2          ]
               1      ELSE[ "CALCULATE FIRST ORDER STATS"
               2          AFLUN=ABS(SCAV(5))*SCAVUN(5)/100.;
               2          ]
               1      WRITE(IOUT,380) AFL,AFLUN;
               1
               1      "TOTAL DOSE/(Awall*Apn*Afl)"
               1      TDA3=TTDA(3);TDA3UN=TTDAUN(3);
               1      WRITE(IOUT,390)TDA3,TDA3UN;
               1
               1      "<s>g,w: SCAV(6)=<s>g,w -1"
               1      SRAT=1.+SCAV(6);
               1      IF((SCAV(6).EQ.0.0).OR.(SCAVUN(6).EQ.99.9))["BAD STATS"
               2          SRATUN=ABS(SCAV(6));
               2          ]
               1      ELSE[ "CALCULATE FIRST ORDER STATS"
               2          SRATUN=ABS(SCAV(6))*SCAVUN(6)/100.;
               2          ]
               1      WRITE(IOUT,395) SRAT,SRATUN;
               1
               1      "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
               1      TDAS=TTDA(4);TDASUN=TTDAUN(4);
               1      WRITE(IOUT,396)TDAS,TDASUN;
               1
               1      ] "END OF IFULL = 3"
               0
               0  "OUTPUT Kscat,Katt,Kwall,Kpn,Kfl THE INVERSES OF THE Ai's"
               0  IF(IFULL.GT.0)[
               1      KSCT=1./ASCT;KSCTUN=ASCTUN/ASCT**2;WRITE(IOUT,321)KSCT,KSCTUN;
               1      KATT=1./AATT;KATTUN=AATTUN/AATT**2;WRITE(IOUT,331)KATT,KATTUN;
               1      KWLL=1./AWLL;KWLLUN=AWLLUN/AWLL**2;WRITE(IOUT,341)KWLL,KWLLUN;
               1      IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES ONLY"
               2          KPN=1./APN;KPNUN=APNUN/APN**2;WRITE(IOUT,361)KPN,KPNUN;
               2          ]
               1      ]
               0  IF(IFULL.EQ.3)[
               1      KFL=1./AFL;KFLUN=AFLUN/AFL**2;WRITE(IOUT,381)KFL,KFLUN;
               1      ]
               0
               0  "THE DETAILED OUTPUT FOR EACH CAVITY ZONE"
               0  "****************************************"
               0
               0  IF((IOOPTN.EQ.1).AND.(numcavreg.GT.1))[
               1      "ONLY IF REQUESTED AND MORE THAN ONE CAVITY ZONE"
               1
               1      WRITE(IOUT,400) numcavreg;
               1
               1      "PRINT THE TABLE HEADER"
               1      IF(IFULL.EQ.0)[
               2          WRITE(IOUT,410);
               2          ]
               1      ELSEIF(IFULL.GT.0)[
               2          "SET UP THE PRINTER"
               2          ICHPIN=16; "16 CHARACTERS/INCH"
               2          ILPIN=6;   "6 LINES/INCH"
               2          IPAGE=0;   "NO PAGE THROW"
               2          "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"
               2
               2          IF(IFULL.EQ.1)[WRITE(IOUT,420);]ELSE[WRITE(IOUT,421)];
               2          ]
               1
               1      "LOOP OVER THE CAVITY ZONES"
               1      DO I=1,numcavreg[
               2          IRL=cavreg(I);
               2          $GET-IX-IC(IRL);
               2          IF(IFULL.GE.1)[
               3              "CALCULATE Ascat, Aatt, Awall, DOSE/Awall"
               3
               3              "Ascat: DOSE(IC,IX,2)=Ascat-1"
               3              ASCT=1.+DOSE(IC,IX,2);
               3              IF((DOSE(IC,IX,1).EQ.0.0).OR.(DOSEUN(IC,IX,1).EQ.99.9))["BAD STATS"
               4                  ASCTUN=ABS(DOSE(IC,IX,2));
               4                  ]
               3              ELSE["CALCULATE FIRST ORDER STATS"
               4                  ASCTUN=DOSE(IC,IX,2)*DOSEUN(IC,IX,2)/100.;
               4                  ]
               3
               3              "Aatt: DOSE(IC,IX,3)=1/Aatt-1"
               3              IF(DOSE(IC,IX,3).EQ.-1.0)["HIGHLY IMPROBABLE CASE"
               4                  AATT=1.;AATTUN=0.;
               4                  ]
               3              ELSE[
               4                  AATT=1./(DOSE(IC,IX,3)+1.);
               4                  IF((DOSE(IC,IX,3).EQ.0.0).OR.(DOSEUN(IC,IX,3).EQ.99.9))[
               5                      "BAD STATS"
               5                      AATTUN=ABS(DOSE(IC,IX,3));
               5                      ]
               4                  ELSE["CALCULATE FIRST ORDER STATS"
               5                      AATTUN=(DOSE(IC,IX,3)*DOSEUN(IC,IX,3)/100.)*AATT**2;
               5                      ]
               4                  ]
               3
               3              "Awall: Awall = Ascat * Aatt"
               3              AWLL=ASCT*AATT;
               3              "CALCULATE FIRST ORDER STATS"
               3              AWLLUN=AWLL*SQRT((ASCTUN/ASCT)**2+(AATTUN/AATT)**2);
               3
               3              "TOTAL DOSE/Awall"
               3              TDAW=TDA(IC,IX,1);TDAWUN=TDAUN(IC,IX,1);
               3
               3              ] "END OF IFULL >= 1"
               2
               2          IF(IFULL.GE.2)[
               3              "CALCULATE Apn, AND DOSE/(Awall*Apn)"
               3
               3              IF(IPTSRC.EQ.1)[ "FOR POINT SOURCES"
               4                  "Apn: DOSE(IC,IX,4)=Apn"
               4                  IF(DOSE(IC,IX,4).EQ.0.0)["HIGHLY IMPROBABLE CASE"
               5                      APN=1.;APNUN=0.;
               5                      ]
               4                  ELSE[
               5                      APN=DOSE(IC,IX,4);
               5                      IF((DOSE(IC,IX,4).EQ.0.0).OR.(DOSEUN(IC,IX,4).EQ.99.9))[
               6                          "BAD STATS"
               6                          APNUN=ABS(DOSE(IC,IX,4));
               6                          ]
               5                      ELSE["CALCULATE FIRST ORDER STATS"
               6                          APNUN=ABS(DOSE(IC,IX,4)*DOSEUN(IC,IX,4)/100.);
               6                          ]
               5                      ]
               4
               4                  "TOTAL DOSE/(Awall*Apn)"
               4                  TDAA=TDA(IC,IX,2);TDAAUN=TDAUN(IC,IX,2);
               4                  ]
               3              ELSE[
               4                  APN=1.;APNUN=0.;TDAA=TDAW;TDAAUN=TDAWUN;
               4                  ]
               3
               3              ] "END OF IFULL >= 2"
               2
               2          IF(IFULL.EQ.3)[
               3
               3              "CALCULATE Afl, TOTAL DOSE/(Awall*Apn*<s>g,w*Afl), AND <s>g,w"
               3
               3              "Afl: DOSE(IC,IX,5)=Afl"
               3              AFL=DOSE(IC,IX,5);
               3              IF((DOSE(IC,IX,5).EQ.0.0).OR.(DOSEUN(IC,IX,5).EQ.99.9))["BAD STATS"
               4                  AFLUN=ABS(DOSE(IC,IX,5));
               4                  ]
               3              ELSE[ "CALCULATE FIRST ORDER STATS"
               4                  AFLUN=ABS(DOSE(IC,IX,5))*DOSEUN(IC,IX,5)/100.;
               4                  ]
               3
               3              "TOTAL DOSE/(Awall*Apn*Afl)"
               3              TDA3=TDA(IC,IX,3);TDA3UN=TDAUN(IC,IX,3);
               3
               3              "<s>g,w: DOSE(IC,IX,6) = <s>g,w -1"
               3              SRAT=1.+DOSE(IC,IX,6);
               3              IF((DOSE(IC,IX,6).EQ.0.0).OR.(DOSEUN(IC,IX,6).EQ.99.9))["BAD STATS"
               4                  SRATUN=ABS(DOSE(IC,IX,6));
               4                  ]
               3              ELSE[ "CALCULATE FIRST ORDER STATS"
               4                  SRATUN=ABS(DOSE(IC,IX,6))*DOSEUN(IC,IX,6)/100.;
               4                  ]
               3
               3              "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
               3              TDAS=TDA(IC,IX,4);TDASUN=TDAUN(IC,IX,4);
               3
               3              ] "END OF IFULL = 3"
               2
               2          "PRINT OUT RESULTS FOR EACH ZONE"
               2
               2          IF(IFULL.EQ.0)[
               3              WRITE(IOUT,430)
               3              IRL,IC,IX,                     "POSITION"
               3              DOSE(IC,IX,1),DOSEUN(IC,IX,1); "TOTAL DOSE"
               3              ]
               2
               2          ELSEIF(IFULL.EQ.1)[
               3              WRITE(IOUT,440)
               3              IRL,IC,IX,                     "POSITION"
               3              DOSE(IC,IX,1),DOSEUN(IC,IX,1), "TOTAL DOSE"
               3              ASCT,ASCTUN,                   "Ascat"
               3              AATT,AATTUN,                   "Aatt"
               3              AWLL,AWLLUN,                   "Awall"
               3              TDAW,TDAWUN;                   "TOTAL DOSE/Awall"
               3              ]
               2
               2          ELSEIF(IFULL.EQ.2)[
               3              WRITE(IOUT,445)
               3              IRL,IC,IX,                     "POSITION"
               3              DOSE(IC,IX,1),DOSEUN(IC,IX,1), "TOTAL DOSE"
               3              ASCT,ASCTUN,                   "Ascat"
               3              AATT,AATTUN,                   "Aatt"
               3              AWLL,AWLLUN,                   "Awall"
               3              TDAW,TDAWUN,                   "TOTAL DOSE/Awall"
               3              APN, APNUN,                    "Apn"
               3              TDAA,TDAAUN;                   "TOTAL DOSE/(Awall*Apn)"
               3              ]
               2          ELSEIF(IFULL.EQ.3)[
               3              WRITE(IOUT,450)
               3              IRL,IC,IX,       "POSITION"
               3              DOSE(IC,IX,1),   "TOTAL DOSE"
               3              ASCT,            "Ascat"
               3              AATT,            "Aatt"
               3              AWLL,            "Awall"
               3              TDAW,            "TOTAL DOSE/Awall"
               3              APN,             "Apn"
               3              TDAA,            "TOTAL DOSE/(Awall*Apn)"
               3              AFL,             "Afl"
               3              TDA3,            "TOTAL DOSE/(Awall*Apn*Afl)"
               3              SRAT,            "<s>g,w"
               3              TDAS,            "TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
               3              DOSEUN(IC,IX,1), "UNCERTAINTY IN TOTAL DOSE"
               3              ASCTUN,          "UNCERTAINTY IN Ascat"
               3              AATTUN,          "UNCERTAINTY IN Aatt"
               3              AWLLUN,          "UNCERTAINTY IN Awall"
               3              TDAWUN,          "UNCERTAINTY IN TOTAL DOSE/Awall"
               3              APNUN,           "UNCERTAINTY IN Apn"
               3              TDAAUN,          "UNCERTAINTY IN TOTAL DOSE/(Awall*Apn)"
               3              AFLUN,           "UNCERTAINTY IN Afl"
               3              TDA3UN,          "UNCERTAINTY IN TOTAL DOSE/(Awall*Apn*Afl)"
               3              SRATUN,          "UNCERTAINTY IN <s>g,w"
               3              TDASUN;          "UNCERTAINTY TOTAL DOSE/(Awall*Apn*Afl*<s>g,w)"
               3              ]
               2
               2
               2          ] "END OF LOOP OVER CAVITY ZONES"
               1      ]     "END OF DETAILED SUMMARY"
               0
               0  "RESET UP THE PRINTER"
               0  ICHPIN=12; "12 CHARACTERS/INCH"
               0  ILPIN=6;   "6 LINES/INCH"
               0  IPAGE=0;   "NO PAGE THROW"
               0  "CALL PRNTER(ICHPIN,ILPIN,IOUT,IPAGE);"
               0
               0  RETURN;
               0  %I0                                                                            ;
               0  "FORMATS"
               0  150  FORMAT(// ,T5,'*** WARNING ***  IDNEAR=0, ABOVE RESULTS',
               0              ' INCOMPLETE (NOT ALL STEPS COUNTED)');
               0  200  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS',T51,
               0               I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'# OF TIMES MSCAT SWITCHED OFF',T51,
               0               I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
               0  210  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS IN CAVITY REGION'
               0               ,T51,I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'# TIMES MSCAT SWITCHED OFF IN CAVITY REGION.'
               0               ,T51,I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
               0  220  FORMAT(// ,T8,'STEP COUNTING RESULTS FOR WALL MATERIAL IN THE CAVITY'/
               0               // ,T8,'# PRIMARY CHARGED PARTICLE STEPS',T51,
               0               I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'# OF TIMES MSCAT SWITCHED OFF',T51,
               0               I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
               0  230  FORMAT(// ,T8,'# PRIMARY CHARGED PARTICLE STEPS IN CAVITY REGION'
               0               ,T51,I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'# TIMES MSCAT SWITCHED OFF IN CAVITY REGION.'
               0               ,T51,I12,' +/- ',0PF5.2,'%'/
               0               ' ',T8,'RATIO',T64,F7.3,' +/- ',0PF5.2,'%');
               0  300  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: 1 REGION'/
               0              ' ',T20,'***************************************');
               0  301  FORMAT(// ,T20,'SUM OF RESULTS FOR THE CAVITY: ',I2,' REGIONS'/
               0              ' ',T20,'*****************************************');
               0  310  FORMAT(//'TOTAL DOSE (GRAYS/(INCIDENT FLUENCE):',
               0                T50,1PE11.4,' +/-  ',0PF5.2,'%');
               0  320  FORMAT(' Ascat:',T50,F8.5,'   +/- ',F8.5);
               0  321  FORMAT(//'Kscat:',T50,F8.5,'   +/- ',F8.5);
               0  330  FORMAT(' Aatt :',T50,F8.5,'   +/- ',F8.5);
               0  331  FORMAT(' Katt :',T50,F8.5,'   +/- ',F8.5);
               0  340  FORMAT(' Awall:',T50,F8.5,'   +/- ',F8.5);
               0  341  FORMAT(' Kwall:',T50,F8.5,'   +/- ',F8.5);
               0  350  FORMAT(' TOTAL DOSE/Awall:',
               0                T50,1PE11.4,' +/-  ',0PF5.2,'%');
               0  360  FORMAT(//'Apn  :',T50,F8.5,'   +/- ',F8.5);
               0  361  FORMAT(' Kpn  :',T50,F8.5,'   +/- ',F8.5);
               0  370  FORMAT(' TOTAL DOSE/([Apn]*Awall):',
               0                T50,1PE11.4,' +/-  ',0PF5.2,'%');
               0  380  FORMAT(//'Afl  :',T50,F8.5,'   +/- ',F8.5);
               0  381  FORMAT(' Kfl  :',T50,F8.5,'   +/- ',F8.5);
               0  390  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall):',
               0                T50,1PE11.4,' +/-  ',0PF5.2,'%');
               0  395  FORMAT(//'<s>g,w  :',T50,F8.5,'   +/- ',F8.5);
               0  396  FORMAT(' TOTAL DOSE/(Afl*[Apn]*Awall*<s>g,w):',
               0                T50,1PE11.4,' +/-  ',0PF5.2,'%');
               0  400  FORMAT(// ,T20,'DETAILED RESULTS FOR EACH OF THE ',I4,' CAVITY REGIONS'/
               0              ' ',T20,'****************************************************');
               0  410  FORMAT(//'Z# C# S#     Total Dose     '/
               0              ' -- -- -- -------------------');
               0  420  FORMAT(//'Z# C# S#',
               0              '     Total Dose   ',
               0              '      Ascat      ',
               0              '       Aatt      ',
               0              '      Awall      ',
               0              '  Total Dose/Awall',
               0              '       Apn       ',
               0              ' T Dose/(Awall*Apn)'/
               0              ' -- -- --',
               0              '     ----------   ',
               0              '      -----      ',
               0              '       ----      ',
               0              '      -----      ',
               0              '  ----------------',
               0              '       ---       ',
               0              ' ------------------');
               0  421  FORMAT(//'Z# C# S#',
               0              ' Total Dose',
               0              '   Ascat  ',
               0              '   Aatt   ',
               0              '   Awall  ',
               0              ' Dose/Awall',
               0              '    Apn   ',
               0              ' D/(Aw*Apn)',
               0              '    Afl   ',
               0              ' D/AwApnAfl',
               0              '  <s>g,w  ',
               0              ' D/AwApAf*s'/
               0              ' -- -- --',
               0              ' ----------',
               0              '   -----  ',
               0              '   ----   ',
               0              '   -----  ',
               0              ' ----------',
               0              '    ---   ',
               0              ' ----------',
               0              '    ---   ',
               0              ' ----------',
               0              '  ------  ',
               0              ' ----------');
               0  430  FORMAT(' ',I2,2(1X,I2),1X,1PE11.4,' +/-',0PF5.2,'%');
               0  440  FORMAT(' ',I2,2(1X,I2),
               0                  1X,1PE11.4,'(',0PF5.2,'%)',
               0                  3(F8.5,'(',F7.5,')'),
               0                  1X,1PE11.4,'(',0PF5.2,'%)');
               0  445  FORMAT(' ',I2,2(1X,I2),
               0                  1X,1PE11.4,'(',0PF5.2,'%)',
               0                  3(F8.5,'(',F7.5,')'),
               0                  1X,1PE11.4,'(',0PF5.2,'%)',
               0                  F8.5,'(',F7.5,')',
               0                  1X,1PE11.4,'(',0PF5.2,'%)');
               0  450  FORMAT(' ',I2,2(1X,I2),
               0                  1X,1PE11.4,
               0                  3(1X,F8.5,1X),
               0                  1X,1PE11.4,
               0                  1X,F8.5,1X,
               0                  1X,1PE11.4,
               0                  1X,F8.5,1X,
               0                  1X,1PE11.4,
               0                  1X,F8.5,1X,
               0                  1X,1PE11.4/
               0              ' ','ERRORS = ',
               0                  4X,'(',0PF5.2,'%)',
               0                  3(1X,'(',F7.5,')'),
               0                  4X,'(',0PF5.2,'%)',
               0                  1X,'(',F7.5,')',
               0                  4X,'(',0PF5.2,'%)',
               0                  1X,'(',F7.5,')',
               0                  4X,'(',0PF5.2,'%)',
               0                  1X,'(',F7.5,')',
               0                  4X,'(',0PF5.2,'%)');
               0
               0  END; "END OF SUBROUTINE OSUMRY"
               0
               0  subroutine initialize_range_rejection;
               0
               0  implicit none;
               0
               0  COMIN/ELECIN,GEOM,MISC,USER,MEDIA/;
               0
               0  $INTEGER irl,medium,cavity_medium,ix,IC,neke,lelke,lelec,qel;
               0  $REAL    elke,elke_min,elke_max,rhof,rhof_min,range,max_range,si,sip;
               0  $REAL    eke,ekei,elkei,elktmp,dedxmid,aux,fedep;
               0  $INTEGER lelktmp,j;
               0
               0  write(6,*);
               0  write(6,*) '  initialize_range_rejection';
               0  write(6,*) '  ==========================';
               0  write(6,*);
               0
               0  lelec = -1; qel = 0;
               0  cavity_medium = 0;
               0  "Determin first the cavity medium and check for possible errors"
               0  DO irl = 2,nreg
               0  [
               1      medium = med(irl);
               1      IF( ntrack(irl) = 1 ) [
               2          IF( cavity_medium = 0 ) [
               3              cavity_medium = medium;
               3              write(6,*) ' Cavity medium is med # ',cavity_medium;
               3          ]
               2          ELSE [
               3              IF( medium ~= cavity_medium ) [
               4                  write(6,*)
               4                    ' Warning: cavity composed of several media: ',medium;
               4                  write(6,*)
               4                    ' Turning off range rejection! ';
               4                  irejct = 0;
               4                  return;
               4              ]
               3          ]
               2      ]
               1  ]
               0
               0
               0  " Now determine smallest cylinder encloding the cavity "
               0  " (non-cavity regions composed of cavity material are counted as cavity"
               0  " I think we can safely say that the cavity is bound by the rsph coords.
               0  "
               0  r_cavity_min = 1E10;
               0  r_cavity_max = -1e10;
               0  DO irl = 2,nreg
               0  [
               1      medium = med(irl);
               1      IF( ntrack(irl) = 1 | medium = cavity_medium ) [
               2          $GET-IX-IC(irl);
               2          IF( RSPH(IX-1) < r_cavity_min ) [ r_cavity_min = rsph(ix-1); ]
               2          IF( RSPH(IX) > r_cavity_max ) [ r_cavity_max = rsph(ix); ]
               2      ]
               1  ]
               0  IF ( R_CAVITY_MIN.GT.RSPH(IX) ) [ R_CAVITY_MIN = 0.0; ]
               0
               0  write(6,*) '  The smallest spheres enclosing the cavity are defined by: ';
               0  write(6,*) r_cavity_min,' < r < ',r_cavity_max;
               0  write(6,*);
               0
               0  IF( nmed = 1 ) [
               1      write(6,*) '  There is only one medium in the simulation => ';
               1      write(6,*) '      no additional range-rejection can be done!';
               1      return;
               1  ]
               0
               0  " Now prepare an array for range calculation in the medium with the "
               0  " mallest stopping power (excluding the cavity material)            "
               0  " First determine energy window. We assume that the PEGS data has been "
               0  " checked to cover the necessary energy range                          "
               0  elke_min = -1e10;
               0  elke_max = 1e10;
               0  DO medium = 1,nmed [
               1    IF( medium ~= cavity_medium ) [
               2        neke = meke(medium);
               2        elke = (1 - eke0(medium))/eke1(medium);
               2        IF( elke > elke_min ) [ elke_min = elke; ]
               2        elke = (neke - eke0(medium))/eke1(medium);
               2        IF( elke < elke_max ) [ elke_max = elke; ]
               2    ]
               1  ]
               0  write(6,*) ' Range rejection data will be calculated for ';
               0  write(6,*) Exp(elke_min),' < E < ',Exp(elke_max);
               0
               0  "Then determine the minimum density scaling factor (rhof)"
               0  rhof_min = 1e10;
               0  DO irl = 2,nreg
               0  [
               1      medium = med(irl); $SET-RHOF;
               1      IF( rhof < rhof_min ) [ rhof_min = rhof; ]
               1  ]
               0  write(6,*) ' rhof_min = ',rhof_min;
               0  write(6,*);
               0
               0  rhof = rhof_min;
               0  eker1 = ($MXRANGE-1)/(elke_max - elke_min);
               0  eker0 = $MXRANGE - eker1*elke_max;
               0  "write(6,*) ' eker1 eker0: ',eker1,eker0;
               0  "write(6,*);
               0
               0  " Calculate maxium range for 1st table energy "
               0  elke = (1-eker0)/eker1;
               0  eke = Exp(elke);
               0  max_range = -1e10;
               0  DO medium=1,nmed[
               1      IF( medium ~= cavity_medium ) [
               2          $SET INTERVAL elke,eke;
               2          IF( lelke < 1 ) [ lelke = 1; ]
               2          $COMPUTE-RANGE;
               2          IF( range > max_range ) [ max_range = range; ]
               2      ]
               1  ]
               0  si = 1.02*max_range;
               0
               0  DO j=1,$MXRANGE-1
               0  [
               1      elke = (j+1-eker0)/eker1;
               1      eke = Exp(elke);
               1      max_range = -1e10;
               1      DO medium=1,nmed[
               2          IF( medium ~= cavity_medium ) [
               3              $SET INTERVAL elke,eke;
               3              $COMPUTE-RANGE;
               3              IF( range > max_range ) [ max_range = range; ]
               3          ]
               2      ]
               1      sip = 1.02*max_range;  "A safety factor"
               1      rangerr1(j) = (sip - si)*eker1;
               1      rangerr0(j) = sip - rangerr1(j)*elke;
               1      "write(6,'(4g15.6)') eke,sip,rangerr0(j),rangerr1(j);"
               1      si = sip;
               1  ]
               0  rangerr1($MXRANGE) = rangerr1($MXRANGE-1);
               0  rangerr0($MXRANGE) = rangerr0($MXRANGE-1);
               0
               0  return;
               0  end;
               0
               0  subroutine range_rejection(elke,x,y,z,ir,iq,idisc);
               0
               0  implicit none;
               0
               0  $INTEGER ir,iq,idisc;
               0  $REAL    elke,x,y,z;
               0
               0  COMIN/GEOM,USER/;
               0
               0  $REAL    r2,r,zl,rl,tperp,range;
               0  $INTEGER lelke;
               0
               0  idisc = 0;  "No range discard
               0  IF( ntrack(ir) = 1 ) [ return; ]  "No additional rejection in the cavity
               0  r2 = x*x + y*y + z*z;
               0  IF( r2 >= r_cavity_min*r_cavity_min & r2 <= r_cavity_max*r_cavity_max ) [
               1      return;
               1  ]
               0  r  = Sqrt(r2);
               0  IF( r < r_cavity_min ) [ rl = r_cavity_min - r; ]
               0  ELSE [ rl = r - r_cavity_max; ]
               0
               0  lelke = eker1*elke + eker0;
               0  range = rangerr1(lelke)*elke + rangerr0(lelke);
               0  IF( range <= rl ) [ idisc = 50 + 49*iq; ]
               0
               0  return; end;
               0
               0
               0  "****************************************************************************"
               0
               0  subroutine combine_results(file_name);
               0
               0  "****************************************************************************"
               0  implicit none;
               0  character*(*) file_name;
               0
               0  ;COMIN/SCORE,RANDOM,IODAT2,IODAT4,GEOM,SOURCE/;
               0  "******************************************************* ADDED BY JT, DEC.98"
               0  "*                Variables for post-processing parallel run               *"
               0  "***************************************************************************"
               0  $INTEGER   TMPIST,TMPISTC,TMPIMS,TMPIMSC;      "T> temporary variables
               0  $INTEGER   TMPISM,TMPISMC,TMPIMM,TMPIMMC;      "T> temporary variables
               0  $INTEGER   TMPNCASE;                           "T>temp variable for NCASE
               0  $REAL      TMPDOSE($MAXCDOSE,$MAXRADII,$MAXIT);"T> temporary dose array
               0  $REAL      TMPTMCPU;                           "T>dummy variable for TIMCPU
               0
               0  "$INTEGER   DATCOUNT;                           T>number of .egs4dat files"
               0  "datcount used to be a local variable that holds the number of parallel"
               0  "jobs if irestart=5. As now data file reading from parallel runs is done"
               0  "in a separate routine, it must go into a common block as it is used in"
               0  "main."
               0
               0  "extra components added    "
               0  "to obtain Aatt and Ascat  "
               0  "with a history by history "
               0  "scoring scheme            "
               0  "            EMH March 2002"
               0  real*8 tcav_dose,tcav2_dose,tcav_dose1,tcav2_dose1,tcav_dosec;
               0  real*8 tcav_dose0,tcav2_dose0,tcav_dose2,tcav2_dose2,tcav_dosec01,tcav_dosec02;
               0  "***************************************************************************"
               0
               0  $INTEGER my_unit,egs_get_unit,iout,ic,ix,it,lnblnk1,irl;
               0  $LOGICAL first_time;
               0  data first_time/.true./, iout/1/;
               0  save first_time,iout;
               0
               0  IF( first_time ) [
               1
               1        OUTPUT ;(/1X,'Summing the following .egsdat files');
               1        OUTPUT ; (1X,'------------------------------------'/);
               1        WRITE(IOUT,'(/1X,''Summing the following .egsdat files'')');
               1        WRITE(IOUT,'(1X,''------------------------------------''/)');
               1
               1        datcount=0;
               1        /TMCPUO,NCASEO/=0;
               1        /cav_dose, cav_dose0, cav_dose1, cav_dose2/ =0;
               1        /cav2_dose,cav2_dose0,cav2_dose1,cav2_dose2/=0;
               1        /cav_dosec,cav_dosec01,cav_dosec02/         =0;
               1        first_time = .false.;
               1
               1        DO IS=1,$STAT[
               2          ISTIS(IS)=0; ISTCIS(IS)=0;
               2          IMSIS(IS)=0; IMSCIS(IS)=0;
               2          ISMIS(IS)=0; ISMCIS(IS)=0;
               2          IMMIS(IS)=0; IMMCIS(IS)=0;
               2
               2          DO IC=1,NC[
               3           DO IX=1,NR[
               4            DO IT=1,$MAXIT[
               5               DOSEIS(IC,IX,IT,IS)=0.0;
               5            ]
               4           ]
               3          ]
               2        ]
               1
               1  ]
               0
               0  my_unit = egs_get_unit(4);
               0  WRITE(IOUT,'(A)') $cstring(file_name);
               0  WRITE(6,'(A)') $cstring(file_name);
               0  open(my_unit,file=file_name,status='old',err=:EOF_RS1:);
               0
               0  read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dose, tcav_dose0,
               0                                              tcav_dose1, tcav_dose2;
               0  read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav2_dose,tcav2_dose0,
               0                                              tcav2_dose1,tcav2_dose2;
               0  read(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) tcav_dosec,tcav_dosec01,
               0                                              tcav_dosec02;
               0
               0  cav_dose =cav_dose +tcav_dose; cav_dose0=cav_dose0+tcav_dose0;
               0  cav_dose1=cav_dose1+tcav_dose1;cav_dose2=cav_dose2+tcav_dose2;
               0
               0  cav2_dose  = cav2_dose  + tcav2_dose;
               0  cav2_dose0 = cav2_dose0 + tcav2_dose0;
               0  cav2_dose1 = cav2_dose1 + tcav2_dose1;
               0  cav2_dose2 = cav2_dose2 + tcav2_dose2;
               0
               0  cav_dosec   = cav_dosec   + tcav_dosec;
               0  cav_dosec01 = cav_dosec01 + tcav_dosec01;
               0  cav_dosec02 = cav_dosec02 + tcav_dosec02;
               0
               0
               0  DO IS=1,$STAT[
               1     READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
               1         TMPIST,TMPISTC,TMPIMS,TMPIMSC,
               1         TMPISM,TMPISMC,TMPIMM,TMPIMMC;
               1     ISTIS(IS)=ISTIS(IS)+TMPIST;
               1     ISTCIS(IS)=ISTCIS(IS)+TMPISTC;
               1     IMSIS(IS)=IMSIS(IS)+TMPIMS;
               1     IMSCIS(IS)=IMSCIS(IS)+TMPIMSC;
               1     ISMIS(IS)=ISMIS(IS)+TMPISM;
               1     ISMCIS(IS)=ISMCIS(IS)+TMPISMC;
               1     IMMIS(IS)=IMMIS(IS)+TMPIMM;
               1     IMMCIS(IS)=IMMCIS(IS)+TMPIMMC;
               1
               1     READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:)
               1         (((TMPDOSE(IC,IX,IT),IT=1,$MAXIT),IX=1,NR),IC=1,NC);
               1     DO IC=1,NC[
               2        DO IX=1,NR[
               3           DO IT=1,$MAXIT[
               4              DOSEIS(IC,IX,IT,IS)=DOSEIS(IC,IX,IT,IS)+TMPDOSE(IC,IX,IT);
               4           ]
               3        ]
               2     ]
               1  ]"End of IS loop"
               0
               0  $RETRIEVE RNG STATE FROM UNIT my_unit;
               0  READ(my_unit,*,err=:EOF_RS3:,end=:EOF_RS3:) TMPNCASE,TMPTMCPU;
               0
               0  write(6,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;
               0  write(iout,*) '   ncase = ',TMPNCASE,' cpu time = ',TMPTMCPU;
               0
               0  TMCPUO=TMCPUO+TMPTMCPU; NCASEO=NCASEO+TMPNCASE;
               0
               0  datcount=datcount+1;
               0
               0  CLOSE(UNIT=my_unit);
               0  return;
               0
               0  :EOF_RS1:;
               0  WRITE(6,*) 'failed to open file';
               0  return;
               0
               0  :EOF_RS3:;
               0  write(6,*) 'failed to read file';
               0  close(my_unit); return; end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc ranmar random number generator                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  The following is the initialization routine for the RANMAR random number   "
               0  "  generator (RNG) proposed by Marsaglia and Zaman and designed to be used    "
               0  "  with the EGSnrc system.                                                    "
               0  "                                                                             "
               0  "  Note that this implementation uses integers to store the state of the RNG  "
               0  "  and to generate the next number in the sequence. Only at the end are the   "
               0  "  random numbers are converted to reals by a multiplication with 2**(-24)    "
               0  "  (there are only 24 significant bits). I found the integer implementation   "
               0  "  to be about 30% faster then using reals on Pentium III machines, and       "
               0  "  nearly 70% faster on older SGI workstations.                               "
               0  "                                                                             "
               0  "  The use of RANMAR requires the file ranmar.macros (which defines the       "
               0  "  actual random number generation as a macro).                               "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  subroutine init_ranmar;
               0
               0  implicit none;
               0
               0  ;COMIN/RANDOM/;
               0
               0  integer*4 s,t;
               0  integer*4 i,j,k,l,m,ii,jj;
               0
               0  IF( ixx <= 0 | ixx > 31328 ) ixx = 1802; "Sets Marsaglia default"
               0  IF( jxx <= 0 | jxx > 30081 ) jxx = 9373; "sets Marsaglia default"
               0
               0  i = mod(ixx/177,177) + 2;
               0  j = mod(ixx,    177) + 2;
               0  k = mod(jxx/169,178) + 1;
               0  l = mod(jxx,    169)    ;
               0
               0  DO ii = 1,97 [
               1
               1      s = 0; t = 8388608;  "t is 2**23 i.e. half of the maximum allowed"
               1                           "(note that only 24 bits are used)          "
               1
               1      DO jj = 1,24 [
               2
               2                           "The if( fool_optimizer ...) statements below are"
               2                           "to prevent re-arangement of statements for high "
               2                           "level optimizations and thus different sequences"
               2                           "on different architectures                      "
               2
               2          m = mod(mod(i*j,179)*k,179);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          i = j;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          j = k;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          k = m;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          l = mod(53*l+1,169);
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          IF(mod(l*m,64) >= 32) s = s + t;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2          t = t/2;
               2          IF( fool_optimizer = 999 ) [ write(6,*) i,j,k,m,s,t; ]
               2      ]
               1      urndm(ii) = s;
               1  ]
               0
               0  crndm  =   362436;
               0  cdrndm =  7654321;
               0  cmrndm = 16777213;
               0
               0  twom24 = 1./16777216.;
               0
               0  ixx = 97;
               0  jxx = 33;
               0
               0  rng_seed = $NRANMAR + 1;
               0
               0  return;
               0  end; "End of init_ranmar for EGSnrc"
               0
               0  subroutine ranmar_get;
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $INTEGER i,iopt;
               0  IF( rng_seed = 999999 ) call init_ranmar;
               0  DO i=1,$NRANMAR [
               1      iopt = urndm(ixx) - urndm(jxx);
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      urndm(ixx) = iopt;
               1      ixx = ixx - 1; jxx = jxx - 1;
               1      IF(ixx = 0)        [ ixx = 97; ]
               1      ELSE IF( jxx = 0 ) [ jxx = 97; ]
               1      crndm = crndm - cdrndm;
               1      IF(crndm < 0) crndm = crndm + cmrndm;
               1      iopt = iopt - crndm;
               1      IF(iopt < 0) iopt = iopt + 16777216;
               1      rng_array(i) = iopt;
               1  ]
               0  rng_seed = 1; return; end;
               0
               0  ;"       end of ranmar.mortran    "
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc source calculations in spherical geometry                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Joanne Treurniet, 1999                                    "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This code was originally adapted from SRCRZ.MORPH.MORTRAN by Joanne        "
               0  "  Treurniet in 1999. SRCRZ.MORPH.MORTRAN was written by Eric Fox in 1984,    "
               0  "  and evolved through contributions by Dave Rogers, Alex Bielajew, George    "
               0  "  Ding, Charlie Ma, J.S. and Aaron Merovitz.                                 "
               0  "                                                                             "
               0  "  This subroutine is dedicated exclusively to calculations related to the    "
               0  "  source configuration. It is accessed from four locations:                  "
               0  "                                                                             "
               0  "  1) from the INPUT SUBROUTINE. Control is transferred to this routine to    "
               0  "     read in source specific information. Control is transferred back to the "
               0  "     INPUT SUBROUTINE following these inputs                                 "
               0  "                                                                             "
               0  "  2) from the 'ONE TIME ONLY CONSTANTS' section of the main routine to scale "
               0  "     the geometry of the incident beam and calculate the fluence             "
               0  "                                                                             "
               0  "  3) from the histories loop of the main routine. A call is made prior to    "
               0  "     each history to set the point of entry into the target, the initial     "
               0  "     direction cosines, the initial energy and the statistical weight of the "
               0  "     incident particle.                                                      "
               0  "                                                                             "
               0  "  4) from the input summary routine to print source info                     "
               0  "                                                                             "
               0  "  Fluence is defined at the point on axis at the front face of the geometry. "
               0  "                                                                             "
               0  "  VERSION 1.1  J.Treurniet  4/99    STARTING WITH                            "
               0  "                                    SRCRZ.MORPH.MORTRAN, BY E.F.,            "
               0  "                                    D.W.O.R., A.F.B., B.A.F.,                "
               0  "                                    G.X.D., C.M.Ma, J.S. AND A.M.            "
               0  "                                    and using srcsph.mortran                 "
               0  "                                    sources 0, 1, 10, 11                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %Q1                                                                            ;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  ;
               0  "INPUT/OUTPUT CONTROL MACROS
               0  "***************************
               0  ;
               0  "THIS MACRO IS REQUIRED FOR PRESTA"
               0  ;
               0  "The following is the $CALL-HOWNEAR macro for PRESTA-II
               0  "This routine is intended to be used to calculate the minimum perpendiclar     "
               0  "to the nearest bounding surface. This version is specially designed for the   "
               0  "NRCC spherical geometry package. A different version is needed for other      "
               0  "geometry packages.                                                            "
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0  call hownear({P1},x(np),y(np),z(np),ir(np));
            {  0  }
               0
               0  subroutine hownear(tperp,xx,yy,zz,irl);
               0
               0  $IMPLICIT-NONE;
               0
               0  COMIN/GEOM/;
               0
               0  $REAL
               0  tperp, "nearest distance to any boundary (output)
               0  RHOL, RHOL2, RL,
               0  xx,     "x-position of the particle (input)
               0  yy,     "y-position of the particle (input)
               0  zz;     "z-position of the particle (input)
               0  ;
               0  $INTEGER
               0  IX, IC, IRL;
               0  ;
               0
               0  $GET-IX-IC(IRL);
               0  RHOL2=XX**2+YY**2;
               0  RL=SQRT(RHOL2+ZZ**2);
               0  tperp=RSPH(IX)-RL;
               0  IF(IX.NE.1)[
               1      tperp=MIN(tperp,RL-RSPH(IX-1));
               1      ]
               0  IF(NC.NE.1)[
               1      RHOL=SQRT(RHOL2);
               1      IF(IC.NE.NC)[
               2          tperp=MIN(tperp,ABS(COSALP(IC)*(RHOL-TANALP(IC)*ZZ)));
               2          ]
               1      IF(IC.NE.1)[
               2          tperp=MIN(tperp,ABS(COSALP(IC-1)*(RHOL-TANALP(IC-1)*ZZ)));
               2          ]
               1      ]
               0
               0  return;
               0  end;
               0
               0  ;
               0
               0  "***************************************************************************
               0  SUBROUTINE SRCSPH;             "toc:
               0  "***************************************************************************
               0  !LABELS 1000;
               0  "THIS ENTRY IS USED TO SET VALUES WHICH WILL BE REQUIRED LATER
               0  $IMPLICIT-NONE;
               0
               0  INTEGER LATCH;
               0  $INTEGER ERR15;
               0  CHARACTER*5 LINE1;
               0
               0  $INTEGER i, k, IB, ICOUNT, IERROR, IBNSOK, IRDIST, IRIN, NRCFLG;
               0  $INTEGER IC, ICTST;
               0
               0  $REAL    TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,FNORM;
               0
               0  $REAL    XIN,YIN,ZIN,UIN,VIN,WIN;
               0  $REAL    YINP,ZINP;
               0  $REAL    WEIGHT, RSHADW, RLAST, GRIDSZ;
               0  $INTEGER ICORRL;
               0  $REAL    SCARG1,SCARG2,SCARG3,SCARG4;
               0
               0  $REAL    RNNO1,RNNO2;
               0  $REAL    RHO2,RRHO;
               0
               0  $REAL    D, AK, TNTST2, SPLIT;
               0
               0
               0  "***************************************************************************"
               0  "*            Variables passed to the subroutine GET_INPUTS                *"
               0  "***************************************************************************"
               0  COMIN/GetInput/;
               0
               0  INTEGER NUM_IPART,
               0  NUM_SOURCE,
               0  NUM_SOPTS,
               0  NUM_MODEIN,
               0  NUM_RDFIL,
               0  NUM_NRDIST,
               0  NUM_RDISTF,
               0  NUM_RPDF,
               0  NUM_RDIOUTSP,
               0  NUM_FILSPC;
               0
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0  INTEGER MODEIN;
               0  CHARACTER*80 SPCFIL;
               0
               0  "COMMIN BLOCK DECLARATIONS
               0  "*************************
               0  ;COMIN/GEOM,IODAT2,PRINTC,MEDIA,MISC,SCORE,SOURCE,UPHIOT,USER,RANDOM/;
               0
               0  " At least the following variables must be declared static "
               0  save TEMP1,TEMP2,TEMP3,TEMP4,TEMP5,FNORM,IBNSOK,MODEIN;
               0
               0
               0  "                        INPUT SOURCE PARAMETERS    ""toc:
               0  "                        =======================    ""toc:
               0
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0
               0  "*******************************************************************************
               0  "                             SOURCE INPUT
               0  "                            **************
               0  "*******************************************************************************
               0  " SOURCE DELIMETERS:    :start source inputs:
               0  "                       :stop source inputs:
               0  "
               0  "FOR ALL SOURCES
               0  "                                      Charge of the incident beam
               0  "  INCIDENT PARTICLE= electron   (-1)  electrons
               0  "                     photon     (0)   photons
               0  "                     positron   (1)   positrons
               0  "
               0  "  SOURCE NUMBER                 (I)   number of the source
               0  "                                      [ISOURC]
               0  "
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 0:    FOR PARALLEL BEAM FROM ANY ANGLE
               0  "              RBEAM,UINC,VINC,WINC
               0  "               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
               0  "                               DEFAULTS TO MAX RADIUS
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 1:   FOR POINT SOURCE INCIDENT FROM ANY ANGLE
               0  "             DISTR,RBEAM,UINC,VINC,WINC
               0  "               DISTR   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
               0  "                       IN CM (DEFAULTS TO 100.)
               0  "               RBEAM   RADIUS OF THE BEAM AT THE FRONT OF THE TARGET IN CM
               0  "                               DEFAULTS TO MAX RADIUS
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 10:  FOR PARALLEL BEAM FROM ANY ANGLE WITH RADIAL DISTRIBUTION
               0  "             UINC,VINC,WINC
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 11:  FOR POINT SOURCE INCIDENT FROM ANY ANGLE WITH RADIAL DISTRIBUTION
               0  "             DISTR,RBEAM,UINC,VINC,WINC
               0  "               DISTR   DISTANCE OF THE SOURCE FROM THE MIDDLE OF THE TARGET
               0  "                       IN CM (DEFAULTS TO 100.)
               0  "               UINC    INCIDENT X-AXIS DIRECTION COSINE
               0  "               VINC    INCIDENT Y-AXIS DIRECTION COSINE
               0  "               WINC    INCIDENT Z-AXIS DIRECTION COSINE
               0  "                       NOTE: (UINC,VINC,WINC) GET AUTOMATICALLY NORMALIZED
               0  "                             DEFAULTS TO (0.0,0.0,1.0)
               0  ;
               0  "------------------------------------------------------------------------------
               0  "
               0  " SOURCE 10 OR 11:
               0  "       SPECIFY MODE:
               0  "               MODE = local (0)     IF RADIAL DISTRIBUTION IS TO BE INPUT
               0  "                                    LOCALLY WHETHER THROUGH THE KEYBOARD
               0  "                                    (INTERACTIVE USE) OR THROUGH THE
               0  "                                    .INP FILE (DEFAULT)
               0  "                    = external (1)  IF THE DISTRIBUTION IS TO BE INPUT
               0  "                                    VIA AN EXTERNAL FILE
               0  ;
               0  "       IF MODE=local SPECIFY:
               0  "
               0  "           RDISTF(I)= TOP OF RADIAL BIN I FOR I=1,NBIN
               0  "           RPDF(I)= PROBABILITY OF INITIAL PARTICLE BEING IN BIN I FOR
               0  "                    I=1,NBIN.
               0  "
               0  "                      PROBABILITIES DO NOT NEED TO BE NORMALIZED
               0  "                      BUT SHOULD BE IN UNITS CM**-2
               0  "
               0  "       IF MODE=external SPECIFY:
               0  "
               0  "           RDIST FILNAME = FILENAME(WITH EXT) CONTAINING THE ABOVE INFORMATION
               0  "
               0  "
               0  "       SPECIFY:
               0  "           DISTRIBUTION DATA = NONE => NO DISTRIBUTION DATA IN OUTPUT SUMMARY
               0  "                             = OUTPUT SUMMARY => INCLUDE DISTRIBUTION
               0  "                               DATA IN OUTPUT SUMMARY
               0  ;
               0  "--------------------------------------------------------------------------"
               0  "|                           Required inputs                              |"
               0  "--------------------------------------------------------------------------"
               0
               0  ERR15 = 15;
               0  DELIMETER='SOURCE INPUTS';
               0
               0  IVAL = IVAL + 1;   "IVAL is passed in IODAT2"
               0  NUM_IPART = IVAL;
               0  VALUES_SOUGHT(IVAL)='INCIDENT PARTICLE';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=3;
               0  DEFAULT(IVAL)=0;
               0  ALLOWED_INPUTS(IVAL,3)='ELECTRON';
               0  ALLOWED_INPUTS(IVAL,0)='PHOTON';
               0  ALLOWED_INPUTS(IVAL,1)='POSITRON';
               0  ALLOWED_INPUTS(IVAL,2)='ALL';
               0
               0  IVAL = IVAL + 1;
               0  NUM_SOURCE = IVAL;
               0  VALUES_SOUGHT(IVAL)='SOURCE NUMBER';
               0  NVALUE(IVAL)=1;
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=21;
               0  DEFAULT(IVAL)=0;
               0  $GET_INPUT(NUM_SOURCE);
               0  ISOURC=VALUE(NUM_SOURCE,1);
               0
               0  "************************************************************
               0  " IF ISOURC>4, QUIT.  WE'RE LEAVING THE CODE IN, BUT SOURCES
               0  " 10 AND 11 SEEM TO GO INTO AN INFINITE LOOP AFTER HATCHING
               0  " (On entering srchst) -- JT
               0  " ***********************************************************
               0
               0  IF (ISOURC>4) [
               1      WRITE(ERR15,*);
               1      WRITE(ERR15,*)'***********************ERROR*************************';
               1      WRITE(ERR15,*)'THE SOURCES WITH RADIAL DISTRIBUTIONS ARE NOT';
               1      WRITE(ERR15,*)'AVAILABLE.  IN JUNE 1999, THEY WERE FOUND TO HANG';
               1      WRITE(ERR15,*)'AFTER THE CALL TO HATCH.  THIS HAS NOT AS YET';
               1      WRITE(ERR15,*)'BEEN FIXED SINCE WE HAVE NOT NEEDED THESE SOURCES.';
               1      WRITE(ERR15,*);
               1      ERROR_FLAG=1; RETURN;
               1      ];
               0
               0
               0  IVAL = IVAL + 1;
               0  NUM_SOPTS = IVAL;
               0  VALUES_SOUGHT(IVAL)='SOURCE OPTIONS';
               0  NVALUE(IVAL)=5;
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=-999999;
               0  VALUE_MAX(IVAL)=999999;
               0  DEFAULT(IVAL)=1;
               0
               0  NMIN=NUM_IPART;
               0  NMAX=NUM_SOPTS;
               0  $GET_INPUTS(NMIN,NMAX);
               0
               0  IQIN=VALUE(NUM_IPART,1);
               0  "this is done because VALUE(I,IVAL) cannot have negative array indices"
               0  IF (IQIN=3) [IQIN=-1;]
               0  TEMP1=VALUE(NUM_SOPTS,1);
               0  TEMP2=VALUE(NUM_SOPTS,2);
               0  TEMP3=VALUE(NUM_SOPTS,3);
               0  TEMP4=VALUE(NUM_SOPTS,4);
               0  TEMP5=VALUE(NUM_SOPTS,5);
               0
               0  OUTPUT IQIN,ISOURC,TEMP1,TEMP2,TEMP3,TEMP4;(T10,'SRCSPH READ:', 2I5,4F12.5);
               0
               0  IF((ISOURC.EQ.10).OR.(ISOURC.EQ.11))[ "INCLUDE RADIAL DISTRIBUTION"
               1      IVAL = IVAL + 1;
               1      NUM_MODEIN = IVAL;
               1      VALUES_SOUGHT(IVAL)='MODE';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=1;
               1      ALLOWED_INPUTS(IVAL,0)='LOCAL';
               1      ALLOWED_INPUTS(IVAL,1)='EXTERNAL';
               1      $GET_INPUT(NUM_MODEIN);
               1      MODEIN=VALUE(NUM_MODEIN,1);
               1
               1      IF(MODEIN.EQ.0)[
               2
               2          IVAL = IVAL + 1;
               2          NUM_RDISTF = IVAL;
               2          VALUES_SOUGHT(IVAL)='RDISTF';
               2          TYPE(IVAL)=1;
               2          VALUE_MIN(IVAL)=-999999;
               2          VALUE_MAX(IVAL)=999999;
               2          $GET_INPUT(NUM_RDISTF);
               2
               2          IVAL = IVAL + 1;
               2          NUM_RPDF = IVAL;
               2          VALUES_SOUGHT(IVAL)='RPDF';
               2          TYPE(IVAL)=1;
               2          VALUE_MIN(IVAL)=0;
               2          VALUE_MAX(IVAL)=999999;
               2          $GET_INPUT(NUM_RPDF);
               2
               2          IF(NVALUE(NUM_RDISTF).NE.NVALUE(NUM_RPDF))[
               3              WRITE(ERR15,*);
               3              WRITE(ERR15,*)'**********************ERROR**********************';
               3              WRITE(ERR15,*)'RDISTF HAS',NVALUE(NUM_RDISTF),' VALUES';
               3              WRITE(ERR15,*)'RPDF HAS  ',NVALUE(NUM_RPDF),' VALUES';
               3              WRITE(ERR15,*)'>>> THEY MUST HAVE THE SAME NUMBER OF VALUES <<<';
               3              WRITE(ERR15,*);
               3              ERROR_FLAG=1; RETURN;
               3              ] ELSE [
               3              NRDIST=NVALUE(NUM_RDISTF);
               3              ]
               2          ]
               1      ELSE[ "INPUT FROM SEPARATE SOURCE FILE"
               2          IVAL = IVAL + 1;
               2          NUM_RDFIL = IVAL;
               2          VALUES_SOUGHT(IVAL)='RDIST FILENAME';
               2          NVALUE(IVAL)=1;
               2          TYPE(IVAL)=2;
               2          $GET_INPUT(NUM_RDFIL);
               2          READ (CHAR_VALUE(NUM_RDFIL,1),FMT='(A)') SPCFIL;
               2          ]
               1      NUM_RDIOUTSP = IVAL;
               1      VALUES_SOUGHT(IVAL)='DISTRIBUTION DATA';
               1      NVALUE(IVAL)=1;
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=0;
               1      ALLOWED_INPUTS(IVAL,0)='NONE';
               1      ALLOWED_INPUTS(IVAL,1)='OUTPUT SUMMARY';
               1      $GET_INPUT(NUM_RDIOUTSP);
               1      IOUTSP=VALUE(NUM_RDIOUTSP,1);
               1
               1      IF(IOUTSP.NE.1) IOUTSP=0;
               1      ]
               0
               0  IF((IQIN.LT.-1).OR.(IQIN.GT.1)) IQIN=0;
               0
               0  SVTMP1=TEMP1;SVTMP2=TEMP2;SVTMP3=TEMP3;SVTMP4=TEMP4;
               0
               0
               0  RETURN;
               0
               0
               0  ENTRY SRCINI(SCARG1,SCARG2,SCARG3,SCARG4,ICORRL);
               0  " The arguments to this call aren't used here.  They were probably used
               0  " for a source type not yet defined for sph, so I'll leave it in -- JT
               0
               0  IF((ISOURC.NE.0).AND.(ISOURC.NE.1).AND.(ISOURC.NE.4).AND.
               0  (ISOURC.NE.10).AND.(ISOURC.NE.11))[
               1      "DEFAULT SOURCE TYPE- PARALLEL BEAM FROM THE FRONT"
               1      ISOURC=0;TEMP1=0.0;TEMP2=0.0;TEMP3=0.0;TEMP4=1.0;
               1      ]
               0
               0  IF(ISOURC.EQ.0)[
               1      "PARALLEL BEAM AT ANY ANGLE"
               1      RBEAM=TEMP1;
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.RSPH(NR)))RBEAM=RSPH(NR);
               1      FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
               1      IF(FNORM.EQ.0.0)[
               2          UINC=0.0;VINC=0.0;WINC=1.0;
               2          ]
               1      ELSE[
               2          "TO SIMPLIFY, THE BEAM IS ROTATED SO THAT THERE IS NO         "
               2          "U-COMPONENT. THIS IS ALLOWED BY THE SYMMETRY OF THE GEOMETRY."
               2          FNORM=SQRT(FNORM);
               2          WINC=TEMP4/FNORM;
               2          VINC=SQRT((1.0-WINC)*(1.0+WINC));
               2          UINC=0.0;
               2          ]
               1      OUTPUT IQIN,RBEAM,UINC,VINC,WINC;
               1      (' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' PARALLEL BEAM AT ANY ANGLE'/
               1      ' RADIUS OF THE BEAM ON THE TARGET:',T60,F10.4,' cm'/
               1      ' X-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.1)[
               1      "POINT SOURCE AT ANY ANGLE"
               1      DISTR=ABS(TEMP1);
               1      IF(DISTR.LE.RSPH(NR))DISTR=100.;          "DEFAULT"
               1      IF(DISTR.LE.RSPH(NR))DISTR=100.+RSPH(NR); "DEFAULT FOR BIG TARGET"
               1      RBEAM=TEMP2;
               1      "RSHADW=MAXIMUM BEAM RADIUS ALLOWED BY SHADOWING"
               1      RSHADW=(RSPH(NR)/DISTR)*SQRT((DISTR+RSPH(NR))*(DISTR-RSPH(NR)));
               1      IF((RBEAM.LE.0.0).OR.(RBEAM.GT.RSHADW))RBEAM=RSHADW;
               1      FNORM=TEMP3**2+TEMP4**2+TEMP5**2;
               1      IF(FNORM.EQ.0.0)[
               2          UINC=0.0;VINC=0.0;WINC=1.0;
               2          ]
               1      ELSE[
               2          "TO SIMPLIFY, THE BEAM IS ROTATED SO THAT THERE IS NO         "
               2          "U-COMPONENT. THIS IS ALLOWED BY THE SYMMETRY OF THE GEOMETRY."
               2          FNORM=SQRT(FNORM);
               2          WINC=TEMP5/FNORM;
               2          VINC=SQRT((1.0-WINC)*(1.0+WINC));
               2          UINC=0.0;
               2          ]
               1      OUTPUT IQIN,DISTR,RBEAM,UINC,VINC,WINC;
               1      (' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' POINT SOURCE BEAM AT ANY ANGLE'/
               1      ' SOURCE DISTANCE TO THE MIDDLE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' RADIUS OF THE BEAM ON THE TARGET:',T60,F10.4,' cm'/
               1      ' X-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.4)["point spread function calculation"
               1
               1      "DO NOTHING, I.E.:"
               1      "XIN = YIN = ZIN = 0.0"
               1      "UIN = VIN = 0.0; WIN = 1.0"
               1      OUTPUT;
               1      ('PARTICLE LOCATED AT ORIGIN',
               1      ' MOVING PARALLEL TO Z-AXIS',/
               1      'USED FOR POINT SPREAD FUNCTION CALCULATIONS')
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.10)[
               1      "PARALLEL BEAM AT ANY ANGLE WITH RADIAL DISTRIBUTION"
               1      FNORM=TEMP1**2+TEMP2**2+TEMP3**2;
               1      IF(FNORM.EQ.0.0)[
               2          UINC=0.0;VINC=0.0;WINC=1.0;
               2          ]
               1      ELSE[
               2          "TO SIMPLIFY, THE BEAM IS ROTATED SO THAT THERE IS NO         "
               2          "U-COMPONENT. THIS IS ALLOWED BY THE SYMMETRY OF THE GEOMETRY."
               2          FNORM=SQRT(FNORM);
               2          WINC=TEMP3/FNORM;
               2          VINC=SQRT((1.0-WINC)*(1.0+WINC));
               2          UINC=0.0;
               2          ]
               1      OUTPUT IQIN,UINC,VINC,WINC;
               1      (' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' PARALLEL BEAM AT ANY ANGLE WITH RADIAL DISTRIBUTION'/
               1      ' X-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.11)[
               1      "POINT SOURCE AT ANY ANGLE WITH RADIAL DISTRIBUTION"
               1      DISTR=ABS(TEMP1);
               1      IF(DISTR.LE.RSPH(NR))DISTR=100.;          "DEFAULT"
               1      IF(DISTR.LE.RSPH(NR))DISTR=100.+RSPH(NR); "DEFAULT FOR BIG TARGET"
               1      FNORM=TEMP2**2+TEMP3**2+TEMP4**2;
               1      IF(FNORM.EQ.0.0)[
               2          UINC=0.0;VINC=0.0;WINC=1.0;
               2          ]
               1      ELSE[
               2          "TO SIMPLIFY, THE BEAM IS ROTATED SO THAT THERE IS NO         "
               2          "U-COMPONENT. THIS IS ALLOWED BY THE SYMMETRY OF THE GEOMETRY."
               2          FNORM=SQRT(FNORM);
               2          WINC=TEMP4/FNORM;
               2          VINC=SQRT((1.0-WINC)*(1.0+WINC));
               2          UINC=0.0;
               2          ]
               1      OUTPUT IQIN,DISTR,UINC,VINC,WINC;
               1      (' ELECTRIC CHARGE OF THE SOURCE:',T60,I12/
               1      ' POINT SOURCE AT ANY ANGLE WITH RADIAL DISTRIBUTION'/
               1      ' SOURCE DISTANCE TO THE MIDDLE OF THE TARGET:',T60,F10.4,' cm'/
               1      ' X-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Y-AXIS DIRECTION COSINE:',T60,F10.4/
               1      ' Z-AXIS DIRECTION COSINE:',T60,F10.4/);
               1      ]
               0
               0  OUTPUT IOUTSP;
               0  (' PRINT DISTRIBUTION DATA IN OUTPUT SUMMARY, YES(1) OR NO(0): ',I2);
               0
               0  IF((ISOURC.EQ.10).OR.(ISOURC.EQ.11))[ "INCLUDE RADIAL DISTRIBUTION"
               1
               1      IF(MODEIN.NE.1) MODEIN=0; "DEFAULT"
               1
               1      IF(MODEIN.EQ.0)[ "HAS READ RADIAL DIST LOCALLY (FROM .INP)
               2          OUTPUT NRDIST;(' NUMBER OF RADIAL BINS: ',I4);
               2          IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
               3              OUTPUT;
               3              (' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
               3              ' RESET TO 100 ***');
               3              NRDIST=100;
               3              ]
               2          OUTPUT NRDIST;('   INPUT',I4,' SETS OF RDISTF,RPDF IN 2F20.0 FORMAT');
               2          OUTPUT;('   RDISTF INCREASING IN SIZE, RPDF NON-NEGATIVE');
               2          DO I=1,NRDIST [
               3              RDISTF(I)=VALUE(NUM_RDISTF,I);
               3              RPDF(I)=VALUE(NUM_RPDF,I);
               3              ]
               2          ]
               1      ELSE[ "READ INPUT FROM A SEPARATE SOURCE FILE"
               2          OUTPUT SPCFIL;(' FILE WITH DISTRIBUTION DATA READ AS:',A80);
               2          OPEN(UNIT=9,STATUS='OLD',file=SPCFIL);
               2          READ(9,*)NRDIST;
               2          IF((NRDIST.LT.1).OR.(NRDIST.GT.100))[
               3              OUTPUT;
               3              (' *** NUMBER RADIAL BINS OUT OF RANGE (<1 OR >100),',
               3              ' RESET TO 100 ***');
               3              NRDIST=100;
               3              ]
               2          READ(9,*)(RDISTF(IB),RPDF(IB),IB=1,NRDIST);
               2          CLOSE(UNIT=9);
               2          OUTPUT NRDIST;('    HAVE READ',I5,' INPUT RADIAL BINS FROM FILE');
               2          ]
               1
               1      "DO A CHECK ON THE RADIAL DISTRIBUTION"
               1      ICOUNT=0;
               1      RLAST=0;
               1      IERROR=0;
               1      :R-DIST-INPUT:LOOP[
               2          ICOUNT=ICOUNT+1;
               2          IF(ICOUNT.GT.NRDIST)[EXIT:R-DIST-INPUT:;]
               2          IF(RDISTF(ICOUNT).LE.RLAST)[
               3              IERROR=1;
               3              OUTPUT;
               3              (' *** RDISTF<=LAST ONE. NOT ALLOWED,',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT.');
               3              ]
               2          ELSEIF(RDISTF(ICOUNT).GT.RSPH(NR))[
               3              IERROR=1;
               3              OUTPUT RSPH(NR);
               3              (' *** RDISTF>',G14.7,', GEOMETRY SIZE.',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT');
               3              ]
               2          ELSEIF(RPDF(ICOUNT).LT.0.0)[
               3              IERROR=1;
               3              OUTPUT;(' PDF < 0 NOT ALLOWED,',
               3              ' TERMINATING RADIAL DISTRIBUTION INPUT');
               3              ]
               2          IF(IERROR.EQ.1)[
               3              ICOUNT=ICOUNT-1;
               3              IF(ICOUNT.EQ.0)[
               4                  OUTPUT;(' *** NO RADIAL DISTRIBUTION DEFINED,',
               4                  ' STOPPING EXECUTION ***');
               4                  STOP;
               4                  ]
               3              OUTPUT ICOUNT;
               3              (' RADIAL DITRIBUTION INPUT APPEARS TO BE INCOMPLETE,',
               3              ' NRDIST RESET TO ',I12);
               3              NRDIST=ICOUNT;
               3              EXIT:R-DIST-INPUT:;
               3              ]
               2          RLAST=RDISTF(ICOUNT);
               2          ]
               1
               1      OUTPUT RDISTF(NRDIST);
               1      ('    RADIAL DISTRIBUTION RANGES FROM 0 TO',F12.3,' cm');
               1
               1      ]
               0
               0  RETURN;  "NORMAL RETURN"
               0
               0  :EOF:;  "BAD INPUT"
               0  ERROR_FLAG=1;RETURN;
               0
               0  "ALL DATA HAS NOW BEEN FED INTO THE ROUTINE"
               0
               0  "************************************************************************
               0
               0  ENTRY SRCOTO(WEIGHT);
               0  "==================="
               0
               0  "CALCULATION OF ONE TIME ONLY CONSTANTS THAT MAY VARY WITH SOURCE TYPE"
               0
               0  IF(ISOURC.EQ.0)[
               1      "PARALLEL BEAM AT ANY ANGLE"
               1      IDSTON=0; "NO RADIAL DISTRIBUTION"
               1      ISRCTY=0; "PARALLEL BEAM"
               1      RBEAM=RBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      RBEAM2=RBEAM**2;
               1      ABEAM=PI*RBEAM2; "BEAM'S AREA ON THE FRONT OF THE TARGET"
               1      WEIGHT=1.0; "INCIDENT WEIGHT"
               1      AINFLU=FLOAT(NCASET)/ABEAM; "INCIDENT FLUENCE"
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.1)[
               1      "POINT SOURCE AT ANY ANGLE"
               1      IDSTON=0; "NO RADIAL DISTRIBUTION"
               1      ISRCTY=1; "POINT SOURCE"
               1      RBEAM=RBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               1      RBEAM2=RBEAM**2;
               1      ABEAM=PI*RBEAM2; "BEAM'S AREA ON THE FRONT OF THE TARGET"
               1      DISTR2=DISTR**2;
               1      "INCIDENT FLUENCE TIMES SOLID ANGLE"
               1      "  THE SOLID ANGLE FACTOR IS CANCELLED BY THE WEIGHTING ROUTINE"
               1      "  SEE BIELAJEW,ROGERS AND NAHUM, PHYS MED BIOL 1985 FOR DETAILS"
               1      AINFLU=FLOAT(NCASET)/DISTR2;
               1      ]
               0
               0  ELSEIF(ISOURC.EQ.4)["point spread function calculation"
               1      WEIGHT = 1.0;"incident weight"
               1      AINFLU=FLOAT(NCASET); "INCIDENT FLUENCE"
               1      "i.e., we give dose/incident particle"
               1      ]
               0
               0  ELSEIF((ISOURC.EQ.10).OR.(ISOURC.EQ.11))[ "RADIAL DISTRIBUTION"
               1
               1      IDSTON=1; "RADIAL DISTRIBUTION FLAG ON"
               1
               1      "CALCULATE THE CPDF FROM THE PDF AND NORMALIZE IT"
               1      "NOTE THAT THE RADIAL WEIGHTING IS INCLUDED AT THIS STAGE"
               1      RCDF(1)=0.5*RDISTF(1)**2*RPDF(1);
               1      DO IB=2,NRDIST[
               2          RCDF(IB)=RCDF(IB-1)+0.5*(RDISTF(IB)**2-RDISTF(IB-1)**2)*RPDF(IB);
               2          ]
               1      FNORM=1./RCDF(NRDIST);
               1      IBNSOK=0;
               1      GRIDSZ=1./FLOAT($MXRDIST);
               1      DO IB=1,NRDIST[
               2          RCDF(IB)=FNORM*RCDF(IB);
               2          IF(IB.EQ.1)[IF(RCDF(1).LT.GRIDSZ )IBNSOK=1;]
               2          ELSEIF((RCDF(IB)-RCDF(IB-1)).LT.GRIDSZ)[IBNSOK=1.0;]
               2          ]"END OF LOOP ON IB"
               1      IF(IBNSOK.NE.0)[OUTPUT;(//'0*******WARNING******'/
               2          T20,'SOME OF NORMALIZED BIN PROBABILITIES SO SMALL BINS MAY BE MISSED'/);]
               1      "CALCULATE RCDFIN - AN ARRAY WHICH ALLOWS THE RAPID SAMPLING FOR THE"
               1      "RADIAL BY PRECOMPUTING THE RESULTS FOR A FINE GRID"
               1      DO K=1,$MXRDIST[
               2          AK=FLOAT(K)*GRIDSZ;
               2          DO I=1,NRDIST[
               3              IRDIST=I;IF(AK.LE.RCDF(I))[GOTO :FOUND-R-BIN:;]
               3              ]
               2          "WE SHOULD NEVER FALL THROUGH TO HERE"
               2          OUTPUT;(' *** FELL THROUGH RADIAL SAMPLING ROUTINE *** ');
               2          :FOUND-R-BIN:
               2          IF(IRDIST.NE.1)[RCDFIN(K,1)=RDISTF(IRDIST-1)**2;]
               2          ELSE[RCDFIN(K,1)=0.0;]
               2          RCDFIN(K,2)=RDISTF(IRDIST)**2-RCDFIN(K,1);
               2          ]"END LOOP OVER K"
               1      "OUTPUT IF IWATCH IS ACTIVE"
               1      IF(IWATCH.NE.0)[
               2          OUTPUT;(' RDISTF,   RPDF,   RCDF:'//);
               2          OUTPUT (RDISTF(IB),RPDF(IB),RCDF(IB),IB=1,NRDIST);(3E17.7);
               2          OUTPUT;(//);
               2          ]
               1
               1      IF(ISOURC.EQ.10)[ "PARALLEL BEAM"
               2          ISRCTY=0; "PARALLEL BEAM"
               2          WEIGHT=1.0; "INCIDENT WEIGHT"
               2          ABEAM=PI*RDISTF(NRDIST)**2; "BEAM'S AREA ON THE FRONT OF THE TARGET"
               2          AINFLU=FLOAT(NCASET)/ABEAM;
               2          ]
               1      ELSE[ "POINT SOURCE"
               2          ISRCTY=1; "POINT SOURCE"
               2          DISTR2=DISTR**2;
               2          "INCIDENT FLUENCE TIMES SOLID ANGLE"
               2          "  THE SOLID ANGLE FACTOR IS CANCELLED BY THE WEIGHTING ROUTINE"
               2          "  SEE BIELAJEW,ROGERS AND NAHUM, PHYS MED BIOL 1985 FOR DETAILS"
               2          AINFLU=FLOAT(NCASET)/DISTR2;
               2          "RSHADW=MAXIMUM BEAM RADIUS ALLOWED BY SHADOWING"
               2          RSHADW=(RSPH(NR)/DISTR)*SQRT((DISTR+RSPH(NR))*(DISTR-RSPH(NR)));
               2          RBEAM=RSHADW; "NEEDED TO REJECT LATER IF R SELECTED IS TOO BIG"
               2          RBEAM=RBEAM*$ONE-EPS; "SCALE DOWN TO INSURE A STRIKE ON THE TARGET"
               2          ABEAM=PI*RBEAM2; "BEAM'S AREA ON THE FRONT OF THE TARGET"
               2          ]
               1      ]
               0
               0  RETURN;
               0
               0  "************************************************************************
               0
               0  ENTRY SRCOUT;
               0  "==========="
               0
               0  "                          DESCRIBE SOURCE"
               0  "                          ==============="
               0
               0  WRITE(IOUT,500);
               0  IF(ISOURC.EQ.0)     [WRITE(IOUT,510) RBEAM,UINC,VINC,WINC,AINFLU;      ]
               0  ELSEIF(ISOURC.EQ.1) [WRITE(IOUT,520) DISTR,RBEAM,UINC,VINC,WINC,AINFLU;]
               0  ELSEIF(ISOURC.EQ.4) [WRITE(IOUT,524) ;]
               0  ELSEIF(ISOURC.EQ.10)[WRITE(IOUT,530) UINC,VINC,WINC,AINFLU;            ]
               0  ELSEIF(ISOURC.EQ.11)[WRITE(IOUT,540) DISTR,UINC,VINC,WINC,AINFLU;      ]
               0  IF(IDSTON.EQ.1)[ "RADIAL DISTRIBUTION"
               1      WRITE(IOUT,550);
               1      IF(IOUTSP.EQ.1)[
               2          WRITE(IOUT,560)NRDIST;
               2          DO IB=1,NRDIST[WRITE(IOUT,570)IB,RDISTF(IB),RPDF(IB),RCDF(IB);]
               2          ]
               1      IF(IBNSOK.NE.0.0) WRITE(IOUT,580);
               1      ]
               0
               0  RETURN;
               0
               0
               0  "************************************************************************
               0
               0
               0  "                    SAMPLE SOURCE EACH HISTORY     "
               0  "                    ==========================     "
               0
               0  ENTRY SRCHST(XIN,YIN,ZIN,UIN,VIN,WIN,IRIN,WEIGHT,NRCFLG);
               0  "======================================================="
               0
               0  "CALCULATE THE HISTORY DEPENDENT CONSTANTS THAT MAY CHANGE DEPENDING ON"
               0  "THE SOURCE TYPE"
               0
               0  IF(ISOURC.EQ.4) ["not need to sample position and direction"
               1      xin    = 0.0;yin = 0.0;zin = 0.0;"particle at origin"
               1      uin    = 0.0;vin = 0.0;win = 1.0;"moving along z-axis"
               1      irin   = 2; "initial region always inner most sphere"
               1      weight = 1.0;"incident weight"
               1      return;
               1      ]
               0
               0  IF(IDSTON.EQ.0)[ "NO RADIAL DISTRIBUTION"
               1      LOOP[
               2          $RANDOMSET XIN; XIN =(2.0*XIN -1.0)*RBEAM; "CHOOSE X"
               2          $RANDOMSET YINP;YINP=(2.0*YINP-1.0)*RBEAM; "CHOOSE Y (UNROTATED)"
               2          RHO2=XIN**2+YINP**2;
               2          ] UNTIL RHO2.LE.RBEAM2;
               1      ]
               0  ELSE[ "RADIAL DISTRIBUTION"
               1      LOOP[
               2          "SAMPLE THE INCIDENT RADIAL DISTRIBUTION"
               2          $RANDOMSET RNNO1;$RANDOMSET RNNO2;
               2          "IN NEXT STATEMENT MIN AVOIDS K=$MXRDIST+1, ALMOST NEVER IMPLEMENTED"
               2          K=MIN(FLOAT($MXRDIST)*RNNO1+1.,FLOAT($MXRDIST));
               2          RRHO=SQRT(RCDFIN(K,1)+RNNO2*RCDFIN(K,2));
               2          ] UNTIL RRHO.LE.RBEAM;
               1
               1      $RANDOMSET XIN;XIN=(2.0*XIN-1.0)*RRHO; "CHOOSE X"
               1      RHO2=RRHO**2;
               1      YINP=RHO2-XIN**2;
               1      IF(YINP.LE.0.0)[YINP=0.0;]ELSE[YINP=SQRT(YINP);] "FIND Y (UNROTATED)"
               1      ]
               0
               0  ZINP=RSPH2(NR)-RHO2;
               0  IF(ZINP.LE.0.0)[ZINP=0.0;]ELSE[ZINP=-SQRT(ZINP);] "FIND Z (UNROTATED)"
               0  ZINP=ZINP*0.999995; "ALLOW A LITTLE PENETRATION"
               0
               0  "ROTATION YINP, ZINP ABOUT X-AXIS TO ACCOUNT FOR THE BEAM INCIDENCE"
               0  ZIN=ZINP*WINC-YINP*VINC;
               0  YIN=YINP*WINC+ZINP*VINC;
               0
               0  "FIND THE STARTING REGION'S CONE NUMBER"
               0  "NOTE THAT ON THE SUREFACE, IRIN=NREG+IC(CONE NUMBER)-NC"
               0  IF(NC.EQ.1)["ONLY ONE CONE"
               1      IRIN=NREG;
               1      ]
               0  ELSEIF(ZIN.GT.0.0)[ "HITS THE FORWARD HEMISPHERE"
               1      IF(NC.EQ.2)[ "UNIQUE SOLUTION IN THIS CASE"
               2          IRIN=NREG-1;
               2          ]
               1      ELSE[ "MUST SEARCH FOR ENTRANCE REGION"
               2          TNTST2=RHO2/ZIN**2;
               2          IC=1; "IF SEARCH FAILS, THE PARTICLE STARTS IN THE FIRST CONE"
               2          DO ICTST=1,NPLAN1[
               3              IF(TNTST2.GE.TANAL2(ICTST))[IC=IC+1;EXIT;]
               3              ]
               2          IC=MIN(NPLAN1,IC); "TO KEEP PARTICLE IN THE FORWARD HEMISPHERE"
               2          IRIN=NREG+IC-NC;
               2          ]
               1      ]
               0  ELSEIF(ZIN.LT.0.0)[ "HITS THE BACKWARD HEMISPHERE"
               1      IF(NC.EQ.2)[ "UNIQUE SOLUTION IN THIS CASE"
               2          IRIN=NREG;
               2          ]
               1      ELSE[ "MUST SEARCH FOR ENTRANCE REGION"
               2          TNTST2=RHO2/ZIN**2;
               2          IC=NC; "IF SEARCH FAILS, THE PARTICLE STARTS IN THE LAST CONE"
               2          DO ICTST=NPLAN2,NC[
               3              IF(TNTST2.GE.TANAL2(ICTST-1))[IC=IC-1;EXIT;]
               3              ]
               2          IC=MAX(NPLAN2,IC); "TO KEEP PARTICLE IN THE BACKWARD HEMISPHERE"
               2          IRIN=NREG+IC-NC;
               2          ]
               1      ]
               0  ELSE[ "ZIN=0.0, RIGHT ON THE EQUATOR - IMPROBABLE CASE"
               1      IF    (WINC.GT.0.0)[ "GOING FORWARD"  IRIN=NREG+NPLAN1-NC;]
               1      ELSEIF(WINC.LT.0.0)[ "GOING BACKWARD" IRIN=NREG+NPLAN2-NC;]
               1      ELSE               [ "PARALLEL TO EQUATORIAL PLANE"
               2          "SHARE EQUALLY BETWEEN FRONT AND BACK HEMISPHERES"
               2          $RANDOMSET SPLIT;
               2          IF(SPLIT.LT.0.5)[IRIN=NREG+NPLAN1-NC;]ELSE[IRIN=NREG+NPLAN2-NC;]
               2          ]
               1      ]
               0  ;
               0
               0  "FIND INITIAL DIRECTION COSINES"
               0  IF(ISRCTY.EQ.0)[ "PARALLEL BEAM"
               1      UIN=UINC;VIN=VINC;WIN=WINC;
               1      ]
               0  ELSE[ "POINT SOURCE"
               1      "FOR D AND WEIGHT USE UNROTATED FORMS - THEY ARE INVARIANT"
               1      D=SQRT((DISTR+ZINP)**2+RHO2);
               1      WEIGHT=ABEAM*(DISTR+RSPH2(NR)/ZINP)/(D**3);
               1      UIN=XIN/D;VIN=(DISTR*VINC+YIN)/D;WIN=(DISTR*WINC+ZIN)/D;
               1      OMEGIS(IS)=OMEGIS(IS)+WEIGHT;
               1      ]
               0
               0  RETURN;
               0
               0  "FORMATS"
               0  %I0                                                                            ;
               0  100   FORMAT(' ',2(I2,' '),4(G14.7,' '))
               0  200   FORMAT(' ',I1)
               0  300   FORMAT(' ',I3)
               0  400   FORMAT(' ',2(G14.7,' '))
               0  410   FORMAT(27A1)
               0  500   FORMAT(' ',95('*')//T30,'SOURCE PARAMETERS'//' ',95('*')/)
               0  510   FORMAT(T20,'PARALLEL BEAM FROM ANY ANGLE, RADIUS =',F8.3,' cm'/
               0       1  T30,' X-AXIS DIRECTION COSINE=',F10.4/
               0       2  T30,' Y-AXIS DIRECTION COSINE=',F10.4/
               0       3  T30,' Z-AXIS DIRECTION COSINE=',F10.4/
               0       4  T30,' INCIDENT FLUENCE=', 1PE13.3,'/cm**2')
               0  520   FORMAT(T20,'POINT SOURCE FROM ANY ANGLE',
               0       1  F8.1,' cm AWAY, RADIUS =',F8.3,' cm'/
               0       2  T30,' X-AXIS DIRECTION COSINE=',F10.4/
               0       3  T30,' Y-AXIS DIRECTION COSINE=',F10.4/
               0       4  T30,' Z-AXIS DIRECTION COSINE=',F10.4/
               0       5       T20,'INCIDENT FLUENCE * SOLID ANGLE=',1PE13.3,'/cm**2')
               0  524   FORMAT(T20,'PARTICLE LOCATED AT ORIGIN',
               0       1           ' MOVING PARALLEL TO Z-AXIS',/
               0       2           'USED FOR POINT SPREAD FUNCTION CALCULATIONS')
               0  530   FORMAT(T20,'PARALLEL BEAM FROM ANY ANGLE'/
               0       1  T30,' X-AXIS DIRECTION COSINE=',F10.4/
               0       2  T30,' Y-AXIS DIRECTION COSINE=',F10.4/
               0       3  T30,' Z-AXIS DIRECTION COSINE=',F10.4/
               0       4  T30,' INCIDENT FLUENCE=', 1PE13.3,'/cm**2')
               0  540   FORMAT(T20,'POINT SOURCE FROM ANY ANGLE',
               0       1  F8.1,' cm AWAY'/
               0       2  T30,' X-AXIS DIRECTION COSINE=',F10.4/
               0       3  T30,' Y-AXIS DIRECTION COSINE=',F10.4/
               0       4  T30,' Z-AXIS DIRECTION COSINE=',F10.4/
               0       5       T20,'INCIDENT FLUENCE * SOLID ANGLE=',1PE13.3,'/cm**2')
               0  550   FORMAT(' ',T20,'RADIAL DISTRIBUTION'/)
               0  560   FORMAT(' ',T20,'RADIAL DISTBN, # OF INCIDENT RADIAL BINS:',T60,I5/
               0       1' ',T20,'BIN    KINETIC RADIAL     PROBABILITY  CUMULATIVE PROB')
               0  570   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4)
               0  580   FORMAT(' *******WARNING******'/T20,'SOME OF NORMALIZED BIN',
               0       1' PROBABILITIES SO SMALL BINS MAY BE MISSED'/)
               0  %I4                                                                            ;
               0
               0  END;   "END OF SUBROUTINE SRCSPH"
               0  "LAST LINE IN SRCSPH.MOR - ONCE ONLY"
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc input source spectrum subroutine                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2000                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This subroutine is used to do all the work associated with having an input "
               0  "  source spectrum for the NRC user codes.                                    "
               0  "                                                                             "
               0  "  This implementation of ENSRC uses the alias sampling technique to sample   "
               0  "  the source energy from a histogrammed input energy spectrum (and thus      "
               0  "  needs nrcaux.mortran). To avoid confusions with multiple definitions of    "
               0  "  the spectrum common block, this common block should not be used any longer "
               0  "  and all data needed stored in the static arrays ensrcd, srcpdf, srcpdf_at  "
               0  "  and srcbin_at. For now, to assure compatibility with current versions of   "
               0  "  NRC user codes, ensrcd and srcpdf are left in the common/source/.          "
               0  "                                                                             "
               0  "  Input is based on the input routine adapted by Aaron Merowitz from the     "
               0  "  original ENSRC implementation that uses get_input.                         "
               0  "                                                                             "
               0  "                                                                             "
               0  "  ENTRY POINTS                                                               "
               0  "  ------------                                                               "
               0  "                                                                             "
               0  "   NSRC                    call from anywhere in your user code (but before  "
               0  "                           the first SHOWER call) to get                     "
               0  "                           input data as defined below                       "
               0  "                                                                             "
               0  "   NSRC1:                  initialization routine. To be called after        "
               0  "                           ENSRC and before the first SHOWER call            "
               0  "                                                                             "
               0  "   NSRCO:                  produces a summary of the input data.             "
               0  "                                                                             "
               0  "   NSRCH(ENIN):            called from main for each history to sample the   "
               0  "                           spectrum (MONOEN=1) or return the source energy   "
               0  "                           if mono-energetic beam                            "
               0  "                           COMMON/SOURCE/ (EINSRC) (MONOEN=2).               "
               0  "                                                                             "
               0  "   NSRC_EMAX(EK_MAX):      Puts maximum spectrum energy (source energy       "
               0  "                           for mono-energetic beams) into EK_MAX             "
               0  "                                                                             "
               0  "   INPUTS                                                                    "
               0  "   ------                                                                    "
               0  "                                                                             "
               0  "   NENSRC                  number of energy bins used to define the          "
               0  "                           distribution                                      "
               0  "                                                                             "
               0  "   SRCPDF(I=1,NENSRC)      the source probability distribution not           "
               0  "                           necessarily normalized                            "
               0  "                           probability of particle in this bin or /MeV       "
               0  "                                                                             "
               0  "   ENSRCD(I=0,NENSRC)      ensrcd(i-1) is the bottom energy in bin i,        "
               0  "                           ensrcd(i) the top energy                          "
               0  "                           Note the definition as $REAL ensrcd(0:$NENSRC)    "
               0  "                                                                             "
               0  "   ENMIN                   equal ensrcd(0), still there for compatibility    "
               0  "                                                                             "
               0  "   IWATCH                  diagnostic printout if IWATCH is not 0            "
               0  "                                                                             "
               0  "   MONOEN                  passed in COMIN USER  = 0 if monoenergetic        "
               0  "                                            = 2 if ISOURC=21                 "
               0  "   EIN                     passed in IODAT2-K.E. of monoenergetic source     "
               0  "                                                                             "
               0  "                                                                             "
               0  "   OTHER ARRAYS                                                              "
               0  "   ------------                                                              "
               0  "                                                                             "
               0  "   srcpdf_at, srcbin_at    arrays necessary for the alias sampling           "
               0  "                           technique, they are initialized via a call to     "
               0  "                           prepare_alias_sampling and used in                "
               0  "                           the function alias_sample to do the actual        "
               0  "                           sampling                                          "
               0  "                                                                             "
               0  "                                                                             "
               0  "   NOTES                                                                     "
               0  "   -----                                                                     "
               0  "                                                                             "
               0  "   This routine DOES NOT need the COMIN SPECTR                               "
               0  "                                                                             "
               0  "   If ENFLAG=1 (variable in COMMON/SOURCE/) then the energy has been         "
               0  "   previously set and stored in EINSRC (variable in COMMON/SOURCE/)          "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0
               0
               0  SUBROUTINE ENSRC;
               0
               0  $IMPLICIT-NONE;
               0
               0  ;"LINE SKIP"
               0
               0  "***************************************************************************"
               0  "*               Variables passed to the subroutine GET_INPUTS             *"
               0  "***************************************************************************"
               0  COMIN/GetInput/;
               0
               0  "These variables point to the index of their values_sought"
               0  INTEGER NUM_EITYPE,
               0  NUM_KIEN,
               0  NUM_SPFIL,
               0  NUM_SPIOUSP;
               0
               0  "COMMIN BLOCK DEFINITIONS
               0  "************************
               0  ;COMIN/PRINTC,IODAT2,SCORE,SPECTR,USER,RANDOM,SOURCE/;
               0  "                           ^
               0  " We want to make the energy spectrum sampling self contained ->
               0  " no need to put required data in a common block that is defined in the
               0  " main user code. The only dependence on the user code should be $NENSRC which
               0  " is used to define array dimensions.
               0
               0  $INTEGER "nensrc,"
               0  srcbin_at($NENSRC),
               0  mode;
               0  $REAL    "ensrcd(0:$NENSRC),"
               0  "srcpdf($NENSRC),"
               0  srcpdf_at($NENSRC),
               0  enmin,enmax,sume1,sume,
               0  Ek_max,Emono;
               0  $LOGICAL is_mono;
               0  character*256 filnam,spec_title;
               0  integer*4 lnblnk1; "use our own in-house lnblnk routine because some"
               0  "compilers do not have lnblnk"
               0
               0  save enmin,enmax,"nensrc," srcbin_at,"ensrcd,srcpdf," srcpdf_at,Emono,
               0  is_mono,mode,filnam,spec_title;
               0
               0  $INTEGER ib;
               0  $REAL    enin,alias_sample;
               0
               0  "******************************************************************************
               0  "            NOT REQUIRED IF ISOURC=21 (FULL PHASE SPACE OF READ)
               0  "
               0  " ENSRC DELIMETERS:  :start source inputs:
               0  "                    :stop source inputs:
               0  "
               0  "
               0  "  INCIDENT ENERGY
               0  "        = monoenergetic  (0)  if monoenergetic beam
               0  "        = spectrum       (1)  if energy spectrum to be used
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Monoenergetic:
               0  "
               0  "     INCIDENT KINETIC ENERGY(MEV)   (I)
               0  "                                   kinetic energy of the incident beam in MeV
               0  "                                   (defaults to 1.25)
               0  "
               0  "           ---------------------------------------
               0  "
               0  "  If INCIDENT ENERGY= Spectrum:
               0  "
               0  "                   SPEC FILENAME   (C)  filename (with ext)
               0  "                                   contains spectrum information
               0  "
               0  "                                   FILE FORMAT:
               0  "                                   TITLE      spectrum title  (80 char)
               0  "                                   NENSRC, ENMIN, MODE
               0  "                                   NENSRC     # energy bins in spec.  histogram
               0  "                                   ENMIN      lower energy of first bin
               0  "                                   MODE       =0, assumes cts/bin
               0  "                                              =1  assumes cts/MeV
               0  "                                   ENSRCD(I),SRCPDF(I)  I=1,NENSRC
               0  "                                   top of energy bin and probability of
               0  "                                   initial particle being in this bin.
               0  "                                   probability does not need to be normalized
               0  "
               0  "                   SPEC IOUTSP
               0  "                        = none     (0)  no spectrum data in output summary
               0  "                        = include  (1)  include spectrum data in output summary
               0  ;
               0  "
               0  "*******************************************************************************
               0  ;"------------------------------------------------------------------------------
               0  DELIMETER='SOURCE INPUTS';
               0
               0  IF(ENFLAG.EQ.1)["FULL PHASE-SPACE INFORMATION READ PREVIOUSLY"
               1      MONOEN = 2;
               1      RETURN;
               1      ]
               0  OUTPUT;(' *** INPUT CARD TC1 ***');
               0  IVAL = IVAL +1;
               0  NUM_EITYPE = IVAL;
               0  VALUES_SOUGHT(IVAL)='INCIDENT ENERGY';
               0  TYPE(IVAL)=3;
               0  NVALUE(IVAL)=1;
               0  ALLOWED_INPUTS(IVAL,0)='MONOENERGETIC';
               0  ALLOWED_INPUTS(IVAL,1)='SPECTRUM';
               0  $GET_INPUT(NUM_EITYPE);
               0  MONOEN=VALUE(NUM_EITYPE,1);
               0
               0  IF(MONOEN = 0)[
               1      OUTPUT ;(' MONOENERGETIC BEAM:');
               1      IVAL = IVAL +1;
               1      NUM_KIEN = IVAL;
               1      VALUES_SOUGHT(IVAL)='INCIDENT KINETIC ENERGY(MEV)';
               1      TYPE(IVAL)=1;
               1      NVALUE(IVAL)=1;
               1      VALUE_MIN(IVAL)=0.001;    "databases for EGSnrc stop at 1 keV"
               1      VALUE_MAX(IVAL)=200000;   "not sure what real upper limit is"
               1      DEFAULT(IVAL)=1.25;
               1      $GET_INPUT(NUM_KIEN);
               1      EIN=VALUE(NUM_KIEN,1);
               1      OUTPUT EIN;(/' KINETIC ENERGY OF THE INCIDENT BEAM: ',T60,F10.4);
               1      is_mono = .true.; Emono = EIN;
               1      ]
               0  ELSE[
               1      OUTPUT;(' ENERGY SPECTRUM:');
               1
               1      is_mono = .false.;
               1
               1      IVAL = IVAL +1;
               1      NUM_SPFIL = IVAL;
               1      VALUES_SOUGHT(IVAL)='SPEC FILENAME';
               1      TYPE(IVAL)=2;
               1      $GET_INPUT(NUM_SPFIL);
               1      READ (CHAR_VALUE(NUM_SPFIL,1),FMT='(A)') filnam;
               1
               1      OUTPUT filnam;(/'   READ INPUT ENERGY SPECTRUM FROM: ',A);
               1      call replace_env(filnam);
               1      OPEN(9,file=filnam,STATUS='OLD');
               1      READ(9,'(A)') spec_title;
               1      READ(9,*) nensrc,ensrcd(0),mode;
               1      enmin = ensrcd(0);
               1      IF(NENSRC > $NENSRC) [
               2          OUTPUT NENSRC,$NENSRC;
               2          (//' ********** Asked for too many energy bins******'/
               2          ' NENSRC =',I4, ' reduced to max allowed =',I4/1x,30('*')//);
               2          NENSRC = $NENSRC;
               2          ]
               1      READ(9,*)(ENSRCD(IB),SRCPDF(IB),IB=1,NENSRC);
               1      CLOSE(UNIT=9);
               1      OUTPUT NENSRC; ('    HAVE READ',I5,' INPUT ENERGY BINS FROM FILE');
               1      IF(MODE=0)[OUTPUT;('      Counts/bin assumed');]
               1      ELSEIF(MODE = 1) [
               2          OUTPUT;('      Counts/MeV assumed');
               2          DO IB=1,NENSRC[SRCPDF(IB) = SRCPDF(IB)*(ENSRCD(IB)-ENSRCD(IB-1));]
               2          ] "end mode = 1 block"
               1      ELSE [OUTPUT MODE;(///'*****MODE not 0 or 1 in spectrum file? **'
               2          /80('*') //);]
               1
               1      EIN=ENSRCD(NENSRC);"SET TO MAX ENERGY FOR SOME CHECKS"
               1      OUTPUT ENMIN,EIN;('    ENERGY RANGES FROM',F10.3,' MeV TO',F12.3,' MeV');
               1      enmax = ein;
               1
               1      IVAL = IVAL +1;
               1      NUM_SPIOUSP = IVAL;
               1      VALUES_SOUGHT(IVAL)='SPEC IOUTSP';
               1      TYPE(IVAL)=3;
               1      DEFAULT(IVAL)=0;
               1      ALLOWED_INPUTS(IVAL,0)='NONE';
               1      ALLOWED_INPUTS(IVAL,1)='INCLUDE';
               1      $GET_INPUT(NUM_SPIOUSP);
               1      IOUTSP=VALUE(NUM_SPIOUSP,1);
               1      ]
               0  OUTPUT;(' ');
               0  RETURN;   "NORMAL RETURN"
               0
               0  ENTRY ENSRC1;
               0  "==========="
               0
               0  IF( is_mono ) return;
               0
               0  " Rewritten by IK: to guarantee that the input spectrum is exactly sampled,"
               0  "                  The alias sampling technique is employed
               0  "                  needs prepare_alias_sampling which is in nrcaux.mortran
               0
               0  " Check that enmin < ensrcd(1) "
               0  IF( enmin >= ensrcd(1) ) [
               1      write(6,*) ' Bad spectrum: minimum energy is > top of first bin! ';
               1      stop;
               1      ]
               0
               0  call prepare_alias_sampling(nensrc,srcpdf,srcpdf_at,srcbin_at);
               0
               0  RETURN;
               0
               0  ENTRY ENSRCO;
               0  "==========="
               0
               0  IF( is_mono ) [
               1      write(iout,'(18x,a,f9.3,a)') 'Mono-energy: ',Emono,' MeV';
               1      return;
               1      ]
               0  IF(enflag = 1) [ "this is a phase space input, print nothing here" return;]
               0  WRITE(IOUT,105) FILNAM(:lnblnk1(FILNAM)),SPEC_TITLE(:lnblnk1(SPEC_TITLE));
               0  105 FORMAT(18x,' Spectrum file and title:'/18x,A/18x,A);
               0  sume1 = 0; sume = 0;
               0  DO ib=1,nensrc[
               1      sume = sume + srcpdf(ib);
               1      sume1 = sume1 + srcpdf(ib)*(ensrcd(ib)+ensrcd(ib-1))/2;
               1      ]
               0  WRITE(IOUT,'(20x,a,f10.4)') ' Average spectrum energy is ',sume1/sume;
               0  IF(IOUTSP.EQ.1)[
               1      IF(MODE=0)[WRITE(IOUT,'(20x,'' Counts/bin assumed'')');]
               1      ELSE   [WRITE(IOUT,'(20x,'' Counts/MeV assumed'')');]
               1      WRITE(IOUT,110)NENSRC,enmin;
               1      DO IB=1,NENSRC[
               2          WRITE(IOUT,120)IB,ensrcd(ib),srcpdf(ib),srcpdf_at(ib),srcbin_at(ib);
               2          ]
               1      ]
               0  RETURN;
               0
               0
               0  ENTRY ENSRCH(ENIN);
               0  "================"
               0
               0  IF( is_mono ) [ enin = Emono; return; ]
               0
               0  enin = alias_sample(nensrc,ensrcd,srcpdf_at,srcbin_at);
               0  RETURN;
               0
               0  ENTRY ENSRC_EMAX(Ek_max);
               0
               0  IF( is_mono ) [ Ek_max = Emono; ]
               0  ELSE [ Ek_max = ensrcd(nensrc); ]
               0  return;
               0
               0
               0  100   FORMAT(' ',I1);
               0  102   FORMAT(' ',G14.7);
               0  110   FORMAT(' ',T20,'Energy dist''n, # of incident energy bins:',T60,I3/
               0  T20,' Lower energy of first bin:',T60,F7.3,' (MeV)'/
               0  ' ',T20,'bin    kinetic energy     probability  at prob   at bin');
               0  120   FORMAT(' ',T20,I3,T28,F7.3,T45,1PE10.3,T60,0PF7.4,T70,i4);
               0
               0  END; "end subroutine ensrc"
               0
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc spherical geometry input subroutine                                 "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Joanne Treurniet, 1999                                    "
               0  "                                                                             "
               0  "  Contributors:    Iwan Kawrakow                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  ;"******************************************************************************
               0  "
               0  "                              *******************
               0  "                              *                 *
               0  "                              * geomsph.mortran *
               0  "                              *                 *
               0  "                              *******************
               0  "
               0  "
               0  "   THIS SUBROUTINE IS USED TO DO ALL THE WORK ASSOCIATED WITH HAVING
               0  "   A SPHERICAL GEOMETRY INPUT.
               0  "
               0  "       VERSION 1.1       J. Treurniet               05/99
               0  "
               0  "
               0  "===============================================================================
               0  "
               0  "   CONES NOW SUPPORTED. SINCE 90 DEGREES CONE IS NEEDED BY THE CONE GEOMETRY
               0  "   CHECKING MACRO, IF THE USER DOES NOT INCLUDE THE 90 DEGREES CONE, THE NEXT
               0  "   ANGLE GREATER THAN 90 IS AUTOMATICALLY FORCED TO BE 90.
               0  "
               0  "   ANGLES AND RADII CAN BE ENTERED INDIVIDUALLY OR IN GROUPS.
               0  "
               0  "
               0  "       VERSION 2.0      E. Mainegra-Hing           10/10/2003
               0  "
               0  "*******************************************************************************
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  ;
               0  "*******************************************************************************
               0  "                       SPHERICAL GEOMETRY INPUT
               0  "                       **************************
               0  "*******************************************************************************
               0  "
               0  " GEOMSPH DELIMETERS:   :start geometrical inputs:
               0  "                       :stop geometrical inputs:
               0  "
               0  "
               0  "  NUMBER OF CONES        (M)   number of cones (individual or by group)
               0  "                               If omitted or ZERO, pure spherical geometry
               0  "                               assumed.
               0  "
               0  "  ANGLES                 (M)   ANGLES defining the geometry (reals)
               0  "                               No needed in pure spherical geometries.
               0  "
               0  "                               For group input there must be as many entries
               0  "                               as for the NUMBER OF CONES, i.e. :
               0  "                               NCON1,NCON2,...,NCONn
               0  "                               DANG1,DANG2,...,DANGn
               0  "
               0  "                               For individual input, ncones must be equal
               0  "                               to the number of entries, i.e.:
               0  "                               ncones
               0  "                               DANG1, DANG2,...,DANGncones
               0  "
               0  "  NUMBER OF SPHERES      (M)   number of spheres (individual or by group)
               0  "
               0  "                               For individual inputs, number of spheres
               0  "                               can be omitted
               0  "
               0  "
               0  "  RADII                  (M)   radii of spheres defining the geometry (reals)
               0  "
               0  "                               For group input there must be as many entries
               0  "                               as for the NUMBER OF SPHERES, i.e. :
               0  "                               NSPH1,NSPH2,...,NSPHn
               0  "                               DRAD1,DRAD2,...,DRADn
               0  "
               0  "  CAVITY ZONES           (M)   geometrical zone numbers in the cavity (reals)
               0  "
               0  "-------------------------------------------------------------------------------
               0  "  MATERIAL INPUT
               0  "  **************
               0  "
               0  "  MEDIA              (M)   material name which must match that in the
               0  "                           pegs4 data set EXACTLY, including case.
               0  "                           24 characters max per medium, ended by , or ;
               0  "
               0  "  MEDNUM                 (M)   the material number (integers)
               0  "                               (MEDNUM=0 => vacuum)
               0  "  START REGION           (M)   initial geometrical zone(irl) (integers) for
               0  "                               this medium [NREGLO]
               0  "  STOP REGION            (M)   final geometrical zone(irl) (integers) for
               0  "                               this medium.[NREGHI]
               0  "                               ( >NREGLO to input more than one zone)
               0  "                               DEFAULTS:   MEDNUM=0 FOR REGION=1 (i.e. VACUUM)
               0  "                                           MEDNUM=1 FOR REGION=2,NREG
               0  "
               0  "                         These inputs should be thought of as triplets of
               0  "                         MEDNUM,START and STOP REGIONs     which are used
               0  "                         to specify the medium numbers for all regions where
               0  "                         the medium is not the default (medium 1).
               0  "
               0  "***************************************************************************"
               0  "
               0  ;
               0  SUBROUTINE GEOMSPH;
               0  "ERROR_FLAG is now in common block"
               0
               0  "DECLARATION OF COMIN BLOCKS
               0  "***************************
               0  ;COMIN/GEOM,IODAT2,MEDIA,MISC,SCORE,SOURCE,USER,RANDOM,UPHIOT,GetInput/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used to declare inputs                      *"
               0  "***************************************************************************"
               0
               0  INTEGER "NMED, "MEDNUM, NREGLO, NREGHI;               "material input"
               0
               0  "***************************************************************************"
               0  "*                Variables used to point to the inputs                    *"
               0  "***************************************************************************"
               0  "Spherical geometry input"
               0  INTEGER NUM_CONES,
               0  NUM_SPHERES,
               0  NUM_ANGLES,  "missing in original geomsph.mortran"
               0  NUM_RADII,
               0  NUM_RSPH,
               0  NUM_CAVREG;
               0
               0  "Material Input"
               0  INTEGER NUM_MEDIA,
               0  NUM_MEDNUM,
               0  NUM_NREGLO,
               0  NUM_NREGHI;
               0  "---------------------------------------------------------------------------"
               0  INTEGER ERR;  "$inputfile.errors file"
               0  INTEGER LNBLNK,SLENGHT;
               0  INTEGER I,J,K,PLN,COUNT;
               0  INTEGER IX, IZ, REGNUM;
               0  REAL    ADDING;
               0
               0  "---------------------------------------------------------------------------"
               0  $INTEGER NCONE, NCONES(0:$MAXCANGLE), IC;
               0  $INTEGER NRADIUS(0:$MAXRADII);
               0  $REAL    ANGRAD;
               0  logical  NoNinety;
               0  "LOCAL VARIABLE DECLARATION"
               0  "EMH,01/11/19"
               0  "---------------------------------------------------------------------------"
               0  " This must stay I and not be changed to IVAL.  Doing that means that
               0  " the previous NVALUE(IVAL) will be used so multiple inputs aren't read.
               0  I=0;  "initialize index number of the value_sought"
               0  ERR=15;  "output errors to unit # 15"
               0
               0  ERROR_FLAG=0;   "Initialization of bad input flag"
               0
               0  "                      SPHERICAL GEOMETRY INPUT"
               0  "                      **************************"
               0
               0  DELIMETER = 'GEOMETRICAL INPUTS';
               0
               0  IVAL=IVAL+1;
               0  NUM_CONES = IVAL;
               0  VALUES_SOUGHT(IVAL)='NUMBER OF CONES';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  "VALUE_MAX(IVAL)=$MAXCDOSE;"
               0  VALUE_MAX(IVAL)=1000000000;
               0  DEFAULT(IVAL)=1;
               0  $GET_INPUT(IVAL);
               0  "it's more natural to enter the number of cones"
               0  "and get the subtended regions afterwards.     "
               0  "                              EMH, 01/11/19   "
               0
               0  ALPHA(0) = 0.0;
               0  NCONE = 0;"get total number of cones"
               0  DO I = 1, NVALUE(NUM_CONES)[
               1      NCONES(I) = VALUE(NUM_CONES,I);
               1      NCONE     = NCONE + NCONES(I);
               1      IF( NCONE > $MAXCANGLE) [
               2          OUTPUT NCONE, $MAXCANGLE;
               2          (///' Number of cones,',I10,' is greater than $MAXCANGLE=',I10/
               2          '  You must change the definition of $MAXCANGLE in the user code'/
               2          '      and recompile'///);
               2          STOP;
               2          ]
               1      ]
               0  OUTPUT NCONE;(/'Conical dimension [NCONE] : ',I5,' cones in the problem');
               0  NC = NCONE + 1;"number of conical sections = total number of cones + 1"
               0
               0  IF(NC = 1)["PURE SPHERICAL GEOMETRY"
               1      ALPHA(1)=180.0; "NONE CONES"
               1      NPLAN1=1;NPLAN2=2;
               1      ]
               0  ELSEIF(NC = 2)["HEMISPHERICAL GEOMETRY"
               1      ALPHA(1)=90.0; "ONE CONE ONLY AT 90 DEGREES"
               1      NPLAN1=1;NPLAN2=2;
               1      ]
               0  ELSEIF(NC > 2)["USER DEFINES NC-2 CONES"
               1      IVAL = IVAL + 1;
               1      NUM_ANGLE = IVAL;
               1      VALUES_SOUGHT(IVAL)='ANGLES';
               1      TYPE(IVAL)=1;
               1      VALUE_MIN(IVAL)=0.0;
               1      VALUE_MAX(IVAL)=180.0;
               1      $GET_INPUT(NUM_ANGLE);
               1      IF ( NVALUE(NUM_ANGLE).EQ.NVALUE(NUM_CONES) )
               1      [                                   "group input: NCON1,NCON2,...,NCONn"
               2          NCONES(0) = 0; K = 0;                          "DANG1,DANG2,...,DANGn"
               2          DO I = 1, NVALUE(NUM_CONES)[
               3              K = K + NCONES(I-1);
               3              DO J = 1,NCONES(I)[
               4                  ALPHA(K+J) = ALPHA(K+J-1) + VALUE(NUM_ANGLE,I);
               4                  "OUTPUT K+J, ALPHA(K+J);     "
               4                  "(' CONE OPENING ANGLE # ',I3,': ',F8.4);   "
               4                  ]
               3              ]
               2          ]
               1      ELSEIF ( NVALUE(NUM_ANGLE).EQ.NCONE)
               1      [                               "individual input: NCONE"
               2          DO I=1,NCONE [                "                  ANG1,ANG2,...,ANGncone"
               3              ALPHA(I)=VALUE(NUM_ANGLE,I);
               3              "OUTPUT I, ALPHA(I);     "
               3              "(' CONE OPENING ANGLE # ',I3,': ',F8.4);   "
               3              ]
               2          ]
               1      ELSE [ "input error for cones"
               2          OUTPUT;
               2          (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
               2          ' MISMATCH BETWEEN NUMBER OF CONES AND NUMBER OF ANGULAR ENTRIES'/
               2          ' CHECK THIS AND TRY AGAIN !!!'//
               2          ' PROGRAM STOPPED.');
               2          STOP;
               2          ]
               1
               1      NoNinety = .true.;"assume initially 90 degree not included"
               1      IC=0; "LOOP INDEX"
               1      LOOP[ "CHECK IF USER PUT IN 90 DEGREE CONE"
               2          IC=IC+1;
               2          IF(ALPHA(IC) = 90.0)["user included 90 degree, great!!!"
               3              NPLAN1=IC;NPLAN2=NPLAN1+1;
               3              NoNinety = .false.;
               3              OUTPUT;
               3              (/' *** WARNING ***. 90 DEGREE CONE INPUT',
               3              ' BY USER. JUST MAKING THE POINT.'/);
               3              EXIT;
               3              ]
               2          ]UNTIL (IC = NCONE);
               1
               1      IF ( NoNinety )[
               2          IF ( NC > $MAXCANGLE )["remeber NC = NCONE + 1"
               3              OUTPUT;
               3              (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
               3              ' ABOUT TO ADD 90 DEGREES, BUT DIMENSIONS EXCEEDED'/
               3              ' MAXIMUM NUMBER OF ANGLES.'//
               3              ' PROGRAM STOPPED.');
               3              STOP;
               3              ]
               2          IC=NCONE; "LOOP INDEX"
               2          LOOP[ "PUT IN THE 90 DEGREE CONE"
               3              IF(ALPHA(IC) > 90.0)["SHIFT UPWARDS
               4                  ALPHA(IC+1)=ALPHA(IC);
               4                  ]
               3              ELSE[ "PUT IN THE 90 DEGREE CONE RIGHT HERE"
               4                  ALPHA(IC+1)=90.0;
               4                  NPLAN1=IC+1;NPLAN2=NPLAN1+1;
               4                  NCONE = NCONE + 1; NC = NCONE + 1;
               4                  OUTPUT NPLAN1;(' FORCING ANGLE #',I3,' TO BE 90 DEGREES');
               4                  EXIT;
               4                  ]
               3              IC=IC-1;
               3              ]UNTIL (IC = 0);
               2
               2          IF(IC = 0)[ "FELL THROUGH THE LOOP => ALL INPUT CONES > 90"
               3              ALPHA(1)=90.0;
               3              NPLAN1=1;NPLAN2=2;
               3              OUTPUT NPLAN1;(' FORCING ANGLE #',I3,' TO BE 90 DEGREES');
               3              ];
               2          ];
               1      ] "END OF ANGLE INPUT FOR NC>2"
               0  $SKIP-LINE;
               0
               0  DO IC=1,NCONE[
               1      IF ( ALPHA(IC) > 180.0 )[
               2          OUTPUT;
               2          (/' ***** ERROR IN GEOMETRICAL INPUT FOR CONES *****'/
               2          ' POLAR ANGLES CAN NOT BE GREATER THAN 180 DEGREES'//
               2          ' PROGRAM STOPPED.');
               2          STOP;
               2          ]
               1      ]
               0
               0  "0 and 180 degrees are the boundaries(i.e. 0th and NCth), "
               0  "if those values are entered by input let's use them."
               0  "ALPHA(0) =   0.0; set above"
               0  IF ( ALPHA(1) = 0.0 )["shift down angle array since 0 degree is 0th element"
               1      DO IC=1,NCONE-1[ ALPHA(IC) = ALPHA(IC+1); ]
               1      NC = NCONE; NCONE = NCONE - 1;
               1      ]
               0  IF ( ALPHA(NCONE) = 180.0 )["user did the work, let's use it !!!"
               1      NC = NCONE; NCONE = NCONE - 1;
               1      ]
               0  "should put here a check whether NC > $MAXCANGLE!!!!!!!!!!!"
               0  ALPHA(NC)= 180.0;"just in case it didn't fall in the IF"
               0
               0
               0  IF(NC = 1)["PURE SPHERICAL GEOMETRY"
               1      OUTPUT;(' ==> This is a pure spherical geometry !');
               1      DO IC=0,NC["O and 180 degree included"
               2          ANGRAD=(PI/180.)*ALPHA(IC);
               2          COSALP(IC)=COS(ANGRAD);
               2          SINALP(IC)=SIN(ANGRAD);
               2          TANALP(IC)=TAN(ANGRAD);
               2          TANAL2(IC)=TANALP(IC)**2;
               2          ]
               1      ]
               0  ELSEIF(NC > 1)[
               1      OUTPUT;(' CONE OPENING ANGLES:');
               1      OUTPUT (ALPHA(IC),IC=1,NC);(8F10.4);
               1      NPLAN2=NPLAN1+1;
               1      DO IC=0,NC["O and 180 degree included"
               2          ANGRAD=(PI/180.)*ALPHA(IC);
               2          COSALP(IC)=COS(ANGRAD);
               2          SINALP(IC)=SIN(ANGRAD);
               2          TANALP(IC)=TAN(ANGRAD);
               2          TANAL2(IC)=TANALP(IC)**2;
               2          ]
               1      $SKIP-LINE;
               1      ]
               0  OUTPUT NC;(/'NUMBER OF CONICAL REGIONS NC = ',I5);
               0  OUTPUT NPLAN1;(/'REGION WHERE 90 deg IS UPPER CONE :',I5,/);
               0
               0
               0  IVAL=IVAL+1;
               0  NUM_RADII = IVAL;
               0  VALUES_SOUGHT(IVAL)='NUMBER OF SPHERES';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=1000000000;
               0  "VALUE_MAX(IVAL)=$MAXRADII;"
               0  DEFAULT(IVAL)=$MAXRADII;
               0  $GET_INPUT(NUM_RADII);
               0
               0  NR = 0;"get total number of spheres"
               0  DO I = 1, NVALUE(NUM_RADII)[
               1      NRADIUS(I) = VALUE(NUM_RADII,I);
               1      NR         = NR + NRADIUS(I);
               1      IF( NR > $MAXRADII) [
               2          OUTPUT NR, $MAXRADII;
               2          (///' Number of spheres,',I10,' is greater than $MAXRADII=',I10/
               2          '  You must change the definition of $MAXRADII in the user code'/
               2          '      and recompile'///);
               2          STOP;
               2          ]
               1      ]
               0  IF (NR > 0)[
               1      OUTPUT NR;(/'Spherical dimension: ',I6,' spheres in the problem ...');
               1      ]
               0
               0  IVAL = IVAL + 1;
               0  NUM_RSPH = IVAL;
               0  VALUES_SOUGHT(IVAL)='RADII';
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0.0000001;
               0  VALUE_MAX(IVAL)=999999.9;
               0  DEFAULT(IVAL)=1.0;
               0  $GET_INPUT(NUM_RSPH);
               0  IF (NR = 0) [
               1      NR = NVALUE(NUM_RSPH);
               1      OUTPUT NR;(/'Spherical dimension: ',I6,' spheres in the problem ...');
               1      ]
               0
               0
               0  RSPH(0) = 0.0;
               0
               0  IF ( NVALUE(NUM_RADII).EQ.NVALUE(NUM_RSPH) )
               0  [                                   "group input: NRAD1,NCON2,...,NCONn"
               1      NRADIUS(0) = 0; K = 0;                     "DRAD1,DRAD2,...,DRADn"
               1      DO I = 1, NVALUE(NUM_RADII)[
               2          K = K + NRADIUS(I-1);
               2          DO J = 1,NRADIUS(I)[
               3              RSPH(K+J) = RSPH(K+J-1) + VALUE(NUM_RSPH,I);
               3              RSPH2(K+J)= RSPH(K+J)**2;
               3              ]
               2          ]
               1      ]
               0  ELSEIF ( NVALUE(NUM_RSPH).EQ.NR)
               0  [                               "individual input: NR"
               1      DO I=1,NR [                "              RAD1,RAD2,...,RADnr"
               2          RSPH(I) = VALUE(NUM_RSPH,I);
               2          RSPH2(I)= RSPH(I)**2;
               2          ]
               1      ]
               0  ELSE [ "input error for spheres"
               1      OUTPUT;
               1      (/' ***** ERROR IN GEOMETRICAL INPUT FOR SPHERES *****'/
               1      ' MISMATCH BETWEEN NUMBER OF SPHERES AND NUMBER OF RADIAL ENTRIES'/
               1      ' CHECK THIS AND TRY AGAIN !!!'//
               1      ' PROGRAM STOPPED.');
               1      STOP;
               1      ]
               0
               0  $SKIP-LINE;
               0  I = MIN(100,NR);
               0  DO IX=1,I [
               1      "RSPH(IX)=VALUE(NUM_RSPH,IX);"
               1      "RSPH2(IX)=RSPH(IX)**2;"
               1      IF(RSPH(IX)=0.0)[
               2          OUTPUT;(' IMPROPER INPUT. RADIUS OF 0.0 NOT ALLOWED'/);
               2          ]
               1      OUTPUT IX,RSPH(IX);(' RING RADIUS #',I6,':',T60,F12.6,' cms');
               1      ]
               0  OUTPUT; (/);
               0
               0  NREG=NR*NC+1;
               0
               0  "define cavity zones"
               0
               0  IVAL = IVAL + 1;
               0  NUM_CAVREG = IVAL;
               0  VALUES_SOUGHT(IVAL)='CAVITY ZONES';
               0  TYPE(IVAL)=1;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=999999;
               0  DEFAULT(IVAL)=1;
               0  $GET_INPUT(IVAL);
               0  numcavreg = NVALUE(IVAL);
               0  OUTPUT numcavreg;(/' number of cavity regions: ', I4 );
               0
               0  DO IX=1,numcavreg [ cavreg(IX) = VALUE(IVAL,IX); ]
               0
               0  "CHECK THAT THE NUMBER OF CAVITY ZONES DOES NOT EXCEED ITS BOUNDS"
               0  IF(numcavreg.LE.0)["no cavity defined, just dose in all the regions desired"
               1      DO I=1,NREG[cavreg(I)=0;]
               1      OUTPUT; (' **** no cavity regions defined ****'/);
               1      ]
               0  ELSEIF(numcavreg.GE.NREG)[
               1      "IF IT DOES, REVERT TO THE STANDARD CHAMBER CONFIGURATION"
               1      numcavreg=1;cavreg(1)=3;DO I=2,NREG[cavreg(I)=0;]
               1      OUTPUT;
               1      (' TOO MANY CAVITY ZONES, REVERTING TO STANDARD CHAMBER');
               1      ]
               0  ELSEIF(numcavreg.EQ.(NREG-1))[
               1      "WHOLE GEOMETRY IS A CAVITY ZONE, SCORE EVERYWHERE"
               1      OUTPUT; (' WHOLE GEOMETRY IS A CAVITY ZONE, SCORING EVERYWHERE');
               1      numcavreg=NREG-1;DO I=2,NREG[cavreg(I-1)=I;]
               1      ]
               0  ELSE[ "check cavity regions are within the right limits"
               1      I=0;
               1      LOOP[
               2          I=I+1;
               2          IF((cavreg(I).LE.1).OR.(cavreg(I).GT.NREG))["wrong cavity region number"
               3              OUTPUT cavreg(i);
               3              (' wrong cavity region number: ', I5 /
               3              ' INAPPROPRIATE CAVITY ZONES, REVERTING TO STANDARD CHAMBER');
               3              "CHECK FOR INAPPROPRIATE INPUT"
               3              "REVERT TO THE STANDARD CHAMBER IF THIS HAPPENS"
               3              numcavreg=1;cavreg(1)=3;DO I=2,NREG[cavreg(I)=0;]
               3              EXIT; "THEN EXIT THE LOOP"
               3              ]
               2          ELSE[
               3              OUTPUT i,cavreg(i);
               3              ('    ===> cavity region # ', I5, ' is region # ', I5);
               3              ]
               2
               2          ]WHILE(I.LT.numcavreg);
               1      ] "CAVITY ZONES ARE DEFINED"
               0
               0
               0  "                               MATERIAL INPUT
               0  "                               **************
               0  IVAL = IVAL + 1;
               0  NUM_MEDIA = IVAL;
               0  VALUES_SOUGHT(IVAL)='MEDIA';
               0  TYPE(IVAL)=2;
               0  $GET_INPUT(IVAL); "get the number of media"
               0  NMED=NVALUE(IVAL);
               0  DO I=1,NMED [
               1      SLENGHT=LNBLNK(CHAR_VALUE(NUM_MEDIA,I));
               1      READ (CHAR_VALUE(NUM_MEDIA,I),FMT='(24A1)') (MEDIA(J,I),J=1,SLENGHT);
               1      IF (SLENGHT<24) [DO J=SLENGHT+1, 24 [MEDIA(J,I)=' ';]]
               1      OUTPUT I,(MEDIA(J,I),J=1,24);(' MEDIUM #',I1,':',T55,24A1);
               1      ]
               0
               0  IF((NMED.LT.1).OR.(NMED.GT.$MXMED)) [
               1      NMED=1;
               1      OUTPUT;
               1      (' ***** NO MEDIUM OR TOO MANY MEDIA. RESET TO ONE MEDIUM INPUT. *****'/);
               1      ]
               0
               0  $SKIP-LINE;
               0
               0  IVAL = IVAL + 1;
               0  NUM_MEDNUM = IVAL;
               0  VALUES_SOUGHT(IVAL)='MEDNUM';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NMED;
               0  DEFAULT(IVAL)=1;
               0  $GET_INPUT(NUM_MEDNUM);
               0
               0  IVAL = IVAL + 1;
               0  NUM_NREGLO = IVAL;
               0  VALUES_SOUGHT(IVAL)='START REGION';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0  $GET_INPUT(NUM_NREGLO);
               0
               0  IVAL = IVAL + 1;
               0  NUM_NREGHI = IVAL;
               0  VALUES_SOUGHT(IVAL)='STOP REGION';
               0  TYPE(IVAL)=0;
               0  VALUE_MIN(IVAL)=0;
               0  VALUE_MAX(IVAL)=NREG;
               0  DEFAULT(IVAL)=1;
               0  $GET_INPUT(NUM_NREGHI);
               0
               0
               0  OUTPUT;(/' *** INPUT CARD M3 ***');
               0  MED(1)=0;
               0  DO I=2,NREG [MED(I)=1;]  "defaults"
               0  OUTPUT NREG;(/' # OF GEOMETRICAL ZONES = ',T60,I12);
               0  WRITE (*,*) 'REGION(  1) = MATERIAL( 0) (VACUUM)';
               0
               0  IF ((NVALUE(NUM_NREGLO)~=NVALUE(NUM_MEDNUM))|
               0  (NVALUE(NUM_NREGHI)~=NVALUE(NUM_MEDNUM))) [
               1      WRITE(ERR,*)'**************ERROR**************';
               1      WRITE(ERR,*)'MEDNUM HAS      ',NVALUE(NUM_MEDNUM),' VALUES';
               1      WRITE(ERR,*)'START REGION HAS',NVALUE(NUM_NREGLO),' VALUES';
               1      WRITE(ERR,*)'STOP REGION HAS ',NVALUE(NUM_NREGHI),' VALUES';
               1      WRITE(ERR,*)'>>>> THEY MUST ALL HAVE THE SAME NUMBER OF VALUES';
               1      ERROR_FLAG=1;
               1      RETURN;
               1      ]
               0  "In the following, we allow for vacuum input"
               0  IF (VALUE(NUM_MEDNUM,1) >= 0) [
               1      DO I=1, NVALUE(NUM_MEDNUM) [
               2          MEDNUM=VALUE(NUM_MEDNUM,I);
               2          NREGLO=VALUE(NUM_NREGLO,I);
               2          NREGHI=VALUE(NUM_NREGHI,I);
               2          IF (NREGHI<=NREGLO) [
               3              MED(NREGLO)=MEDNUM;
               3              OUTPUT NREGLO,MEDNUM;(' REGION(',I4,') = MATERIAL(',I3,')');
               3              ]
               2          ELSE [
               3              DO K=NREGLO,NREGHI [MED(K)=MEDNUM;]
               3              OUTPUT NREGLO,NREGHI,MEDNUM;
               3              (' REGION(',I4,') TO REGION(',I4,') = MATERIAL(',I3,')');
               3              ]
               2          ] "end do I"
               1      ] "end IF ~=0"
               0
               0
               0  "For error checking, get all geomsph inputs"
               0  "$GET_INPUTS(NUM_CONES,NUM_NREGHI);"
               0
               0  $SKIP-LINE;
               0
               0  END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parameter input functions                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Aaron Merovitz, 1998                                      "
               0  "                   Dave Rogers, 1998                                         "
               0  "                   Iwan Kawrakow, 1998                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
               0  "                                                                             "
               0  "  - Input values taken only if between specified delimiters (prior this      "
               0  "    change, the first VALUES_SOUGHT found was taken, even if it was not      "
               0  "    between the specified delimiters).                                       "
               0  "                                                                             "
               0  "  - Changed argument list to a common block GetInput defined in egs4.macros  "
               0  "    to avoid memory use explosion.                                           "
               0  "                                                                             "
               0  "  - Eliminated initial loop checking for presence of values sought as it is  "
               0  "    not necessary.                                                           "
               0  "                                                                             "
               0  "  - Introduced macros for handling strings (skipping blanks and comments,    "
               0  "    changing to upper case, etc.)                                            "
               0  "                                                                             "
               0  "  - Eliminated string input bug: strings were always converted to upper case "
               0  "                                                                             "
               0  "  - Changed definition of strings to character*$MACRO where $MACRO has a     "
               0  "    certain value that can be be defined in the user code if longer strings  "
               0  "    are required.                                                            "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
               0  "                                                                             "
               0  "  - Missing or misspelled end delimiter together with a missing value sought  "
               0  "    caused the routine to terminate. It now prints an error message and      "
               0  "    continues to look for additional input.                                  "
               0  "                                                                             "
               0  "  - Introduced an array ERROR_FLAGS where the input status of each of the    "
               0  "    attempted inputs is stored.                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT;
               0  "                                                                           "
               0  "                                                                           "
               0  " FUNCTION: Extracts the requested values_sought from input file and        "
               0  "           returns it to the caller.                                       "
               0  "                                                                           "
               0  " USAGE   :      Inputs must have the general form:                         "
               0  "              ***************************************                      "
               0  "              * Value_sought=  Value(s)             *                      "
               0  "              ***************************************                      "
               0  "         e.g.:        MEDNUM= 0, 1, 2                                      "
               0  "                      MEDIA= AIR700ICRU                                    "
               0  "                      RAYLEIGH SCATTERING= on                              "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "
               0  "   Inputs are all in the format: name of value_sought= value
               0  "   where the name of value_sought must match that expected by the
               0  "   program and the = sign must have no blanks between it and value_sought.
               0  "
               0  "   The value_sought must be the first thing on a line but blanks are
               0  "     allowed before it.
               0  "
               0  "   Various inputs are only sought between certain delimeter strings
               0  "     which are defined below (eg :start I/O control: :stop I/O control:)
               0  "     If not specified, the whole file is searched for a requested value_sought.
               0  "     Delimeter strings are enclosed by colons.
               0  "     Note that within delimeter strings, order of inputs does not matter.
               0  "
               0  "   If a requested quantity is not found, this is noted in $input.errors
               0  "     and this file is printed at the end of the log file.
               0  "
               0  "   A semi-colon implies the end of input for this quantity but is
               0  "     not mandatory.  However, this means they cannot be used in titles.
               0  "   A # sign indicated everything else on the line is a comment (and
               0  "     cannot be used in titles.
               0  "   Case is not important in the names of the quantites.
               0  "
               0  "   Commas separate multiple values for a given quantity and a comma
               0  "     at the end of a line implies there is more input on the next line.
               0  "   Values can extend over as many lines as needed. Use commas to imply
               0  "     there are more values on the next line.
               0  "
               0  "   Blank lines and blanks in general are ignored.
               0  "
               0  "   The maximum record length is 256 characters.
               0  "
               0  "
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  "                                                                           "
               0  "                                                                           "
               0  " FEATURES: If the amount of values needed for a particular values_sought   "
               0  "           is known and passed throught NVALUE(I), the subroutine will     "
               0  "           check that the number of inputs correspond.  Otherwise,         "
               0  "           NVALUE(I) will return the # of inputs found.                    "
               0  "                                                                           "
               0  "           For any integer or real (TYPE=0 or 1), get_inputs will check    "
               0  "           that the numerical value input is between VALUE_MIN and         "
               0  "           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
               0  "                                                                           "
               0  "           Writing in the input file can be upper case or lower case.      "
               0  "           However, all FORTRAN >MUST< be programmed in upper case.        "
               0  "              Changed the above: Can now be upper or lower case            "
               0  "                                 IK, Dec. 1998                             "
               0  "                                                                           "
               0  "           For clarity, inputs can be terminated with a semicolon(;).      "
               0  "           This is by no means necessary.                                  "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "                                                                           "
               0  "                   **** DECLARE YOUR INPUTS ****                           "
               0  "                                                                           "
               0  "    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
               0  "                                                                           "
               0  "  I=I+1;                              <--index counter                     "
               0  "  NUM_DRMIN=I;                        <--named pointer to the index num.   "
               0  "  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
               0  "  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
               0  "  TYPE(I)=0;                          <--Type (0-3)                        "
               0  "  VALUE_MIN(I)=0;                     <--Minimum value                     "
               0  "  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
               0  "  DEFAULT(I)=0;                       <--Default value                     "
               0  "                                                                           "
               0  "    CHARACTER INPUTS (TYPE 2)                                              "
               0  "                                                                           "
               0  "  I=I+1;
               0  "  NUM_TITLE=I;
               0  "  VALUES_SOUGHT(I)='TITLE';
               0  "  TYPE(I)=2;
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "
               0  "    ALLOWED INPTUS (TYPE 3)
               0  "
               0  "  I=I+1;
               0  "  NUM_IWATCH=I;
               0  "  VALUES_SOUGHT(I)='IWATCH';
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "  TYPE(I)=3;
               0  "  ALLOWED_INPUTS(I,0)='OFF';
               0  "  ALLOWED_INPUTS(I,1)='INTERACTIONS';
               0  "  ALLOWED_INPUTS(I,2)='STEPS';
               0  "  ALLOWED_INPUTS(I,3)='DEPOSITED';
               0  "  ALLOWED_INPUTS(I,4)='GRAPH';
               0  "                                                                           "
               0  "                      **** STATE THE DELIMETER ****                        "
               0  "                                                                           "
               0  "            DELIMETER='TRANSPORT CONTROL'                                  "
               0  "     OR     DELIMETER='NONE';                                              "
               0  "                                                                           "
               0  "  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
               0  "                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
               0  "                                                                           "
               0  "   The inputs are returned through CHAR_VALUE for character inputs         "
               0  "   or VALUE for integers, reals and allowed inputs                         "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0
               0
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING256 TEXTPIECE;  "Used to read a piece of TEXT                 "
               0  CHARACTER*$STRING80  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING80  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  UNITNUM=i_input; "inputfile.egs4inp"
               0  DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);   "Rewind the input file"
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIMETER = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIMETER~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A256)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A256)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  "the following is no longer used so comment it out"
               0  ":GI1002:
               0  "      WRITE (ERR,*) '***************ERROR***************';
               0  "      IF (CHECK=100) [
               0  "         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               0  "         WRITE (ERR,*) 'WAS NOT FOUND';
               0  "      ]
               0  "      ELSE [
               0  "         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               0  "                       '<<',' NOT FOUND';
               0  "      ]
               0  "      WRITE (ERR,*) 'END OF FILE REACHED';
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0
               0
1              0  %E   "get_inputs.mortran"
               0  "*****************************************************************************
               0  "
               0  subroutine get_transport_parameter(ounit);
               0  "
               0  " is provided for use with the EGSnrc system. It reads all physics
               0  " related parameters from the input file using the get_input routine.
               0  " For a description for the format/conventions used in get_input,
               0  " see the description at the beginning of this file.
               0  " In order to use this routine, include transportp.macros BEFORE
               0  " get_inputs.mortran via the configuration file.
               0  " If the routine is called with ounit > 0, the transport parameter
               0  " settings will be printid on unit ounit.
               0  "
               0  " Version 0.1           Iwan Kawrakow, January 1999
               0  "
               0  "******************************************************************************
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  You can change this by including the statement
               0  "
               0  "  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
               0  "
               0  "  in your input file.
               0  "
               0  "  Currently, the following options are available (case does not matter and
               0  "             the internal variables are shown in [ ] brackets):
               0  "
               0  "       Global ECUT=     Global (in all regions) electron transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Global (in all regions) photon transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions
               0  "                        will be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%).
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        difference even in `well conditioned' situations
               0  "                        (e.g. depth dose curves for RTP energy range
               0  "                        electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If KM, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, NRC default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but significant in the keV energy range. If NRC is
               0  "                        selected, the NRC brems cross-section data base will
               0  "                        be used, which is a version of the NIST data base
               0  "                        with corrected electron-electron brems contributions
               0  "                        (corrections to the NIST data is typically only
               0  "                        significant for low values of the atomic number Z
               0  "                        and for k/T < 0.005).
               0  "       Triplet production= On or Off (default).  Turns on/off simulation
               0  "                        of triplet production.  If On, then Borsellino's
               0  "                        first Born approximation is used to sample triplet
               0  "                        events based on the triplet cross-section data.
               0  "                        [ itriplet ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej (default)
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impulse approximation.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to use for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Radiative Compton corrections= On or Off (default). If on, then
               0  "                        include radiative corrections for Compton scattering.
               0  "                        Equations are based on original Brown & Feynman
               0  "                        equations (Phys. Rev. 85, p 231--1952).  Requires
               0  "                        a change to the user codes Makefile to include
               0  "                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
               0  "                        SOURCES (just before
               0  "                        $(EGS_SOURCEDIR)get_inputs.mortran).
               0  "                        [ radc_flag ]
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski, penelope.  If set to On or ik, then use
               0  "                        Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then
               0  "                        use the cross-sections of Casnati (contained in the
               0  "                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
               0  "                        kolbenstvedt, gryzinski and penelope. This is only of
               0  "                        interest in kV X-ray calculations.
               0  "                        Case-sensitive except for Off, On or ik options.
               0  "                        [ eii_flag ]
               0  "       Pair angular sampling= Off, Simple, KM.
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.  Uniform
               0  "                        Default is Simple, make sure you always use
               0  "                        Simple or KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel), epdl (Evaluated Photon Data
               0  "                        Library), xcom (the default), pegs4, mcdf-xcom and
               0  "                        mcdf-epdl:
               0  "                        Allows the use of photon cross-sections other than
               0  "                        from the PEGS4 file (unless the pegs4 option is
               0  "                        specified).  Options mcdf-xcom and mcdf-epdl use
               0  "                        Sabbatucci and Salvat's renormalized photoelectric
               0  "                        cross sections with either xcom or epdl for all other
               0  "                        cross sections.  These are more accurate but can
               0  "                        increase CPU time by up to 6 %.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turn on coherent (Rayleigh) scattering.
               0  "                        Default is On. Should be turned on for low energy
               0  "                        applications.
               0  "                        If custom, user must provide media names and form
               0  "                        factor files for each desired medium. For the rest
               0  "                        of the media, default atomic FF are used.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "Ali:photonuc, 2 blocks of comments"
               0  "       Photonuclear attenuation= Off (default) or On
               0  "                        If On, models the photonuclear effect. Current
               0  "                        implementation is crude. Available on a
               0  "                        region-by-region basis (see below)
               0  "                        [ IPHOTONUCR ]
               0  "       Photonuclear cross sections= Total photonuclear cross sections. User-
               0  "                        supplied total photonuclear cross-sections in
               0  "                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
               0  "                        where photonuc_xsections is the name supplied for
               0  "                        this input (case sensitive). In the absence of
               0  "                        any user-supplied data, or if photonuc_xsections
               0  "                        is set to 'default', the default file is
               0  "                        iaea_photonuc.data.
               0  "                        [ photonuc_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is On
               0  "                        [ IPHTER ]
               0  "       Atomic relaxations= Off, On, eadl, simple
               0  "                        Default is eadl.  On defaults to eadl.
               0  "                        When simulating atomic relaxations:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross sections
               0  "                        - Shell vacancies created in photoelectric,
               0  "                          compton and electron impact ionization events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         The eadl option features a more accurate treatment
               0  "                         of relaxation events and uses binding energies
               0  "                         consistent with those in of the photon cross sections
               0  "                         used in the simulation.  If using mcdf-xcom or
               0  "                         mcdf-epdl photon cross sections, you cannot use
               0  "                         the simple option and this will automatically get
               0  "                         reset to eadl.
               0  "                         Make sure to use eadl or simple for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "       and photonuclear effect(Ali:photonuc)
               0  "       can also be turned On/Off on a region-by-region
               0  "       basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "                or                  Ali:photonuc
               0  "       Photonuclear start region=
               0  "       Photonuclear stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0
               0  implicit none;  "Hard coded to catch possible user replacements of the "
               0  "following common blocks"
               0
               0  character*80 line;
               0  character*512 toUpper;
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0
               0  $INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
               0  num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
               0  num_ffmed,num_ffiles,
               0  num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
               0  num_pxsec,num_pxsec_out, num_cxsec,
               0  num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
               0  num_efield, num_bfield, num_emlmt,"EMH: EM fields"
               0  num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
               0  egs_open_file,lnblnk1;
               0
               0  $LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"
               0
               0  character*15 output_strings(14);"Ali:photonuc, increased by 1"
               0  save         output_strings,line;
               0  save         ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions,
               0  num_photonuc;"Ali:photonuc"
               0
               0
               0  DO k=1,80 [ line(k:k) = '='; ]
               0  delimeter = $THE_DELIMETER;
               0  ival = 0;
               0
               0  ;
               0  /ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,
               0  "Ali:photonuc, 1 line"
               0  photonuc_inregions/ = .false.;
               0
               0  "open a .errors file exclusively for output from this subroutine"
               0  i_errors=15;
               0  i_errors=egs_open_file(i_errors,0,1,'.errors');
               0
               0  write(i_errors,*)
               0  ' If you are not trying to reset transport parameters, ';
               0  write(i_errors,*)
               0  ' ignore all the output until the message ';
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  " ECUT "
               0  ival                = ival + 1;
               0  num_ecut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-ECUT;
               0
               0  " PCUT "
               0  ival                = ival + 1;
               0  num_pcut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-PCUT;
               0
               0  " SMAX "
               0  ival                = ival + 1;
               0  num_smax            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_SMAX;             "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $MAX-SMAX;
               0
               0  " Incoherent (Compton) scattering "
               0  ival                = ival + 1;
               0  num_incoh           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'Simple';
               0  allowed_inputs(ival,5) = 'norej';
               0
               0  " Radiative corrections for Compton scattering "
               0  ival                = ival + 1;
               0  num_radc            = ival;
               0  values_sought(ival) = $RADC_COMPTON;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Coherent (Rayleigh) scattering "
               0  ival                = ival + 1;
               0  num_coh             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'custom';
               0
               0  " Atomic Relaxations "
               0  ival                = ival + 1;
               0  num_relax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'eadl';
               0  allowed_inputs(ival,5) = 'simple';
               0
               0  " Photoelectron angular sampling "
               0  ival                = ival + 1;
               0  num_pe_ang          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Bremsstrahlung angular sampling "
               0  ival                = ival + 1;
               0  num_brems_ang       = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Simple';
               0  allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0
               0  " Bremsstrahlung cross sections "
               0  ival                = ival + 1;
               0  num_brems_cs        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
               0  allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"
               0
               0
               0  " Pair angular sampling "
               0  ival                = ival + 1;
               0  num_pair_ang        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
               0  allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0  allowed_inputs(ival,3) = 'Uniform';
               0  allowed_inputs(ival,4) = 'Blend';
               0
               0  " Pair cross sections "
               0  ival                = ival + 1;
               0  num_pair_cs         = ival;
               0  values_sought(ival) = $PAIR_CROSS_SECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NRC';
               0
               0  " Triplet production "
               0  ival                = ival + 1;
               0  num_triplet         = ival;
               0  values_sought(ival) = $TRIPLET_PRODUCTION;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Spin effects          "
               0  ival                = ival + 1;
               0  num_spin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SPIN_EFFECTS;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';                 "Only global on/off available"
               0
               0  " Electron impact ionization "
               0  ival                = ival + 1;
               0  num_eii             = ival;
               0  values_sought(ival) = $ELECTRON_IMPACT_IONI;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0  "type(ival)          = 3;"
               0  "allowed_inputs(ival,0) = 'Off';"
               0  "allowed_inputs(ival,1) = 'On';"
               0  "allowed_inputs(ival,2) = 'casnati';"
               0  "allowed_inputs(ival,3) = 'kolbenstvedt';"
               0  "allowed_inputs(ival,4) = 'gryzinski';"
               0
               0  " L-shell EII xsection scaling"
               0  ival                = ival + 1;
               0  num_eii_L= ival;                                "Set the variable pointer"
               0  values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0e+9;
               0  default(ival)       = 1.0;
               0
               0  " ESTEPE "
               0  ival                = ival + 1;
               0  num_estepe          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 1e-5;                     "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $MAX-ELOSS;
               0
               0  " XIMAX "
               0  ival                = ival + 1;
               0  num_ximax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $EXACT-BCA-XIMAX;
               0
               0  " BCA "
               0  ival                = ival + 1;
               0  num_bca             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Exact';
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Skindepth "
               0  ival                = ival + 1;
               0  num_skin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1;                       "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $SKIN-DEPTH-FOR-BCA;
               0
               0  " Electron-step algorithm "
               0  ival                = ival + 1;
               0  num_alg             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Photon cross sections "
               0  ival                = ival + 1;
               0  num_pxsec           = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " Photon cross sections output "
               0  ival                = ival + 1;
               0  num_pxsec_out       = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS_OUT;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Compton cross sections "
               0  ival                = ival + 1;
               0  num_cxsec           = ival;
               0  values_sought(ival) = $COMPTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " E-Field "
               0  ival                = ival + 1;
               0  num_efield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $E_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e15;                    "Define the allowed range"
               0  value_max(ival)     =  1e15;
               0  default(ival)       =  0;
               0
               0  " B-Field "
               0  ival                = ival + 1;
               0  num_bfield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $B_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e10;                    "Define the allowed range"
               0  value_max(ival)     =  1e10;
               0  default(ival)       =  0;
               0
               0  " EM-field step and eloss restriction "
               0  ival                = ival + 1;
               0  num_emlmt           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $EM_LMT;                 "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0;
               0  default(ival)       = 0.02;
               0
               0  "Ali:photonuc, 2 blocks"
               0  " Photonuclear "
               0  ival                = ival + 1;
               0  num_photonuc        = ival;           "set the variable pointer"
               0  values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
               0  nvalue(ival)        = 1;              "1 input"
               0  type(ival)          = 3;              "an `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Photonuclear cross sections "
               0  ival                = ival + 1;
               0  num_photonuc_xsec   = ival;
               0  values_sought(ival) = $PHOTONUC_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  "Ali:photonuc, 1 line"
               0  Nmin = num_ecut; Nmax = num_photonuc_xsec;
               0  "Nmin = num_ecut; Nmax = num_cxsec;"
               0
               0  CALL GET_INPUT;
               0
               0  IF( error_flags(num_ecut) = 0 ) [
               1      DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
               1      ]
               0  IF( error_flags(num_pcut) = 0 ) [
               1      DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
               1      ]
               0  IF( error_flags(num_smax) = 0 ) [
               1      DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
               1      ]
               0  IF( error_flags(num_brems_ang) = 0 ) [
               1      ibrdst = value(num_brems_ang,1);
               1      ]
               0  IF( error_flags(num_brems_cs) = 0 ) [
               1      ibr_nist = value(num_brems_cs,1);
               1      ]
               0  IF( error_flags(num_radc) = 0 ) [
               1      radc_flag = value(num_radc,1);
               1      ]
               0  IF( error_flags(num_pair_ang) = 0 ) [
               1      iprdst = value(num_pair_ang,1);
               1      ]
               0  IF( error_flags(num_pair_cs) = 0 ) [
               1      pair_nrc = value(num_pair_cs,1);
               1      ]
               0  IF( error_flags(num_triplet) = 0 ) [
               1      itriplet = value(num_triplet,1);
               1      ]
               0  IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
               0  IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
               0  IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
               0  IF( error_flags(num_bca) = 0 ) [
               1      bca_algorithm = value(num_bca,1);
               1      IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               1      ]
               0  IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
               0  IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
               0  IF( error_flags(num_spin) = 0 ) [
               1      itmp = value(num_spin,1);
               1      IF( itmp = 1 ) [ spin_effects = .true.; ]
               1      ELSE           [ spin_effects = .false.; ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_eii) = 0 ) [
               1      eii_xfile = char_value(num_eii,1);eii_flag=1;
               1      IF (toUpper($cstring(eii_xfile)).eq.'ON' |
               1      toUpper($cstring(eii_xfile)).eq.'IK' )[
               2          eii_xfile = 'ik';
               2          $egs_info(*,'==> Using default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
               2          eii_xfile='Off';eii_flag=0;
               2          ]
               1      ELSE["Using non-default EII data compilation"
               2          $egs_warning(*,'==> Using non-default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_pxsec) = 0 ) [
               1      photon_xsections = char_value(num_pxsec,1);
               1      IF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-XCOM' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
               2          ]
               1      ELSEIF ( toUpper( $cstring(photon_xsections) ) = 'MCDF-EPDL' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
               2          ]
               1      ELSE[
               2          mcdf_pe_xsections = .false.;
               2          ]
               1      ]
               0
               0  IF( error_flags(num_pxsec_out) = 0 ) [
               1      xsec_out = value(num_pxsec_out,1);
               1      ]
               0  IF( error_flags(num_cxsec) = 0 ) [
               1      comp_xsections = char_value(num_cxsec,1);
               1      ]
               0  "Ali:photonuc, 3 lines"
               0  IF( error_flags(num_photonuc_xsec) = 0 ) [
               1      photonuc_xsections = char_value(num_photonuc_xsec,1);
               1      ]
               0
               0  IF( error_flags(num_efield) = 0 ) [
               1      ExIN = value(num_efield,1);
               1      EyIN = value(num_efield,2);
               1      EzIN = value(num_efield,3);
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( ExIN**2+EyIN**2+EzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented only for the C++ applications     "
               0  IF( error_flags(num_bfield) = 0 ) [
               1      BxIN = value(num_bfield,1);
               1      ByIN = value(num_bfield,2);
               1      BzIN = value(num_bfield,3);
               1      Bx=BxIN;By=ByIN;Bz=BzIN;
               1      Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      IF( BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               2          emfield_on=.true.
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_coh) = 0 ) [
               1      IF(value(num_coh,1) = 4)[
               2          write(*,'(/a/)') ' ===> custom ff requested!';
               2          ival                = ival + 1;
               2          num_ffmed           = ival;
               2          values_sought(ival) = 'ff media names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          ival                = ival + 1;
               2          num_ffiles          = ival;
               2          values_sought(ival) = 'ff file names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          Nmin = num_ffmed; Nmax = num_ffiles;
               2          CALL GET_INPUT;
               2          IF( error_flags(num_ffmed) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffmed));
               3              ]
               2          IF( error_flags(num_ffiles) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffiles));
               3              ]
               2          IF (nvalue(num_ffmed)>$MXMED)[
               3              $egs_fatal('(a,a,i3,a)',
               3              '***** Number of media with custom ff larger ',
               3              'than maximum number of media $MXMED = ',$MXMED,
               3              ' increase $MXMED and try again!!!');
               3              ]
               2          DO i=1,nvalue(num_ffmed) [
               3              iray_ff_media(i) = char_value(num_ffmed,i);
               3              iray_ff_file(i)  = char_value(num_ffiles,i);
               3              ]
               2          value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
               2          ]
               1      write(*,'(/)');
               1      ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $TURN-ON/OFF-IN-REGIONS(num_incoh,
               0  'Bound Compton start region',
               0  'Bound Compton stop region',
               0  ibcmp); incoh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_coh,
               0  'Rayleigh start region',
               0  'Rayleigh stop region',
               0  iraylr); coh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_relax,
               0  'Relaxations start region',
               0  'Relaxations stop region',
               0  iedgfl); relax_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_pe_ang,
               0  'PE sampling start region',
               0  'PE sampling stop region',
               0  iphter); pe_inregions = aux_inregions;
               0  "Ali:photonuc, 1 block"
               0  $TURN-ON/OFF-IN-REGIONS(num_photonuc,
               0  'Photonuclear start region',
               0  'Photonuclear stop region',
               0  iphotonucr); photonuc_inregions = aux_inregions;
               0  $SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
               0  'Set ECUT stop region');
               0  ecut_inregions = aux_inregions;
               0
               0  $SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
               0  'Set PCUT stop region');
               0  pcut_inregions = aux_inregions;
               0
               0  $SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
               0  'Set SMAX stop region');
               0  smax_inregions = aux_inregions;
               0
               0  write(i_errors,*);
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  "Check if EADL relaxation requested. Note that original relaxation"
               0  "algorithm using <M> and <N> is only turned ON for all regions."
               0  "Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
               0  "default case."
               0  IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
               1      eadl_relax = .true.;
               1      "Default relaxation is EADL"
               1      IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
               1      ]
               0  ELSE [
               1      IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
               2          eadl_relax = .true.; value(num_relax,1)=4;
               2          $egs_warning('(a/,a/,a/)',
               2          '    Simplified atomic relaxation not allowed',
               2          '    with shellwise PE cross sections. Resetting',
               2          '    to detailed EADL atomic relaxation!!!');
               2          ]
               1      ELSE [
               2          eadl_relax = .false.;
               2          ]
               1      ]
               0
               0  " we put the information stored in allowed_inputs into "
               0  " output_strings just in case the user over-rides it "
               0  " before printing out the settings "
               0
               0  output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
               0  itmp = value(num_incoh,1);
               0  output_strings(2) = allowed_inputs(num_incoh,itmp);
               0  $RADC_WARNING;
               0  output_strings(12) = allowed_inputs(num_radc,radc_flag);
               0  itmp = value(num_coh,1);
               0  output_strings(3) = allowed_inputs(num_coh,itmp);
               0  itmp = value(num_relax,1);
               0  output_strings(4) = allowed_inputs(num_relax,itmp);
               0  itmp = value(num_pe_ang,1);
               0  output_strings(5) = allowed_inputs(num_pe_ang,itmp);
               0  output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
               0  output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
               0  output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
               0  output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
               0  output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
               0  output_strings(11) = allowed_inputs(num_triplet,itriplet);
               0  "output_strings(13) = allowed_inputs(num_eii,eii_flag);"
               0  "Ali:photonuc, 2 lines"
               0  itmp = value(num_photonuc,1);
               0  output_strings(14) = allowed_inputs(num_photonuc,itmp);
               0
               0  entry show_transport_parameter(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0  write(ounit,'(a,/)')
               0  '                   Electron/Photon transport parameter';
               0  write(ounit,'(a,/)') line;
               0
               0
               0  IF (mcdf_pe_xsections)[
               1      write(ounit,'(a,38x,a,a)') ' Photon cross sections',
               1      'mcdf-',$cstring(photon_xsections);
               1      ]
               0  ELSE[
               1      write(ounit,'(a,38x,a)') ' Photon cross sections',
               1      $cstring(photon_xsections);
               1      ]
               0  write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);
               0
               0  write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
               0  IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
               1      ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
               1      ]
               0  write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
               0  write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
               0  write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
               0  write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
               0  write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
               0  write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
               0  write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
               0  write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
               0  "Ali:photonuc, 3 lines. EMH added IF statement"
               0  IF ( value(num_photonuc,1) > 0 )[
               1      write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
               1      write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
               1      $cstring(photonuc_xsections);
               1      ]
               0
               0  write(ounit,*);
               0
               0  write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
               0  IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
               1      ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
               1      ]
               0  write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
               0  write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
               0  IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
               0  ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
               0  write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
               0  IF (eii_L_factor ~= 1.0) [
               1      write(ounit,'(a,25x,f6.4)')
               1      ' L-shell EII xsections scaling factor',eii_L_factor;
               1      ]
               0  write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
               0  IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
               1      ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
               1      ]
               0  write(ounit,'(a,16x,f6.4)')
               0  ' Maximum fractional energy loss/step (ESTEPE)',estepe;
               0  write(ounit,'(a,21x,f6.4)')
               0  ' Maximum 1st elastic moment/step (XIMAX)',ximax;
               0  write(ounit,'(a,33x,a10)')
               0  ' Boundary crossing algorithm',output_strings(7);
               0  write(ounit,'(a,22x,g9.4)')
               0  ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
               0  write(ounit,'(a,37x,a10)')
               0  ' Electron-step algorithm',output_strings(8);
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
               1      write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
               1      ExIN,EyIN,EzIN;
               1      ]
               0  IF( Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
               1      Bx,By,Bz;
               1      ]
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
               0  Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
               1      ]
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0
               0  return;
               0  end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine set_elastic_parameter;
               0
               0  implicit none;
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0  ;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
               0  $INTEGER imed,ival,lnblnk1,nchanged;
               0  character*24 medname;
               0
               0  ounit = i_log;
               0  ounit = i_log;
               0  delimeter = $THE_DELIMETER;
               0  call get_input_set_error_level(0);
               0  ival = 0;
               0  DO imed=1,nmed [
               1      call egs_get_medium_name(imed,medname);
               1      ival                = ival + 1;
               1      values_sought(ival) = 'scale elastic scattering in '//
               1      medname(:lnblnk1(medname));
               1      nvalue(ival)        = 1;
               1      type(ival)          = 1;
               1      value_min(ival)     = 1e-3;
               1      value_max(ival)     = 1e3;
               1      default(ival)       = 1;
               1      ]
               0  Nmin = 1; Nmax = nmed;
               0  CALL GET_INPUT;
               0  nchanged = 0;
               0  DO imed=1,nmed [
               1      IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
               1      ]
               0  IF( nchanged > 0 ) [
               1      write(ounit,'(//a)')
               1      '================ Elastic scattering scaled as follows ==================';
               1      DO imed=1,nmed [
               2          IF( error_flags(imed) = 0 ) [
               3              call egs_get_medium_name(imed,medname);
               3              xcc(imed)  = xcc(imed)*value(imed,1);
               3              blcc(imed) = blcc(imed)*value(imed,1);
               3              write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
               3              value(imed,1);
               3              ]
               2          ]
               1      write(ounit,'(a//)')
               1      '========================================================================';
               1      ]
               0  return; end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc auxiliary routines for NRC user codes                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These are auxiliary routines used in many NRC user codes.                  "
               0  "                                                                             "
               0  "  If you include them via your configuration file, your user code will need  "
               0  "  to define $MXDATA and $STAT. For example, if you are not using the         "
               0  "  statistical analysis package:                                              "
               0  "                                                                             "
               0  "  REPLACE {$MXDATA} WITH {1}; REPLACE{$STAT} WITH {1};                       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %C80                                                                           ;
               0  "*****************************************************************************"
               0  "                                                                             "
               0  "                        WATCH                                                "
               0  "                                                                             "
               0  SUBROUTINE WATCH(IARG,IWATCH);
               0
               0  "============================================================================="
               0  "                                                                             "
               0  "     A general purpose auxiliary routine for use with the EGSnrc system
               0  "
               0  "     It prints out information about the particle transport                  "
               0  "                                                                             "
               0  "       For IWATCH = 1 it prints information about each discrete interaction  "
               0  "       For IWATCH = 2 or 3 it prints information about each step as well     "
               0  "       For IWATCH = 4 it prints graphing data for use with EGS_Windows       "
               0  "                                                                             "
               0  "                                                                             "
               0  "    Routine is used via two mandatory and 1 optional call from the user's    "
               0  "          code                                                               "
               0  "                                                                             "
               0  "   1)The routine must be initialized by a call with IARG=-99 before the first"
               0  "          call to SHOWER. It should be after all inputs are in place.        "
               0  "   2)The routine must be called near the beginning of the AUSGAB subroutine  "
               0  "          IF (IWATCH > 0 ) CALL WATCH(IARG,IWATCH);                          "
               0  "   3)The routine may be called at the end of each history with IARG = - 1 so "
               0  "          a message will get printed stated history is complete              "
               0  "                                                                             "
               0  "    Since WATCH cannot output values related to the initial values in a      "
               0  "    shower call, it is useful to also put something like the following       "
               0  "    immediately prior to the CALL SHOWER stmt                                "
               0  "           IF((IWATCH ~= 0) & (IWATCH ~= 4))[                                "
               0  "              OUTPUT 1,EIN,IQI,IRI,XI,YI,ZI,UI,VI,WI,LATCHI,WTI;              "
               0  "               (/' INITIAL SHOWER VALUES',T36,':',                           "
               0  "               I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);                         "
               0  "           ]                                                                 "
               0  "    Note EIN is the kinetic energy of the incident particle                  "
               0  "                                                                             "
               0  "                                                                             "
               0  "   The routine uses up to 132 columns for output.                            "
               0  "                                                                             "
               0  "     JAN 1984  GENERALIZED VERSION WITH INITIALIZATION                       "
               0  "                              DAVE ROGERS NRCC                               "
               0  "     JUN 1987  PUT IN IWATCH = 4 OPTION     AFB                              "
               0  "     JUL 1988  COMPATIBLE WITH X-RAY FLUORESCENCE  DWOR                      "
               0  "     SEP 1990  ADDED ENERGY OUTPUT TO IWATCH = 4 OPTION     AFB              "
               0  "     OCT 1990  UNIX compatible carriage control   DWOR                       "
               0  "     JAN 2000  Rewritten to output relaxation particles and also             "
               0  "               so some of the output makes more sense BW                     "
               0  "                                                                             "
               0  "*****************************************************************************"
               0
               0  "define a local macro"
               0  REPLACE {$CNTOUT(#);(#);} WITH {
            {  0  ICOUNT=ICOUNT+1;
            {  0  OUTPUT {P1},KE,IQ({P1}),IR({P1}),X({P1}),Y({P1}),Z({P1}),U({P1}),V({P1}),
            {  0  W({P1}),LATCH({P1}),WT({P1});  ({P2},I5,F9.3,2I4,3F8.3,3F7.3,I10,1PE10.3);
            {  0  }
               0
               0  $IMPLICIT-NONE;
               0  $INTEGER iarg,iwatch,IP,ICOUNT,JHSTRY,J,N;
               0  $REAL KE;
               0  $INTEGER graph_unit;
               0  integer  egs_open_file;
               0  $INTEGER ku,kr,ka;
               0
               0  ;COMIN/BOUNDS, STACK,EPCONT,EGS-VARIANCE-REDUCTION,USEFUL,EGS-IO/;
               0
               0  DATA ICOUNT/0/,JHSTRY/1/ graph_unit/-1/;
               0  save     ICOUNT,JHSTRY,graph_unit;
               0
               0  ku = 13; kr = 0; ka = 1;
               0  IF(IARG = -99) [ "Initialize flags so we will get calls thru AUSGAB"
               1      DO J=1,29[IAUSFL(J)=1;];
               1      /IAUSFL(22),IAUSFL(23),IAUSFL(24)/=0;
               1      ]
               0
               0  IF(IARG = -1) ["main is assumed to call AUSGAB with IARG=-1 at end of history"
               1      IF(IWATCH = 4) [
               2          IF( graph_unit < 0 ) [
               3              graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               3              ]
               2          WRITE(graph_unit,:GRAPHICS_FORMAT:) 0,0,0,0.0,0.0,0.0,0.0,JHSTRY;
               2          JHSTRY=JHSTRY+1;
               2          ]
               1      ELSE[
               2          OUTPUT JHSTRY;(' END OF HISTORY',I8,3X,40('*')/);
               2          JHSTRY=JHSTRY+1;ICOUNT=ICOUNT+2;RETURN;
               2          ]
               1      ]
               0
               0  IF( (IWATCH ~= 4) & ((ICOUNT >= 50) | (ICOUNT = 0) | (IARG = -99)) )[
               1      "PRINT HEADER"
               1      ICOUNT=1;
               1      OUTPUT;(//T39,' NP',3X,'ENERGY  Q REGION    X',7X,
               1      'Y',7X,'Z',6X,'U',6X,'V',6X,'W',6X,'LATCH',2X,'WEIGHT'/);
               1      ]
               0
               0  IF((IWATCH = 4) & (IARG >= 0) & (IARG ~= 5)) [ "GRAPHICS OUTPUT"
               1      IF( graph_unit < 0 ) graph_unit = egs_open_file(ku,kr,ka,'.egsgph');
               1      WRITE(graph_unit,:GRAPHICS_FORMAT:) NP,IQ(NP),IR(NP),X(NP),Y(NP),Z(NP),E(NP);
               1      :GRAPHICS_FORMAT:FORMAT(2I4,1X,I6,4G15.8,I12);
               1      ]
               0
               0  IF(IARG = 5  |  IARG < 0) RETURN;
               0  IF(IWATCH = 4) RETURN; "NONE OF THE REST NEEDED FOR GRAPHICS OUTPUT"
               0
               0  KE=E(NP);IF(IQ(NP).NE.0)[KE=E(NP)-PRM;]
               0
               0  IF(IARG = 0 & IWATCH = 2)[
               1      $CNTOUT(NP);(T11,'STEP ABOUT TO OCCUR', T36,':');
               1      ]
               0  ELSEIF(IARG = 0)[RETURN;]
               0  IF(    IARG = 1)[
               1      $CNTOUT(NP);(' Discard  AE,AP<E<ECUT',T36,':');]
               0  ELSEIF(IARG = 2)[
               1      $CNTOUT(NP);(' Discard  E<AE,AP',T36,':');]
               0  ELSEIF(IARG = 3)[
               1      $CNTOUT(NP);(' Discard -user request',T36,':');]
               0  ELSEIF(IARG = 4)[OUTPUT EDEP,IR(NP);
               1      (T10,'Local energy deposition',T36,':',F12.5,' MeV in region ',I6);]
               0
               0  ELSEIF(IARG = 6)[
               1      $CNTOUT(NP);(' bremsstrahlung  about to occur',T36,':');]
               0  ELSEIF(IARG = 7)[
               1      IF(nbr_split =1) ["no splitting or SBS is on in BEAMnrc"
               2          DO IP=NPold,NP[
               3              IF(IQ(IP)=-1)[
               4                  KE = E(IP) - RM;
               4                  $CNTOUT(IP);(T10,'Resulting electron',T36,':');
               4                  ]
               3              ELSE[
               4                  KE = E(IP);
               4                  $CNTOUT(IP);(T10,'Resulting photon',T36,':');
               4                  ]
               3              ]
               2          ]
               1      ELSE ["splitting case--e- is always at NPold"
               2          KE = E(NPold) - RM;
               2          $CNTOUT(NPold);(T10,'Resulting electron',T36,':');
               2          DO IP=NPold+1,NP[
               3              KE= E(IP);
               3              IF(IP = NPold+1)["print info for first one only"
               4                  $CNTOUT(IP);(T10,'Split photons',T36,':');
               4                  ]
               3              ELSE[ $CNTOUT(IP);(T36,':'); ]
               3              ]
               2          ]" end of splitting block"
               1      ]
               0
               0  ELSEIF(IARG = 8)[$CNTOUT(NP);(' Moller   about to occur',T36,':');]
               0  ELSEIF(IARG = 9)[
               1      "surely this logic not needed?"
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(NP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting electrons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 10)[
               1      $CNTOUT(NP);(' Bhabba   about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 11)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[ $CNTOUT(IP);(T11,'Resulting e- or e+',T36,':'); ]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 12)[
               1      $CNTOUT(NP);(' Positron about to decay in flight',T36,':');
               1      ]
               0  ELSEIF(IARG = 13)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting photons',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 28)[
               1      $CNTOUT(NP);(' Positron will annihilate at rest',T36,':');
               1      ]
               0  ELSEIF(IARG = 14)[
               1      IF(NP=NPold)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(' Positron annihilates at rest',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 15)[
               1      $CNTOUT(NP);(' Pair production about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 16)["after pair production"
               1      IF(NP=NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP=NPold & i_survived_rr > 0)["we have cleared the stack"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ELSE[
               2          DO IP=NPold,NP[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IP=NPold)[$CNTOUT(IP);(T11,'Resulting pair',T36,':');]
               3              ELSE[$CNTOUT(IP);(T36,':');]
               3              ]
               2          IF(i_survived_rr > 0)[
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I2,'
            '  3              particle(s) with probability ',F8.5);
               3              $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               3              ]
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 17)[$CNTOUT(NP);(' Compton  about to occur',T36,':');]
               0  ELSEIF(IARG = 18)["after call to COMPT"
               1      IF(NP = NPold & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Interaction rejected',T36,':');
               2          ]
               1      ELSEIF(NP > NPold)["have not cleared the stack with rus rou"
               2          DO IP=NPold,NPold+1[
               3              KE = E(IP) - ABS(IQ(IP))*RM;
               3              IF(IQ(IP).NE.0)[$CNTOUT(IP);(T11,'compton electron created',T36,':');]
               3              ELSE[$CNTOUT(IP);(T11,'compton scattered photon',T36,':');]
               3              ]
               2          ]
               1      IF(i_survived_rr > 0)["whether the stack has been cleared or not"
               2          OUTPUT i_survived_rr,prob_rr;
               2          (T10,'Russian Roulette eliminated ',I2,
               2          ' particle(s) with probability ',F8.5)
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 19)[
               1      $CNTOUT(NP);(' Photoelectric about to occur',T36,':');
               1      ]
               0  ELSEIF(IARG = 20)[
               1      IF(NPold=NP & IQ(NP)=0 & i_survived_rr = 0)[
               2          $CNTOUT(NP);(T11,'Photon energy below N-shell',/,
               2          T11,'Photon discarded',T36,':');
               2          ]
               1      ELSEIF(IQ(NPold) = -1 & i_survived_rr = 0)[
               2          KE= E(NPold)-RM;
               2          $CNTOUT(NPold);(T10,'Resulting photoelectron',T36,':');
               2          ]
               1      ELSEIF(i_survived_rr > 0)["done some russian roulette"
               2          IF(NP=NPold-1 | IQ(NPold) ~= -1)[
               3              IF(i_survived_rr > 1)["eliminated more than the photoelectron"
               4                  OUTPUT i_survived_rr-1,prob_rr;
               4                  (T10,'Russian Roulette eliminated ',I4,
               4                  ' particle(s) with probability ',F8.5,' plus');
               4                  ]
               3              OUTPUT prob_rr;
               3              (T10,'Russian Roulette eliminated resulting photoelectron',
               3              ' with probability ',F8.5);
               3              ]
               2          ELSE["NPold could hold the photoelectron"
               3              KE = E(NPold) - RM;
               3              $CNTOUT(NPold);(T10,'Resulting photoelectron?',T36,':');
               3              OUTPUT i_survived_rr,prob_rr;
               3              (T10,'Russian Roulette eliminated ',I4,
               3              ' particle(s) with probability ',F8.5);
               3              ]
               2          $CNTOUT(NP);(T10,'Now on top of stack',T36,':');
               2          ]
               1      ]
               0
               0  ELSEIF(IARG = 24)[$CNTOUT(NP);(' Rayleigh scattering occured',T36,':');]
               0
               0  ELSEIF(IARG = 25)[$CNTOUT(NP);(T10,'Fluorescent X-ray created',T36,':');]
               0
               0  ELSEIF(IARG = 26)[$CNTOUT(NP);(T10,'Coster-Kronig e- created',T36,':');]
               0
               0  ELSEIF(IARG = 27)[$CNTOUT(NP);(T10,'Auger electron created',T36,':');]
               0
               0  IF(IARG = 0  &  IWATCH = 2)[OUTPUT  USTEP,TUSTEP,VSTEP,TVSTEP,EDEP;
               1      (T5,'USTEP,TUSTEP,VSTEP,TVSTEP,EDEP',T36,':    ',5(1PE13.4));ICOUNT=ICOUNT+1;]
               0
               0  IF(NP = 1  |  IARG = 0) RETURN;
               0  IF( IARG <= 3)[
               1      N=NP-1;
               1      KE = E(N) - ABS(IQ(N))*RM;
               1      $CNTOUT(N);(T10,'Now on top of stack',T36,':');
               1      ]
               0  RETURN;END;
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
1              0  %E
               0  "*******************************************************************************
               0  "
               0  "
               0  "                       *****************
               0  "                       *               *
               0  "                       * SIGMA.MORTRAN *
               0  "                       *               *
               0  "                       *****************
               0  "
               0  "
               0  "       SIGMA IS A STATISTICAL ANALYSIS ROUTINE DESIGNED TO BE USED BY EGS
               0  "       USER PROGRAMS TO GIVE THE TOTALS OR AVERAGES AND THEIR UNCERTAINTIES
               0  "       OF THE DATA CALCULATED BY THE MONTE CARLO CODE.
               0  "       THE UNCERTAINTIES ARE RETURNED AS PERCENTS.
               0  "
               0  "       VARIABLES
               0  "       =========
               0  "
               0  "       DATA(NDATA,ISTAT)       THE TWO DIMENSIONAL ARRAY OF DATA TO BE
               0  "                               ANALYZED. ISTAT IS THE NUMBER OF STATISTICAL
               0  "                               BATCHES AND NDATA IS THE NUMBER OF ERRORS TO
               0  "                               BE CALCULATED. AFTER THE END OF THE CALCULATION,
               0  "                               DATA(N,1) CONTAINS THE TOTAL OR AVERAGE AND
               0  "                               DATA(N,2) CONTAINS THE ERROR. NDATA SHOULD
               0  "                               BE < OR = $MAXDATA AND ISTAT SHOULD BE < OR =
               0  "                               $STAT WHCH MUST BE DEFINED IN THE MAIN ROUTINE.
               0  "                               Note $STAT must be 2 or greater, even if istat=1
               0  "
               0  "       MODE    =  0 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS
               0  "                               IGNORED. (eg. STOPPING POWER RATIO)
               0  "               =  1 =>         ANALYSIS ON MEAN VALUES WHERE ZERO DATA IS NOT
               0  "                               IGNORED. (e.g. DOSE)
               0  "               =  2 =>         ANALYSIS ON TOTAL VALUES (eg. TOTAL EDEP)
               0  "
               0  "       IERR    =  0 =>         NORMAL COMPLETION.
               0  "               =  1 =>         WARNING: MODE OUT OF RANGE, DEFAULTED TO 0
               0  "               = 10 =>         ERROR: ONLY ONE BATCH INPUT, QUICK CALCULATION
               0  "                                      DONE. ERROR=99.9%
               0  "               = 11 =>         ERROR: NO NON-ZERO DATA FOUND IN A GIVEN SET,
               0  "                                       ERROR=99.9%
               0  "               = -1 =>         FATAL ERROR: NDATA OR ISTAT OUT OF RANGE, NO
               0  "                                            CALCULATION DONE.
               0  "
               0  "
               0  "               VERSION  1      A.F.B.  83/7/22
               0  "               Version  2      IK      Jan 6 6000 implemented implicit none
               0  "
               0  "*******************************************************************************
1              0  %E
               0  SUBROUTINE SIGMA(NDATA,ISTAT,MODE,IERR);
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER NDATA,ISTAT,MODE,IERR;
               0
               0  REPLACE {;COMIN/ERROR/;} WITH {
            {  0  ;COMMON/ERROR/DATA($MXDATA,$STAT);
            {  0  $REAL data;
            {  0  }
               0  ;COMIN/ERROR,EGS-IO/;
               0
               0  $INTEGER n,non0,i;
               0  $REAL    stat,sdenom;
               0  real*8   emax,avg,error,datum,argmnt;
               0  "It is a good idea to use double precision"
               0  "in cases with very low stat. uncertainties"
               0
               0  DATA EMAX/99.9/;
               0
               0  IERR=0; "ASSUME NORMAL COMPLETION"
               0
               0  "TEST INPUTS AND SET ERROR CODES AND RETURN IF NEEDED."
               0
               0  IF((MODE < 0) | (MODE > 2)) [MODE=2;IERR=1;]
               0
               0  IF((NDATA.LE.0).OR.(NDATA.GT.$MXDATA).OR.(ISTAT.LE.0).OR.(ISTAT.GT.$STAT)) [
               1      IERR=-1;RETURN;"FATAL INPUT ERROR, RETURN IMMEDIATELY"
               1      ]
               0  IF(ISTAT = 1)[
               1      IERR=10;"ONLY ONE STATISTICAL BATCH, QUICK CALCULATION"
               1      DO N=1,NDATA[DATA(N,2)=EMAX;]
               1      RETURN;
               1      ]
               0
               0  "MOST ANOMALIES HAVE BEEN HANDLED. NOW DO THE ANALYSIS"
               0
               0  IF(MODE.NE.0)[STAT=FLOAT(ISTAT);SDENOM=STAT*(STAT-1.);]
               0  DO N=1,NDATA[
               1      NON0=0;             "NON-ZERO COUNTER"
               1      AVG=0.0;ERROR=0.0;
               1      DO I=1,ISTAT[
               2          DATUM=DATA(N,I);
               2          IF(DATUM.NE.0.0)[NON0=NON0+1;AVG=AVG+DATUM;ERROR=ERROR+DATUM**2;]
               2          ]
               1      IF(NON0 = 0)[IERR=11;ERROR=EMAX;GOTO :TRANSFER:;"NO NON-ZERO DATA "]
               1
               1      ELSEIF((NON0 = 1) & (MODE = 0))[ERROR=EMAX;GOTO:TRANSFER:;"ONLY ONE DATUM"]
               1
               1      ELSE[
               2          IF(MODE = 0)[STAT=FLOAT(NON0);SDENOM=STAT*(STAT-1.);]
               2          ]
               1
               1      AVG=AVG/STAT;ARGMNT=ERROR-STAT*AVG**2;
               1      "FLAG -VE SQUARE ROOTS THAT CAN ONLY OCCUR DUE TO ROUND-OFF ERRORS"
               1      IF(ARGMNT.LT.0.0)[
               2          OUTPUT ARGMNT,ERROR,STAT,AVG,SDENOM;
               2          (' ***** - SQ RT IN SIGMA. ARGMNT,ERROR,STAT,AVG,SDENOM='/' ',5E12.4);
               2          ARGMNT=0.0;
               2          ]
               1      ERROR=SQRT(ARGMNT/SDENOM);
               1
               1      IF(AVG = 0.)[ERROR=EMAX;]ELSE[ERROR=100.*ERROR/ABS(AVG);]
               1
               1      IF(MODE =  2)AVG=AVG*STAT;
               1
               1      :TRANSFER:;
               1      DATA(N,1)=AVG;DATA(N,2)=MIN(EMAX,ERROR);
               1      ] "END OF NDATA LOOP"
               0  RETURN;
               0  END; "END OF SIGMA"
               0  ;
               0
               0  "*****************************************************************************
               0  " The following are routines that implement
               0  " the alias sampling technique for sampling from a histogram
               0  " distribution coded for use with EGSnrc
               0  "
               0  " subroutine prepare_alias_sampling
               0  " function   alias_sample
               0  "
               0  " I. Kawrakow, January 2000
               0  "
               0  "*****************************************************************************
               0
               0  subroutine prepare_alias_sampling(nsbin,fs_array,ws_array,ibin_array);
               0  "====================================================================
               0  "
               0  " inputs:  nsbin:    number of bins in the histogram
               0  "          fs_array: bin probabilities
               0  "
               0  " Note that we don't need the bin limits at this point, they
               0  " are needed for the actual sampling (in alias_sample)
               0  "
               0  " outputs: ws_array, ibin_array: alias table ready for sampling
               0  "
               0  "====================================================================
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     fs_array(nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      IF( fs_array(i) < 1e-30 ) fs_array(i) = 1e-30;
               1      ws_array(i) = -fs_array(i); ibin_array(i) = 1;
               1      sum = sum + fs_array(i);
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return;
               0  end;
               0
               0
               0  $REAL function alias_sample(nsbin,xs_array,ws_array,ibin_array);
               0  "===============================================================
               0  "
               0  " samples from an alias table which must have been prepared
               0  " using prepare_alias_table
               0  "
               0  "===============================================================
               0
               0  implicit none;
               0
               0  $INTEGER nsbin,ibin_array(nsbin);
               0  $REAL    xs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    v1,v2,aj;
               0  $INTEGER j;
               0
               0  $RANDOMSET v1; $RANDOMSET v2;
               0  aj = 1 + v1*nsbin; j = aj;
               0  IF( j > nsbin ) j = nsbin; " this happens only if $RANDOMSET produces
               0  " numbers in (0,1]
               0  aj = aj - j;
               0  IF( aj > ws_array(j) ) [ j = ibin_array(j); ]
               0  alias_sample = (1-v2)*xs_array(j-1) + v2*xs_array(j);
               0  return;
               0  end;
               0  ;
1              0  %E
               0  ;
               0  "==========================end of nrcaux.mortran======================"
               0
               0
               0
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc I/O functions                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Marc-Andre Renaud                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " Iwan Kawrakow, 2004:                                                        "
               0  "                                                                             "
               0  " re-factored egs_init so that it is easy to program a corresponding egs_init "
               0  " when one loads a EGSnrc user code as a library and therefore no command     "
               0  " line arguments are available. (see beam library).                           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  REPLACE {$max_unit} WITH {99}
               0
               0  REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "
               0
               0  REPLACE {;COMIN/my_times/;} WITH {;
            {  0  common/my_times/ t_elapsed, t_cpu, t_first;
            {  0  $REAL            t_elapsed, t_cpu;
            {  0  integer          t_first(8);
            {  0  real             egs_tot_time,egs_etime;
            {  0  };
               0
               0  "******************************************************************************
               0  " subroutine egs_init;
               0  "******************************************************************************
               0  " A call to this subroutine becomes Step 0 in every EGSnrc user code.
               0  " Its purpose is to:
               0  "   - initialize arrays and default values for various transport options
               0  "     (this was previously done in block data, but due to the GNU Fortran
               0  "     compiler complaints and extremely slow compilation when the number of
               0  "     regions is large, we decided to remove block data from the source)
               0  "   - Process command line arguments specifying input file, pegs4 data file,etc.
               0  "     In the current version the following command line options are supported:
               0  "
               0  "       -i or --input ifile          Input file is ifile.egsinp
               0  "
               0  "       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
               0  "                                    The system will look for it in the
               0  "                                    HEN_HOUSE and the user's pegs4 data areas
               0  "
               0  "       -o or --output ofile         Output data will be writtent to
               0  "                                    ofile.egslog, ofile.egslst, etc., instead
               0  "                                    of ifile.egslog, etc.
               0  "
               0  "       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
               0  "                                    of the directory specified in the
               0  "                                    machine.macros file.
               0  "
               0  "       -e or --egs-home dir         Change EGS_HOME to be dir instead of
               0  "                                    the directory specified by the EGS_HOME
               0  "                                    environment variable
               0  "
               0  "       -h or --help                 Print a help message and exit
               0  "                                    ignoring all other arguments
               0  "
               0  "       -b or --batch                Specify a 'batch' run. The difference
               0  "                                    between a 'batch' run and an interactive
               0  "                                    run is that in 'batch' mode unit 6 is
               0  "                                    connected to a file, whereas in interactive
               0  "                                    mode unit 6 goes to the standard output.
               0  "                                    The file name in batch run is determined
               0  "                                    as follows:
               0  "                                     - ofile.egslog, if ofile was specified
               0  "                                       with the -o option
               0  "                                     - ifile.egslog, if there was no -o option
               0  "                                       used but an input file was specified
               0  "                                       with -i
               0  "                                     - test.egslog, if neither -i nor -o was
               0  "                                       used.
               0  "
               0  "       -P or --parallel n           Tell the system that this run is part of
               0  "                                    a parallel run and that this is job number
               0  "                                    n (so that the random number sequence
               0  "                                    can be initialized differently)
               0  "
               0  "       -c or --chunk N              Tell the system to use N histories per
               0  "                                    calculation 'chunk' in parallel runs.
               0  "
               0  "   - open default EGSnrc data file units thus avoiding the necessity for
               0  "     symbolik links
               0  "   - open user code specific I/O units if a .io file is found in
               0  "     the user code area. The format of this file is an integer
               0  "     followed by a string on every line.
               0  "     The string specifies the file extension
               0  "     and the integer the unit number this file should connect to, e.g.
               0  "       4   .egsdat
               0  "       15  .egserr
               0  "       1   .egslst
               0  "     will result in connecting unit 4 to the file ifile.egsdat
               0  "     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
               0  "  -  Outputs a summary to standard output about configuration etc
               0  "  -  Creates a temporary working directory in the user code area
               0  "
               0  "  The files always opened (appart from the ones specified in the .io file)
               0  "  are the following:
               0  "
               0  "  1. The PEGS data file (and so, for now, the -p pegs_file command line
               0  "     option must be always given)
               0  "     The algorithm for looking for a PEGS data file is:
               0  "       - The file name passed with -p. In this way, PEGS files can be located
               0  "         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
               0  "         and $EGS_HOME/pegs4/data) if the absolute path name is given after
               0  "         the -p option.
               0  "       - $EGS_HOME/pegs4/data/pegs_file or
               0  "         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
               0  "       - $HEN_HOUSE/pegs4/data/pegs_file or
               0  "         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
               0  "     See note below on how $HEN_HOUSE and $EGS_HOME are determined
               0  "
               0  "  2. If a -i ifile option was given as argument, ifile.egsinp is
               0  "     opened as fortran unit 5.
               0  "     The input file MUST be in the user code directory on $EGS_HOME
               0  "
               0  "  3. If the run is a batch run (the -b option was present on the command
               0  "     line), fortran unit 6 is connected to an output file with a .egslog
               0  "     extension instead of going to standard output.
               0  "     The algorithm for determining the .egslog file name is the following:
               0  "       - If the -o ofile option was present, the output to unit 6 will go
               0  "         to ofile.egslog
               0  "       - If there was no -o option, but there is an inpuit file specified
               0  "         with -i ifile, output to unit 6 will go to ifile.egslog
               0  "       - If neither of the above is true, the output will go to
               0  "         test.egslog.
               0  "
               0  "  Note on determining EGS_HOME:
               0  "  EGS_HOME is normally taken from the environment variable EGS_HOME.
               0  "  However, one can overwrite the environment by giving the
               0  "    -e | --egs-home  new_egs_home_location
               0  "  option on the command line.
               0  "  EGS_HOME must be set, either via the environment or via the command line,
               0  "  otherwise the job will abort.
               0  "
               0  "  Note on determining HEN_HOUSE:
               0  "  HEN_HOUSE is set to the value defined in machine.macros, which is
               0  "  created by the configure script or the configuration wizard in the GUI
               0  "  This value can be overwritten by giving the
               0  "    -H | --hen-house new_hen_house_location
               0  "  option on the command line.
               0  "  HEN_HOUSE is NOT taken from the environment.
               0  "
               0  "  The name of the temporary working directory is created using
               0  "    egsrun_getpid_ifile_hostname, if there was an input file, or
               0  "    egsrun_getpid_noinput_hostname, if there was no input file specified.
               0  "  In the above, getpid is the process id returned bt the getpid() intrinsic
               0  "  and hostname is the host name as determined by egs_get_hostnm().
               0  "  During run time, all output from the program (the .egslog file and
               0  "  all other files specified in the .io file) is kept in the
               0  "  temporary working directory. After succesful completion, egs_finish
               0  "  moves all output back to the user code area and removes the
               0  "  temporary working directory. This implies that if for whatever reason
               0  "  the job terminates prematurely, the temporary working directory
               0  "  with all output will be left behind.
               0  "
               0  "
               0  "
               0  "******************************************************************************
               0  subroutine egs_init;
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/my_times/;
               0  $REAL dum;
               0
               0
               0
               0
               0
               0  call egs_set_defaults;
               0  call egs_check_arguments;
               0  call egs_init1;
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_init1;
               0  "******************************************************************************
               0
               0  implicit none;
               0  ;COMIN/EGS-IO,MISC,my_times/;
               0  integer   l, lnblnk1, l1, l2;
               0  integer   i;
               0  character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
               0  line*80,
               0  line1*80,dattim*24;
               0  $LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home,is_opened;
               0  $INTEGER  mypid;
               0  integer   getpid;
               0  integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
               0  $REAL     dum;
               0  $declare_write_buffer;
               0
               0  t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
               0  call egs_date_and_time(t_first);
               0
               0  $set_string(line,'=');
               0  $set_string(line1,'.');
               0
               0  " Handy macros for checking command line arguments "
               0  REPLACE {$check_get_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg-1 [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; call getarg(i+1,{P3}); EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$check_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  IF(~is_pegsless)[
               1      " Get the pegs4 data file "
               1      on_egs_home = .false.;
               1      inquire(file=pegs_file,exist=ex);
               1      IF( ex ) [
               2          kmpi=egs_get_unit(kmpi);
               2          IF(kmpi<0)[
               3              $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               3              ]
               2          open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               2          $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               2          goto :found_pegs_file:;
               2          ]
               1      arg = $cstring(pegs_file);
               1      ex = egs_strip_extension(arg,'.pegs4dat');
               1      l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
               1      l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              on_egs_home = .true.;
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1      l = lnblnk1(hen_house);
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1
               1      $egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));
               1
               1      ]
               0
               0  :found_pegs_file:
               0  ;
               0  " Open egsnrc data files "
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  "set proposed unit numbers"
               0  i_nist_data=76;
               0  i_incoh=78;
               0  i_photo_relax=77;
               0  i_photo_cs=79;
               0  i_mscat=11;
               0
               0  REPLACE {$open_data_file(#,#,#,#);} WITH {;
            {  0  $set_string({P2},' ');
            {  0  {P2} = $cstring({P1}) // {P3};
            {  0  inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
            {  0  IF( ~ex ) [
            {  0  $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
            {  0  ]
            {  0  IF( ~is_opened ) [
            {  0  {P4}=egs_get_unit({P4});
            {  0  IF({P4}<0)[
            {  0  $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
            {  0  $cstring({P2}));
            {  0  ]
            {  0  open({P4},file={P2},status='old',err=:data_file_error:);
            {  0  ]
            {  0  ELSE [ {P4} = itmp; ]
            {  0  $egs_debug('(a,a)','opened data file ',$cstring({P2}));
            {  0  };
               0  $open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
               0  $open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);
               0
               0  $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0
               0  have_input = .false.;
               0  i_input=5;
               0  IF( lnblnk1(input_file) > 0 ) [
               1      have_input = .true.;
               1      l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
               1      l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
               1      IF( l + l1 + l2 > 1024 ) [
               2          $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
               2          ]
               1      ex = egs_strip_extension(input_file,'.egsinp');
               1      tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ~ex ) [
               2          $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
               2          ]
               1      $AVAILABLE_UNIT(i_input,tmp_string);
               1      open(i_input,file=tmp_string,status='old',err=:open_input_error:);
               1      ]
               0
               0  " Construct a temporary directory name to run from "
               0  $set_string(work_dir,' ');
               0  work_dir = 'egsrun_'; mypid = getpid();
               0  call egs_itostring(work_dir,mypid,.false.);
               0  call egs_get_hostnm(host_name);
               0  IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
               0  IF( have_input ) [
               1      work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               1      '_' // $cstring(host_name) // $file_sep;
               1      ]
               0  ELSE [
               1      work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               1      $file_sep;
               1      ]
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               0  DO i=1,lnblnk1(tmp_string) [
               1      IF( tmp_string(i:i) = '/' ) [
               2          tmp_string(i:i) = $file_sep;
               2          ]
               1      ]
               0  ex = egs_isdir(tmp_string);
               0  IF( ex ) [
               1      $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
               1      ]
               0  tmp1_string = 'mkdir ' // $cstring(tmp_string);
               0  l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
               0  " some systems need the command string to be 0 terminated"
               0  istat = egs_system(tmp1_string);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
               1      ]
               0
               0  call egs_open_units(.true.);
               0
               0  " Now print a summary of what happened "
               0  $egs_info('(a)',line);
               0  $egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
               0  call egs_get_fdate(dattim);
               0  $egs_info('(a,/,a)',dattim,line);
               0
               0  REPLACE {$write_description(#);} WITH {;
            {  0  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
            {  0  $egs_info('(a,$)',line1(:l));
            {  0  };
               0  pos1 = lnblnk1('output file(s)');
               0  pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
               0  pos2 = min(pos2,80-lnblnk1(user_code));
               0  $set_string(tmp_string,' '); tmp_string = pegs_file;
               0  call egs_strip_path(tmp_string);
               0  ex = egs_strip_extension(tmp_string,'.pegs4dat');
               0  IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
               0  ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
               0  IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
               1      $set_string(tmp_string,' '); tmp_string = pegs_file;
               1      ]
               0  pos2 = min(pos2,80-lnblnk1(tmp_string));
               0  pos2 = min(pos2,80-lnblnk1(host_name));
               0  pos2 = min(pos2,80-lnblnk1($CONFIG_TIME));
               0  IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
               0  pos2 = min(pos2,80-lnblnk1(output_file));
               0  IF( pos2 < pos1+2 ) pos2 = pos1 + 2;
               0
               0  $write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
               0  $write_description('configuration time'); $egs_info('(a)',$CONFIG_TIME);
               0  $write_description('app compile time'); $egs_info('(a)',COMPILE_TIME);
               0  $write_description('git commit hash'); $egs_info('(a)',GIT_HASH);
               0  $write_description('application'); $egs_info('(a)',$cstring(user_code));
               0  $write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
               0  $write_description('using host'); $egs_info('(a)',$cstring(host_name));
               0  IF( have_input ) [
               1      $write_description('input file'); $egs_info('(a)',$cstring(input_file));
               1      ]
               0  $write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
               0  IF( n_parallel > 0 ) [
               1      $write_description('number of parallel jobs');
               1      $egs_info('(i2)',n_parallel);
               1      $write_description('job number'); $egs_info('(i2)',i_parallel);
               1      ]
               0  $egs_info('(a)',line);
               0
               0  IF (is_uniform_run)[
               1      $egs_info('(//a,i0,a,i0,a//)',
               1      '-> User requests uniform run control. I am job # ',
               1      i_parallel,' of ',n_parallel,' jobs');
               1      ]
               0
               0  return;
               0
               0  " Errors "
               0  :open_input_error:
               0  $egs_fatal(*,'failed to open input file ',$cstring(tmp_string));
               0
               0  :open_pegs_error:
               0  $egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));
               0
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_check_arguments;
               0  "*****************************************************************************
               0  implicit none;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character arg*256,tmp_string*512, line1*80;
               0  $LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home;
               0  integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
               0  $declare_write_buffer;
               0
               0  narg = iargc();
               0  IF( narg < 1 ) return;
               0
               0  " Check for hen_house "
               0  $check_get_argument('-H','--hen-house',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(hen_house,' ');
               1      IF( l > 0 ) [
               2          IF( l > 254 ) [
               3              $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
               3              ]
               2          hen_house(:l) = $cstring(arg);
               2          IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
               2          ]
               1      ELSE [
               2          $egs_fatal('(a)',' empty argument after -H');
               2          ]
               1      DO i=1,lnblnk1(hen_house) [
               2          IF( hen_house(i:i) = '/' ) [
               3              hen_house(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(hen_house) ) [
               1      $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
               1      $warning('(a)','does not exist. Hope you know what you are doing.');
               1      ]
               0
               0  " Check if the user requested help "
               0  $check_argument('-h','--help',arg);
               0  IF( have_arg ) [
               1      call getarg(0,arg); call egs_strip_path(arg);
               1      $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
               1      tmp_string = $cstring(hen_house) // 'pieces/help_message';
               1      i_help=98;
               1      i_help=egs_get_unit(i_help);
               1      IF(i_help<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
               2          ]
               1      open(i_help,file=tmp_string,status='old',err=:no_help_file:);
               1      LOOP [
               2          read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
               2          $egs_info('(a)',line1);
               2          ]
               1      :end_of_help:;
               1      $CALL_EXIT(0);
               1      :no_help_file:;
               1      $egs_fatal(*,'Did not find the help_message file!');
               1      ]
               0
               0  " Check for batch option "
               0  $check_argument('-b','--batch',arg);
               0  IF( have_arg ) is_batch = .true.;
               0
               0  " Check for parallel run option"
               0  $check_get_argument('-P','--parallel',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_parallel_arg:) n_parallel;
               1      IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
               1      goto :ok_parallel_arg:;
               1      :wrong_parallel_arg:;
               1      $egs_warning(*,
               1      ' Wrong/missing parallel job number argument, -P option ignored');
               1      n_parallel = 0;
               1      :ok_parallel_arg:;
               1      ]
               0
               0  $check_get_argument('-j','--job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_job_arg:) i_parallel;
               1      IF( i_parallel < 0 ) goto :wrong_job_arg:;
               1      goto :ok_job_arg:;
               1      :wrong_job_arg:;
               1      $egs_warning(*,' Wrong/missing job argument, -j option ognored');
               1      i_parallel = 0;
               1      :ok_job_arg:;
               1      ]
               0
               0  $check_get_argument('-f','--first-job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_first_job_arg:) first_parallel;
               1      IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
               1      goto :ok_first_job_arg:;
               1      :wrong_first_job_arg:;
               1      $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
               1      first_parallel = 1;
               1      :ok_first_job_arg:;
               1      ]
               0
               0  IF( n_parallel > 0 | i_parallel > 0 ) [
               1      IF( n_parallel*i_parallel = 0 ) [
               2          $egs_warning(*,'You need to specify number of jobs AND job number ',
               2          '=> will not use parallel run ');
               2          n_parallel = 0; i_parallel = 0;
               2          ]
               1      IF( first_parallel > i_parallel ) [
               2          $egs_warning(*,'i_parallel (',i_parallel,
               2          ') can not be smaller than first_parallel (',first_parallel,')');
               2          first_parallel = i_parallel;
               2          ]
               1      ]
               0
               0  " Check for run control option "
               0  $check_argument('-u','--urc',arg);
               0  IF( have_arg ) is_uniform_run = .true.;
               0
               0  $egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));
               0
               0  " Check for egs_home "
               0  $check_get_argument('-e','--egs-home',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(egs_home,' ');
               1      IF( l = 0 ) [
               2          $egs_fatal('(a)',' empty argument after -e');
               2          ]
               1      IF( l > 254 ) [
               2          $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
               2          ]
               1      egs_home(:l) = $cstring(arg);
               1      IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
               1      DO i=1,lnblnk1(egs_home) [
               2          IF( egs_home(i:i) = '/' ) [
               3              egs_home(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(egs_home) ) [
               1      $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
               1      ]
               0  $egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));
               0
               0  " Get the pegs4 data file "
               0  on_egs_home = .false.;
               0  is_pegsless=.false.;
               0  $check_get_argument('-p','--pegs-file',arg);
               0  IF( ~have_arg ) [
               1      $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
            '  1      in pegs-less mode with media details specified in input file.');
               1      is_pegsless=.true.;
               1      ]
               0  ELSE[
               1      pegs_file = $cstring(arg);
               1      ]
               0
               0  " Deduct the user code name from the executable name "
               0  call egs_get_usercode(user_code);
               0
               0  " Check for an input file "
               0  $check_get_argument('-i','--input',arg);
               0  IF( have_arg ) [
               1      ex = egs_strip_extension(arg,'.egsinp');
               1      l2 = lnblnk1(arg) + lnblnk1('.egsinp');
               1      IF( l2 > 256 ) [
               2          $egs_fatal(*,'input file name is too long ',l2);
               2          ]
               1      input_file = $cstring(arg);
               1      ]
               0
               0  " Check for an output file option "
               0  $check_get_argument('-o','--output',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg);
               1      IF( l > 256 ) [
               2          $egs_fatal(*,'output file name is too long ',l);
               2          ]
               1      output_file(:l) = $cstring(arg);
               1      ]
               0  ELSE [
               1      IF( lnblnk1(input_file) > 0 ) [
               2          output_file(:lnblnk1(input_file)) = $cstring(input_file);
               2          ]
               1      ELSE [
               2          output_file = 'test';
               2          ]
               1      ]
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_open_units(flag);
               0  "******************************************************************************
               0  " Open output files.
               0  " Looks for output file definition in user_code.io.
               0  " In addition, if it is a batch run connects a .egslog file to unit 6.
               0  " If flag is .true., open the files in the temporary working directory,
               0  " else open them in the user code directory.
               0  "******************************************************************************
               0  implicit none;
               0  $LOGICAL flag;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
               0  input_line*100, arg*20;
               0  integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
               0  $LOGICAL  ex,is_open;
               0  $declare_write_buffer;
               0
               0  $set_string(tmp_string,' '); $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  IF( flag ) [
               1      tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               1      ]
               0  ELSE [
               1      tmp_string = $cstring(ucode_dir);
               1      ]
               0
               0  tmp_string = $cstring(tmp_string) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  $set_string(tmp1_string,' ');
               0  i_log=6;
               0  IF( is_batch ) [
               1      tmp1_string = $cstring(tmp_string) // '.egslog';
               1      $AVAILABLE_UNIT(i_log,tmp1_string);
               1      open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
               1      ]
               0  $set_string(tmp2_string,' ');
               0  tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
               0  inquire(file=tmp2_string,exist=ex);
               0  n_files = 0;
               0  IF( ex ) [
               1      i_iofile=99;
               1      i_iofile=egs_get_unit(i_iofile);
               1      IF (i_iofile<1)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
               2          ]
               1      open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
               1      LOOP [
               2          read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
               2          IF( input_line(1:1) = '#' ) NEXT;
               2          "The DEC and SGI compilers fail at the following statement!"
               2          "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
               2          read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
               2          istart = 1;
               2          DO i=lnblnk1(input_line),1,-1 [
               3              IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
               3              ]
               2          DO i=1,len(arg) [ arg(i:i) = ' '; ]
               2          DO i=istart,lnblnk1(input_line) [
               3              arg(i+1-istart:i+1-istart) = input_line(i:i);
               3              ]
               2          inquire(unit=u,opened=is_open);
               2          IF( is_open ) [
               3              $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
               3              'Unit ',u,' which you want to connect to a ',
               3              $cstring(arg),' file ',
               3              'is already in use. Will assume this code is being used as',
               3              'a shared library source and this file will be opened explicitly.');
               3              ]
               2          ELSE[
               3              n_files = n_files + 1;
               3              IF( n_files > $mx_units ) [
               4                  $egs_fatal(*,'Too many units requested in .io.',
               4                  ' Increas $mx_units and retry');
               4                  ]
               3              file_units(n_files) = u;
               3              $set_string(file_extensions(n_files),' ');
               3              l = lnblnk1(arg);
               3              IF( l > $max_extension_length ) [
               4                  $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
               4                  $max_extension_length,' chars. ',
               4                  'Increase $max_extension_length and retry ');
               4                  ]
               3              file_extensions(n_files) = $cstring(arg);
               3              tmp1_string = $cstring(tmp_string) // $cstring(arg);
               3              open(u,file=tmp1_string,status='unknown');
               3              $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
               3              ' to unit ',u);
               3              ]
               2          :end_of_ioline:
               2          ]
               1      :end_of_iofile:
               1      close(i_iofile);
               1      ]
               0  return;
               0
               0  :output_file_error:
               0  $egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));
               0
               0  :io_file_error:
               0  $egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
               0  return; end;
               0
               0
               0  "******************************************************************************
               0  subroutine egs_finish;
               0  "******************************************************************************
               0  " This subroutine becomes the last step in every EGSnrc user code.
               0  " It's purpose is to move the all output files from the temporary working
               0  " directory to the user code directory and to remove the working dir.
               0  " This was previously done by the egs_run script.
               0  " This routine also prints a summary to standard output.
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/EGS-IO,my_times/;
               0  character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
               0  character dattim*24;
               0  integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
               0  $LOGICAL is_open,egs_isdir;
               0  $REAL    t1,t2,tt_cpu;
               0  $declare_write_buffer;
               0
               0  $set_string(line,'=');
               0  IF( n_parallel = 0 | i_parallel > 0 ) [
               1      "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
               1      "or if it is parallel but it is not the final egs_finish (after combining"
               1      "results from parallel runs)"
               1      t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
               1      t1 = t_elapsed; t2 = t1/3600;
               1      $egs_info('(//a,/,a,/)',line,'Finished simulation');
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
               1      t1 = tt_cpu; t2 = t1/3600;
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
               1      $egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
               1      ]
               0  call egs_get_fdate(dattim);
               0  $egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);
               0
               0  " Close all I/O units "
               0  n_open=0;
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code);
               0  DO i=1,$max_unit [
               1      IF( is_batch | i ~= i_log ) [
               2          inquire(i,opened=is_open);
               2          IF( is_open ) [
               3              inquire(i,name=fname);
               3              IF(index($cstring(fname),$cstring(base))>0)[
               4                  close(i); n_open = n_open+1; ]
               3              ]
               2          ]
               1      ]
               0
               0  "If work_dir is empty, this is a second call to egs_finish for the last"
               0  "job in a parallel run. This implies that the temporary working "
               0  "directory has been already removed => just return"
               0
               0  IF( lnblnk1(work_dir) = 0 ) [ return; ]
               0
               0  " Now generate a junk file in the working directory so that the move "
               0  " command does not fail in case there are no files "
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir);
               0  DO i=1,lnblnk1(base) [
               1      IF( base(i:i) = '/' ) [
               2          base(i:i) = $file_sep;
               2          ]
               1      ]
               0  IF( egs_isdir(base) ) [
               1      $set_string(tmp_string,' '); $set_string(junk_file,' ');
               1      junk_file = $cstring(work_dir);
               1      l = lnblnk1(junk_file); junk_file(l:l) = ' ';
               1      junk_file = $cstring(junk_file) // '_junk';
               1      tmp_string = $cstring(base) // $cstring(junk_file);
               1      i_junk=99;
               1      i_junk=egs_get_unit(i_junk);
               1      IF(i_junk<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
               2          ]
               1      open(i_junk,file=tmp_string,status='unknown');
               1      write(i_junk,*) 'junk';
               1      close(i_junk);
               1
               1      " Move all files from the working directory to the user code directory "
               1      $set_string(base1,' ');
               1      base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               1      $cstring(work_dir);
               1      base1 = $cstring(egs_home) // $cstring(user_code);
               1      $set_string(tmp_string,' ');
               1      tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
               1      l = lnblnk1(tmp_string)+1;
               1      tmp_string(l:l) = char(0);
               1      istat = egs_system(tmp_string);
               1      IF( istat ~= 0 ) [
               2          $egs_warning(*,'Moving files from working directory failed ?');
               2          $warning(*,'=> will not remove working directory');
               2          ]
               1      ELSE [
               2          " Remove the working directory "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $remove_directory // $cstring(base);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = egs_system(tmp_string);
               2          IF( istat ~= 0 ) [
               3              $egs_warning(*,'Failed to remove working directory ',
               3              $cstring(work_dir));
               3              ]
               2          " Remove the junk file "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = unlink(tmp_string);
               2          ]
               1      ]
               0
               0  " Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
               0  " in the user code directory "
               0  $set_string(work_dir,' ');
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_set_defaults;
               0  "******************************************************************************
               0  " Replaces BLOCK DATA "
               0  implicit none;
               0  $COMIN-SET-DEFAULTS;
               0
               0  integer  i,j,lnblnk1;
               0  $TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
               0  character fool_dec;
               0  data MEDIA1/$S'NAI                     '/;
               0  data fool_dec/'/'/;
               0  data fool_intel_optimizer/.false./;
               0
               0  vacdst = 1e8;
               0  $set-region-by-region-defaults;
               0
               0  eii_flag = 0; "No EII by default. "
               0  eii_xfile = 'Off';
               0  eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
               0  "========================================="
               0  "See egsnrc.macros for defaults used below"
               0  "========================================="
               0  xsec_out = $XSEC-DEFAULT;
               0  photon_xsections = $XDATA-DEFAULT;"default photon xsection"
               0  comp_xsections = $COMP-XDATA-DEFAULT;
               0  eadl_relax = $EADL-RELAX-DEFAULT;
               0  mcdf_pe_xsections = $MCDF-PE-DEFAULT;
               0  "Ali:photonuc, 2 lines"
               0  photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
               0  "EMH:emf"
               0  ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented ONLY for the C++ applications     "
               0  BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
               0  Bx=BxIN;    By=ByIN;    Bz=BzIN;
               0  Bx_new=Bx;  By_new=By;  Bz_new=Bz;
               0  emfield_on=.false.;
               0  IF( ExIN**2+EyIN**2+EzIN**2 + BxIN**2+ByIN**2+BzIN**2 > 0 ) [
               1      emfield_on=.true.
               1      ]
               0
               0  DO i=1,$MXMED [
               1      iraylm(i) = 0; "Rayleigh data available?"
               1      DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
               1      DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
               1      " set all thresholds to zero "
               1      /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
               1      ]
               0  DO i=1,$MXSHXSEC [
               1      DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
               1      ]
               0  ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
               0  ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
               0  pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
               0  itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
               0  iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
               0  rhof = 1;
               0  DO i=1,5 [ iausfl(i) = 1; ]
               0  "Ali:photonuc, line below already includes iarg=29,30"
               0  DO i=6,$MXAUS [ iausfl(i) = 0; ]
               0  ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
               0  skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
               0  transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
               0  bca_algorithm = $BCA-ALGORITHM-DEFAULT;
               0  exact_bca = $EXACT-BCA-DEFAULT;
               0  spin_effects = $SPIN-EFFECTS-DEFAULT;
               0  count_pII_steps = 0; count_all_steps = 0;
               0  radc_flag = 0;
               0  nmed = $default_nmed;
               0  kmpi = 12; kmpo = 8; dunit = 1;
               0  rng_seed = 999999;
               0  latchi = 0;
               0
               0  rmt2 = 2*rm; rmsq = rm*rm;
               0
               0  pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
               0  nbr_split = 1;
               0  i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;
               0
               0  $set_string(hen_house,' ');
               0  i = lnblnk1($HEN_HOUSE);
               0  hen_house(:i) = $HEN_HOUSE;
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;
               0
               0  n_files = 0;
               0  $set_egs_home;
               0  i = lnblnk1(egs_home);
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
               0  $set_string(input_file,' ');
               0  $set_string(output_file,' ');
               0  $set_string(work_dir,' ');
               0  $set_string(pegs_file,' ');
               0  $set_string(host_name,' ');
               0  n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
               0  first_parallel = 1;
               0  is_uniform_run = $URC-DEFAULT;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_combine_runs(combine_routine,extension);
               0  "*****************************************************************************
               0  " This subroutine loops over job number i from 1 to $max_unit,
               0  " checks if the file output_file_wi.extension exists, and if yes,
               0  " calls the external subroutine combine_routine with that file name.
               0  "*****************************************************************************
               0  implicit none;
               0  external combine_routine;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  character*1024 tmp_string,base,command,outfile,parfile_name,base1,
               0  text_string;
               0  integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
               0  $INTEGER i,k,j,numparfiles,textindex;
               0  integer urcSleep, urcCheckIntervals;
               0  $LOGICAL ex,iwin;
               0
               0  iwin=.false.; "start off assuming a non-Windows system"
               0
               0  urcSleep          = $URC-SLEEP;    "Set to 1 s in egsnrc.macros"
               0  urcCheckIntervals = $URC-INTERVALS;"Set to 1 in egsnrc.macros"
               0
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w';
               0
               0  "the following is to count the number of output files from"
               0  "a parallel run"
               0  $set_string(base1,' ');
               0  base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w*' // $cstring(extension);
               0  $set_string(outfile,' ');
               0  outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  'parfiles_tmp';
               0
               0  :check-output-files:;
               0  "try Unix/Linux first"
               0  $set_string(command,' ');
               0  command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)["now assume a Windows system"
               1      command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
               1      $cstring(outfile);
               1      istat = egs_system($cstring(command));
               1      IF(istat~=0)[
               2          $egs_fatal(*,
               2          ' Failed to write number of output files from parallel runs.');
               2          ]
               1      ELSE [
               2          iwin=.true.;
               2          ]
               1      ]
               0
               0  "now open parfiles_tmp and read the number of files"
               0  ipar=1;
               0  ipar=egs_open_file(ipar,0,1,$cstring(outfile));
               0  IF(iwin)[
               1      "need to do a bit of manipulation of a text string to get the number of files
               1      read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
               1      text_string = $cstring(text_string);
               1      textindex = index(text_string,'File(s)');
               1      text_string = text_string(:textindex-1);
               1      read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
               1      ]
               0  ELSE[
               1      read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
               1      ]
               0  close(ipar);
               0
               0  #ifdef HAVE_C_COMPILER;
               0  IF ( is_uniform_run & numparfiles < n_parallel & urcCheckIntervals > 0 ) [
               1      call egs_sleep(urcSleep);"sleep for urcSleep seconds"
               1      urcCheckIntervals -= 1;
               1      goto :check-output-files:;
               1      ]
               0  #endif;
               0
               0  "now remove parfiles_tmp"
               0  $set_string(command,' ');
               0
               0  IF(iwin)[
               1      command = 'del /Q ' // $cstring(outfile);
               1      ]
               0  ELSE[
               1      command = 'rm -f ' // $cstring(outfile);
               1      ]
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)[
               1      $egs_warning(*,' Failed to delete list of output files from parallel runs.');
               1      ]
               0
               0  k=1;
               0  j=1;
               0  WHILE(j<=numparfiles) [
               1      $set_string(tmp_string,' ');
               1      tmp_string = $cstring(base);
               1      call egs_itostring(tmp_string,k,.false.);
               1      tmp_string = $cstring(tmp_string) // $cstring(extension);
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ex ) [
               2          call combine_routine(tmp_string);
               2          j=j+1;
               2          ]
               1      k=k+1;
               1      ]
               0  return;
               0
               0  :end_of_parfile:
               0  $egs_fatal(*,' Failed to read number of output files from parallel runs.');
               0  end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_strip_extension(filen,fext);
               0  "******************************************************************************
               0  " Check if the string pointed to by filen ends with the string pointed to by
               0  " fext and if yes, replace with blanks and return .true., otherwise return
               0  " false.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) filen,fext;
               0  integer  l1,l2,lnblnk1,i;
               0
               0  l1 = lnblnk1(filen); l2 = lnblnk1(fext);
               0  IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
               1      egs_strip_extension = .true.;
               1      DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
               1      ]
               0  ELSE [ egs_strip_extension = .false.; ]
               0  return; end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_is_absolute_path(fn);
               0  "******************************************************************************
               0  " Returns .true., if the string pointed to by fn is an absolute file name,
               0  " .fale. otherwise.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) fn;
               0  integer  i,lnblnk1;
               0  DO i=1,lnblnk1(fn) [
               1      IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
               1      ]
               0  egs_is_absolute_path = .false.; return; end;
               0
               0  "******************************************************************************
               0  integer  function egs_get_unit(iunit);
               0  "******************************************************************************
               0  " Returns iunit, if the Fortran I/O unit iunit is not currently in use.
               0  " Otherwise return the first free I/O unit found or -1 if none is available.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, i;
               0  $LOGICAL is_open;
               0
               0  IF( iunit > 0 ) [
               1      inquire(iunit,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = iunit; return; ]
               1      ]
               0  DO i=1,$max_unit [
               1      inquire(i,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = i; return; ]
               1      ]
               0  egs_get_unit = -1; return; end;
               0
               0  "******************************************************************************
               0  integer function egs_open_file(iunit,rl,action,extension);
               0  "******************************************************************************
               0  " Open a file trying to connect to Fortran I/O unit iunit.
               0  " If iunit is already in use, connect to the first free I/O unit found.
               0  " If no free I/O unit is found, then
               0  "   - if action = 0, return -1.
               0  "   - if action ~= 0, call the $egs_fatal macro.
               0  " If extension is an absolute file name (including path), use extension
               0  " as a file name, otherwise use output_file.extension in the temporary
               0  " working directory as name. In both cases use status='unknown' to open the
               0  " file. If rl = -1, open the file with stream access to write C-style binary
               0  " files. If rl = 0, open the file for formatted sequential access, otherwise
               0  " open for unformatted direct access with record length = rl.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, rl, action;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  $LOGICAL egs_is_absolute_path,is_open;
               0  integer  egs_get_unit;
               0  integer  i,lnblnk1;
               0  character*1024 tmp_string,error_string;
               0  $INTEGER the_unit;
               0  $declare_write_buffer;
               0
               0  egs_open_file = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_file = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      inquire(file=extension,opened=is_open);
               1      IF(is_open)[
               2          inquire(file=extension,number=the_unit);
               2          $egs_warning('(a,a,/,a,i3,/,a,/,a)',
               2          'File ',$cstring(extension),
               2          ' is already opened and connected to unit ',the_unit,
               2          ' Will not try to re-open this file, assuming it has been opened',
               2          ' by the .io file.');
               2          ]
               1      ELSE IF ( rl = -1 ) [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='stream');
               2          ]
               1      ELSE IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='unknown');
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='direct', recl=rl);
               2          ]
               1      egs_open_file = the_unit; return;
               1      ]
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  tmp_string = $cstring(tmp_string) // $cstring(extension);
               0
               0  inquire(file=tmp_string,opened=is_open);
               0  IF(is_open)[
               1      inquire(file=tmp_string,number=the_unit);
               1      $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
               1      'File ',$cstring(tmp_string),
               1      ' is already opened and connected to unit ',the_unit,
               1      ' Will not try to re-open this file, assuming it has been opened',
               1      ' by specifying it in the .io file.');
               1      ]
               0  ELSE IF ( rl = -1 ) [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='stream');
               1      ]
               0  ELSE IF( rl = 0 ) [
               1      open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='direct', recl=rl,err=:open_error:);
               1      ]
               0  egs_open_file = the_unit; return;
               0
               0  :open_error:
               0  error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
               0  // char(10) // 'iunit = ';
               0  call egs_itostring(error_string,iunit,.false.);
               0  error_string = $cstring(error_string) // ' the_unit = ';
               0  call egs_itostring(error_string,the_unit,.false.);
               0  $egs_fatal('(a)',$cstring(error_string));
               0  end;
               0
               0
               0  "******************************************************************************
               0  integer  function egs_open_datfile(iunit,rl,action,extension);
               0  "******************************************************************************
               0  "
               0  " Open an existing 'data' file.
               0  " First try to connect the file to Fortran unit iunit, but if iunit is
               0  " already in use, use the first free unit instead.
               0  " extension is the datafile extension (e.g. '.egsdat') .
               0  " The algorithm for searching for the file is as follows:
               0  "  1. If extension is an absolute file name (including path),
               0  "     try opening this file, else
               0  "  2. Try output_file.extension in the user code directory.
               0  "  3. Try input_file.extension in the user code directory (if input_file is
               0  "     different from output_file).
               0  " If the file is found, open it using status='old' for
               0  "   a) formatted sequential access, if rl=0
               0  "   b) unformatted direct access with record length = rl, if rl > 0.
               0  "
               0  " Return value:
               0  "   - if all is OK, return the opened unit number
               0  "   - if something fails, then
               0  "       * if action = 0, return error code less than 0.
               0  "       * if action != 0, call the $egs_fatal macro with an error message.
               0  "
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit,rl,action;
               0  character*(*) extension;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  integer  i,the_unit,lnblnk1,egs_get_unit;
               0  $LOGICAL egs_is_absolute_path;
               0  character base*1024, fn*1024;
               0  $declare_write_buffer;
               0
               0  egs_open_datfile = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_datfile = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='old',err=:no_datfile_0:);
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='old',form='unformatted',
               2          access='direct',recl=rl,err=:no_datfile_0:);
               2          ]
               1      egs_open_datfile = the_unit; return;
               1
               1      :no_datfile_0:;
               1      IF( action = 0 ) [ egs_open_datfile = -2; return; ]
               1      $egs_fatal(*,'Failed to open file ',$cstring(extension));
               1      ]
               0
               0  $set_string(base,' '); $set_string(fn,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  "fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(output_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_1:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_1:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_1:;
               0  $egs_warning('(a,a)','Failed to open ',$cstring(fn));
               0  $set_string(fn,' ');
               0  "fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(input_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_2:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_2:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_2:;
               0  $egs_fatal(*,'Failed to open data file');
               0  end;
               0
               0  "******************************************************************************
               0  integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
               0  "******************************************************************************
               0  " Open the file filen for sequential formatted I/O and return the unit
               0  " number it was connected to.
               0  " If iunit ~= 0, try to connect to unit |iuniti|, otherwise
               0  " use the first unconnected unit found.
               0  " If iunit > 0
               0  "    open the unit even if it was already open, if do_it_anyway is .true.,
               0  "    otherwise return -4.
               0  " If iunit < 0
               0  "    if the unit |iunit| is already in use and do_it_anyway is .true.,
               0  "    search for the first available unit, otherwise return -4.
               0  " Return values:
               0  "   unit number, if the file was succesfully opened.
               0  "   -1, if there was no free unit numer to connect to.
               0  "   -2, if the file does not exist.
               0  "   -3, if the file exist, but could not be opened.
               0  "   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit;
               0  $LOGICAL do_it_anyway;
               0  character*(*) filen;
               0
               0  $LOGICAL aux;
               0  $INTEGER the_unit,i;
               0
               0  inquire(file=filen,exist=aux);
               0  IF( ~aux ) [ egs_open_file_junk = -2; return; ]
               0  IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
               0  IF( the_unit ~= 0 ) [
               1      inquire(unit=the_unit,opened=aux);
               1      IF( aux ) [
               2          IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
               2          IF( iunit < 0 ) the_unit = 0;
               2          ]
               1      ]
               0  IF( the_unit = 0 ) [
               1      DO i=1,$max_unit [
               2          inquire(unit=i,opened=aux);
               2          IF( ~aux ) [ the_unit = i; EXIT; ]
               2          ]
               1      IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
               1      ]
               0  open(the_unit,file=filen,status='old',err=:failed_to_open:);
               0  egs_open_file_junk = the_unit; return;
               0  :failed_to_open:
               0  egs_open_file_junk = -3; return; end;
               0
               0  "==============================================================================
               0  subroutine egs_strip_path(fname);
               0  "==============================================================================
               0  " Strip the path name from fname (if any)
               0  implicit none;
               0  character*(*) fname;
               0  integer  i,l,l1,lnblnk1,j;
               0  character slash;
               0  slash = '/';
               0  l = lnblnk1(fname);
               0  DO i=1,l [
               1      IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
               1      ]
               0  DO i=l,1,-1 [
               1      IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
               2          l1 = l-i;
               2          fname(:l1) = fname(i+1:l);
               2          DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
               2          return;
               2          ]
               1      ]
               0  return; end;
               0
               0  "==============================================================================
               0  subroutine replace_env(fname);
               0  "==============================================================================
               0  "subroutine to replace environment variables (beginning with $) with their"
               0  "full names or ~ with the full name of $HOME"
               0  "Assumes environment variable or ~ appears only at the beginning of the"
               0  "file name"
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character*(*) fname;
               0  character*256 dirname;
               0  integer indsep,ind1,ind2;
               0
               0  indsep = index(fname,$file_sep);
               0  IF(indsep <= 0) return;
               0  "hope that the user has just supplied the file name"
               0  "and it is in the current directory"
               0
               0  ind1=index(fname,'$');
               0  ind2=index(fname,'~');
               0
               0  "examine first character of name"
               0  IF(ind1=1)[
               1      "get the environment variable"
               1      call getenv(fname(2:indsep-1),dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' First element in name does not specify a defined environment variable.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  ELSEIF(ind2=1)[
               1      call getenv('HOME',dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' HOME is undefined.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  return;
               0  end;
               0
               0  "=============================================================================
               0  subroutine egs_get_usercode(ucode);
               0  "=============================================================================
               0  " Deduct the user code name from the executable name
               0  " The algorithm assumes that the executable is called
               0  "   xxx[_debug|noopt][.exe]
               0  " and it will fail if this is not the case.
               0  "=============================================================================
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  character*(*) ucode;
               0  character*512 arg;
               0  integer  l,l1,lnblnk1,i;
               0  $declare_write_buffer;
               0
               0  call getarg(0,arg); call egs_strip_path(arg);
               0  l = lnblnk1(arg);
               0  IF( arg(l-3:l) = '.exe' ) [
               1      arg(l-3:l) = ' '; l = l - 4;
               1      ]
               0  IF( arg(l-5:l) = '_debug' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  IF( arg(l-5:l) = '_noopt' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  l1 = len(ucode);
               0  IF( l > l1 ) [
               1      $egs_fatal(*,' user code name is too long (',l,' chars)');
               1      ]
               0  $set_string(ucode,' '); ucode(:l) = arg(:l);
               0  return; end;
               0
               0  subroutine egs_itostring(string,i,leave_space);
               0  implicit none;
               0  character*(*) string;
               0  $INTEGER i;
               0  integer  l,lnblnk1,idiv,itmp,iaux;
               0  $LOGICAL first,leave_space;
               0  l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
               0  idiv = 1000000000; itmp = i; first = .false.;
               0  do while(idiv.gt.0) ;
               0  iaux = itmp/idiv;
               0  IF( (iaux > 0 | first ) & l <= len(string) ) [
               1      string(l:l) = char(iaux+48); first = .true.; l = l+1;
               1      ]
               0  itmp = itmp - iaux*idiv; idiv = idiv/10;
               0  end do;
               0  return; end;
               0
               0  "=============================================================================
               0  $REAL function egs_rndm();
               0  "=============================================================================
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET egs_rndm;
               0  return; end;
               0
               0  "=============================================================================
               0  integer  function egs_add_medium(medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed,medname_len;
               0  character c;
               0  $LOGICAL  same;
               0  $declare_write_buffer;
               0
               0  l = min(len(medname),24); medname_len = l;
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
               1      ]
               0  DO imed=1,nmed [
               1      l = 24;
               1      DO i=1,24 [
               2          IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
               2          ]
               1      IF( l = medname_len ) [
               2          same = .true.;
               2          DO i=1,l [
               3              c = medname(i:i);
               3              IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
               3              ]
               2          IF( same ) [
               3              egs_add_medium = imed; return;
               3              ]
               2          ]
               1      ]
               0  nmed = nmed + 1;
               0  IF( nmed > $MXMED ) [
               1      $egs_fatal('(a,/,a,i3,a)',
               1      'In egs_add_medium: maximum number of media exceeded ',
               1      'Increase the macro $MXMED (currently ',$MXMED,') and retry');
               1      ]
               0  l = min(len(medname),24);
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
               1      media(i,nmed) = ' ';
               1      media(i,nmed)(1:1) = c;
               1      ]
               0  IF( l < 24 ) [
               1      DO i=l+1,24 [ media(i,nmed) = ' '; ]
               1      ]
               0  egs_add_medium = nmed;
               0  return; end;
               0
               0  subroutine egs_get_medium_name(imed,medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed;
               0  DO i=1,len(medname) [ medname(i:i) = ' '; ]
               0  IF( imed < 1 | imed > nmed ) [ return; ]
               0  l = 24;
               0  DO l=24,1,-1 [
               1      IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
               1      ]
               0  l = min(l,len(medname));
               0  DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
               0  return; end;
               0  ;
               0
               0  "============================================================================"
               0  "  Pass pointers to the cross section interpolation coefficients to          "
               0  "  an external subroutine                                                    "
               0  "============================================================================"
               0  subroutine egs_get_electron_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - eke0(imed))/eke1(imed);
               0  lemax = (meke(imed) - eke0(imed))/eke1(imed);
               0  IF( which = 1 ) [
               1      call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
               1      ] ELSE IF( which = 6 ) [
               1      call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
               1      ] ELSE IF( which = 7 ) [
               1      call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
               1      ] ELSE IF( which = 8 ) [
               1      call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
               1      ] ELSE IF( which = 9 ) [
               1      call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown electron data type ',which);
               1      ]
               0  return; end;
               0
               0  subroutine egs_get_photon_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/PHOTIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - ge0(imed))/ge1(imed);
               0  lemax = (mge(imed) - ge0(imed))/ge1(imed);
               0  IF( which = 1 ) [
               1      call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown photon data type ',which);
               1      ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine egs_print_binding_energies;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EDGE,MEDIA,EGS-IO/;
               0  $INTEGER    i,j;
               0  integer*4   lnblnk1;
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0  ' M1',' M2',' M3',' M4',' M5',
               0  ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0  $egs_info('(a,a,a)',
               0  'Binding energies from ',$cstring(photon_xsections),
               0  ' photon cross section library');
               0  DO j = 1,$MXELEMENT [
               1      DO i = 1,$MXPESHELL [
               2          IF ( binding_energies(i,j) > 0 ) [
               3              $egs_info('(a,i3,a,a,a,1pe12.4,a)',
               3              ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
               3              ]
               2          ]
               1      ]
               0
               0  return;end;
               0
               0
               0  "============================================================================="
               0  "  scale elastic scattering strength by a given factor                        "
               0  "============================================================================="
               0  subroutine egs_scale_xcc(imed,factor);
               0  implicit none;
               0  $INTEGER imed;
               0  $REAL    factor;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA/;
               0  IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_write_string(ounit,string);
               0  implicit none;
               0  $INTEGER ounit;
               0  character*(*) string;
               0  write(ounit,'(a,$)') string;
               0  $FLUSH_UNIT(ounit);
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_swap_2(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(2),tmp;
               0  tmp=c(2); c(2)=c(1); c(1)=tmp;
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_swap_4(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(4),tmp;
               0  tmp=c(4); c(4)=c(1); c(1)=tmp;
               0  tmp=c(3); c(3)=c(2); c(2)=tmp;
               0  return; end;
               0
               0
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0  " Utility subroutines and functions previously in egsnrc.mortran
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0
1              0  %E
               0  subroutine set_spline(x,f,a,b,c,d,n);
               0  "======================================================================"
               0  "
               0  " Sets cubic spline interpolation coefficients for the data contained  "
               0  " in the array f(n) at the abscissas x(n)                              "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    x(n),f(n),a(n),b(n),c(n),d(n);
               0
               0  $INTEGER m1,m2,m,mr;
               0  $REAL    s,r;
               0
               0  m1 = 2; m2 = n-1; s = 0;
               0  DO m=1,m2 [
               1      d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
               1      c(m) = r - s; s = r;
               1      ]
               0  /s,r,c(1),c(n)/=0;
               0  DO m=m1,m2 [
               1      c(m) = c(m) + r*c(m-1);
               1      b(m) = 2*(x(m-1) - x(m+1)) - r*s;
               1      s = d(m); r = s/b(m);
               1      ]
               0  mr = m2;
               0  DO m=m1,m2 [
               1      c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
               1      mr = mr - 1;
               1      ]
               0  DO m=1,m2 [
               1      s = d(m); r = c(m+1) - c(m); d(m) = r/s;
               1      c(m) = 3*c(m);
               1      b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
               1      a(m) = f(m);
               1      ]
               0  return; end;
               0  ;
               0
               0  $REAL function spline(s,x,a,b,c,d,n);
               0  "======================================================================"
               0  "                                                                      "
               0  " Returns the value of the function at s using the spline coefficients "
               0  " a,b,c,d, which must have been set using set_spline                   "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    s,x(n),a(n),b(n),c(n),d(n);
               0
               0  integer  m_lower,m_upper,direction,m,ml,mu,mav;
               0  $REAL    q;
               0
               0  IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
               0  ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
               0  IF ( s >= x(m_upper + direction) ) [
               1      m = m_upper + 2*direction - 1;
               1      ]
               0  ELSE IF( s <= x(m_lower+1-direction) ) [
               1      m = m_lower - 2*direction + 1;
               1      ]
               0  ELSE [   " Perform a binary search to find the interval s is in "
               1      ml = m_lower; mu = m_upper;
               1      WHILE ( iabs(mu-ml) > 1 ) [
               2          mav = (ml+mu)/2;
               2          IF( s < x(mav) ) [ mu = mav; ]
               2          ELSE             [ ml = mav; ]
               2          ]
               1      m = mu + direction - 1;
               1      ]
               0  q = s - x(m);
               0  spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
               0  return; end;
               0  ;
               0
1              0  %E "start of prepare_alias_table subroutine"
               0  "****************************************************************************
               0
               0  subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Prepare an alias sampling table, given the histogram probabilities
               0  " xs_array,fs_array.
               0  "*****************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
               1      IF( aux < 1e-30 ) aux = 1e-30;
               1      ws_array(i) = -aux; ibin_array(i) = 1;
               1      sum = sum + aux;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT_1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT_2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return; end;
               0  ;
               0
1              0  %E   " start of alias_sample1 function "
               0  "******************************************************************************
               0
               0  $REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Sample a random variable from the alias table
               0  "    xs_array,fs_array,ws_array,ibin_array
               0  " which must have been prepared with prepare_alias_table
               0  "
               0  "******************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $INTEGER j;
               0  $REAL    r1,r2,aj,x,dx,a,rnno1;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  aj = 1 + r1*nsbin; j = aj; aj = aj - j;
               0  IF( aj > ws_array(j) ) j = ibin_array(j);
               0  x = xs_array(j-1); dx = xs_array(j)-x;
               0  IF( fs_array(j-1) > 0 ) [
               1      a = fs_array(j)/fs_array(j-1)-1;
               1      IF( abs(a) < 0.2 ) [
               2          rnno1 = 0.5*(1-r2)*a;
               2          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
               2          ]
               1      ELSE [
               2          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
               2          ]
               1      ]
               0  ELSE [
               1      alias_sample1 = x + dx*sqrt(r2);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of prepare_alias_histogram routine "
               0  subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
               0  "*************************************************************
               0  "                                                                           "
               0  " Prepares an alias histogram for the probability array ws_array of         "
               0  " dimension nsbin.                                                          "
               0  " On return, the ws_array is modified and contains the alias weights,       "
               0  " ibin_array holds the alias indices.                                       "
               0  " To be used with the integer function sample_alias_histogram, which        "
               0  " returns a bin index j with probability ws_array(j)                        "
               0  "                                                                           "
               0  " Iwan Kawrakow, November 2001
               0  "***************************************************************************"
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      sum = sum + ws_array(i); ibin_array(i) = -1;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
               2          ]
               1
               1      DO j_l = 1,nsbin [
               2          IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
               2          ]
               1
               1      aux = sum - ws_array(j_l);
               1      ws_array(j_h) = ws_array(j_h) - aux;
               1      ws_array(j_l) = ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1
               1      ]
               0
               0  DO i=1,nsbin [
               1      IF( ibin_array(i) < 0 ) [
               2          ibin_array(i) = i; ws_array(i) = 1;
               2          ]
               1      ]
               0
               0  return;
               0  end;
               0
1              0  %E   " start of sample_alias_histogram function "
               0  $INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
               0  "***********************************************************************
               0  "
               0  " This function samples a bin index using the alias sampling technique.
               0  " The arrays ws_array and ibin_array of dimension nsbin must have been
               0  " prepared with the subroutine prepare_alias_histogram.
               0  "
               0  " Iwan Kawrakow, November 2001.
               0  "***********************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(*);
               0  $REAL     ws_array(*);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    r1,r2;
               0  $INTEGER ibin;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  ibin = 1 + nsbin*r1;
               0  IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
               0  sample_alias_histogram = ibin;
               0  return;
               0  end;
               0
1              0  %E   " start of gauss_legendre subroutine "
               0  "******************************************************************************
               0
               0  subroutine gauss_legendre(x1,x2,x,w,n);
               0
               0  "     Given the lower and upper limit of integration, x1 and x2,
               0  "     and given n, this routine returns arrays x and w,
               0  "     containing the abscissas and weights of the Gauss-Legendre
               0  "     n - point quadrature formula
               0  "
               0  "******************************************************************************
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER n;
               0  real*8   x1,x2,x(n),w(n);
               0
               0  real*8     eps,Pi;
               0  parameter (eps = 3.D-14, Pi = 3.141592654D0);
               0
               0  $INTEGER i,m,j;
               0  real*8   xm,xl,z,z1,p1,p2,p3,pp;
               0
               0  m = (n + 1)/2;
               0  xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
               0  DO i=1,m [
               1      z=cos(Pi*(i-.25d0)/(n+.5d0));
               1      LOOP [
               2          p1=1.d0; p2=0.d0;
               2          DO j=1,n [
               3              p3 = p2; p2 = p1;
               3              p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
               3              ]
               2          pp=n*(z*p1-p2)/(z*z-1.d0);
               2          z1=z; z=z1-p1/pp;
               2          ] UNTIL (abs(z-z1) < eps);
               1      x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
               1      w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of lnblnk1 function"
               0  "******************************************************************************
               0
               0  integer  function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  integer i;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
1              0  %E   " start of erf1 function "
               0  "************************************************************************
               0  "       an error function routine which is needed since some of
               0  "       the compiler don't have it as an intrinsic
               0  "
               0  "       Originally came from some library somewhere (Harwell I think)
               0  "       recoded in mortran
               0  "************************************************************************
               0
               0  $REAL FUNCTION ERF1(X);
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL x;
               0
               0  double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
               0  " (K=1) and for erfc(x) x>3 (K=2)
               0  double precision
               0  CONST,                   " 2/sqrt(pi)
               0  BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
               0  Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
               0  $INTEGER N,                     " recursion index n
               0  K,                     " K=1,2 for x <= 3 or x > 3
               0  NLIM(2);               " Maximum value of n in sum for K=1,2
               0
               0  DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
               0  -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
               0  0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
               0  -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
               0  0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
               0  -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
               0  0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
               0  -0.0000000000000005 ,  0.0000000000000001 ,
               0  0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
               0  -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
               0  0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
               0  0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
               0  -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;
               0
               0  DATA NLIM/ 22,16 /;
               0  DATA CONST/ 1.128379167095513 /;
               0
               0  IF( x > 3 ) [ y = 3/x; k = 2; ]
               0  ELSE        [ y = x/3; k = 1; ]
               0
               0  " Calculate sum of Chebyshev polynomials by backwards recursion
               0  "
               0  "       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
               0  "       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
               0  "                                      = ( B(0) - B(2) + A(0) ) / 2
               0  "
               0  "       where B(N+2) = B(N+1) = 0
               0  "       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
               0  "
               0  FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
               0  BN1 = 0.0;                       " Initialise B(N+2) = 0
               0  BN  = 0.0;                       " Initialise B(N+1) = 0
               0
               0  DO n = NLIM(K),0,-1 [
               1      BN2 = BN1; BN1 = BN;
               1      BN = FAC * BN1 - BN2 + A(N,K)
               1      ]
               0
               0  IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
               0  ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]
               0
               0  RETURN;
               0  end;
               0
1              0  %E   " start of zero function "
               0  "********************************************************"
               0  "   Finds minimum non-zero value which can be used for   "
               0  "   evaluating logarithms without getting a NAN.         "
               0  "                                                        "
               0  " Starting with 10^-20 and decreasing it by 5 orders of  "
               0  " magnitud at a time, a check is made until the compiler "
               0  " recognizes the number as zero and the previous number  "
               0  " used. The same procedure is applied to this number but "
               0  " decreasing it by one order of magnitud. Finally it is  "
               0  " divided by 2..10 until the zero-check is successful.   "
               0  "********************************************************"
               0  $REAL FUNCTION ZERO();
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER i;
               0  $REAL    x, xtemp;
               0
               0  x = 1.E-20;
               0  "jump over 5 orders of magnitude"
               0  DO i=1,100[
               1      IF (x = 0.0) [EXIT;]
               1      ELSE[xtemp = x;]
               1      x = x/1.E5;
               1      ]
               0  x = xtemp;
               0  "jump over 1 order of magnitude"
               0  DO i=1,5[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/10;
               1      ]
               0  x = xtemp;
               0  "divide it up by 2...10"
               0  DO i=2,10[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/i;
               1      ]
               0  zero = xtemp;
               0  return;end;
               0  ;
               0
1              0  %E   " start of toUpper function "
               0  "**************************************"
               0  "
               0  "   Converts a string to upper case.   "
               0  "                                      "
               0  "**************************************"
               0  character*512 function toUpper(a_string);
               0  character*(*) a_string;
               0  character*512 the_string;
               0  $INTEGER cursor, i, lnblnk1;
               0  toUpper = a_string; the_string = a_string;
               0  DO i=1, lnblnk1(the_string) [
               1      cursor=ICHAR(the_string(i:i));
               1      IF ((cursor.GE.97).AND.(cursor.LE.122)) [
               2          cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
               2          ]
               1      ]
               0  return; end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0  "================================================================="
               0  integer*1 function egs_read_byte(iunit, jrec);
               0  "================================================================="
               0  " Reads one byte from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*1 i_1;
               0  character c_1;
               0  equivalence (i_1,c_1);
               0  ;COMIN/EGS-IO/;
               0  read(iunit,rec=jrec,IOSTAT=ierr) c_1;
               0  IF (ierr.ne.0) [
               1      $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
               1      $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               1      egs_read_byte = -1; return;
               1      ]
               0  jrec = jrec + 1; egs_read_byte = i_1;
               0  return; end;
               0
               0  "================================================================="
               0  integer*2 function egs_read_short(iunit, jrec);
               0  "================================================================="
               0  " Reads short int from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*2 i_2;
               0  character c_2(2);
               0  equivalence (i_2,c_2);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+1[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_2(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_short = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 2; egs_read_short = i_2;
               0  return; end;
               0
               0  "================================================================="
               0  integer*4 function egs_read_int(iunit, jrec);
               0  "================================================================="
               0  " Reads integer from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*4 i_4;
               0  character c_4(4);
               0  equivalence (i_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_int = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_int = i_4;
               0  return; end;
               0
               0
               0  "================================================================="
               0  real*4 function egs_read_real(iunit, jrec);
               0  "================================================================="
               0  " Reads float from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  real*4 r_4;
               0  character c_4(4);
               0  equivalence (r_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_real = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_real = r_4;
               0  return; end;
               0
               0  "****************************************************************
               0  "*                                                              *
               0  "*                 Function ibsearch(a, nsh, b)                 *
               0  "*                                                              *
               0  "*       binary search for an element l of array b such that    *
               0  "*   b[l] =< a < b[l+1], array must be monotonically increasing *
               0  "*                                                              *
               0  "****************************************************************
               0  $INTEGER function ibsearch(a, nsh, b);
               0  implicit none;
               0  $REAL a, b(*);
               0  $INTEGER min,max,help,nsh;
               0  $REAL x;
               0  min = 1; max = nsh; x = a;
               0  WHILE ( min < max-1 )[
               1      help = (max+min)/2;
               1      IF ( b(help).le.x)[min = help;]
               1      ELSE[max = help;]
               1      ]
               0  ibsearch = min;
               0  return;end;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parallel processing functions                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " The following set of functions only gets included if we found a working     "
               0  " C compiler that can compile egs_c_utils.c                                   "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  #ifdef HAVE_C_COMPILER;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_create_lockfile(flag);
               0  "*****************************************************************************
               0  " Create a lock file in the user code directory to store parallel processing
               0  " information. To be called from job #1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_create_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to create a lock file named ',$cstring(fname));
               1      ]
               0  egs_create_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  $INTEGER function egs_open_lockfile(flag);
               0  "*****************************************************************************
               0  " Open a lock file in the user code directory to read/write parallel
               0  " processing info. To be called from all jobs except 1.
               0  "*****************************************************************************
               0  $INTEGER flag;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l,istat;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_open_control_file(fname,istat);
               0  IF( istat ~= 0 & flag = 1 ) [
               1      $egs_fatal(*,'Failed to open the lock file named ',$cstring(fname));
               1      ]
               0  egs_open_lockfile = istat;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_remove_lockfile(istat);
               0  "*****************************************************************************
               0  $INTEGER istat;
               0  ;COMIN/EGS-IO/;
               0  character*512 fname;
               0  $INTEGER i,lnblnk1,l;
               0  $set_string(fname,' ');
               0  fname = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '.lock';
               0  l = lnblnk1(fname)+1;
               0  fname(l:l) = char(0); " String must be null terminated "
               0  call egs_remove_file(fname,istat);
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_pjob_control(ncase,n_run,n_left,n_tot,sum,sum2,res,dres);
               0  "*****************************************************************************
               0  "
               0  " This subroutine controls a parallel run. It only works if the EGS_HOME
               0  " directory is the same for all machines participating in the parallel
               0  " processing (e.g. EGS_HOME is on a NFS for *nix or on a network share on
               0  " Windows).
               0  " n_case: number of histories to be run (all jobs, not just the current
               0  "         job)  (input)
               0  " n_run:  number of histories the user code should run (output). If n_run = 0,
               0  "         then finish simulation, clean up, call egs_finish and
               0  "         egs_pjob_finish (in that order) and exit.
               0  " n_left  no. of histories left to run after current job has been submitted
               0  " n_tot:  should be set to number of histories from previous runs (if any)
               0  "         for first call from job number 1. For all other jobs and for all
               0  "         other calls from job 1, it is set by egs_pjob_control to the
               0  "         number of histories run so far (including previous runs and other
               0  "         parallel jobs).
               0  "         Note: n_case, n_run and n_tot are $LONG_INT
               0  " sum,    input. for first call and job 1, score and score squared for quantity
               0  " sum2:   of interest, should be zero for first call from jobs other than 1.
               0  "         score for quantity of interest since last call to this subroutine
               0  "         for all other calls.
               0  " res:    combined result for the quantity of interest from previous runs
               0  "         and other parallel jobs, output
               0  " dres:   relative uncertainty of res in %
               0  "
               0  " The shower loop of a user code that wants to use the new parallel processing
               0  " implementation should look something like this:
               0  "
               0  " /sum,sum2/=0; (or result from a previous run, if i_parallel=1)
               0  " /last_sum,last_sum2/=0;
               0  " :start_simulation:
               0  " x=sum-last_sum; x2=sum2-last_sum2; last_sum=sum; last_sum2=sum2;
               0  " call egs_pjob_control(ncase,n_run,n_tot,x,x2,res,dres);
               0  " IF( n_run = 0 ) goto :end_simulation:
               0  " write(6,*) ' running ',n_run,' histories,' n_tot so far: ',n_tot;
               0  " write(6,*) ' result so far: ',res,' +/- ',dres,' %';
               0  " DO icase=1,n_run [
               0  "    get source particle, call shower. sum and sum2 are updated
               0  " ]
               0  " goto :start_simulation:;
               0  " :end_simulation:
               0  " analyze and output results for this job.
               0  " call egs_finish;
               0  "   (after egs_finish all output files are closed and moved to the user code
               0  "    directory from the temporary working directory).
               0  " call egs_pjob_finish(combine_results,'.egsdat');
               0  " output combined results.
               0  " end;
               0  "
               0  " In the above, combine_results is a user supplied subroutine that
               0  " combines parallel runs and takes a file name as an argument.
               0  " egs_pjob_finish  decreases the number of running job, n_job, in the
               0  " job control file by one. If n_job > 0, it simply returns.
               0  " If n_job = 0 (i.e. this job is the last job), it checks for
               0  " data files output_file_wj.egsdat, j=1,99. For each file found, it calls
               0  " combine_results with that file name.
               0  "
               0
               0  implicit none;
               0  $LONG_INT ncase,n_run,n_tot;
               0  $REAL    sum,sum2,res,dres;
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $LONG_INT n_last,n_left,nn_tot;
               0  integer   t_dum(8);
               0  $INTEGER  i,lnblnk1,n_write,n_read,istat,n_job;
               0  $INTEGER  egs_create_lockfile, egs_open_lockfile;
               0  $REAL     tmp,tmp2;
               0  $LOGICAL first_time;
               0  character control_string*256;
               0  data first_time/.true./;
               0  save first_time,n_last;
               0
               0
               0
               0
               0  IF( is_uniform_run ) [
               1      IF (first_time)[
               2          n_run = ncase/n_parallel;
               2          first_time = .false.;
               2          ]
               1      ELSE[
               2          n_run = 0;
               2          ]
               1      n_left = 0;
               1      return;
               1      ]
               0
               0  IF( n_parallel <= 0 ) [
               1      n_run = ncase; return;
               1      ]
               0
               0  IF( first_time ) n_last = 0;
               0
               0  $set_string(control_string,' ');
               0  n_run = ncase/n_parallel/$N_CHUNKS;
               0  n_left = ncase;
               0
               0  REPLACE {$control_format} WITH {
            {  0  '(2i15,i4,2(1pe16.8),1pe13.5,0pf7.2,2x,8i5)'};
               0
               0  IF( first_time ) [
               1      IF( n_run > n_left ) n_run = n_left;
               1      n_left = ncase - n_run;
               1
               1      IF( i_parallel = first_parallel ) [ "I'm first job => "
               2          "create the job control file"
               2          istat = egs_create_lockfile(1); "The 1 tells egs_create_lockfile to "
               2          "print an error message and exit if"
               2          "it fails."
               2          IF( n_tot > 1 ) [ "=> a continuation from a previous run "
               3              res = sum/n_tot; dres = sum2/n_tot - res*res;
               3              IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               3              ELSE [ dres = 99.9 ]
               3              ] ELSE [ res = 0; dres = 99.9; ]
               2
               2
               2
               2
               2
               2          write(control_string,$control_format)
               2          n_left,n_tot,1,sum,sum2,res,dres,(t_first(i),i=1,8);
               2          n_write = lnblnk1(control_string) + 1;
               2          call egs_write_control_file(control_string,n_write,istat);
               2          IF( istat ~= n_write ) [
               3              $egs_fatal(*,'job 1: failed to write to lock file ',n_write,istat);
               3              ]
               2          call egs_unlock_control_file(istat);
               2          IF( istat ~= 0 ) [
               3              $egs_fatal(*,'job 1: failed to unlock the file ',istat);
               3              ]
               2          first_time = .false.;
               2          n_max_parallel = 1; n_last = n_run;
               2          return;
               2          ]
               1      istat = egs_open_lockfile(1);
               1      ]
               0
               0  " Here for all calls except first call from job 1. "
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,err=:error_lockfile_read:) n_left,nn_tot,n_job,tmp,tmp2,
               0  res,dres,(t_dum(i),i=1,8);
               0
               0  " Update the number of histories finished so far "
               0  nn_tot = nn_tot + n_last;
               0
               0  " Update the score for the quantity of interest "
               0  tmp = tmp + sum; tmp2 = tmp2 + sum2;
               0
               0  " First call => increase number of running jobs "
               0  IF( first_time ) [
               1      first_time = .false.; n_job = n_job + 1;
               1      nn_tot = nn_tot + n_tot;
               1      ]
               0  n_tot = nn_tot;
               0
               0  " If n_tot > 1, do stat. analysis and put result is res, dres "
               0  IF( n_tot > 1 ) [
               1      res = tmp/n_tot; dres = tmp2/n_tot - res*res;
               1      IF( res > 0 & dres > 0 ) [ dres = sqrt(dres/(n_tot-1))/res*100; ]
               1      ELSE [ dres = 99.9 ]
               1      ] ELSE [ res = 0; dres = 99.9; ]
               0
               0  " Take another chunk of histories to run "
               0  IF( n_run > n_left ) [
               1      n_run = n_left; n_left = 0;
               1      ] ELSE [ n_left = n_left - n_run; ]
               0
               0  n_last = n_run;
               0
               0  " Write new job control info into job control string "
               0  $set_string(control_string,' ');
               0  write(control_string,$control_format)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_dum(i),i=1,8);
               0
               0  " Rewind again the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1
               1      ]
               0
               0  " Write the new job control string "
               0  n_write = lnblnk1(control_string) + 1;
               0  call egs_write_control_file(control_string,n_write,istat);
               0  IF( istat ~= n_write ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               1      n_write,istat);
               1      ]
               0
               0  " Finally unlock the job control file so that other jobs can access it. "
               0  call egs_unlock_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to unlock the file ',istat);
               1      ]
               0  IF( n_job > n_max_parallel ) n_max_parallel = n_job;
               0  return;
               0
               0  :error_lockfile_read:
               0  $egs_fatal('(a,/a)','Failed to read from job control file: got ',
               0  $cstring(control_string));
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_pjob_finish(n_job);
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER n_job;
               0
               0  ;COMIN/EGS-IO,my_times/;
               0
               0  $INTEGER  istat,i,lnblnk1,n_read,n_write;
               0  $LONG_INT n_left,n_tot;
               0  integer   t_start(8),t_end(8);
               0  $REAL     tmp,tmp2,res,dres,t_run;
               0  real      egs_time_diff;
               0  character control_string*256;
               0
               0
               0
               0
               0  IF( is_uniform_run )[
               1      IF( i_parallel = n_parallel )[
               2          n_job = 0;"I am the last job!!!"
               2          goto :complete_calculation:;
               2          ]
               1      ELSE ["nothing to do here"
               2          n_job = 1;"Only last job allowed to finish!"
               2          return;
               2          ]
               1      ]
               0
               0  " Lock and rewind the job control file "
               0  call egs_rewind_control_file(istat);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the control ',
               1      'file', istat);
               1      ]
               0
               0  " Read the job control string string "
               0  n_read = len(control_string);
               0  call egs_read_control_file(control_string,n_read,istat);
               0
               0  " Read from the job control string string "
               0  read(control_string,*,end=:error2_lockfile_read:,err=:error2_lockfile_read:)
               0  n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               0
               0  n_job = n_job - 1;
               0  IF( n_job > 0 ) [  " Other jobs still running "
               1      $set_string(control_string,' ');
               1      write(control_string,$control_format)
               1      n_left,n_tot,n_job,tmp,tmp2,res,dres,(t_start(i),i=1,8);
               1      call egs_rewind_control_file(istat);
               1      IF( istat ~= 0 ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to rewind or lock the ',
               2          'control file, error was:', istat);
               2          ]
               1      n_write = lnblnk1(control_string) + 1;
               1      call egs_write_control_file(control_string,n_write,istat);
               1      IF( istat ~= n_write ) [
               2          $egs_fatal(*,'job ',i_parallel,': failed to write to lock file ',
               2          n_write,istat);
               2          ]
               1      call egs_unlock_control_file(istat);
               1      call egs_close_control_file(istat);
               1      return;
               1      ]
               0
               0  " If here, I'm the last job => remove job control file
               0
               0  call egs_close_control_file(istat);
               0  call egs_remove_lockfile(istat);
               0
               0  :complete_calculation:;
               0  i_parallel = 0; call egs_open_units(.false.);
               0  IF ( is_uniform_run )[
               1      $egs_info('(/a/,a,t55,i3/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      '***************************************************************');
               1      ]
               0  ELSE[
               1      call egs_date_and_time(t_end);
               1      t_run = egs_time_diff(t_start,t_end);
               1      $egs_info('(/a/,a,t55,i3/,a,t55,i3/,a,f9.1,a,f9.4,a/,a//)',
               1      '**************** finished parallel execution ******************',
               1      ' number of parallel jobs requested: ',n_parallel,
               1      ' max. number of jobs executing simultaneously: ',n_max_parallel,
               1      ' elapsed time since first job started: ',t_run,' s (',t_run/3600,' h)',
               1      '***************************************************************');
               1      ]
               0  return;
               0
               0  :error2_lockfile_read:;
               0  $egs_fatal('(a,/a)',
               0  'In egs_pjob_finish: failed to read from control string ',
               0  $cstring(control_string));
               0
               0  return; end;
               0
               0
               0  #endif;
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc core source code                                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                   Victor Malkov                                             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but NOTE, this doesn't happen inside a REPLACE macro
               0  "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
               0  "   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
               0  "                                                                  "
               0  "   If the user requests radiative splitting (via nbr_split > 1),  "
               0  "   this routine produces 2*nbr_split annihilation photons at once,"
               0  "   each carying the fraction 1/nbr_split of the weight of the     "
               0  "   incident positron.                                             "
               0  "                                                                  "
               0  "   Except for taking out the calculation of                       "
               0  "   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
               0  "   rejection function normalized to its maximum, the sampling     "
               0  "   technique is the same as the original EGS4 implementation.     "
               0  "                                                                  "
               0  "   I. Kawrakow, January 2000                                      "
               0  "                                                                  "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                   "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
               0                   "EGS-VARIANCE-REDUCTION/;                         "
               0
               0  $DEFINE-LOCAL-VARIABLES-ANNIH;
               0  $INTEGER ip;
               0
               0  NPold = NP; "Set the old stack counter"
               0  IF( nbr_split <= 0 ) [ return; ]
               0  PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
               0                   "i.e. electron assumed to be at rest
               0  AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
               0  A=AVIP/RM;
               0  "AI=1.0/A;  AI not necessary, IK Oct 97"
               0  G=A-1.0;
               0  T=G-1.0;
               0  P=SQRT(A*T);
               0  POT=P/T;
               0  EP0=1.0/(A+P);
               0  "   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
               0  "Take the calculation of the logarithm out of the loop, IK Oct 97"
               0  WSAMP=LOG((1.0-EP0)/EP0);
               0
               0  aa = u(np); bb = v(np); cc = w(np);
               0  sinpsi = aa*aa + bb*bb;
               0  IF( sinpsi > 1e-20 ) [
               1     sinpsi = sqrt(sinpsi);
               1     sindel = bb/sinpsi; cosdel = aa/sinpsi;
               1  ]
               0
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0
               0  DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
               1                          "radiative event                              "
               1
               1      IF( np+1 > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1
               1      LOOP[
               2          $RANDOMSET RNNO01;
               2          EP=EP0*EXP(RNNO01*WSAMP);
               2          "   NOW DECIDE WHETHER TO ACCEPT"
               2          $RANDOMSET RNNO02;
               2          "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
               2          "The above rejection function has a maximum = 1 - 2/A**2"
               2          "For efficiency, it is better to divide by the maximum value, IK Oct 97"
               2          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
               2      ] UNTIL (RNNO02 <= REJF);
               1
               1
               1      "   SET UP ENERGIES"
               1      ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
               1      PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
               1      E(NP)=PESG1; IQ(NP)=0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG1-RM)*POT/ESG1));
               1      SINTHE=SQRT(1.0-COSTHE*COSTHE);
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1      PESG2=PAVIP-PESG1; esg2 = pesg2;
               1      e(np) = pesg2; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      COSTHE=MAX(-1.0,MIN(1.0,(ESG2-RM)*POT/ESG2));
               1      SINTHE=-SQRT(1.0-COSTHE*COSTHE);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1
               1  ]
               0  np = np-1;
               0
               0  RETURN;
               0  "END OF SUBROUTINE ANNIH"   END;
               0
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH_AT_REST;
               0  "                                                                  "
               0  " It is handy to be able to initiate annihilation at rest from     "
               0  " places other than the electron discard section (e.g. AUSGAB)     "
               0  " Annihilation at rest takes a sufficent amount of time to not     "
               0  " have any real benefit from this code being inline in the         "
               0  " ELECTR subroutine.                                               "
               0  " I. Kawrakow, June 2005.                                          "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-ANNIH-ATREST;
               0  $REAL costhe,sinthe,cphi,sphi;
               0  $INTEGER ibr,ip;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  NPold = NP;
               0  $CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0      " nbr_split > 1 means user wants to use radiative "
               0      " splitting => produce 2*nbr_split annihilation   "
               0      " photons at once                                 "
               0  DO ibr = 1, nbr_split [
               1      "Pick random direction for first gamma
               1      $RANDOMSET costhe; costhe = 2*costhe-1;
               1      sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      e(np) = prm; iq(np) = 0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               1      np = np+1;
               1      e(np) = prm; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               1      np = np+1;
               1  ]
               0  np = np-1;
               0  return; end;
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BHABHA;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
               0  "   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
               0  "   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                     "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
               0                                  "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BHABHA;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
               0  EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
               0  PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
               0  EKIN=PEKIN;
               0  T0=EKIN/RM;
               0  E0=T0+1.;
               0  YY=1./(T0+2.);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
               0  BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  EP0C=1.-EP0;
               0  Y2=YY*YY;
               0  YP=1.-2.*YY;
               0  YP2=YP*YP;
               0  B4=YP2*YP;
               0  B3=B4+YP2;
               0  B2=YP*(3.+Y2);
               0  B1=2.-Y2;
               0  "   SAMPLE BR FROM MINIMUM(EP0) TO 1."
               0  LOOP[$RANDOMSET RNNO03;
               1  BR=EP0/(1.-EP0C*RNNO03);
               1  "   APPLY REJECTION FUNCTION"
               1  $RANDOMSET RNNO04;
               1  "REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
               1  REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
               1  ]UNTIL RNNO04.LE.REJF2 ;
               0  "   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
               0  $CHECK-STACK(np+1,'BHABHA');
               0  IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
               0  "THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
               0  "   DIVIDE UP THE ENERGY"
               0  BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
               0  PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
               0  PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
               0  ESE1=PESE1;
               0  ESE2=PESE2;
               0  E(NP)=PESE1;
               0  E(NP+1)=PESE2;
               0  "   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
               0  H1=(PEIP+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"
               0
               0  "AFB modified the following statement 92/10/28 to avoid"
               0  "numerical difficulties"
               0  "DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
               0  DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));
               0
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(2,1);
               0  NP=NP+1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE BHABHA"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BREMS;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Samples bremsstrahlung energy using                            "
               0  "    - Coulomb corrected Bethe-Heitler above 50 MeV                "
               0  "    - Bethe-Heitler below 50 MeV                                  "
               0  "   if ibr_nist = 0, or                                            "
               0  "    - the NIST bremsstrahlung cross section data base             "
               0  "      (prepared in a form of an alias table for rapid sampling)   "
               0  "   if ibr_nist = 1  or                                            "
               0  "    - the NRC bremsstrahlung cross section data base, which is    "
               0  "      the same as the NIST database, but with corrections to      "
               0  "      the electron-electron contribution, which are mostly        "
               0  "      important for low Z and low k                               "
               0  "   if ibr_nist = 2                                                "
               0  "   and direction using                                            "
               0  "    - formula 2BS from from Koch and Motz if IBRDST=1             "
               0  "    - leading term of the brems angular dsstr. if IBRDST=0        "
               0  "    - photon direction = electron direction if IBRDST<0           "
               0  "                                                                  "
               0  "   This version replaces the original EGS4 implementation         "
               0  "   because of a bug discovered in the EGS4 brems routine          "
               0  "   In order to work properly, the parameter DL1,..,DL6            "
               0  "   are re-calculated in subroutine fix_brems which is called      "
               0  "   from HATCH                                                     "
               0  "   In addition, this version has the internal capability of       "
               0  "   bremsstrahlung splitting.                                      "
               0  "   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
               0  "   to the desired number > 1 (1 is the default)                   "
               0  "   Be aware that event-by-event energy conservation is NOT        "
               0  "   guaranteed, so don't use for calculations where this is        "
               0  "   important (e.g. calculation of detector response functions)    "
               0  "   The result will be nbr_split photons, all with the weight      "
               0  "   wt(npold)/nbr_split, and an electron with the original weight  "
               0  "   and energy given by the incident energy - energy of last photon"
               0  "                                                                  "
               0  " I. Kawrakow, January 2000                                        "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
               0                             "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BREMS;
               0  $REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;
               0
               0  IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
               0                               "by setting nbr_split to zero!"
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
               0  EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
               0  weight = wt(np)/nbr_split;
               0
               0  "   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
               0  "   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
               0  IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
               0  L1 = L+1;
               0
               0  ekin = peie-prm;
               0  brmin = ap(medium)/ekin;
               0  "waux = -log(brmin);"
               0  waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
               0                                "log_ap = log(ap(medium)) is calculated in   "
               0                                "fix_brems for each medium, elke is needed   "
               0                                "in electr to calculate the branching ratios "
               0                                "and therefore it must be known at this point"
               0
               0  IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
               1                      "angle from KM-2BS (ibrdst=1) or from the leading"
               1                      "term (ibrdst=0). If nbr_split > 1, we can re-use"
               1                      "the following quantities several time"
               1
               1      a = u(np); b = v(np); c = w(np);
               1      sinpsi = a*a + b*b;
               1      IF( sinpsi > 1e-20 ) [
               2         sinpsi = sqrt(sinpsi);
               2         sindel = b/sinpsi; cosdel = a/sinpsi;
               2      ]
               1
               1      ztarg = zbrang(medium);
               1      tteie = eie/rm;
               1      beta = sqrt((tteie-1)*(tteie+1))/tteie;
               1      y2max = 2*beta*(1+beta)*tteie*tteie;
               1      y2maxi = 1/y2max;
               1      IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]
               1
               1  ]
               0
               0  IF( ibr_nist >= 1 ) [
               1      ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
               1      jj = ajj; ajj = ajj - jj;
               1      IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
               1  ]
               0
               0  DO ibr = 1,nbr_split [
               1
               1      IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
               2                           "data base"
               2          IF( ekin > nb_emin(medium) ) [
               3              $RANDOMSET r1;
               3              IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
               3              br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
               3                                 nb_fdata(0,j,medium),
               3                                 nb_wdata(1,j,medium),nb_idata(1,j,medium));
               3          ]
               2          ELSE [ $RANDOMSET br; ]
               2          esg = ap(medium)*exp(br*waux); pesg = esg;
               2          pese = peie - pesg; ese = pese;
               2      ]
               1      ELSE [
               2
               2          LOOP [ "User wants to use Bethe-Heitler"
               3
               3              $RANDOMSET rnno06; $RANDOMSET rnno07;
               3              br = brmin*exp(rnno06*waux);
               3              esg = ekin*br; pesg = esg;
               3              pese = peie - pesg; ese = pese;
               3              delta = esg/eie/ese*delcm(medium); aux = ese/eie;
               3              IF( delta < 1 ) [
               4                  phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4                  phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
               4                          delta*dl3(l1,medium));
               4              ]
               3              ELSE [
               4                  phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
               4                  phi2 = phi1;
               4              ]
               3              rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;
               3
               3          ] UNTIL (rnno07 < rejf);
               2      ]
               1
               1      "   SET UP THE NEW PHOTON                                          "
               1      np=np+1;
               1      IF( np > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1      e(np) = pesg; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      wt(np) = weight;
               1      IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
               2                          "the electron. This option is given so that "
               2                          "the user can implement their own brems angle "
               2                          "schemes via a call to ausgab"
               2          u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
               2      ]
               1      ELSE [
               2         IF( ibrdst = 1 ) [
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3             ttese = ese/rm; esedei = ttese/tteie;
               3             rjarg1 = 1+esedei*esedei;
               3             rjarg2 = rjarg1 + 2*esedei;
               3             aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
               3             IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
               3             ELSE [ rjarg3 = log(aux/(1+aux1)); ]
               3             rejmax = rjarg1*rjarg3-rjarg2;
               3             LOOP [
               4                 $RANDOMSET y2tst; $RANDOMSET rtest;
               4                 aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               4                 rtest = rtest*aux3*rejmax;
               4                 y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               4                 aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               4                 IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               4                 aux2 = log(aux/(1+aux1/aux3**4));
               4                 rejtst = aux4+aux5*aux2;
               4             ] UNTIL (rtest < rejtst );
               3
               3         ]
               2         ELSE [
               3             $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
               3         ]
               2         costhe = 1 - 2*y2tst*y2maxi;
               2         sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
               2         $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               2         IF( sinpsi >= 1e-10 ) [
               3             us = sinthe*cphi; vs = sinthe*sphi;
               3             u(np) = c*cosdel*us - sindel*vs + a*costhe;
               3             v(np) = c*sindel*us + cosdel*vs + b*costhe;
               3             w(np) = c*costhe - sinpsi*us;
               3         ]
               2         ELSE [
               3             u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
               3         ]
               2      ]
               1  ]
               0
               0  e(npold) = pese;
               0
               0  RETURN;
               0  "END OF SUBROUTINE BREMS"   END;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impulse approximation  "
               0  "   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections lead to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "                                                                  "
               0  "   I.Kawrakow, March 2008:                                        "
               0  "      If ibcmp = 2 or 3, the actual bound Compton scattering      "
               0  "      cross section is used and rejections lead to resampling     "
               0  "      instead of rejecting the entire interactions as stated above"
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT;
               0  $LOGICAL first_time;
               0  $INTEGER ibcmpl;
               0
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  $RADC_CHECK;
               0
               0  irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);
               0
               0  :resample-compton:;
               0  IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
               1                     "=>first sample the shell and see whether an    "
               1                     "  interaction is possible                      "
               1      $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
               1      i = int(rnno17); "rnno17 = rnno17 - i;
               1      IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:;     ]
               2      ]
               1      Jo = Jo_array(j);          "Jo is the Compton profile parameter"
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      IF( first_time ) [
               2          broi2 = broi*broi;
               2          alph1 = Log(broi);
               2          bro   = 1/broi;
               2          alph2 = ko*(broi+1)*bro*bro;
               2          alpha = alph1+alph2;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)*bro;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
               3          ]
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          aux = 1+br*br;
               2          rejf3 = aux - br*sinthe;
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19*aux.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      IF( first_time ) [
               2          bro = 1./broi; bro1 = 1 - bro;
               2          rejmax = broi + bro;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 + br*br - br*sinthe;
               2      ] UNTIL rnno16*br*rejmax.le.rejf3;
               1  ]
               0  first_time = .false.;
               0
               0  IF(br < bro | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2          $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE: ;
               1  ]
               0
               0  $RADC_REJECTION;
               0
               0  costhe = 1 - temp;
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0;
               1      goto :FINISHED-COMPTON-SAMPLING:;
               1  ]
               0
               0  " Check for rejection due to the limited range of pzmax "
               0  br2 = br*br;
               0  aux = ko*(ko-Uj)*temp;
               0  aux1 = 2*aux + Uj*Uj;
               0  pzmax = aux - Uj;
               0  IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0  pzmax = pzmax/sqrt(aux1);
               0
               0
               0
               0
               0
               0
               0
               0  qc2 = 1 + br*br - 2*br*costhe;
               0  qc  = sqrt(qc2);
               0
               0  IF( pzmax > 1 ) [
               1      pzmax = 1; af = 0; Fmax = 1; fpz = 1;
               1      goto :RETRY-PZ:;
               1  ]
               0
               0  aux3 = 1 + 2*Jo*abs(pzmax);
               0  aux4 = 0.5*(1-aux3*aux3);
               0  fpz  = 0.5*exp(aux4);
               0  af   = qc*(1+br*(br-costhe)/qc2);
               0
               0  IF( af < 0 ) [
               1      IF( pzmax > 0 ) fpz = 1 - fpz;
               1      $RANDOMSET eta_incoh;
               1      IF( eta_incoh > fpz ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:; ]
               2      ]
               1      af = 0; Fmax = 1; goto :RETRY-PZ:;
               1  ]
               0
               0  IF( pzmax < -0.15 ) [
               1      Fmax = 1-af*0.15;
               1      fpz1 = fpz*Fmax*Jo;
               1  ]
               0  ELSE IF( pzmax < 0.15 ) [
               1      Fmax = 1 + af*pzmax;
               1      aux3 = 1/(1+0.33267252734*aux3);
               1              "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
               1              "of Abramowitz and Stegun, needed for approximating Erf        "
               1      aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
               1             erfJo_array(j);
               1      IF( pzmax > 0 ) [
               2          "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
               2          fpz = 1 - fpz;
               2      ]
               1      ELSE [
               2          "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
               2      ]
               1  ]
               0  ELSE [
               1      Fmax = 1 + af*0.15;
               1      fpz1 = (1 - Fmax*fpz)*Jo;
               1      fpz = 1 - fpz;
               1  ]
               0  $RANDOMSET eta_incoh;
               0  IF(eta_incoh*Jo > fpz1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0
               0  "At this point, all rejections are handled, now we need to sample pz "
               0  "between -1 and pzmax using the Compton profile of the selected shell"
               0  "and F(pz,cos(theta)) as a rejection function                        "
               0
               0  :RETRY-PZ:;
               0  IF( ibcmpl ~= 2 ) [
               1    $RANDOMSET rnno18; rnno18 = rnno18*fpz;
               1    IF( rnno18 < 0.5 ) [
               2      rnno18 = Max(1e-30,2*rnno18);
               2      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
               2    ]
               1    ELSE [
               2      rnno18 = 2*(1-rnno18);
               2      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
               2    ]
               1    IF( abs(pz) > 1 ) goto :RETRY-PZ:;
               1        "Due to the non-relativistic approximation"
               1        "for pz, it has to be between -1 and 1    "
               1    IF( pz < 0.15  ) [
               2      IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
               2      ELSE             [ frej = 1 + af*pz;   ]
               2      $RANDOMSET eta;
               2      IF( eta*Fmax > frej ) goto :RETRY-PZ:;
               2    ]
               1    "If pz > 0.15, F is always 1 => no need for rejection"
               1  ]
               0  ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]
               0
               0  " Calculate energy of scattered photon "
               0  pz2 = pz*pz;
               0  IF( abs(pz) < 0.01 ) [
               1      br = br*(1 + pz*(qc + (br2-costhe)*pz));
               1  ]
               0  ELSE [
               1      aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               1      aux2 = qc2 - br2*pz2*sinthe;
               1      IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               1  ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmpl = 1 | ibcmpl = 3 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = pzero;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2          "relax will put all particles with energies above ecut,pcut on the "
               2          "stack, the remaining energy will be scored in edep and deposited  "
               2          "locally (via the call to ausgab below)                            "
               2      ]
               1      ELSE [
               2          edep = Uj;
               2          edep_local = edep;
               2          $AUSCALL($SPHOTONA);
               2      ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE old_COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impuls approximation   "
               0  "    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections leed to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "   This version ignores the function F(cos(theta),pz).            "
               0  "   This leads to a small error (at least compared to the cross    "
               0  "   section we want to sample) at low energies (say, below Z keV)  "
               0  "   The advantage is that it is substantially faster then the      "
               0  "   version with F taken into account.                             "
               0  "                                                                  "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
               0                                 "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT-old;
               0
               0  i_survived_RR = 0;"0=> all survived russian roulette if played"
               0                    "must set here since, if bound compton and event is"
               0                    "rejected, this wouldn't be set to the new 0 value"
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  irl = ir(np);
               0  IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
               1                         "=>first sample the shell and see whether an    "
               1                         "  interaction is possible                      "
               1      $RANDOMSET rnno17;
               1      DO i=1,n_shell(medium) [
               2          rnno17 = rnno17 - eno_array(i,medium);
               2          IF( rnno17 <= 0 ) EXIT;
               2      ]
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE-old:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      broi2 = broi*broi;
               1      alph1 = Log(broi);
               1      alph2 = ko*(broi+1)/broi2;
               1      alpha = alph1/(alph1+alph2);
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15 < alpha ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)/broi;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16 + (1-rnno16)/broi2);
               3          ]
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 - br*sinthe/(1+br*br);
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      bro = 1./broi; bro1 = 1 - bro;
               1      rejmax = broi + bro;
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = (br + 1./br - sinthe)/rejmax;
               2      ] UNTIL rnno16.le.rejf3;
               1  ]
               0
               0  IF(br < 1./broi | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2      $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE-old: ;
               1  ]
               0
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0; costhe = 1 - temp;
               1      goto :FINISHED-COMPTON-SAMPLING-old:;
               1  ]
               0
               0  " Sample Doppler broadening using the Compton profile of the selected shell"
               0  br2 = br*br;
               0  costhe = 1 - temp;
               0  aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
               0  pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
               0  :RETRY-PZ-old:;
               0  $RANDOMSET rnno18;
               0  IF( rnno18 < 0.5 ) [
               1      rnno18 = Max(1e-30,2*rnno18);
               1      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  ELSE [
               1      IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
               1      rnno18 = 2*(1-rnno18);
               1      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;
               0
               0  " Calculate energy of scattered photon "
               0  aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               0  aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
               0  IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING-old:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmp(irl) = 1 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = 0;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2            "relax will put all particles with energies above ecut,pcut on the "
               2            "stack, the remaining energy will be scored in edep and deposited  "
               2            "localy (via the call to ausgab below)                             "
               2      ]
               1      ELSE [ edep = Uj; ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED-old:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  SUBROUTINE ELECTR(IRCODE);
               0  "******************************************************************"
               0  "   This subroutine has been almost completely recoded to include  "
               0  "   the EGSnrc enhancements.                                       "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Complete recoding            "
               0  "   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
               0  "                                     fictitious method (important "
               0  "                                     for low energy transport     "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE;
               0
               0  $COMIN-ELECTR; "default replacement produces the following:
               0                 "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
               0                          "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
               0                          "UPHIOT,USEFUL,USER,RANDOM/;"
               0  ;COMIN/EII-DATA/;
               0  ;COMIN/EM/;
               0  $REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
               0  LOGICAL random_tustep;
               0
               0  $DEFINE-LOCAL-VARIABLES-ELECTR;
               0
               0
               0
               0
               0
               0  data ierust/0/;         "To count negative ustep's"
               0
               0  save ierust;
               0
               0  $CALL-USER-ELECTRON;
               0
               0  ircode = 1; "Set up normal return-which means there is a photon
               0              "with less available energy than the lowest energy electron,
               0              "so return to shower so it can call photon to follow it.
               0              "(For efficiency's sake, we like to stay in this routine
               0              " as long as there are electrons to process. That's why this
               0              " apparently convoluted scheme of STACK contro is effected.)
               0
               0  irold = ir(np);    "Initialize previous region
               0                     "(ir() is an integer that is attached to the particle's
               0                     " phase space. It contains the region
               0                     " number that the current particle is in.
               0                     " Np is the stack pointer, it points to where on the
               0                     " stack the current particle is.)
               0  irl    = irold;    "region number in local variable
               0
               0
               0  $start_new_particle;
               0  " Default replacement for the above is medium = med(irl); "
               0  " This is made a macro so that it can be replaced with a call to a "
               0  " user provided function start_new_particle(); for the C/C++ interface "
               0
               0  :NEWELECTRON:LOOP
               0  [
               1      "Go once through this loop for each 'new' electron whose charge and
               1      "energy has not been checked
               1
               1      lelec = iq(np); "Save charge in local variable
               1                      "(iq = -1 for electrons, 0 for photons and 1 for positrons)
               1      qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
               1      peie  = e(np);  "precise energy of incident electron (double precision)
               1      eie   = peie;   "energy incident electron (conversion to single)
               1
               1      IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               1          "(Ecut is the lower transport threshold.)
               1
               1      "medium = med(irl);" "(This renders the above assignment redundant!)
               1      "The above assignment is unnecessary, IK, June 2003"
               1
               1      IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"
               1
               1      :TSTEP:LOOP
               1      [
               2          "Go through this loop each time we recompute distance to an interaction
               2
               2
               2
               2          compute_tstep = .true.; "MFP resampled => calculate distance to the
               2                                  "interaction in the USTEP loop
               2          eke = eie - rm; "moved here so that kinetic energy will be known"
               2                          "to user even for a vacuum step, IK January 2000"
               2          IF(medium ~= 0)
               2          [
               3              "Not vacuum. Must sample to see how far to next interaction.
               3
               3              $SELECT-ELECTRON-MFP;
               3                  " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
               3                  "                                       demfp = -log(rnne1);
               3                  "($RANDOMSET is a macro'ed random number generator)
               3                  "(demfp = differential electron mean free path)
               3
               3              elke = log(eke);
               3              "(eke = kinetic energy, rm = rest mass, all in units of MeV)
               3              $SET INTERVAL elke,eke; "Prepare to approximate cross section
               3
               3              $EVALUATE-SIG0;
               3                 "The fix up of the fictitious method uses cross section per"
               3                 "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               3                 "until the next discrete interaction occures (see below)"
               3                 "As this quantity is a single constant for a material,"
               3                 "$SET INTERVAL is not necessary at this point. However, to not"
               3                 "completely alter the logic of the TSTEP and USTEP loops,"
               3                 "this is left for now"
               3
               3          ] "end non-vacuum test
               2
               2          :USTEP:LOOP
               2          [
               3              "Here for each check with user geometry.
               3              "Compute size of maximum acceptable step, which is limited
               3              "by multiple scattering or other approximations.
               3              IF(medium = 0)
               3              [
               4                      "vacuum
               4                      $EMFIELD_INITIATE_SET_TUSTEP;
               4                      tstep = vacdst; ustep = tstep; tustep = ustep;
               4                      callhowfar = .true.; "Always call HOWFAR for vacuum steps!"
               4
               4                      "(Important definitions:
               4                      " tstep  = total pathlength to the next discrete interaction
               4                      " vacdst = infinity (actually 10^8)
               4                      " tustep = total pathlength of the electron step
               4                      " ustep  = projected transport distance in the
               4                      "          direction of motion at the start of the step
               4                      " Note that tustep and ustep are modified below.
               4                      " The above provide defaults.)
               4
               4                      " EM field step size restriction in vacuum
               4                      $SET-TUSTEP-EM-FIELD;
               4                      ustep = tustep;
               4              ]
               3              ELSE
               3              [
               4                  "non-vacuum
               4                  $SET-RHOF;    "density ratio scaling template
               4                                "EGS allows the density to vary
               4                                "continuously (user option)
               4
               4                  $SCALE-SIG0;
               4                  IF(sig <= 0)
               4                  [
               5                      "This can happen if the threshold for brems,
               5                      "(ap + rm), is greater than ae.  Moller threshold is
               5                      "2*ae - rm. If sig is zero, we are below the
               5                      "thresholds for both bremsstrahlung and Moller.
               5                      "In this case we will just lose energy by
               5                      "ionization loss until we go below cut-off. Do not
               5                      "assume range is available, so just ask for step
               5                      "same as vacuum.  Electron transport will reduce
               5                      "into little steps.
               5                      "(Note: ae is the lower threshold for creation of a
               5                      "       secondary Moller electron, ap is the lower
               5                      "       threshold for creation of a brem.)
               5                      tstep = vacdst;
               5                      sig0 = 1.E-15;
               5                  ]
               4                  ELSE
               4                  [
               5                      $CALCULATE-TSTEP-FROM-DEMFP;
               5                  ] "end sig if-else
               4
               4                  "calculate stopping power"
               4                  IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
               4                  ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
               4                  dedx  = rhof*dedx0;
               4
               4                  "Determine maximum step-size (Formerly $SET-TUSTEP)
               4                  $EVALUATE tmxs USING tmxs(elke);
               4                  tmxs = tmxs/rhof;
               4
               4                  "Compute the range to E_min(medium) (e_min is the first
               4                  "energy in the table). Do not go more than range.
               4                  "Don't replace this macro and don't override range, because
               4                  "the energy loss evaluation below relies on the accurate
               4                  "(and self-consistent) evaluation of range!
               4                  $COMPUTE-RANGE;
               4
               4                  "The RANDOMIZE-TUSTEP option as coded by AFB forced the
               4                  "electrons to approach discrete events (Moller,brems etc.)
               4                  "only in a single scattering mode => waste of CPU time.
               4                  "Moved here and changed by IK Oct 22 1997
               4                  random_tustep = $RANDOMIZE-TUSTEP;
               4                  IF(random_tustep)
               4                  [
               5                      $RANDOMSET rnnotu;
               5                      tmxs = rnnotu*min(tmxs,smaxir(irl));
               5                  ]
               4                  ELSE
               4                  [
               5                      tmxs = min(tmxs,smaxir(irl));
               5                  ]
               4                  tustep = min(tstep,tmxs,range);
               4                  $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field
               4
               4                  $CALL-HOWNEAR(tperp);
               4                  dnear(np) = tperp;
               4                  $RANGE-DISCARD;       "optional regional range rejection for"
               4                                        "particles below e_max_rr if i_do_rr set"
               4
               4                  $USER-RANGE-DISCARD;  "default is ;, but user may implement"
               4
               4                  $SET-SKINDEPTH(eke,elke);
               4                    "This macro sets the minimum step size for a condensed"
               4                    "history (CH) step. When the exact BCA is used, the minimum"
               4                    "CH step is determined by efficiency considerations only"
               4                    "At about 3 elastic MFP's single scattering becomes more"
               4                    "efficient than CH and so the algorithm switches off CH"
               4                    "If one of the various inexact BCA's is invoked, this macro"
               4                    "provides a simple way to include more sophisticated"
               4                    "decisions about the maximum acceptable approximated CH step"
               4
               4                  tustep = min(tustep,max(tperp,skindepth));
               4                  $EMFIELD_INITIATE_SET_TUSTEP;
               4                  "The transport logic below is determined by the logical
               4                  "variables callhhowfar, domultiple and dosingle
               4                  "
               4                  "There are the following possibilities:
               4                  "
               4                  "   callhowfar = .false.  This indicates that the
               4                  "   ====================  intended step is shorter than tperp
               4                  "                         independent of BCA used
               4                  "  - domultiple = .false. dosingle = .false. and
               4                  "                         callmsdist = .true.
               4                  "       ==> everything has been done in msdist
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only if exact_bca = .false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only if exact_bca = .true.
               4                  "           sampled distance to a single scattering event is
               4                  "           shorter than tperp ==> do single scattering at the
               4                  "           end of the step
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4                  "
               4                  "   callhowfar = .true. This indicates that the intended step
               4                  "   =================== is longer than tperp and forces a
               4                  "                       call to hawfar which returns the
               4                  "                       straight line distance to the boundary
               4                  "                       in the initial direction of motion
               4                  "                       (via a modification of ustep)
               4                  "  - domultiple = .false. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           simply put the particle on the boundary
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           single elastic scattering has to be done
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4
               4                  "IF(tustep <= tperp & tustep > skindepth)"
               4                  "This statement changed to be consistent with PRESTA-I"
               4                  count_all_steps = count_all_steps + 1;
               4                  is_ch_step = .false.;
               4                  IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
               4                  [
               5                      "We are further way from a boundary than a skindepth, so
               5                      "perform a normal condensed-history step
               5                      callhowfar = .false.; "Do not call HAWFAR
               5                      domultiple = .false.; "Multiple scattering done here
               5                      dosingle   = .false.; "MS => no single scattering
               5                      callmsdist = .true.;  "Remember that msdist has been called
               5
               5                      "Fourth order technique for de
               5                      $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);
               5
               5                      tvstep = tustep; is_ch_step = .true.;
               5
               5                      IF (transport_algorithm = $PRESTA-II)
               5                      [
               6                        call msdist_pII
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                      ELSE
               5                      [
               6                        call msdist_pI
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "We are within a skindepth from a boundary, invoke
               5                      "one of the various boundary-crossing algorithms
               5                      callmsdist = .false.;
               5                           "Remember that msdist has not been called
               5                      IF (exact_bca)
               5                      [
               6                          "Cross the boundary in a single scattering mode
               6                          domultiple = .false.; "Do not do multiple scattering
               6                          "Sample the distance to a single scattering event
               6                          $RANDOMSET rnnoss;
               6                          IF( rnnoss < 1.e-30 ) [
               7                              rnnoss = 1.e-30;
               7                          ]
               6                          lambda = - Log(1 - rnnoss);
               6                          lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
               6                          IF( lambda >= 0 & lambda_max > 0 ) [
               7                              IF( lambda < lambda_max ) [
               8                                  tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
               8                              ]
               7                              ELSE [
               8                                tuss = 0.5 * lambda * ssmfp;
               8                              ]
               7                              IF (tuss < tustep) [
               8                                  tustep = tuss;
               8                                  dosingle = .true.;
               8                              ]
               7                              ELSE [
               8                                  dosingle = .false.;
               8                              ]
               7                          ]
               6                          ELSE [
               7                            $egs_warning(*,' lambda > lambda_max: ',
               7                               lambda,lambda_max,' eke dedx: ',eke,dedx,
               7                               ' ir medium blcc: ',ir(np),medium,blcc(medium),
               7                               ' position = ',x(np),y(np),z(np));
               7                            dosingle = .false.;
               7                            np=np-1; return;
               7                          ]
               6                          ustep = tustep;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Boundary crossing a la EGS4/PRESTA-I but using
               6                          "exact PLC
               6                          dosingle = .false.;
               6                          domultiple = .true.;
               6                          $SET-USTEP;
               6                      ]
               5                      IF(ustep < tperp)
               5                      [
               6                          callhowfar = .false.;
               6                      ]
               5                      ELSE
               5                      [
               6                          callhowfar = .true.;
               6                      ]
               5                  ]
               4              ] "end non-vacuum test
               3
               3              $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
               3                                    "default for $SET-USTEP-EM-FIELD; is ;(null)
               3              irold  = ir(np); "save current region
               3              irnew  = ir(np); "default new region is current region
               3              idisc  = 0; "default is no discard (this flag is initialized here)
               3              ustep0 = ustep; "Save the intended ustep."
               3
               3              "IF(callhowfar) [ call howfar; ]"
               3              $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"
               3
               3              "Now see if user requested discard
               3              IF(idisc > 0) "(idisc is returned by howfar)
               3              [
               4                  "User requested immediate discard
               4                  go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              $CHECK-NEGATIVE-USTEP;
               3
               3              IF(ustep = 0 | medium = 0)
               3              [
               4                  "Do fast step in vacuum
               4                  IF(ustep ~= 0)
               4                  [
               5                      IF $EM_MACROS_ACTIVE
               5                      [
               6                          edep = pzero; "no energy loss in vacuum
               6                          "transport in EMF in vacuum:"
               6                          "only a B or and E field can be active"
               6                          "(not both at the same time)"
               6                          $EMFieldInVacuum;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Step in vacuum
               6                          vstep  = ustep;
               6                          tvstep = vstep;
               6                          "( vstep is ustep truncated (possibly) by howfar
               6                          " tvstep is the total curved path associated with vstep)
               6                          edep = pzero; "no energy loss in vacuum
               6                          $VACUUM-ADD-WORK-EM-FIELD;
               6                              "additional vacuum transport in em field
               6                          e_range = vacdst;
               6                          $AUSCALL($TRANAUSB);
               6                          "Transport the particle
               6                          x(np) = x(np) + u(np)*vstep;
               6                          y(np) = y(np) + v(np)*vstep;
               6                          z(np) = z(np) + w(np)*vstep;
               6                          dnear(np) = dnear(np) - vstep;
               6                              "(dnear is distance to the nearest boundary
               6                              " that goes along with particle stack and
               6                              " which the user's howfar can supply (option)
               6                          $SET-ANGLES-EM-FIELD;
               6                              "default for $SET-ANGLES-EM-FIELD; is ; (null)
               6                               "(allows for EM field deflection
               6                      ] "end of EM_MACROS_ACTIVE block"
               5                  ] "end of vacuum step
               4
               4                  IF(irnew ~= irold) [ $electron_region_change; ];
               4
               4                  IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
               4                  IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               4                  IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
               4                  NEXT :TSTEP: ; "(Start again at :TSTEP:)
               4
               4              ] "Go try another big step in (possibly) new medium
               3
               3              vstep = ustep;
               3              $EM_FIELD_SS;
               3              IF(callhowfar)
               3              [
               4                  IF(exact_bca)
               4                  [
               5                      "If callhowfar=.true. and exact_bca=.true. we are"
               5                      "in a single scattering mode"
               5                      tvstep = vstep;
               5                      IF(tvstep ~= tustep)
               5                      [
               6                         "Boundary was crossed. Shut off single scattering"
               6                          dosingle = .false.;
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "callhowfar=.true. and exact_bca=.false."
               5                      "=>we are doing an approximate CH step"
               5                      "calculate the average curved path-length corresponding"
               5                      "to vstep"
               5                      $SET-TVSTEP;
               5                  ]
               4                  "Fourth order technique for dedx
               4                  "Must be done for an approx. CH step or a
               4                  "single scattering step.
               4                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               4              ]
               3              ELSE
               3              [
               4                 "callhowfar=.false. => step has not been reduced due to
               4                 "                      boundaries
               4                 tvstep = tustep;
               4                 IF ( ~callmsdist )
               4                 [
               5                    "Second order technique for dedx
               5                    "Already done in a normal CH step with call to msdist
               5                    $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               5                 ]
               4              ]
               3
               3              $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
               3                  "( Calculates tvstep given vstep
               3                  " default for $SET-TVSTEP-EM-FIELD; is ; (null)
               3
               3              save_de = de;     "the energy loss is used to calculate the number
               3                                "of MFP gone up to now. If energy loss
               3                                "fluctuations are implemented, de will be
               3                                "changed in $DE-FLUCTUATION; => save
               3
               3              "The following macro template allows the user to change the
               3              "ionization loss.
               3              "(Provides a user hook for Landau/Vavilov processes)
               3              $DE-FLUCTUATION;
               3                  "default for $DE-FLUCTUATION; is ; (null)
               3              edep = de; "energy deposition variable for user
               3              $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
               3              $ADD_WORK_EM_FIELD;  "EEMF implementation"
               3                  "Default for $ADD-WORK-EM-FIELD; is ; (null)
               3              ekef = eke - de;  "(final kinetic energy)
               3              eold = eie;       "save old value
               3              enew = eold - de; "energy at end of transport
               3
               3              "Now do multiple scattering
               3              IF ( ~callmsdist )   "everything done if callmsdist = .true.
               3              [
               4                  IF ( domultiple )
               4                  [
               5                      "Approximated CH step => do multiple scattering
               5                      "
               5                      "ekems, elkems, beta2 have been set in either $SET-TUSTEP
               5                      "or $SET-TVSTEP if spin_effects is .true., they are
               5                      "not needed if spin_effects is .false.
               5                      "
               5                      "chia2,etap,xi,xi_corr are also set in the above macros
               5                      "
               5                      "qel (0 for e-, 1 for e+) and medium are now also required
               5                      "(for the spin rejection loop)
               5                      "
               5                      lambda = blccl*tvstep/beta2/etap/(1+chia2);
               5                      xi = xi/xi_corr;
               5                      findindex = .true.; spin_index = .true.;
               5                      call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
               5                                 spin_effects,findindex,spin_index,
               5                                 costhe,sinthe);
               5                  ]
               4                  ELSE
               4                  [
               5                      IF(dosingle)
               5                      [
               6                         "Single scattering
               6
               6                         ekems = Max(ekef,ecut(irl)-rm);
               6                         p2 = ekems*(ekems + rmt2);
               6                         beta2 = p2/(p2 + rmsq);
               6                         chia2 = xcc(medium)/(4*blcc(medium)*p2);
               6                         IF( spin_effects ) [
               7                           elkems = Log(ekems);
               7                           $SET INTERVAL elkems,eke;
               7                           IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
               7                           ELSE          [$EVALUATE etap USING etap_ms(elkems);]
               7                           chia2 = chia2*etap;
               7                         ]
               6                         call sscat(chia2,elkems,beta2,qel,medium,
               6                                    spin_effects,costhe,sinthe);
               6                      ]
               5                      ELSE
               5                      [
               6                         theta  = 0; "No deflection in single scattering model
               6                         sinthe = 0;
               6                         costhe = 1;
               6                      ]
               5                  ]
               4              ]
               3
               3              "We now know distance and amount of energy loss for this step,
               3              "and the angle by which the electron will be scattered. Hence,
               3              "it is time to call the user and inform him of this transport,
               3              "after which we will do it.
               3
               3              "Now transport, deduct energy loss, and do multiple scatter.
               3              e_range = range;
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3              IF( callmsdist ) [
               4                 "Deflection and scattering have been calculated/sampled in msdist
               4                  u_final = uscat;
               4                  v_final = vscat;
               4                  w_final = wscat;
               4                  x_final = xtrans;
               4                  y_final = ytrans;
               4                  z_final = ztrans;
               4              ]
               3              ELSE
               3              [
               4                  IF ~($EM_MACROS_ACTIVE)
               4                  [
               5                      x_final = x(np) + u(np)*vstep;
               5                      y_final = y(np) + v(np)*vstep;
               5                      z_final = z(np) + w(np)*vstep;
               5                  ]
               4
               4                  IF ( domultiple | dosingle )
               4                  [
               5                      u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
               5                      call uphi(2,1); "Apply the deflection, save call to uphi if
               5                                      "no deflection in a single scattering mode
               5                      u_final = u(np); v_final = v(np); w_final = w(np);
               5                      u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
               5                  ]
               4                  ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
               4              ]
               3
               3              $AUSCALL($TRANAUSB);
               3
               3              "Transport the particle
               3
               3              x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3              u(np) = u_final; v(np) = v_final; w(np) = w_final;
               3
               3              dnear(np) = dnear(np) - vstep;
               3              irold = ir(np); "save previous region
               3              $SET-ANGLES-EM-FIELD;
               3              "Default for $SET-ANGLES-EM-FIELD; is ; (null)
               3
               3
               3              "Now done with multiple scattering,
               3              "update energy and see if below cut
               3              "below subtracts only energy deposited"
               3              peie  = peie - edep;
               3              "below subtracts energy deposited + work due to E field"
               3              "peie = peie - de;"
               3              eie   = peie;
               3              e(np) = peie;
               3
               3              "IF( irnew ~= irl & eie <= ecut(irl)) [
               3              "IK: the above is clearly a bug. If the particle energy falls "
               3              "    below ecut, but the particle is actually entering a new "
               3              "    region, the discard will happen in the current region "
               3              "    instead the next. If the particle is a positron, all "
               3              "    resulting annihilation photons will have the new position "
               3              "    but the old region => confusion in the geometry routine "
               3              "    is very likely.      Jan 27 2004 "
               3              IF( irnew = irl & eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              medold = medium;
               3              IF(medium ~= 0)
               3              [
               4                  ekeold = eke; eke = eie - rm; "update kinetic energy
               4                  elke   = log(eke);
               4                  $SET INTERVAL elke,eke; "Get updated interval
               4              ]
               3
               3              IF(irnew ~= irold) [ $electron_region_change; ]
               3
               3              "After transport call to user scoring routine
               3              $AUSCALL($TRANAUSA);
               3
               3              IF(eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              "Now check for deferred discard request.  May have been set
               3              "by either howfar, or one of the transport ausgab calls
               3              IF(idisc < 0) [
               4                go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              IF(medium ~= medold) NEXT :TSTEP:;
               3
               3              $USER_CONTROLS_TSTEP_RECURSION;
               3                  "NRCC update 87/12/08--default is null
               3
               3              $UPDATE-DEMFP;
               3
               3          ] UNTIL(demfp < $EPSEMFP); "end ustep loop
               2
               2          "Compute final sigma to see if resample is needed.
               2          "this will take the energy variation of the sigma into
               2          "account using the fictitious sigma method.
               2
               2          $EVALUATE-SIGF;
               2
               2          sigratio = sigf/sig0;
               2
               2          $RANDOMSET rfict;
               2
               2      ] UNTIL (rfict <= sigratio) ; "end tstep loop
               1
               1      " Now sample electron interaction
               1
               1      IF(lelec < 0)
               1      [
               2          "e-,check branching ratio
               2          $EVALUATE-EBREM-FRACTION;
               2            "Default is $EVALUATE ebr1 USING ebr1(elke);"
               2          $RANDOMSET rnno24;
               2          IF(rnno24 <= ebr1)
               2          [
               3              "It was bremsstrahlung
               3              go to :EBREMS:;
               3          ]
               2          ELSE
               2          [
               3              "It was Moller, but first check the kinematics.
               3              "However, if EII is on, we should still permit an interaction
               3              "even if E<moller threshold as EII interactions go down to
               3              "the ionization threshold which may be less than thmoll.
               3              IF(e(np) <= thmoll(medium) & eii_flag = 0)
               3                   "(thmoll = lower Moller threshold)
               3              [
               4                  "Not enough energy for Moller, so
               4                  "force it to be a bremsstrahlung---provided ok kinematically.
               4                  IF(ebr1 <= 0) [go to :NEWELECTRON:;]
               4                      "Brems not allowed either.
               4                  go to :EBREMS:;
               4              ]
               3              $AUSCALL($MOLLAUSB);
               3              call moller;
               3              "The following macro template allows the user to change the
               3              "particle selection scheme (e.g., adding importance sampling
               3              "such as splitting, leading particle selection, etc.).
               3              "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
               3              "which in turn has the 'null' replacement ';')
               3              $PARTICLE-SELECTION-MOLLER;
               3              $AUSCALL($MOLLAUSA);
               3              IF( iq(np) = 0 ) return;
               3          ]
               2
               2          go to :NEWELECTRON:; "Electron is lowest energy-follow it
               2      ]
               1
               1      "e+ interaction. pbr1 = brems/(brems + bhabha + annih
               1      $EVALUATE-PBREM-FRACTION;
               1         "Default is $EVALUATE pbr1 USING pbr1(elke);"
               1      $RANDOMSET rnno25;
               1      IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
               1      "Decide between bhabha and annihilation
               1      "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
               1      $EVALUATE-BHABHA-FRACTION;
               1         "Default is $EVALUATE pbr2 USING pbr2(elke);"
               1      IF(rnno25 < pbr2)
               1      [
               2          "It is bhabha
               2          $AUSCALL($BHABAUSB);
               2          call bhabha;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-BHABHA;
               2          $AUSCALL($BHABAUSA);
               2          IF( iq(np) = 0 ) return;
               2      ]
               1      ELSE
               1      [
               2          "It is in-flight annihilation
               2          $AUSCALL($ANNIHFAUSB);
               2          call annih;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-ANNIH;
               2          $AUSCALL($ANNIHFAUSA);
               2          EXIT :NEWELECTRON:; "i.e., in order to return to shower
               2          "After annihilation the gammas are bound to be the lowest energy
               2          "particles, so return and follow them.
               2      ] "end pbr2 else
               1
               1  ] REPEAT "newelectron
               0
               0  return; "i.e., return to shower
               0
               0
               0  "---------------------------------------------
               0  "Bremsstrahlung-call section
               0  "---------------------------------------------
               0  :EBREMS:
               0  $AUSCALL($BREMAUSB);
               0  call brems;
               0  "The following macro template allows the user to change the particle
               0  "selection scheme (e.g., adding importance sampling such as splitting,
               0  "leading particle selection, etc.).  (default macro is template
               0  "'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
               0  $PARTICLE-SELECTION-BREMS;
               0  $AUSCALL($BREMAUSA);
               0  IF(iq(np) = 0)
               0  [
               1      "Photon was selected.
               1      return;
               1      "i.e., return to shower
               1  ]
               0  ELSE
               0  [
               1      "Electron was selected
               1      go to :NEWELECTRON:;
               1  ]
               0
               0  "---------------------------------------------
               0  "Electron cutoff energy discard section
               0  "---------------------------------------------
               0  :ECUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(eie > ae(medium)) [
               2          idr = $EGSCUTAUS;
               2          IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
               2      ]
               1      ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
               1  ] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]
               0
               0
               0  $ELECTRON-TRACK-END; "The default replacement for this macros is "
               0                       "          $AUSCALL(idr);                   "
               0                       "Use this macro if you wish to modify the   "
               0                       "treatment of track ends                    "
               0
               0  :POSITRON-ANNIHILATION:; "NRCC extension 86/9/12
               0
               0  IF(lelec > 0) [
               1      "It's a positron. Produce annihilation gammas if edep < peie
               1      IF(edep < peie) [
               2          $AUSCALL($ANNIHRAUSB);
               2          call annih_at_rest;
               2          $PARTICLE-SELECTION-ANNIHREST;
               2          $AUSCALL($ANNIHRAUSA);
               2          "Now discard the positron and take normal return to follow
               2          "the annihilation gammas.
               2          return; "i.e., return to shower
               2      ]
               1  ] "end of positron block
               0
               0  np = np - 1;
               0  ircode = 2; "tell shower an e- or un-annihilated
               0              "e+ has been discarded
               0
               0  return; "i.e., return to shower"
               0
               0  "---------------------------------------------
               0  "User requested electron discard section
               0  "---------------------------------------------
               0  :USER-ELECTRON-DISCARD:
               0
               0  idisc = abs(idisc);
               0
               0  IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
               0  ELSE                          [edep = e(np) + prm;]
               0
               0  $AUSCALL($USERDAUS);
               0
               0  IF(idisc = 99) goto :POSITRON-ANNIHILATION:;
               0
               0  np = np - 1; ircode = 2;
               0
               0  return; "i.e., return to shower
               0  end;    "End of subroutine electr
               0  "*******************************************************************************
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE HATCH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Setup which the user is expected to do before calling HATCH is:"
               0  "     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
               0  "     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
               0  "        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
               0  "        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
               0  "        THE IM'TH MEDIUM IN A1 FORMAT."
               0  "     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
               0  "        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
               0  "        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
               0  "        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
               0  "     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
               0  "        REGIONS."
               0  "     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
               0  "        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
               0  "        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
               0  "        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
               0  "     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
               0  "        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
               0  "     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
               0  "        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
               0  "
               0  "   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
               0  "   The echo to unit 8 has been removed since it is sent"
               0  "                                          to /dev/null anyway!"
               0  "           To put it back search $UOUTPUT  and $ECHO and uncomment"
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  character*512 toUpper;
               0  $COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
               0                        "ELECIN,MEDIA,MISC,PHOTIN,STACK,
               0                        "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;
               0
               0  $DECLARE-PEGS4-COMMON-BLOCKS;
               0
               0  $DEFINE-LOCAL-VARIABLES-HATCH;
               0
               0  character*256 tmp_string;
               0  $INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
               0                        " support this"
               0
               0  DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
               0  DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;
               0
               0  $INIT-PEGS4-VARIABLES;
               0
               0  "   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
               0  :INT:FORMAT(1X,14I5);
               0  :FLT:FORMAT(1X,1PE14.5,4E14.5);
               0  :BYTE:FORMAT(72A1);
               0
               0  IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
               1  "   DO FIRST TIME INITIALIZATION"
               1
               1  $HATCH-USER-INPUT-INIT;
               1
               1  "   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
               1  "   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
               1  "   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
               1  "   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
               1  "   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
               1  "   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
               1  "   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
               1  "   FOR GOOD MEASURE."
               1  NISUB=MXSINC-2;FNSSS=NSINSS;
               1  WID=PI5D2/FLOAT(NISUB);
               1  WSS=WID/(FNSSS-1.0);
               1  ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;
               1
               1  DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
               2  SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"
               2
               2  XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
               2  "   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
               2  IZ=0; DO IZZ=1,3 [
               3  IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
               3  ] "END OF LOOP OVER ZEROS"
               2  IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
               2  DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
               3  XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
               3  YS=SIN(XS+XSI); "SINE OF ANGLE"
               3  SX=SX+XS; "ACCUMULATE SUMS"
               3  SY=SY+YS;
               3  SXX=SXX+XS*XS;
               3  SXY=SXY+XS*YS;
               3  ] "END SUB-SUBINTERVAL LOOP"
               2
               2  "   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
               2  IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
               3  "             FOR SMALL REL.ERR.&GOOD"
               3  "   VALUES OF SINTHE/THETA NEAR ZERO"
               3  SIN1(ISUB)=SXY/SXX;
               3  SIN0(ISUB)=-SIN1(ISUB)*XSI;]
               2  ELSE["DO FULL LEAST SQUARES"
               3  DEL=FNSSS*SXX-SX*SX;
               3  SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
               3  SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
               2  ] "END SUB-INTERVAL LOOP"
               1
               1  SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
               1  SINC1=1.0/WID;
               1
               1  "   NOW TEST FIT, IF REQUESTED"
               1  IF (ISTEST.NE.0)[
               2  "   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
               2  "   END SUBINTERVALS"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
               4  THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
               4  CTHET=PI5D2-THETA;
               4  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               4  $EVALUATE SINTHE USING SIN(THETA);
               4  $EVALUATE COSTHE USING SIN(CTHET);
               4  SINT=SIN(THETA); COST=COS(THETA);
               4  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               4  ADEV=max(ADEV,ASD,ACD);
               4  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               4  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               4  S2C2=SINTHE**2+COSTHE**2;
               4  S2C2MN=min(S2C2MN,S2C2);
               4  S2C2MX=max(S2C2MX,S2C2);
               4  IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
               4  ] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
               2  $egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
               2  $egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                   ADEV,RDEV,S2C2MN,S2C2MX);
               2  "   NOW DO RANDOM TEST"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
               3  CTHET=PI5D2-THETA;
               3  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               3  $EVALUATE SINTHE USING SIN(THETA);
               3  $EVALUATE COSTHE USING SIN(CTHET);
               3  SINT=SIN(THETA); COST=COS(THETA);
               3  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               3  ADEV=max(ADEV,ASD,ACD);
               3  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               3  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               3  S2C2=SINTHE**2+COSTHE**2;
               3  S2C2MN=min(S2C2MN,S2C2);
               3  S2C2MX=max(S2C2MX,S2C2);
               3  ] "END RANDOM ANGLE LOOP"
               2  $egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
               2  $egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                 ADEV,RDEV,S2C2MN,S2C2MX);
               2  ] "END OF SINE TABLE TEST"
               1
               1  "   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
               1  P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]
               1
               1  ] "END OF FIRST TIME INITIALIZATION"
               0
               0  "FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
               0  $need_rayleigh_data;
               0
               0  "Ali:photonuc, 2 lines"
               0  "FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
               0  $need_photonuc_data;
               0  $egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);
               0
               0  "   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
               0  IF(~is_pegsless) REWIND KMPI;
               0  "explicit file name for HP compiler  Nov 23, 1996   DR"
               0  IUECHO=KMPO;
               0  NM=0; "NUMBER OF MEDIA FOUND"
               0  DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
               1    "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
               1    IF(IRAYLM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  "Ali:photonuc, 1 block"
               0  DO IM=1,NMED [
               1    "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
               1    IF(IPHOTONUCM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  IF(~is_pegsless)[
               1  :MEDIUM:
               1  LOOP["MEDIUM SEARCH LOOP"
               2
               2  :MDLOOK:
               2  LOOP["MEDIUM HEADER SEARCH LOOP"
               3    "   FIRST LOOK FOR MEDIUM HEADER"
               3    READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
               3    DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
               3    "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
               3    :MDNAME:
               3    DO IM=1,NMED [
               4      DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
               5      IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
               4    ] "END :MDNAME: DO"
               3    "   NOT IN NAME TABLE, SO IGNORE IT"
               3  ]REPEAT "MDLOOK"
               2
               2  "   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
               2  IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
               2  LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"
               2
               2  "   NOW READY TO READ IN DATA FOR THIS MEDIUM"
               2  "$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"
               2
               2  "   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
               2  "THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  "The next two lines were line prior to Dec 89 mods to get IUNRST"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,5X,F11.0,4X,I2);"
               2  "following used to pick up IUNRST, IAPRIM and EPSTFL"
               2  "Problem is that GASP may or may not be printed, so we make"
               2  "a kludge which will work with all old data files"
               2  "FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
               2  "Note that this reading scheme counts on there being an"
               2  "error when GASP does exist on the line--an error does"
               2  "occur on most compilers, however, we have found that on"
               2  "the rs6000 an error does not occur.  Instead, a warning"
               2  "is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
               2  "This will make no difference in simulations but will cause"
               2  "a problem when running EXAMIN"
               2
               2  " IK: backspace(kmpi) fails under windows using g77 with I/O error"
               2  "     therefore we read the line in a temporary string and then "
               2  "     use memoty I/O to try to read with and without gasp there. "
               2
               2  read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
               2  goto :no_hatch_read_error1:;
               2  :hatch_read_error1:
               2  $egs_fatal(*,'Error while reading pegs4 file');
               2
               2  :no_hatch_read_error1:;
               2  read(tmp_string,1,ERR=:GASP-THERE:)
               2  "READ(KMPI,1,ERR=:GASP-THERE:)"
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
               2  1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
               2  "IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
               2  GO TO :GASP-NOT-THERE:;
               2
               2  :GASP-THERE:;
               2  "WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
               2  "BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
               2  "READ(KMPI,2)"
               2
               2  "The following output is only there because without it"
               2  "code compiled with the new gfortran GNU compiler "
               2  "fails with run time error. Another bug in their "
               2  "pre-alpha quality I/O system ----IK, Oct 26 2005 "
               2  "write(6,*) 'Found medium with gas pressure';"
               2  $egs_info(*,'Found medium with gas pressure');
               2  read(tmp_string,2)
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
               2  IAPRIM(IM);
               2  2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);
               2
               2  :GASP-NOT-THERE:
               2
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  ";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "DO IE=1,NE["
               2  DO IE=1,NNE(IM)[
               3      "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
               3      "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
               3      "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
               3      "IN COMMON BREMPR. AFB 88/05/31.                                  "
               3      "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
               3      $UINPUT(KMPI)
               3      (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
               3      ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
               3      (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
               3      "$UOUTPUT(KMPO)"
               3      "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
               3      "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
               3      "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
               3      ]
               2
               2  "   MEDIA AND THRESH"
               2  "$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
               2  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
               2
               2  "   ACTUAL ARRAY SIZES FROM PEGS"
               2  "$ECHO" READ(KMPI,:INT:)
               2  $LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
               2  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
               2  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
               2
               2  "   BREMPR"
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
               2  "$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
               2     DELPOS(I,IM)),I=1,2);
               2
               2  "   ELECIN"
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)
               2  ($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
               2     TMXS(I,IM)/0,1/),I=1,NEKE);
               2
               2  "   PHOTIN"
               2  "$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);
               2
               2  "   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"
               2
               2
               2  IF (IRAYL.EQ.1) [
               3  "$ECHO" READ(KMPI,:INT:) NGR(IM);
               3  NGRIM=NGR(IM);
               3  "$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
               3   "IF(IRAYLM(IM).NE.1) ["
               3   $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
               3            IM, ' in PEGS4 data set.');
               3   "]"
               3  ]
               2
               2
               2
               2
               2
               2  IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
               3    IF(IRAYL.NE.1) ["No data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["Rayleigh not possible"
               5       $egs_fatal('(a,i3 /,a /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
               5       ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
               5      ]
               4      ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
               5       $egs_warning('(a,i3 /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
               5      ]
               4    ]
               3   ELSE["Rayleigh data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["PEGS4 data selected"
               5        "***********************************************************"
               5        "Preparing data for new Rayleigh angular sampling when using"
               5        "the pegs4 data set,                                        "
               5        "***********************************************************"
               5         call egs_init_rayleigh_sampling(IM);
               5      ]
               4      "ELSE[Taking photon data from either si,epdl,xcom or user]"
               4    ]
               3  ]
               2
               2
               2  "   THAT'S ALL FOR THIS MEDIUM"
               2  ]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"
               1
               1  CLOSE (UNIT=KMPI);
               1
               1  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
               1  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
               1  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
               1  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
               1  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
               1  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
               1  DUNITR=DUNIT; "SAVE REQUESTED"
               1  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
               2     DUNIT=RLC(ID);]
               1  IF(DUNIT.NE.1.0) [
               2  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
               2           DUNITR,DUNIT,'(CM.)' );
               2  ]
               1  DO IM=1,NMED [
               2  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
               2  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
               2
               2  FOR I=1 TO MEKE(IM) [
               3  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
               3  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
               2  $SCALE TEFF0(IM) BY DFACT;
               2  $SCALE BLCC(IM) BY DFACTI;
               2  $SCALE XCC(IM) BY SQRT(DFACTI);
               2  RLDU(IM)=RLC(IM)/DUNIT;
               2  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
               2  ] "END IM DO"
               1
               1  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
               1  VACDST=VACDST*DUNITO/DUNIT;
               1  DUNITO=DUNIT; "SAVE OLD DUNIT"
               1
               1  ]"end regular pegs4 intake"
               0  ELSE["pegsless intake of medium data"
               1
               1  $egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');
               1
               1  $GET-PEGSLESS-XSECTIONS;
               1
               1  ]
               0
               0  "   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
               0  "   ALSO SET DEFAULT DENSITIES"
               0  $adjust_rhor_ecut_pcut;
               0
               0  "BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 88/05/31"
               0  $INITIALIZE-BREMS-ANGLE;
               0
               0  "PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 91/05/29"
               0  $INITIALIZE-PAIR-ANGLE;
               0
               0  " See if user has requested PEGS4 photon cross section data "
               0  IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
               1    $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
               1    'However, the new Rayleigh angular sampling will be used.',
               1    'The original EGS4 angular sampling undersamples large scattering ',
               1    'angles. This may have little impact as Rayleigh scattering ',
               1    'is forward peaked.',
               1    '*********************************************************');
               1
               1  ]
               0  ELSE["re-calculates photon xsections using available or user data"
               1  "Ali:photonuc, 2 lines"
               1      call egs_init_user_photon(photon_xsections,comp_xsections,
               1      photonuc_xsections,xsec_out);
               1  "    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
               1  ]
               0
               0  call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"
               0
               0  "Calling order of the subroutines below is important when using"
               0  "detailed atomic relaxation in order to use the binding energies"
               0  "corresponding to the requested photon cross section library"
               0  IF ( eadl_relax & photon_xsections = 'xcom' )[
               1     call init_compton; "Initialize bound Compton scattering"
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
               1  ]
               0  ELSE[
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
               1                        "if requested
               1     call init_compton; "Initialize bound compton scattering, IK, Jan 99"
               1                        "if requested
               1  ]
               0
               0  IF( xsec_out = 1 & eadl_relax) [
               1    call egs_print_binding_energies;
               1  ]
               0
               0  call fix_brems;    "Re-calculate dl1,... for the different technique"
               0                     "employed in BREMS. Note that the old EGS sampling"
               0                     "technique for BREMS had a bug that shows up only"
               0                     "if AP is not much smaller than electron kinetic energy"
               0
               0  IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
               0                     "initializes the sampling tables and modifies the total"
               0                     "brems cross sections if the NIST brems data base is to"
               0                     "be used                                               "
               0
               0  IF( pair_nrc = 1 ) [ call init_nrc_pair; ]
               0
               0  " Load and initialize EII data if needed. "
               0  call eii_init;
               0
               0  " Load and initialize the triplet data if needed "
               0  call init_triplet;
               0
               0  "   SETUP IS NOW COMPLETE"
               0  IF (NMED.EQ.1)[
               1     $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
               1  ]
               0  ELSE[
               1     $egs_info('(a,i5,a)',
               1               'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
               1  ]
               0
               0  RETURN;
               0
               0  :MDNOMORE:
               0  $egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
               0    ' PROGRAM STOPPED IN HATCH BECAUSE THE',
               0    ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
               0  DO IM=1,NMED [
               1     IF(LOK(IM).NE.1) [
               2        $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
               2     ]
               1  ]
               0  STOP;
               0  "END OF SUBROUTINE HATCH"   END;
               0
               0  subroutine fix_brems;
               0  "******************************************************************"
               0  "
               0  " Calculates the parameter for the rejection function used in
               0  " the current implementation of bremsstrahlung sampling
               0  "
               0  " I Kawrakow, January 2000
               0  "
               0  "*******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;
               0
               0  $INTEGER medium,i;
               0  $REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
               0           XSIF,FCOULC;
               0
               0  DO medium = 1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      Zt = 0; Zb = 0; Zf = 0;
               1      DO i=1, NNE(medium) [
               2          Zi = ZELEM(medium,i); pi = PZ(medium,i);
               2          fc = FCOULC(Zi); xi = XSIF(Zi);
               2          aux = pi*Zi*(Zi + xi);
               2          Zt = Zt + aux;
               2          Zb = Zb - aux*Log(Zi)/3;
               2          Zf = Zf + aux*fc;
               2      ]
               1      Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
               1      fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
               1      fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;
               1
               1      "These are used in BREMS"
               1      dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
               1      dl2(1,medium) = -3.242/fmax1;
               1      dl3(1,medium) = 0.625/fmax1;
               1      dl4(1,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(1,medium) = -4.184/fmax1;
               1      dl6(1,medium) = 0.952;
               1      dl1(2,medium) = (20.029+4*Zg)/fmax1;
               1      dl2(2,medium) = -1.93/fmax1;
               1      dl3(2,medium) = -0.086/fmax1;
               1      dl4(2,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(2,medium) = -4.184/fmax1;
               1      dl6(2,medium) = 0.952;
               1      dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
               1      dl2(3,medium) = -3.242/fmax2;
               1      dl3(3,medium) = 0.625/fmax2;
               1      dl4(3,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(3,medium) = -4.184/fmax2;
               1      dl6(3,medium) = 0.952;
               1      dl1(4,medium) = (20.029+4*Zv)/fmax2;
               1      dl2(4,medium) = -1.93/fmax2;
               1      dl3(4,medium) = -0.086/fmax2;
               1      dl4(4,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(4,medium) = -4.184/fmax2;
               1      dl6(4,medium) = 0.952;
               1
               1      "and these in PAIR"
               1      dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
               1      dl2(5,medium) = (3*(-3.242) - (-1.930));
               1      dl3(5,medium) = (3*(0.625)-(-0.086));
               1      dl4(5,medium) = (2*21.12+8*Zg);
               1      dl5(5,medium) = (2*(-4.184));
               1      dl6(5,medium) = 0.952;
               1      dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
               1      dl2(6,medium) = (3*(-3.242) + (-1.930));
               1      dl3(6,medium) = (3*0.625+(-0.086));
               1      dl4(6,medium) = (4*21.12+16*Zg);
               1      dl5(6,medium) = (4*(-4.184));
               1      dl6(6,medium) = 0.952;
               1      dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
               1      dl2(7,medium) = (3*(-3.242) - (-1.930));
               1      dl3(7,medium) = (3*(0.625)-(-0.086));
               1      dl4(7,medium) = (2*21.12+8*Zv);
               1      dl5(7,medium) = (2*(-4.184));
               1      dl6(7,medium) = 0.952;
               1      dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
               1      dl2(8,medium) = (3*(-3.242) + (-1.930));
               1      dl3(8,medium) = (3*0.625+(-0.086));
               1      dl4(8,medium) = (4*21.12+16*Zv);
               1      dl5(8,medium) = (4*(-4.184));
               1      dl6(8,medium) = 0.952;
               1
               1      bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1      bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1
               1  ]
               0  return;
               0  end;
               0
               0
               0  $REAL function FCOULC(Z);
               0  "************************"
               0  $IMPLICIT-NONE;
               0  $REAL Z;
               0  $REAL fine,asq;
               0  data fine/137.03604/;
               0  asq = Z/fine; asq = asq*asq;
               0  FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
               0  return;
               0  end;
               0
               0  $REAL function XSIF(Z);
               0  "**********************"
               0  $IMPLICIT-NONE;
               0  $REAL    Z;
               0  $INTEGER iZ;
               0  $REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
               0  data     alrad/5.31,4.79,4.74,4.71/;
               0  data     alradp/6.144,5.621,5.805,5.924/;
               0  data     a1440/1194.0/,A183/184.15/;
               0  IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
               0  ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  subroutine init_compton;
               0  "
               0  "  Reads in bound Compton scattering data from unit $INCOHUNIT
               0  "  and performs necessary initializations
               0  "
               0  "  See definitions of variables in egsnrc.macros with definition
               0  "  of COMIN/COMPTON-DATA/
               0  "
               0  "  I.Kawrakow, January 99
               0  "******************************************************************"
               0
               0  implicit none;
               0
               0  $COMIN-INIT-COMPT;
               0
               0  $INTEGER i,j,iz,nsh,j_l,j_h;
               0  $REAL    aux,pztot,atav;
               0  $REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
               0                          "compiler don't have an intrinsic error function"
               0  $LOGICAL getd;
               0
               0  " Initialize radiative Compton corrections, if needed "
               0  $RADC_HATCH;
               0
               0  $need_bound_compton_data(getd);
               0  IF( ~getd ) [
               1      IF( eadl_relax & photon_xsections = 'xcom' )[
               2          $egs_fatal('(a,/a,/a)',
               2                     'You must turn ON Compton binding corrections when using',
               2                     'a detailed atomic relaxation (eadl_relax=true) since ',
               2                     'binding energies taken from incoh.data below 1 keV!');
               2      ]
               1      $egs_info('(a/)',' Bound Compton scattering not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
               0  rewind($INCOHUNIT);
               0  DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
               0  iz = 0;
               0  DO j=1,$MXTOTSH [
               1      read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
               1                         Jo_array(j),be_array(j);
               1      Jo_array(j) = Jo_array(j)*137.;
               1      be_array(j) = be_array(j)*1e-6/PRM;
               1      aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
               1      erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
               1                      "0.82436063535 is exp(0.5)/2"
               1
               1      "For detailed atomic relaxations set shell type
               1      "to actual shell number and update binding energies
               1      "with values from the photo-electric cross sections
               1      IF (eadl_relax)[
               2         IF (iz_array(j) ~= iz)[
               3            shn_array(j) = 1; iz = iz_array(j);
               3         ]
               2         ELSE[
               3            shn_array(j) = shn_array(j-1)+1;
               3         ]
               2         IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
               3           be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
               3         ]
               2         ELSE IF(photon_xsections = 'xcom') [
               3           "Use binding energies from incoh.data below 1 keV"
               3           binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
               3         ]
               2      ]
               1
               1  ]
               0  $egs_info(*,' Done');
               0  $egs_info('(/a)',' Initializing Bound Compton scattering ......');
               0  DO medium = 1,nmed [
               1      pztot = 0; nsh = 0;
               1      DO i = 1, nne(medium) [
               2          iz = int(zelem(medium,i));
               2          DO j = 1, $MXTOTSH [
               3              IF( iz = iz_array(j) ) [
               4                  nsh = nsh + 1;
               4                  IF( nsh > $MXMDSH ) [
               5                      $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
               5                                ' the number of shells is > ',$MXMDSH,'!',
               5                                ' Increase the parameter $MXMDSH! ');
               5                  ]
               4                  shell_array(nsh,medium) = j;
               4                  aux = pz(medium,i)*ne_array(j);
               4                  eno_array(nsh,medium) = aux;
               4                  pztot = pztot + aux;
               4              ]
               3          ]
               2      ]
               1      IF( nsh = 0 ) [
               2          $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
               2      ]
               1      n_shell(medium) = nsh;
               1      $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
               1      DO i=1,nsh [
               2          j = shell_array(i,medium);
               2          eno_array(i,medium) = eno_array(i,medium)/pztot;
               2          $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
               2                    i,j,shn_array(j),eno_array(i,medium),
               2                    Jo_array(j),be_array(j)*PRM*1000.);
               2          eno_array(i,medium) = -eno_array(i,medium);
               2          eno_atbin_array(i,medium) = i;
               2      ]
               1      atav = 1./nsh;
               1      DO i=1,nsh-1 [
               2          DO j_h = 1,nsh-1 [
               3              IF( eno_array(j_h,medium) < 0 ) [
               4                  IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
               4              ]
               3          ]
               2          DO j_l = 1,nsh-1 [
               3              IF( eno_array(j_l,medium) < 0 ) [
               4                  IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
               4              ]
               3          ]
               2          aux = atav - abs(eno_array(j_l,medium));
               2          eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
               2          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
               2          eno_atbin_array(j_l,medium) = j_h;
               2          IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
               2      ]
               1      DO i=1,nsh [
               2          IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
               2      ]
               1  ]
               0
               0  $egs_info('(a/)',' ...... Done.');
               0
               0  $need_relaxation_data(getd);
               0  IF( getd ) return;
               0  $egs_fatal('(/a,/a,/a,/a)',
               0  ' In subroutine init_compton: ',
               0  '   Scattering off bound electrons creates atomic vacancies,',
               0  '   potentially starting an atomic relaxation cascade. ',
               0  '   Please turn ON atomic relaxations.');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE MOLLER;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
               0  "   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
               0  "   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
               0  "   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
               0  "   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
               0  "   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
               0  "   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
               0  "   LOSS DURING TRANSPORT.                                         "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
               0                                            "UPHIOT,USEFUL,RANDOM/;"
               0  ;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;
               0
               0  $DEFINE-LOCAL-VARIABLES-MOLLER;
               0
               0  $REAL sigm,pbrem,rsh,Uj,sig_j;
               0  $INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;
               0
               0  "IRCODE=1;  appears to be unused, IK Oct 97"
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
               0  EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
               0  PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
               0  EKIN=PEKIN;
               0
               0  IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
               1      "The EII flag is set and this medium has shells for which we want to"
               1      "simulate EII => sample if the interaction is with a EII shell"
               1      $SET INTERVAL elke,eke;
               1      $EVALUATE sigm USING esig(elke);
               1      $EVALUATE pbrem USING ebr1(elke);
               1      sigm = sigm*(1 - pbrem);
               1      $RANDOMSET rsh; rsh = sigm*rsh;
               1      DO iele=1,nne(medium) [
               2          iZ = int(zelem(medium,iele)+0.5);
               2          nsh = eii_no(medium,iele);
               2          IF( nsh > 0 ) [
               3              ifirst = eii_first(medium,iele);
               3              DO ish = 1,nsh [
               4                  Uj = binding_energies(ish,iZ);
               4                  IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
               5                      jj = ifirst + ish - 1;
               5                      i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
               5                      sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
               5                      sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
               5                      rsh = rsh - sig_j;
               5                      IF( rsh < 0 ) [
               6                          $AUSCALL($EIIB);
               6                          call eii_sample(ish,iZ,Uj);
               6                          $AUSCALL($EIIA);
               6                          return;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1  ]
               0  IF( ekin <= 2*te(medium) ) return;
               0  T0=EKIN/RM;
               0  E0=T0+1.0;
               0  EXTRAE = EIE - THMOLL(MEDIUM);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  "G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  G2=T0*T0/E02;
               0  G3=(2.*T0+1.)/E02;
               0  "   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
               0  "   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
               0  "   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
               0  "   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
               0  "   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
               0  "   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
               0  "   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
               0  "   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "
               0
               0  "   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
               0  "   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
               0  "   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
               0  "   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
               0  "   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "
               0
               0  GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
               0  LOOP[" TO RETRY IF REJECTED"
               1  $RANDOMSET RNNO27;
               1  BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);
               1
               1  "   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
               1  R=BR/(1.-BR);
               1  $RANDOMSET RNNO28;
               1  REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
               1  RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
               1  ]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"
               0
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
               0  PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
               0  PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
               0  ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
               0  ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
               0  E(NP)=PESE1;
               0  $CHECK-STACK(np+1,'MOLLER');
               0  E(NP+1)=PESE2;
               0  "   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
               0  "   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "
               0
               0  " One possible way of dealing with double counting of angular      "
               0  " deflections in inelastic scattering would be to                  "
               0  " not deflect the 'old' electron as these deflections are          "
               0  " already taken into account in the multiple elastic scattering    "
               0  " This approach has the disadvantage of loosing correlations       "
               0  " between big energy losses and strong angular deflections         "
               0  " The advantage of such an approach is its simplicity.             "
               0  " If spin effects for multiple elastic scattering are turned on,   "
               0  " the double counting is taken into account by the appropriate     "
               0  " modification of the scattering power (which depends on AE)       "
               0  "                                                                  "
               0  "                                                                  "
               0  " IK, June 1999                                                    "
               0
               0  H1=(PEIE+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
               0  DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0
               0  "sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"
               0
               0  CALL UPHI(2,1);
               0
               0  "   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
               0  NP=NP+1;
               0  IQ(NP)=-1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE MOLLER"  END;
               0
1              0  %E
               0
               0  subroutine mscati;
               0  "**********************************************************************"
               0
               0  " Subroutine to read the pre-calculated q^(2+)-surface, prepare data
               0  " required by the mscat and msdist subroutines, initialize spin effect
               0  " corrections
               0  "
               0  " I.Kawrakow, NRC
               0  "**********************************************************************"
               0
               0  implicit none;
               0
               0  $REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
               0  $REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
               0  $INTEGER
               0      i,leil,leip1l,neke,lelke,lelkef,lelktmp;
               0  $LOGICAL  ise_monoton, isp_monoton;
               0
               0  $declare_write_buffer;
               0
               0  "cross section per energy loss"
               0  $REAL sigee,sigep,sig,sige_old,sigp_old;
               0
               0  "entry mscat variables
               0  "======================
               0
               0  $COMIN-MSCATI;
               0
               0  " moved the following from prestaII_inputs, "
               0  " if transport_algorithm = presta-I, exact_bca = .false. and
               0  " skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"
               0
               0  IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               0  ELSE                    [ exact_bca = .false.; ]
               0  IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
               0  IF( ximax <= 0  | ximax >= 1 ) [
               1      IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
               1      ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
               1  ]
               0  IF (transport_algorithm ~= $PRESTA-II &
               0      transport_algorithm ~= $PRESTA--I &
               0      transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
               0  IF( skindepth_for_bca <= 1e-4 ) [
               1      "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
               1      IF( ~exact_bca ) [
               2          $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
               2          $set_ecutmn;
               2          $egs_info(*,'     minimum ECUT found: ',ecutmn);
               2          tstbmn = 1e30;
               2          DO medium = 1,nmed [
               3              tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
               3              tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
               3              aux = Log(tstbm);
               3              IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
               3              tstbm = Log(tstbm/aux);
               3              "Changed the following to the above so that the Intel compiler"
               3              " does not vectorize the loop with -xK. Vectorizing this loop"
               3              " on an Athlon CPU results in segmentation fault."
               3              " IK, Jan 29 2004."
               3              "tstbm = Log(tstbm/Log(tstbm));"
               3              tstbmn = Min(tstbmn,tstbm);
               3          ]
               2          $egs_info(*,'     default BLCMIN is: ',tstbmn);
               2          skindepth_for_bca = Exp(tstbmn);
               2          $egs_info(*,'     this corresponds to ',skindepth_for_bca,
               2           ' elastic MFPs ');
               2      ]
               1      ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
               1  ]
               0
               0  " read MS data for screened Rutherford scattering "
               0  call init_ms_SR;
               0
               0  DO medium = 1,nmed
               0  [
               1      "Absorb Euler constant into the multiple scattering parameter
               1      "1.16699413758864573 = Exp[2 EulerGamma - 1]
               1      blcc(medium) = 1.16699413758864573*blcc(medium);
               1
               1      "Take its square as this is employed throughout
               1      xcc(medium)  = xcc(medium)**2;
               1  ]
               0
               0  IF( spin_effects ) [ call init_spin; ]
               0
               0  "Determine maximum cross section per energy loss for every medium
               0  $egs_info(*,' ');
               0  esige_max = 0;
               0  psige_max = 0;
               0  DO medium = 1,nmed
               0  [
               1
               1    sigee = 1E-15; sigep = 1E-15;
               1    neke = meke(medium); "Number of elements in storage array
               1    ise_monoton = .true.; isp_monoton = .true.;
               1    sige_old = -1; sigp_old = -1;
               1    DO i = 1,neke
               1    [
               2
               2      ei   = exp((float(i) - eke0(medium))/eke1(medium));
               2      eil  = log(ei);
               2      leil = i;
               2      $EVALUATE ededx USING ededx(eil);
               2      $EVALUATE sig USING esig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigee) sigee = sig;
               2      IF( sig < sige_old ) ise_monoton = .false.;
               2      sige_old = sig;
               2      $EVALUATE ededx USING pdedx(eil);
               2      $EVALUATE sig USING psig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigep) sigep = sig;
               2      IF( sig < sigp_old ) isp_monoton = .false.;
               2      sigp_old = sig;
               2
               2    ]
               1    $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
               1            ise_monoton,isp_monoton);
               1    sig_ismonotone(0,medium) = ise_monoton;
               1    sig_ismonotone(1,medium) = isp_monoton;
               1    esig_e(medium) = sigee; psig_e(medium) = sigep;
               1    IF( sigee > esige_max ) esige_max = sigee;
               1    IF( sigep > psige_max ) psige_max = sigep;
               1  ]
               0  $egs_info(*,' ');
               0
               0  $egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
               0  $egs_info(*,' ');
               0
               0  "Determine upper limit in step size for multiple scattering
               0  DO medium = 1,nmed
               0  [
               1      " Calculate range array first "
               1      " =========================== "
               1      ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
               1      eil  = log(ei);
               1      leil = 1;
               1      E_array(1,medium) = ei;
               1      expeke1(medium) = Exp(1./eke1(medium))-1;
               1      range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
               1      neke = meke(medium); "Number of elements in storage array
               1      DO i = 1,neke - 1
               1      [
               2          eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
               2          E_array(i+1,medium) = eip1;
               2          " Calculate range. The following expressions result from the"
               2          " logarithmic interpolation for the (restricted) stopping power "
               2          " and a power power series expansion of the integral "
               2          eke = 0.5*(eip1+ei); elke = Log(eke);
               2          $SET INTERVAL elke,eke;
               2          $EVALUATE ededx USING pdedx(elke);
               2          aux = pdedx1(i,medium)/ededx;
               2          range_ep(1,i+1,medium) = range_ep(1,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          $EVALUATE ededx USING ededx(elke);
               2          aux = ededx1(i,medium)/ededx;
               2          range_ep(0,i+1,medium) = range_ep(0,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          ei = eip1;
               2      ]
               1
               1      " Now tmxs "
               1      " ======== "
               1
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
               1      p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
               1      chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               1      $EVALUATE dedx0 USING ededx(eil);
               1      estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               1      estepx = estepx*ximax;
               1      IF( estepx > estepe ) [ estepx = estepe; ]
               1      si = estepx*ei/dedx0;
               1
               1      DO i = 1,neke - 1
               1      [
               2
               2          elke = (i + 1 - eke0(medium))/eke1(medium);
               2          eke  = Exp(elke); lelke = i+1;
               2          p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
               2          chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               2          $EVALUATE ededx USING ededx(elke);
               2          estepx = 2*p2*beta2*ededx/eke/
               2                    Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               2          estepx = estepx*ximax;
               2          IF( estepx > estepe ) [ estepx = estepe; ]
               2          ekef = (1-estepx)*eke;
               2          IF( ekef <= E_array(1,medium) )
               2          [
               3              sip1 = (E_array(1,medium) - ekef)/dedx0;
               3              ekef = E_array(1,medium);
               3              elkef = (1 - eke0(medium))/eke1(medium);
               3              lelkef = 1;
               3          ]
               2          ELSE
               2          [
               3              elkef = Log(ekef);
               3              $SET INTERVAL elkef,eke;
               3              leip1l = lelkef + 1;
               3              eip1l  = (leip1l - eke0(medium))/eke1(medium);
               3              eip1   = E_array(leip1l,medium);
               3              aux    = (eip1 - ekef)/eip1;
               3              elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
               3              ektmp  = 0.5*(ekef+eip1);
               3              lelktmp = lelkef;
               3              $EVALUATE ededx USING ededx(elktmp);
               3              aux = ededx1(lelktmp,medium)/ededx;
               3              sip1 = (eip1 - ekef)/ededx*(
               3                       1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
               3          ]
               2          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);
               2
               2          "Now solve these equations
               2          "  si   = tmxs1 * eil   + tmxs0
               2          "  sip1 = tmxs1 * eip1l + tmxs0
               2
               2          tmxs1(i,medium) = (sip1 - si)*eke1(medium);
               2          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;
               2
               2          si  = sip1;
               2      ]
               1
               1      "Now pick up last table entry which applies only to last energy
               1      tmxs0(neke,medium) = tmxs0(neke - 1,medium);
               1      tmxs1(neke,medium) = tmxs1(neke - 1,medium);
               1
               1  ]
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
               0                   spin_effects,find_index,spin_index,
               0                   cost,sint);
               0  "========================================================================="
               0  "                                                                         "
               0  " Subroutine to sample multiple electron scattering angles from the exact "
               0  " distribution resulting from elastic scattering described by the screened"
               0  " Rutherford cross section (spin_effects=.false.) or by the screened      "
               0  " Rutherford cross times Mott correction (spin_effects=.true.)            "
               0  "                                                                         "
               0  " I.Kawrakow, NRC                                                         "
               0  "========================================================================="
               0
               0  implicit none;
               0
               0  $REAL    lambda, chia2,q1,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects,find_index,spin_index;
               0
               0  COMIN/MS-Data,RANDOM,EGS-IO/;
               0
               0  $declare_write_buffer;
               0
               0  $REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
               0           cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
               0  $INTEGER icount,i,j,k;
               0
               0  save     i,j,omega2;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  IF(lambda <= 13.8)
               0  [
               1      "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
               1      "that contribute to the forward no-scattering amplitude.
               1      $RANDOMSET sprob;
               1      explambda = Exp(-lambda);
               1      IF (sprob < explambda)
               1      [
               2          "It was a no scattering event
               2          cost = 1; sint = 0;
               2          return;
               2      ]
               1      wsum = (1+lambda)*explambda;
               1      IF ( sprob < wsum )
               1      [
               2        :RETRY_1:;
               2        $RANDOMSET xi;
               2        xi  = 2*chia2*xi/(1 - xi + chia2);
               2        cost = 1 - xi;
               2        IF( spin_effects ) [
               3            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
               3                                  spin_index,.false.);
               3            $RANDOMSET rnno;
               3            IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
               3        ]
               2        sint = sqrt(xi*(2 - xi));
               2        return;
               2      ]
               1      IF ( lambda <= 1 )      "IK introduced this portion because with
               1                              "alternative BCAs mscat can be called with
               1                              " lambda < 1 where there are no pre-calculated
               1                              "data
               1      [
               2          wprob = explambda; wsum = explambda;
               2          cost = 1; sint = 0;
               2          icount = 0;
               2          LOOP
               2          [
               3              icount = icount + 1;
               3              IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
               3              wprob = wprob*lambda/icount;
               3              wsum = wsum + wprob;
               3              :RETRY_2:;
               3              $RANDOMSET xi;
               3              xi  = 2*chia2*xi/(1 - xi + chia2);
               3              cosz = 1 - xi;
               3              IF( spin_effects ) [
               4                  rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
               4                                        spin_index,.false.);
               4                  $RANDOMSET rnno;
               4                  IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
               4              ]
               3              sinz = xi*(2 - xi);
               3              IF ( sinz > 1.e-20 )
               3              [
               4                 sinz = Sqrt(sinz);
               4                 $RANDOMSET xi;
               4                 phi = xi*6.2831853;
               4                 cost = cost*cosz - sint*sinz*Cos(phi);
               4                 sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
               4               ]
               3          ] UNTIL ( wsum > sprob);
               2          return;
               2      ]
               1  ]
               0
               0  "It was a multiple scattering event
               0  "Sample the angle from the q^(2+) surface
               0
               0  IF (lambda <= $LAMBMAX_MS ) [
               1
               1      IF (find_index)
               1      [
               2          llmbda = log(lambda);
               2
               2          " First fix lambda bin
               2          ai = llmbda*dllambi; i = ai; ai = ai - i;
               2          $RANDOMSET xi;
               2          IF(xi < ai) i = i + 1;
               2
               2          " fix now q1 bin
               2          IF( q1 < $QMIN_MS ) [ j = 0; ]
               2          ELSE IF( q1 < $QMAX_MS ) [
               3              aj = q1*dqmsi; j = aj; aj = aj - j;
               3              $RANDOMSET xi;
               3              IF( xi < aj ) j = j + 1;
               3          ]
               2          ELSE [ j = $MAXQ_MS; ]
               2
               2          " Calculate omega2 "
               2          IF(llmbda < 2.2299) [
               3            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
               3              0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
               3          ]
               2          ELSE [
               3            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
               3                     llmbda*(0.1535754 - llmbda*0.00552888)));
               3          ]
               2
               2          find_index = .false.;
               2      ]
               1      "If this is a re-iteration with the same lambda, then omega2, i, and k
               1      "should have been defined in the previous iteration
               1
               1  :RETRY_3:;
               1      $RANDOMSET xi;
               1      ak = xi*$MAXU_MS; k = ak; ak = ak - k;
               1      IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
               1      a = fms_array(i,j,k); u = ums_array(i,j,k);
               1      du = ums_array(i,j,k+1) - u;
               1      $RANDOMSET xi;
               1      IF( abs(a) < 0.2 ) [
               2          x1 = 0.5*(1-xi)*a;
               2          u  = u + xi*du*(1+x1*(1-xi*a));
               2      ]
               1      ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]
               1
               1      xi      = omega2*u/(1 + 0.5*omega2 - u);
               1      IF( xi > 1.99999 ) [ xi = 1.99999; ]
               1        "some machines have trouble when xi is very close to 2 in subsequent"
               1        "calculations. IK, April 25 2002"
               1      cost    = 1 - xi;
               1      IF( spin_effects ) [
               2          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
               2          $RANDOMSET rnno;
               2          IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
               2      ]
               1      sint    = sqrt(xi*(2-xi));
               1      return;
               1  ]
               0
               0  "This is an error condition
               0
               0  $egs_info(*,' ');
               0  $egs_info(*,' *************************************');
               0  $egs_info(*,' Maximum step size in mscat exceeded! ');
               0  $egs_info(*,' Maximum step size initialized: 100000');
               0  $egs_info(*,' Present lambda: ',lambda);
               0  $egs_info(*,' chia2: ',chia2);
               0  $egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
               0  $egs_info(*,' medium: ',medium);
               0  $egs_fatal(*,' Stopping execution');
               0
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  $REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
               0                                spin_index,is_single);
               0  "============================================================================="
               0  "                                                                             "
               0  " Determines the rejection function due to spin effects for                   "
               0  "   charge        qel (=0 for e-, =1 for e+)                                  "
               0  "   log(energy)   elke                                                        "
               0  "   speed         beta2                                                       "
               0  "   1. MS moment  q1                                                          "
               0  "   cos(theta)    cost                                                        "
               0  "                                                                             "
               0  " I.Kawrakow, NRC                                                             "
               0  "============================================================================="
               0
               0  implicit none;
               0
               0  $REAL      elke,beta2,q1,cost;
               0  $INTEGER   qel,medium;
               0  $LOGICAL   spin_index,is_single;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,RANDOM/;
               0
               0  $REAL      rnno,ai,qq1,aj,xi,ak;
               0  $INTEGER   i,j,k;
               0
               0  save       i,j;
               0
               0  IF( spin_index ) [  "Determine the energy and q1 index
               1      spin_index = .false.;
               1      IF( beta2 >= b2spin_min ) [
               2          ai = (beta2 - b2spin_min)*dbeta2i;
               2          i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
               2      ]
               1      ELSE IF( elke > espml ) [
               2          ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
               2      ]
               1      ELSE [ i = 0; ai = -1; ]
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) i = i + 1;
               1      IF( is_single ) [ j = 0; ]
               1      ELSE [
               2          qq1 = 2*q1; qq1 = qq1/(1 + qq1);
               2          aj = qq1*dqq1i; j = aj;
               2          IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
               2          ELSE [  aj = aj - j;
               3                  $RANDOMSET rnno;
               3                  IF( rnno < aj ) j = j + 1;
               3          ]
               2      ]
               1  ]
               0  xi = Sqrt(0.5*(1-cost));
               0  ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
               0  spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
               0                       ak*spin_rej(medium,qel,i,j,k+1);
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0
               0  subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
               0  "============================================================================"
               0  "                                                                            "
               0  " single elastic scattering                                                  "
               0  "                                                                            "
               0  " I.Kawrakow, NRC                                                            "
               0  "============================================================================"
               0
               0  implicit none;
               0
               0  $REAL    chia2,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects;
               0
               0  COMIN/RANDOM/;
               0
               0  $REAL    xi,rnno,rejf,spin_rejection,qzero;
               0  $LOGICAL spin_index;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  spin_index = .true.;
               0  :RETRY-SPIN:;
               0  $RANDOMSET xi;
               0  xi  = 2*chia2*xi/(1 - xi + chia2);
               0  cost = 1 - xi;
               0  IF( spin_effects ) [
               1      qzero=0;
               1      rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
               1      $RANDOMSET rnno;
               1      IF( rnno > rejf ) goto :RETRY-SPIN:;
               1  ]
               0  sint = sqrt(xi*(2 - xi));
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_ms_SR;
               0  "================================================================"
               0  "                                                                "
               0  " Reads in pre-calculated screened Rutherford multiple elastic   "
               0  " scattering data                                                "
               0  "                                                                "
               0  " I. Kawrakow, NRC                                               "
               0  "================================================================"
               0
               0  implicit none;
               0
               0  COMIN/MS-Data,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  integer*4 i,j,k;
               0
               0  $egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
               0  rewind($MSCAT-DATAFILE);
               0  DO i=0,$MAXL_MS [
               1      DO j=0,$MAXQ_MS [
               2          read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
               2          read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
               2          DO k=0,$MAXU_MS-1 [
               3             fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
               3             ims_array(i,j,k) = ims_array(i,j,k)-1;
               3          ]
               2          fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
               2      ]
               1  ]
               0  $egs_info('(a)',' done ');
               0
               0  llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
               0  dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
               0  dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_spin;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline,dloge,eloge;
               0
               0  real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"
               0
               0  real*4        fmax_array(0:$MAXQ_SPIN);
               0  integer*2     i2_array(512),ii2;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,ii4,irec;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0
               0  $INTEGER      spin_unit, rec_length, want_spin_unit;
               0  integer       egs_get_unit;
               0  character     data_version*32,endianess*4;
               0  $LOGICAL      swap;
               0
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " stupid GNU compiler complains that the arguments to egs_swap_ are of "
               0  " one kind here, but of some other kind there => need character arrays and "
               0  " equivalence statements"
               0  real*4        tmp_4;
               0  character     c_2(2), c_4(4);
               0  equivalence   (ii2,c_2), (tmp_4,c_4);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
               0  want_spin_unit = 61;
               0  spin_unit = egs_get_unit(want_spin_unit);
               0  IF( spin_unit < 1 ) [
               1      $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               1  ]
               0  rec_length = 276*$RECL-FACTOR;
               0  open(spin_unit,file=spin_file,form='unformatted',access='direct',
               0       status='old',recl=rec_length,err=:spin-open-error:);
               0  read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
               0                        espin_min,espin_max,b2spin_min,b2spin_max;
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
               1      tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
               1      tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
               1      tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
               0  $egs_info('(a)',data_version);
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,
               0          ' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
               0  $egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
               0          b2spin_min,b2spin_max);
               0  n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
               0  dloge = log(espin_max/espin_min)/n_ener;
               0  eloge = log(espin_min); earray(0) = espin_min;
               0  $FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
               0  DO i=1,n_ener [
               1      eloge = eloge + dloge; earray(i) = exp(eloge);
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0  dbeta2 = (b2spin_max - b2spin_min)/n_ener;
               0  beta2 = b2spin_min; earray(n_ener+1) = espin_max;
               0  DO i=n_ener+2,2*n_ener+1 [
               1      beta2 = beta2 + dbeta2;
               1      IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
               1      ELSE [ earray(i) = 50585.1; ]
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0
               0  " Convert to MeV and set interpolation interavals"
               0
               0
               0
               0
               0  espin_min = espin_min/1000; espin_max = espin_max/1000;
               0  dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               0  espml = Log(espin_min);
               0  dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               0  dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              DO i=0,$MAXE_SPI1 [
               4                  irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
               4                  $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
               4                  read(spin_unit,rec=irec,err=:spin-read-error:)
               4                    dum1,dum2,dum3,aux_o,fmax_array,i2_array;
               4                  IF( swap ) [
               5                    tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
               5                    tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
               5                    tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
               5                    tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
               5                  ]
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      tmp_4 = fmax_array(j);
               5                      IF( swap ) call egs_swap_4(c_4);
               5                      DO k=0,$MAXU_SPIN [
               6                          ii2 = i2_array((n_point+1)*j + k+1);
               6                          IF( swap ) call egs_swap_2(c_2);
               6                          ii4 = ii2;
               6                          IF( ii4 < 0 ) ii4 = ii4 + 65536;
               6                          dum1 = ii4; dum1 = dum1*tmp_4/65535;
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*dum1;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2          $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
               2            c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
               2      ]
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
               2           etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
               2            q1ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
               2            q1cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
               2            q2ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
               2            q2cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  close(spin_unit);
               0  return;
               0
               0  :spin-open-error:
               0  $egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));
               0
               0  :spin-read-error:
               0  $egs_fatal(*,'Error while reading spin data file for element',iZ);
               0
               0  return; end;
1              0  %E
               0
               0  subroutine init_spin_old;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " This version uses the old EGSnrc ASCII spin data format.              "
               0  " If the installation failed to figure out the byte order of your       "
               0  " machine, rename this subroutine to init_spin, the current init_spin   "
               0  " to init_spin_new (or whatever) and download the old spinms data       "
               0  " directory.
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
               0               $file_sep // 'z000';
               0  length = lnblnk1(spin_file);
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
               1                            ' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
               2          iiZ = iZ - iii*100;
               2          iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
               2          iiZ = iiZ - 10*iii;
               2          spin_file(length:length) = char(iiZ+48);
               2          want_spin_unit = 61;
               2          spin_unit = egs_get_unit(want_spin_unit);
               2          IF( spin_unit < 1 ) [
               3              $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               3          ]
               2          open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
               2          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
               2          read(spin_unit,*) n_ener,n_q,n_point;
               2          IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
               3              $egs_fatal(*,' Wrong spin file for Z = ',iZ);
               3          ]
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              read(spin_unit,*); read(spin_unit,*);
               3              DO i=0,$MAXE_SPI1 [
               4                  read(spin_unit,'(a,g14.6)') string,earray(i);
               4                  read(spin_unit,*) dum1,dum2,dum3,aux_o;
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      read(spin_unit,*) tmp_array;
               5                      DO k=0,$MAXU_SPIN [
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
               6                      ]
               5                  ]
               4              ]
               3          ]
               2          close(spin_unit);
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2      ]
               1
               1      " Convert to MeV and set interpolation interavals"
               1      espin_min = espin_min/1000; espin_max = espin_max/1000;
               1      dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               1      espml = Log(espin_min);
               1      dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               1      dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  return;
               0
               0  :SPIN-DBASE-ERROR:
               0  $egs_info(*,' ******************** Error in init_spin ******************* ');
               0  $egs_info('(a,a)','  could not open file ',spin_file);
               0  $egs_fatal(*,' terminating execution ');
               0
               0  end;
1              0  %E
               0  ; "buffer flush
               0
               0  "======================================================================"
               0  "                 subroutine msdist_pII                                "
               0  "                 =====================                                "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep.                         "
               0  "  For description of input and output variables see below             "
               0  "                                                                      "
               0  "  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
               0  "  March 1997          Alex Bielajew        Adaption for EGS4          "
               0  "  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
               0  "                                           mortran version by Bielajew"
               0  "  June 1997           Iwan Kawrakow        Improved energy loss       "
               0  "                                           corrections                "
               0  "  June 1999           Iwan Kawrakow        spin effects, removed      "
               0  "                                           $SUBSTEP-ELOSS-EVALUATION  "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pII
               0  (
               0      e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      med,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects;
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      b,         "substep transport distance,
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      c,         "substep transport distance,
               0      eta,eta1,  "randomization of the substep transport distances
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi1,     "cosine of the first azimuthal angle
               0      cphi2,     "cosine of the second azimuthal angle
               0      w1,        "cosine of the first substep polar scattering angle
               0      w2,        "cosine of the second substep polar scattering angle
               0      w1v2,      "w1*v2;
               0      delta,     "transport parameter (see paper)
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)"
               0      beta2,     "speed at e in units of c, squared"
               0      etap,      "correction to the screening parameter derived from PWA
               0      xi_corr,   "correction to the first MS moments due to spin
               0      ms_corr,
               0      tau,       "average kinetic energy over the step divided by electron mass
               0      tau2,      "tau squared
               0      epsilon,   "fractional energy loss
               0      epsilonp,  "fractional energy loss
               0      temp,temp1,"auxilarity variables for energy loss corrections
               0      temp2,     "
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      gamma,     "q2/q1
               0      lambda,    "distance in number of elastic scattering mean free paths
               0                 "for each sample of the multiple scattering angle
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of ap2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sint1,     "sine   of the first substep polar scattering angle
               0      sint2,     "sine   of the second substep polar scattering angle
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      sphi1,     "sine   of the first azimuthal angle
               0      sphi2,     "sine   of the second azimuthal angle
               0      u2p,       "intermediate scatter or transport direction cosine
               0      u2,        "sint2*cphi2;
               0      v2,        "sint2*sphi2;
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index,  "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index   "saves locating the spin rejection index in 2. call to mscat"
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  medium  = med;
               0
               0  count_pII_steps = count_pII_steps + 1;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  "Commonly used factors
               0  e       = e0 - 0.5*eloss;
               0  tau     = e/prm;
               0  tau2    = tau*tau;
               0  epsilon = eloss/e0;
               0  epsilonp= eloss/e;
               0  "e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
               0  e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
               0  p2      = e*(e + rmt2);
               0  "p2i     = 1/p2;
               0  beta2   = p2/(p2 + rmsq);
               0  "chia2   = xcccc*p2i/(4*blccc);
               0  chia2   = xcccc/(4*p2*blccc);
               0  lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step
               0
               0  temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
               0               (epsilonp/((tau+1)*(tau+2)))**2;
               0  lambda = lambda*(1 - temp2);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2         $EVALUATE gamma USING q2ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2         $EVALUATE gamma USING q2cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]
               0
               0  chia2  = chia2*etap;
               0  lambda = lambda/(etap*(1+chia2))*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
               0  xi     = q1*lambda;
               0
               0  "Sample first substep scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w1,sint1);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);
               0
               0  "Sample second substep scattering angle
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w2,sint2);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);
               0
               0  "Final direction of motion, relative to z-axis motion
               0  u2  = sint2*cphi2;
               0  v2  = sint2*sphi2;
               0  u2p = w1*u2 + sint1*w2;
               0  us  = u2p*cphi1 - v2*sphi1;
               0  vs  = u2p*sphi1 + v2*cphi1;
               0  ws  = w1*w2 - sint1*u2;
               0
               0  "Calculate delta, b, c
               0
               0  xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects
               0
               0  $RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
               0  delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;
               0
               0  "Correct the coefficients for energy loss
               0  temp1 = 2 + tau;
               0  temp = (2+tau*temp1)/((tau+1)*temp1);
               0  "Take logarithmic dependence into account as well
               0  temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
               0  temp = temp * epsilonp;
               0  temp1 = 1 - temp;
               0  delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
               0            (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
               0             "0.40824829 is 1/Sqrt(6)"
               0  b      = eta*delta;
               0  c      = eta*(1-delta);
               0
               0  "Calculate transport direction cosines
               0  w1v2 = w1*v2;
               0  ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
               0  vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
               0  wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;
               0
               0  "Calculate transport distance
               0  ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PII;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
               0
               0  "                 subroutine msdist_pI                                 "
               0  "                 ====================                                 "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep                          "
               0  "  resampling PRESTA-I behaviour.                                      "
               0  "                                                                      "
               0  "  October 1997        Iwan Kawrakow        Initial coding             "
               0  "  June    1999        Iwan Kawrakow        spin effects               "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pI
               0  (
               0      e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      medium,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
               0      r2max,
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi,      "cosine of the azimuthal scattering angle
               0      sphi,      "sine of the  azimuthal scattering angle
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)
               0      beta2,     "speed at e in units of c, squared
               0      etap,      "correction to the screening angle derived from PWA
               0      xi_corr,   "correction to the first MS moment due to spin
               0      ms_corr,
               0      epsilon,   "fractional energy loss
               0      temp,      "auxilarity variable for energy loss corrections
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      lambda,    "distance in number of elastic scattering mean free paths
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of p2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint,      "sine of the MS angle
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      u2p,       "intermediate scatter or transport direction cosine
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index, "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,EMF-INPUTS/;
               0  ;COMIN/EM/;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  e       = e0 - 0.5*eloss;
               0  p2      = e*(e + rmt2);
               0  p2i     = 1/p2;
               0  chia2   = xcccc*p2i/(4*blccc);
               0  beta2   = p2/(p2 + rmsq);
               0  lambda  = tustep*rhof*blccc/beta2;
               0
               0  "Account for energy loss in the MS distribution
               0  factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
               0  epsilon= eloss/e0;
               0  epsilon= epsilon/(1-0.5*epsilon);
               0  temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
               0  lambda = lambda*(1 + temp);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]
               0
               0  chia2   = xcccc*p2i/(4*blccc)*etap;
               0  lambda = lambda/etap/(1+chia2)*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  xi     = q1*lambda;
               0
               0  "Sample multiple scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             ws,sint);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               0  us  = sint*cphi;
               0  vs  = sint*sphi;
               0
               0  "Correct xi used for the PLC calc. for spin effects
               0  xi     = xi*xi_corr;
               0
               0  "Calculate PLC and lateral transport a la PRESTA-I
               0  "Note that we use here the exact expression for <z>
               0  "because it is much simpler and faster than the original PRESTA-I formulas
               0  "(which are also second order approximations)
               0  IF ( xi < 0.1 )
               0  [
               1     z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
               1  ]
               0  ELSE
               0  [
               1     z = (1 - Exp(-xi))/xi;
               1  ]
               0  r  = 0.5*sint;
               0  r2 = r*r; z2 = z*z;
               0  r2max = 1 - z2;
               0  IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]
               0
               0  "Calculate final position vector
               0  ut   = r*cphi; vt = r*sphi; wt = z;
               0
               0  "Calculate transport distance
               0  ustep = Sqrt(z2 + r2)*tustep;
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  $EMFIELD_PI;
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PAIR;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   For a photon energy below 2.1 MeV, the energies of the pair    "
               0  "   particles are uniformly distributed in the allowed range via   "
               0  "   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
               0  "   If the user has a better approach, modify this macro.          "
               0  "   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
               0  "   cross section is employed, above 50 MeV the Coulomb-corrected  "
               0  "   Bethe-Heitler is used.                                         "
               0  "   Modified from its original version to make compatible with the "
               0  "   changes made in BREMS.                                         "
               0  "                                                                  "
               0  "   I. Kawrakow                                                    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
               0                                   "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PAIR;
               0
               0  $DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;
               0
               0  $REAL    k,xx,abin,rbin,alias_sample1;
               0  $INTEGER ibin, iq1, iq2, iprdst_use;
               0  $LOGICAL do_nrc_pair;
               0  $INTEGER itrip;
               0  $REAL    ftrip;
               0
               0  NPold = NP;      "Set the old stack counter"
               0
               0  IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
               1                        " it is much more efficient to do it BEFORE the "
               1                        " actual sampling "
               1      i_survived_RR = 0;  "flag they all survive inititally"
               1      IF( prob_RR <= 0 ) [
               2          IF( n_RR_warning < $MAX-RR-WARNING ) [
               3            n_RR_warning = n_RR_warning + 1;
               3            $egs_warning('(a,g14.6)',
               3                        'Attempt to play Russian Roulette with prob_RR<0! ');
               3          ]
               2      ]
               1      ELSE [
               2          $RANDOMSET rnno_RR;
               2          IF( rnno_RR > prob_RR ) [  "The pair was killed "
               3              i_survived_RR =2; "flag both particles eliminated"
               3              IF( np > 1 ) [ np = np-1; ]
               3              ELSE [ " We have just one photon left on the stack. In order to  "
               4                     " get a proper exit from PHOTO, we have to leave at least "
               4                     " one particle on the stack                               "
               4                  wt(np) = 0; e(np) = 0;
               4              ]
               3              return;
               3          ]
               2          ELSE [ "The pair survived, increase the weight"
               3              wt(np) = wt(np)/prob_RR;
               3          ]
               2      ]
               1  ]
               0
               0  $CHECK-STACK(np+1,'PAIR');
               0  PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
               0  EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
               0  do_nrc_pair = .false.;
               0
               0  IF( itriplet > 0 & eig > 4*rm ) [
               1      itrip = dli_triplet*gle + bli_triplet;
               1      ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
               1      $RANDOMSET rnno34;
               1      IF( rnno34 < ftrip ) [  " Triplet production "
               2          call sample_triplet;
               2          return;
               2      ]
               1  ]
               0
               0  IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
               1                        "(privided the energy is within the available range)"
               1      k = eig/rm;
               1      IF( k < nrcp_emax ) [
               2          do_nrc_pair = .true.;
               2          IF( k <= nrcp_emin ) [ ibin = 1; ]
               2          ELSE [
               3              abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
               3              ibin = abin; abin = abin - ibin;
               3              $RANDOMSET rbin;
               3              IF( rbin < abin ) ibin = ibin + 1;
               3          ]
               2          xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
               2                  nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
               2                  nrcp_idata(1,ibin,medium));
               2             " The above returns the energy fraction of the positron "
               2          IF( xx > 0.5 ) [
               3              pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
               3              pese2 = peig - pese1; iq2 = -1;
               3          ]
               2          ELSE [
               3              pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
               3              pese1 = peig - pese2; iq1 = -1;
               3          ]
               2      ]
               1  ]
               0
               0
               0  IF( ~do_nrc_pair ) [
               1  IF (EIG.LE.2.1) [
               2      "   BELOW 2.1,USE APPROXIMATION"
               2      $SELECT-LOW-ENERGY-PAIR-PRODICTION;
               2  ]
               1  ELSE[   "ABOVE 2.1, MUST SAMPLE"
               2
               2      "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
               2      "   COULOMB CORRECTED
               2
               2      IF (EIG.LT.50.) [ "Use BH without Coulomb correction"
               3
               3          L = 5;
               3          L1 = L + 1;
               3
               3          "Find the actual rejection maximum for this photon energy"
               3          delta = 4*delcm(medium)/eig;
               3          IF( delta < 1 ) [
               4             Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4             Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4             aux2 = log(delta+dl6(l,medium));
               4             Amax = dl4(l,medium)+dl5(l,medium)*aux2;
               4             Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
               4          ]
               3          "and then calculate the probability for sampling from (br-1/2)**2"
               3          aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
               3          aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
               3      ]
               2      ELSE [
               3          "Use BH Coulomb-corrected"
               3          L = 7;
               3          "The absolute maxima are close to the actual maxima at high energies"
               3          "=>use the absolute maxima to save time"
               3          Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
               3          aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
               3      ]
               2
               2      del0 = eig*delcm(medium);
               2      Eavail = eig - rmt2;
               2
               2      LOOP [
               3
               3          $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
               3          IF( rnno30 > aux1 ) [ "use the uniform part"
               4              br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
               4          ]
               3          ELSE [  "use the (br-1/2)**2 part of the distribution"
               4              $RANDOMSET rnno32; $RANDOMSET rnno33;
               4              br = 0.5*(1-max(rnno31,rnno32,rnno33));
               4              rejmax = Amax; l1 = l;
               4          ]
               3          Eminus = br*Eavail + rm;
               3          Eplus  = eig - Eminus;
               3          delta = del0/(Eminus*Eplus);
               3          IF( delta < 1 ) [
               4             rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4            rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
               4          ]
               3
               3      ] UNTIL ( rnno34*rejmax <= rejf );
               2
               2      pese2 = Eminus; pese1 = peig - pese2;
               2      $RANDOMSET RNNO34;
               2      IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
               2
               2  ]
               1  ]
               0
               0  "   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
               0  ESE2=PESE2;
               0  E(NP)=PESE1; E(NP+1)=PESE2;
               0  "   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
               0  "   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
               0  "   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
               0  "   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
               0  "   SET UP A NEW 'ELECTRON'  "
               0  $SET-PAIR-ANGLE;
               0  " DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
               0  " of the angular distribution "
               0  CALL UPHI(1,1);
               0  "   SET UP A NEW 'ELECTRON' "
               0  NP=NP+1;
               0  SINTHE=-SINTHE;
               0  CALL UPHI(3,2);
               0
               0  IQ(NP)=iq2; IQ(NP-1)=iq1;
               0  RETURN;
               0  "END OF SUBROUTINE PAIR"    END;
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " Sampling of triplet production events.                                    "
               0  "                                                                           "
               0  " The treatment is based on Borsellino's first Born approximation           "
               0  " result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
               0  " As the kinematic of the process is already complicated enough and the     "
               0  " cross section itself is not simple either, a Markov-chain method is used  "
               0  " to sample triplet events from the Borsellino equation without any         "
               0  " additional approximations (other then the use of the first Born           "
               0  " approximation and the assumption of free electrons implied by             "
               0  " Borsellino's derivation)                                                  "
               0  "                                                                           "
               0  " Iwan Kawrakow, April 2005.                                                "
               0  "***************************************************************************"
               0
               0  subroutine sample_triplet;
               0
               0  "***************************************************************************"
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  " We use double precision throughout as in many cases the kinematically "
               0  " permitted angular interval is too small to be resolved accurately enough "
               0  " in single precision "
               0
               0  real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
               0         eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
               0         eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
               0         wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);
               0
               0  real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;
               0
               0  real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
               0         Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
               0         aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
               0  real*8 Er,pr,pr2,eta_pr;
               0  real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
               0         eta_costp,Epp,pp_sintp,pp_sntp2;
               0  real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
               0         eta_costm;
               0  real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
               0  real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
               0         a,c,sindel,cosdel,sinpsi;
               0
               0  $INTEGER i;
               0  $LOGICAL use_it;
               0  $INTEGER iscore; " needed for BEAM "
               0
               0  $LOGICAL is_initialized;
               0  data is_initialized/.false./;
               0  save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
               0       eta_costm_array,ebin_array,wp_array,qmin_array,
               0       kmin,kmax,dlogki,alogkm,prmi,tiny_eta;
               0
               0  IF( ~is_initialized ) [
               1      is_initialized = .true.;
               1      tiny_eta = 1e-6;
               1      " Set current cross section value to -1 in each energy bin "
               1      DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
               1      " Find the maximum energy of the cross section data "
               1      kmax = 0; kmin = 4.1*prm;
               1      DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
               1      IF( kmax <= kmin ) return;
               1      dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
               1      alogkm = 1 - dlogki*log(kmin);
               1      prmi = 1/prm;
               1      DO i=1,$MAX_TRIPLET [
               2          k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
               2          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
               2          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
               2          qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
               2      ]
               1  ]
               0
               0  peig = e(np);
               0  IF( peig <= 4*prm ) return;
               0  $CHECK-STACK(np+2,'sample_triplet');
               0
               0  " Determine energy bin "
               0  IF( peig <= kmin ) [ i = 1; ]
               0  ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
               0  ELSE [
               1      ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) [ i = i+1; ]
               1  ]
               0
               0  " First use the bin energy to sample the random numbers "
               0  " that determine recoil momentum and electron/postron angles "
               0  k = ebin_array(i);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  :retry_triplet:;
               0
               0  " Pick the recoil electron momentum from 1/p.
               0  $RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
               0  pr = qmin_array(i)*exp(eta_pr*wp_array(i));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  " Determine min./max. kinematically permitted postron energy for "
               0  " this k and p "
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  " Pick the positron energy "
               0  $RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0
               0  " Now we can determine the pair electron energy from energy conservation "
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  " The minimum cosine of the positron angle follows from the kinematics. "
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0
               0  " Now pick the positron direction from 1/(Ep-pp*cost_p) "
               0  $RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  wmup = wmup*(cost_p - Epp);
               0  sint_p = 1-cost_p*cost_p;
               0  IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  " The minimum amd maximum cosine of the pair electron angle follows from "
               0  " the kinematics "
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0
               0  " Now pick the electron direction from "
               0  "  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
               0  " We have to take into account the "
               0  " 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
               0  " otherwise we end up with 1/sqrt() singularities near the ends of the "
               0  " allowed cost_m range                                                 "
               0  $RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
               0  wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
               0  wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
               0  cost_m = cost_m/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  " Now we have selected all independent kinematic variables. "
               0  " Determine the azimuthal angle between the pair electrons "
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0  " And now evaluate the Borsellino cross section "
               0  k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
               0  k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
               0  s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
               0  s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
               0  S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
               0  aux4 = k3*Ep-k2*Em;
               0  S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
               0  sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));
               0
               0  " We get the following factor due to the transformation from phi to "
               0  " the recoil momentum pr "
               0  cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);
               0
               0  " We have to also multiply by the various factors from the sampling of "
               0  " pr, Ep, cost_p and cost_m "
               0  sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
               0  IF( sigma < 0 ) [
               1      $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
               1  ]
               0
               0  " Now determine if we accept this new event "
               0  use_it = .true.;
               0  IF( sigma < fmax_array(i) ) [
               1      $RANDOMSET rnno;
               1      IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
               1  ]
               0  IF( use_it ) [       " Yes, event accepted "
               1      fmax_array(i) = sigma;
               1      eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
               1      eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
               1  ] ELSE [             " Nop, event rejected => use last accepted "
               1      eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
               1      eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
               1  ]
               0
               0  " We now have a set of random number accepted for sampling around "
               0  " the i'th bin energy. We need to recalculate all variables using "
               0  " the actual photon energy "
               0
               0  k = peig*prmi;
               0  aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
               0  qmin = 4*k/aux5; qmax = aux5/(2*k+1);
               0  pr = qmin*exp(eta_pr*log(qmax/qmin));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  sint_p = sqrt(1-cost_p*cost_p);
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $RANDOMSET phi; phi = phi*6.283185307179586;
               0  ppx = pp*sint_p; ppy = 0;
               0  pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
               0  cphi = cos(phi); sphi = sin(phi);
               0  tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
               0  tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
               0  ppz = pp*cost_p; pmz = pm*cost_m;
               0  prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
               0  " Set up particles on the stack ";
               0  " We always put the recoil electron on top (even if its energy is higher "
               0  " then the energies of the pair particles) because                       "
               0  "   - that way, we know which particle is the recoil  electron in case   "
               0  "     we want to score some quantity related to it                       "
               0  "   - its energy is, on average, lower than the pair particle energies   "
               0  NPold = np;
               0  $TRANSFER PROPERTIES TO (np)   FROM (np);
               0  $TRANSFER PROPERTIES TO (np+1) FROM (np);
               0  $TRANSFER PROPERTIES TO (np+2) FROM (np+1);
               0  pp = 1/pp; pm = 1/pm; pr = 1/pr;
               0  a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
               0  IF( sinpsi > 1e-20 ) [
               1      sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
               1      IF( Ep > Em ) [
               2          u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
               1      v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
               1      w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
               1  ] ELSE [
               1      IF( Ep > Em ) [
               2          u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
               2          iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
               2          iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
               2          iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
               2          iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
               1      iq(np) = -1; E(np) = Er*prm;
               1  ]
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE PHOTO;
               0  "******************************************************************"
               0  " Programmers:  I. Kawrakow, complete recoding,                    "
               0  "                            Fluorescent X-rays, Auger,            "
               0  "                            Coster-Kronig treated in RELAX        "
               0  "               A.F. Bielajew (NRC) photoelectric angular distn    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0
               0  data n_warning/0/;
               0
               0  IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  IF( peig < edge_energies(2,1) ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine PHOTO called with E = ',peig,
               2                     ' which is below the current min. energy of 1 keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  iZ = iedgfl(irl);
               0  do_relax = .false.;
               0  edep = pzero;
               0  IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
               1                             " first sample the element "
               1      IF( nne(medium) = 1 ) [
               2          iZ = int( zelem(medium,1) + 0.5 );
               2          DO j=1,edge_number(iZ) [
               3              IF( peig >= edge_energies(j,iZ) ) EXIT;
               3          ]
               2      ]
               1      ELSE [
               2          aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
               2          sigtot = 0;
               2          DO k=1,nne(medium) [
               3              iZ = int( zelem(medium,k) + 0.5 );
               3              IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                  $egs_info(*,' Error in PHOTO: ');
               4                  $egs_fatal(*,'   Atomic number of element ',k,
               4                     ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4              ]
               3              IF( peig > edge_energies(1,iZ) ) [
               4                  j = 1;
               4                  sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
               4                       edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
               4              ]
               3              ELSE [
               4                  DO j=2,edge_number(iZ) [
               5                      IF( peig >= edge_energies(j,iZ) ) EXIT;
               5                  ]
               4                  sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
               4                          gle*edge_d(j,iZ) ));
               4                  sigma = Exp(sigma);
               4              ]
               3              sigma = sigma * pz(medium,k);
               3              sigtot = sigtot + sigma;
               3              probs(k) = sigma;
               3              ints(k) = j;
               3          ]
               2          $RANDOMSET br; br = br*sigtot;
               2          DO k=1,nne(medium) [
               3              br = br - probs(k);
               3              IF( br <= 0 ) EXIT;
               3          ]
               2          iZ = int( zelem(medium,k) + 0.5 );
               2          j  = ints(k);
               2      ]
               1      " Now we know the atomic number (iZ) and the energy interval the "
               1      " photon energy is in (j). It is time to sample the shell the photon "
               1      " is interacting with. "
               1      " left for now as before, to be changed!!! "
               1      IF( peig <= binding_energies($MXSHELL,iZ) )
               1      [   "Outer shells, no atomic relaxation"
               2             "EADL relax: Below  M2-shell -> just emit e- "
               2             iq(np) = -1;
               2             e(np) = peig + prm;
               2      ]
               1      ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
               2          $RANDOMSET br;
               2          DO k=1,$MXINTER [
               3              IF( peig > binding_energies(k,iZ) ) [
               4                  IF( br < interaction_prob(k,iZ) ) EXIT;
               4                  br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
               4              ]
               3          ]
               2          "Interaction possible with any shell from k=1 to $MXSHELL"
               2          "Defaults to $MXSHELL interaction if DO loop completes"
               2          "****************"
               2          "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
               2          "**************** from previous EGSnrc approach as it doesn't"
               2          "                 generate e- nor x-rays from <M> and <N> shells."
               2          IF (eadl_relax & k > 4)[
               3             "No initial vacancy below L3 for now, just emit e-"
               3             iq(np) = -1;
               3             e(np) = peig + prm;
               3          ]
               2          ELSE["EADL:    Interacts with K,L1..L3 shells"
               3               "default: Interacts with K,L1..L3,<M>, and <N> shells"
               3             e_vac = binding_energies(k,iZ);
               3             e(np) = peig - e_vac + prm; do_relax = .true.;
               3             iq(np) = -1;
               3          ]
               2      ]
               1  ]
               0  ELSE [
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  "****************"
               0  "EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
               0  "**************** but vacancies below L3 deposit energy locally. It wont"
               0  "                 produce x-rays from <M> and <N> shells."
               0  "IF ($EADL_RELAX & k > 4)[
               0  "   edep = e_vac; do_relax = .false.;
               0  "]
               0  IF( do_relax ) [
               1      call relax(e_vac,k,iZ);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  subroutine egs_shellwise_photo;
               0  "******************************************************************"
               0  " Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
               0  " Shellwise implementation and      "
               0  "                                sampling optimizations            "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0  ;COMIN/PE-SHELL-DATA/;
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0  $REAL slope, logE, int_prob;
               0  $INTEGER zpos, ibsearch;
               0  data n_warning/0/;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  do_relax = .false.;
               0  IF( peig < $RELAX-CUTOFF ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
               2                      peig,' which is below the current min. energy of ',
               2                     $RELAX-CUTOFF,' keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  edep = pzero;
               0
               0  IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
               1                          " sample element and atomic shell for"
               1     j = -1;              " the interaction."
               1     IF( nne(medium) = 1 ) [
               2      iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
               2      IF( pe_nshell(zpos) > 0) [
               3        logE = log(peig);
               3        j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3      ]
               2     ]
               1     ELSE [
               2        $RANDOMSET br; logE = log(peig);
               2        "DO k=1,nne(medium) ["
               2        DO k=nne(medium),1,-1 [
               3            iz = int(pe_zsorted(k,medium)+0.5); zpos = pe_zpos(iZ);
               3            IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                $egs_info(*,' Error in egs_shellwise_photo: ');
               4                $egs_fatal(*,'   Atomic number of element ',k,
               4                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4            ]
               3            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3            slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
               3            slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               3            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
               3            br -= exp(int_prob);
               3            IF ( br <= 0 ) EXIT;
               3        ]
               2     ]
               1     " Now we know the atomic number (iZ) and the energy interval the "
               1     " photon energy is in (j). It is time to sample the shell the photon "
               1     " is interacting with. "
               1     IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
               1     [   "no atomic relaxation, create photo-electron"
               2           iq(np) = -1;
               2           e(np) = peig + prm;
               2     ]
               1     ELSE ["sample the shell the photon is interacting with"
               2        $RANDOMSET br; sigtot = 0;
               2        DO k=1,pe_nshell(zpos) [
               3            IF( peig > pe_be(zpos,k) ) [
               4              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
               4              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               4              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
               4              br -= exp(int_prob); sigtot += exp(int_prob);
               4              IF ( br <= 0 ) EXIT;
               4            ]
               3        ]
               2        IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
               3           iq(np) = -1;
               3           e(np) = peig + prm;
               3        ]
               2        ELSE[
               3           e_vac = pe_be(zpos,k);
               3           e(np) = peig - e_vac + prm; do_relax = .true.;
               3           iq(np) = -1;
               3        ]
               2     ]
               1  ]
               0  ELSE ["No atomic relaxations, just create photo-electron"
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  IF( do_relax ) [
               1      call egs_eadl_relax(iZ,k);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_read_shellwise_pe;
               0  "*************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-SHELLWISE-PE-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,l,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  $REAL      rest_xs($MXNE,$MXELEMENT);
               0  $REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
               0  $REAL      new_e($MXNE),deltaEb,slope;
               0  $INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
               0  character  data_dir*128,pe_sw_file*144;
               0
               0  $INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
               0  real*4    egs_read_real,e_r, e_old,sigma_r;
               0  integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
               0  $LOGICAL  is_open, is_there, shift_required;
               0
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0              ' M1',' M2',' M3',' M4',' M5',
               0              ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0
               0
               0
               0  $egs_info('(/a$)',
               0  ' Reading renormalized photoelectric cross sections ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';
               0
               0
               0  pe_sw_unit = egs_get_unit(0);
               0  IF( pe_sw_unit < 1 ) [
               1    $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
               1  ]
               0  open(pe_sw_unit,file=pe_sw_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=1,
               0       err=:no-pe-sw-file:);
               0  GOTO :read-pe-sw:;
               0  :no-pe-sw-file:
               0  $egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
               0             pe_sw_file);
               0  :read-pe-sw:
               0  is_open = .true.;
               0
               0
               0
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [
               2        pe_nshell(i*medio) = 0;
               2        pe_nge(i*medio) = 0;
               2        pe_zsorted(i,medio) = 0;
               2     ]
               1  ]
               0  DO l = 1,$MXELEMENT [
               1     pe_zpos(l) = -1;
               1     DO k = 1,$MXNE [
               2        pe_energy(k,l) = 0.0;
               2        DO m = 1,$MXPESHELL [
               3           pe_xsection(k,l,m) = 0.0;
               3        ]
               2     ]
               1     DO k = 1,$MXPESHELL [
               2        pe_be(l,k) = -99;
               2     ]
               1  ]
               0
               0
               0
               0
               0  curr_rec = 1; iZpos = 0;
               0  nz = egs_read_short(pe_sw_unit,curr_rec);
               0  "$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,medio-1 [
               3           DO k = 1, nne(j)[
               4             IF( iZ = pe_zsorted(k,j) ) [
               5                 is_there = .true.; EXIT;
               5             ]
               4           ]
               3        ]
               2        IF (is_there) NEXT;
               2        "Read data for this element"
               2        iZpos += 1; zread(iZpos) = iZ;
               2        pe_zpos(iZ) = iZpos;
               2        pos         = 3 + (iZ-1)*4;
               2        curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
               2        i_nge       = egs_read_short(pe_sw_unit,curr_rec);
               2        i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
               2        "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
               2        "  ' energy points and ',i_nshell,' shells');
               2        pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
               2        e_old = -1.0; ish = 0;
               2        DO j = 1,i_nge[
               3           e_r = egs_read_real(pe_sw_unit,curr_rec);
               3           sigma_r = egs_read_real(pe_sw_unit,curr_rec);
               3           pe_energy(j,iZpos) = e_r;
               3           pe_xsection(j,iZpos,0) = sigma_r;
               3           rest_xs(j,iZpos) = sigma_r;
               3           DO k = 1, i_nshell[
               4              sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
               4              pe_xsection(j,iZpos,k) = sigma_r;
               4              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;
               4
               4           ]
               3           "Extract binding energies from the data base"
               3           IF (e_r - e_old < 1e-15)[
               4              pe_be(iZpos,i_nshell-ish) = e_r;
               4              ish += 1;
               4           ]
               3           e_old = e_r;
               3
               3        ]
               2        "DO k = 1, i_nshell[
               2        "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
               2        "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
               2        "]
               2
               2     ]
               1  ]
               0  pe_ne = iZpos;
               0  "$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');
               0
               0
               0
               0
               0
               0
               0  "$egs_info(*,' Adjusting cross sections to new binding energies ...');
               0  DO i=1,pe_ne[
               1     iZ = zread(i);
               1     IF (pe_nshell(i) = 0)[
               2        DO j=1,pe_nge(i)[
               3           pe_energy(j,i) =  log(pe_energy(j,i));
               3        ]
               2        NEXT;
               2     ]
               1     "Shift energy scale for different binding energy sets"
               1     DO l=1,pe_nshell(i)[
               2        IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
               3             shift_required = .true.;
               3             deltaEb = binding_energies(l,iZ)-pe_be(i,l);
               3             "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
               3             "           'Eb_p_',labels(l),' = ',pe_be(i,l),
               3             "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
               3             "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
               3             "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
               3             "          );
               3        ]
               2        ELSE[shift_required =.false.;]
               2        is_there = .false.;
               2        DO j=1,pe_nge(i)[
               3           tmp_e(j,l)  = pe_energy(j,i);
               3           tmp_xs(j,l) = pe_xsection(j,i,l);
               3           IF ( shift_required &
               3                pe_energy(j,i) => pe_be(i,l) )[
               4              tmp_e(j,l) += deltaEb;
               4              "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
               4              "Determine edge position in energy array"
               4              IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               5                 ib(l) = j; is_there = .true.;
               5              ]
               4              "Update new energy grid"
               4              IF (l = 1)[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4              "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
               4              ELSE IF(j < ib(l-1))[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4           ]
               3        ]
               2        pe_be(i,l) = binding_energies(l,iZ);
               2     ]
               1     "Re-compute sub-shell xsections for new energy grid new_e"
               1     "Not needed for K shell"
               1     DO l=2,pe_nshell(i)[
               2        DO j=1,pe_nge(i)[
               3           IF ( new_e(j) >= pe_be(i,l-1) )[
               4              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
               4              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
               4              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = log(tmp_xs(m,l));
               4              pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
               4           ]
               3        ]
               2     ]
               1     "Re-compute total xsections for new energy grid new_e"
               1     "$egs_info(*,'-> Z = ',iZ);"
               1     DO j=1,pe_nge(i)[
               2        IF ( j < ib(pe_nshell(i)))[
               3           new_e(j) = pe_energy(j,i);
               3        ]
               2        m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
               2        slope = log(rest_xs(m+1,i)/rest_xs(m,i));
               2        slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
               2        pe_xsection(j,i,0)  = log(rest_xs(m,i));
               2        pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
               2        pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,0) += pe_xsection(j,i,l);
               3        ]
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0));
               2     ]
               1     "Normalize shell cross sections to total for sampling"
               1     "and update energy grid of ith element."
               1     " Prepare for log/log interpolation."
               1     DO j=1,pe_nge(i)[
               2        pe_energy(j,i) =  log(new_e(j));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
               3        ]
               2     ]
               1  ]
               0
               0  $egs_info('(a/)',' done');
               0
               0  IF( is_open ) close(pe_sw_unit);
               0  return;
               0  end;
               0
               0
               0  "******************************************************************"
               0  SUBROUTINE RELAX(energy,n,iZ);
               0  "******************************************************************"
               0  " Subroutine to fill a vacancy in shell n, element iZ              "
               0  " by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
               0  " Transitions between K,L1,L2,L3,average M,average N are taken into"
               0  " account. Particles with energies above the transport cut-offs    "
               0  " (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
               0  " particles is stored in EDEP.                                     "
               0  " In this version a global cut-off of 1 keV applies                "
               0  "  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
               0  "  1 keV will still be absorbed locally (due to lack of data)      "
               0  "                                                                  "
               0  " Version 1:  I. Kawrakow, December 1998                           "
               0  "******************************************************************"
               0  implicit none;
               0
               0  " Input variables "
               0  "================="
               0  $INTEGER n,iZ;
               0  $REAL    energy;  "
               0
               0  $declare_write_buffer;
               0
               0  " Local variables "
               0  "================="
               0  REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
               0                              "relaxation cascade                    "
               0
               0  $INTEGER vac_array($MXVAC), "array with shell vacancies            "
               0           n_vac,             "current number of vacancies           "
               0           shell;             "current shell                         "
               0  $INTEGER final,finala,      "code of final state                   "
               0           final1,final2,     "two vacancies in the final state in   "
               0                              "the case of Auger transitions         "
               0           iql,               "particle charge                       "
               0           irl;               "present region"
               0  $INTEGER first_transition($MXINTER),
               0           last_transition($MXINTER);
               0                              "first and last transition for a given "
               0                              "shell in the list of all possible     "
               0                              "transitions                           "
               0  $INTEGER final_state($MXTRANS);
               0             " final_state(i) is the final atomic state                "
               0             " after transition i coded as follows:                    "
               0             "   * fluorescence - final_state is the shell number      "
               0             "                    of the new vacancy                   "
               0             "   * Coster-Kronig - final_state is the shell number     "
               0             "                     of the new vacancy + 10             "
               0             "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
               0             "             are the shell numbers of the 2 new vacancies"
               0
               0  $INTEGER k, np_old, ip, iarg;
               0  $REAL    e_array($MXVAC),   "array with vacancy energies           "
               0           Ei,Ef,             "initial,final binding energies        "
               0           Ex,                "kinetic energy of emitted particle    "
               0           eta,               "a random number                       "
               0           e_check,           "energy conservation check             "
               0           min_E,ekcut,pkcut,elcut; "cut-off energies  "
               0
               0  $REAL    xphi,yphi,xphi2,yphi2,rhophi2,
               0           cphi,sphi;         "for azimuthal angle selection"
               0
               0  " Global EGS4 variables "
               0  "======================="
               0  $COMIN-RELAX;
               0  ;COMIN/RELAX-USER/;
               0
               0  data first_transition/1,20,27,33,38/;
               0  data last_transition/19,26,32,37,39/;
               0  data final_state/ "See the final_state definition above"
               0           4,3,5,6,                           " K-shell fluorescence    "
               0           202,302,402,404,403,303,           " K-shell Auger           "
               0           502,503,504,602,603,604,           " K-shell Auger           "
               0           505,605,606,                       " K-shell Auger           "
               0           13,14,                             " L1 Coster-Kronig        "
               0           5,6,                               " L1 fluorescence         "
               0           505,605,606,                       " L1 Auger                "
               0           14,                                " L2 Coster-Kronig        "
               0           5,6,                               " L2 fluorescence         "
               0           505,605,606,                       " L2 Auger                "
               0           5,6,                               " L3 fluorescence         "
               0           505,605,606,                       " L3 Auger                "
               0           6,                                 " M  fluorescence         "
               0           606/;                              " M  Auger                "
               0
               0  save first_transition,last_transition,final_state; "to avoid problems with "
               0                                                     "non-static compiler options"
               0
               0  IF (eadl_relax)[
               1     call egs_eadl_relax(iZ,n);
               1     return;
               1  ]
               0
               0  IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"
               0
               0  iz_relax = iZ;
               0  irl = ir(np);
               0  ekcut = ecut(irl)-rm; pkcut = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  IF( energy <= min_E ) [
               1      edep = edep + energy;  "We assume that edep is zeroed "
               1                          "(or set to the appropriate value) in the routine "
               1                          "calling RELAX "
               1      edep_local = energy;
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return;
               1  ]
               0
               0  " Set-up the array of vacancies for the relaxation cascade "
               0  n_vac = 1; vac_array(n_vac) = n; np_old = np;
               0  e_check = 0; e_array(n_vac) = energy;
               0
               0  :START: LOOP[     "Until no  >N-shell vacancies"
               1
               1      shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;
               1
               1      IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
               2          edep = edep + Ei;
               2
               2          edep_local = Ei;
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1
               1      "Set the relax_user common block variables, IK March 22 2004"
               1      ish_relax = shell; u_relax = Ei;
               1      IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
               2          IF( Ei > ekcut ) [
               3              np = np + 1;
               3              $CHECK-STACK(np,'RELAX');
               3              e(np) = Ei + prm; iq(np) = -1;
               3              $TRANSFER PROPERTIES TO (np) FROM (np-1);
               3              $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
               3              eta = (1-eta)*(1+eta);
               3              IF( eta > 1e-20 ) [
               4                  eta = Sqrt(eta);
               4                  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               4                  u(np) = eta*cphi; v(np) = eta*sphi;
               4              ]
               3              ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               3              $AUSCALL($AUGERTRA);
               3          ]
               2          ELSE             [
               3              edep = edep + Ei;
               3
               3              edep_local = Ei;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1      " Sample transition number for this vacancy "
               1      $RANDOMSET eta;
               1      DO k=first_transition(shell),last_transition(shell)-1 [
               2          eta = eta - relaxation_prob(k,iZ);
               2          IF( eta <= 0 ) EXIT;
               2      ]
               1      final = final_state(k); finala = final;
               1      IF( final < 100 ) [
               2          IF( final < 10 ) [ "fuorescence"
               3              iql = 0; elcut = pkcut;
               3          ]
               2          ELSE             [ "Coster-Kronig"
               3              final = final - 10;
               3              iql = -1; elcut = ekcut;
               3          ]
               2          Ef = binding_energies(final,iZ);
               2          Ex = Ei - Ef;
               2          n_vac = n_vac + 1;
               2          vac_array(n_vac) = final;
               2          e_array(n_vac) = Ef
               2      ]
               1      ELSE [  "Auger"
               2          final1 = final/100; final2 = final - final1*100;
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final1;
               2          e_array(n_vac) = binding_energies(final1,iZ);
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final2;
               2          e_array(n_vac) = binding_energies(final2,iZ);
               2          iql = -1;
               2          Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
               2          elcut = ekcut;
               2      ]
               1      IF( Ex <= elcut ) [ "Below cut-off"
               2          edep = edep + Ex;
               2
               2          IF( finala <  10 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ]
               2          ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ]
               1      ELSE [
               2          np = np + 1;
               2          $CHECK-STACK(np,'RELAX');
               2          iq(np) = iql;
               2          IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
               2          $TRANSFER PROPERTIES TO (np) FROM (np-1);
               2          $RANDOMSET eta;
               2          eta = 2*eta - 1;
               2          w(np) = eta;
               2          eta = (1-eta)*(1+eta);
               2          IF( eta > 1e-20 ) [
               3              eta = Sqrt(eta);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = eta*cphi;
               3              v(np) = eta*sphi;
               3          ]
               2          ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               2          IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
               2          ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
               2          ELSE                    [ $AUSCALL($AUGERTRA);  ]
               2      ]
               1  ]
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_init_relax;
               0  "*************************************************************************"
               0  " Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
               0  " data base was originally created by I. Kawrakow to be used with C++ user"
               0  " codes. It has been re-created using 4 bytes integers instead of using   "
               0  " optimized integer sizes to save space. It is now about 34% larger (760K)"
               0  " than before (557K). Reason for this was that some compilers need a switch"
               0  " to get it to read binary files on byte at a time. This would have been a"
               0  " nuisance for users when configuring the already complex system.         "
               0  "                                                                        "
               0  " The final relaxation state from radiative transitions assumes C-style  "
               0  " array indexing and hence needs to be increased by 1.                   "
               0  " Similarly, for non-radiative transitions, there is need to increase the"
               0  " codified value of the two electron states by 65. The reason is that the"
               0  " two transition states are encoded as 64*state1+state2. Because of the C"
               0  " style indexing, state1 and state2 must be increased by 1, increasing the"
               0  " above codified value by 65.                                            "
               0  "                                                                        "
               0  "Shell information for all media elements stored in one-dimensional arrays:"
               0  "                                                                        "
               0  " ish              => absolute shell index (1...shell_ntot)              "
               0  " shell_be(ish)    => shell binding energy                               "
               0  " shell_type(ish)  => shell type according to EADL notation              "
               0  " shell_Z(ish)     => Z of shell element                                 "
               0  " shell_num(ish)   =>  relative shell position within one element        "
               0  " shell_ntot       => total number of shells for all media elements      "
               0  " relax_first(ish) => initial absolute relaxation position               "
               0  " relax_ntran(ish) => number of transitions                              "
               0  " shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
               0  "                                                                        "
               0  "Transition information for all shells also stored in one-dimensional arrays:"
               0  "                                                                         "
               0  " transition index itran runs from 1...relax_ntot                         "
               0  " relax_prob(itran)  => transition probabilities                          "
               0  " relax_atbin(itran) => holds the alias indices                           "
               0  " relax_state(itran) => final relaxation state:                           "
               0  "                       radiative: relative shell position                "
               0  "                   non-radiative: relative position of shells(64*sh1+sh2)"
               0  "                                                                         "
               0  "                              Originally coded by IK in a standalone code"
               0  "                          Modified for use with EGSnrc by EMH, June 2011 "
               0  "                          Corrected bugs and commented by EMH, April 2012"
               0  "*************************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  character  data_dir*128,relax_file*144;
               0
               0  $INTEGER  ish,medio,iZ,ntran;
               0  $REAL     Ec, Pc, tmp, min_be, sumw,Ex;
               0  $LOGICAL  is_open, is_there;
               0  $REAL     wtmp($MAXTRANS);
               0  $INTEGER  itmp($MAXTRANS);
               0
               0  integer*4 pos, curr_rec, sh_eadl;
               0  integer*4 nz, nshell, tr_type;
               0  integer*4 ttype;
               0  real*4    be_r, prob_r;
               0
               0
               0  DO iZ=1,$MXELEMENT[
               1   DO k=1,$MXESHLL[
               2     shell_eadl(iZ,k) = -1;
               2   ]
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  min_be = $RELAX-CUTOFF;
               0  $egs_debug('(a)',' ************ relax_init **************** ');
               0  $egs_debug('(a,f10.7)',
               0          ' Minimum binding energy requiring relaxation data: ',min_be);
               0
               0
               0
               0
               0  $egs_info('(/a)',' Reading EADL relaxation data ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  relax_file = $cstring(data_dir) // 'relax.data';
               0
               0
               0  relax_unit = egs_get_unit(0);
               0  IF( relax_unit < 1 ) [
               1     $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
               1  ]
               0  open(relax_unit,file=relax_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
               0       err=:no-relax-file:);
               0  GOTO :read-relax:;
               0  :no-relax-file:
               0  $egs_fatal('(2a)','egs_init_relax: failed to open ',
               0             relax_file);
               0  :read-relax:
               0  is_open = .true.;
               0
               0
               0
               0  curr_rec = 1;
               0  read(relax_unit,rec=curr_rec) nz;
               0  "$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
               0  shell_ntot = 0;relax_ntot = 0;
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,shell_ntot [
               3           IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
               3        ]
               2        IF (is_there) NEXT;
               2        pos = iZ + 1;
               2        read(relax_unit,rec=pos) curr_rec;
               2        read(relax_unit,rec=curr_rec) nshell;
               2        IF( shell_ntot + nshell > $MAXSHELL ) [
               3           $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
               3                  shell_ntot + nshell,' (at least).',
               3                  ' Increase the parameter $MAXSHELL and retry ');
               3        ]
               2        $egs_info('(a,i3,a,i2,a)',
               2        '  Z = ',iZ,' has ',nshell,' shells');
               2        DO ish=shell_ntot+1,shell_ntot+nshell[
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) shell_type(ish);
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) ntran;
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;
               3
               3          shell_Z(ish) = iZ;
               3          shell_num(ish) = ish - shell_ntot;
               3          shell_eadl(iZ,shell_num(ish)) = ish;
               3          IF (binding_energies(shell_num(ish),iZ) > 0)[
               4             shell_be(ish) = binding_energies(shell_num(ish),iZ);
               4          ]
               3          ELSE IF( photon_xsections = 'epdl' )[
               4            "Use binding energies from relax.data below 1 keV"
               4             binding_energies(shell_num(ish),iZ) = shell_be(ish);
               4          ]
               3          DO k=1,ntran[
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) itmp(k);
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
               4
               4
               4
               4              IF (itmp(k)<64) [itmp(k) +=1;]
               4              ELSE            [itmp(k) += 65;]
               4          ]
               3          IF( shell_be(ish) < min_be ) [
               4              relax_first(ish) = -1;
               4              relax_ntran(ish) = -1;
               4          ]
               3          ELSE [
               4              sumw = 0;
               4              DO k=1,ntran [  sumw = sumw + wtmp(k); ]
               4              IF( sumw > 1 ) [
               5                  DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
               5              ]
               4              ELSE IF( sumw < 1 ) [
               5                  ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
               5              ]
               4              IF( relax_ntot + ntran > $MAXRELAX ) [
               5                 $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
               5                   relax_ntot + ntran,' (at least).',
               5                   ' Increase $MAXRELAX and retry ');
               5              ]
               4              relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
               4              call prepare_alias_histogram(ntran,wtmp,
               4                                   relax_atbin(relax_ntot+1));
               4              DO k=1,ntran [
               5                 j = relax_ntot + k;
               5                 relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
               5              ]
               4              relax_ntot = relax_ntot + ntran;
               4          ]
               3        ]
               2
               2        shell_ntot = shell_ntot + nshell;
               2
               2     ]
               1
               1  ]
               0  $egs_debug('(a,i4,a)',' There are ',
               0          shell_ntot,' shells in the list of shells ');
               0  $egs_info('(a/)',' ...... Done.');
               0
               0
               0  IF( is_open ) close(relax_unit);
               0  return;
               0
               0  stop;
               0  end;
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_warning('(3(a,f10.6),a,i2)',
            {  0         'Evac = ',Evac, ' Ef = ',Ef,
            {  0         "' Z = ',iZ,' Nvac = ',Nvac,"
            {  0         ' min_E = ', min_E,' iq = ',iqf);
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0  "***********************************************************************"
               0    subroutine egs_eadl_relax(iZ, shell_egs);
               0  "************************************************************************"
               0  " Subroutine, called from subroutine relax, to fill a vacancy in         "
               0  " shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
               0  " and Coster-Kronig electrons.  Uses EADL data.                          "
               0  " Results passed via variables in comins.                                "
               0  "   edep                                                                 "
               0  "   edep_local                                                           "
               0  "   e(np)                                                                "
               0  "                                                                        "
               0  " There are calls to ausgab with IARG values                             "
               0  "   24  A fluorescent transition just occurred                           "
               0  "   26  An Auger transition just occurred                                "
               0  "   32  Sub-threshold fluorescent transition just occurred               "
               0  "   33  Sub-threshold Auger transition just occurred                     "
               0  "                                                                        "
               0  " There is an inconsistency in the binding energies (BE) as COMPT uses   "
               0  " different BE (incoh.data)                                              "
               0  "                                                                        "
               0  " Explain need to reduce new_state by 1 below as alias sampling provides "
               0  " bin number from 1...nbin and not 0...nbin-1                            "
               0  "                                                                        "
               0  "                             Originally coded by IK in a standalone code"
               0  "                         Modified for use with EGSnrc by EMH, June 2011 "
               0  "                         Corrected bugs and commented by EMH, April 2012"
               0  "************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-EADL;
               0  ;COMIN/RELAX-USER/;
               0
               0  $REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
               0           cost,sint,cphi,sphi;
               0  "Ec      ecut as k.e. for current region"
               0  "Pc      pcut for current region"
               0  "min_E   the minimum energy for transitions to continue"
               0  "rnno    a random number"
               0  "Evac    binding energy of current vacancy"
               0  "Ef      the sum of the binding energies of the new vacancies"
               0  "Ef1     the first new binding energy of for non-radiative transitions"
               0  "Ef2     the second new binding energy of for non-radiative transitions"
               0  "Ex      the change in total binding energy"
               0  "Ecc     the cutoff energy (Ec or Pc)"
               0  "cost,sint,cphi,sphi variables for calculating particle direction"
               0
               0  $INTEGER  shell, shell_egs, iZ, iarg;
               0  "shell       number in master eadl list"
               0  "shell_egs   shell number in current element"
               0  "iZ          atomic number of element"
               0
               0  $INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
               0  "irl           current region"
               0  "vacs($MAXVAC) array of vacancy shell numbers"
               0  "nvac          current number of vacancies in vacs"
               0  "vac           shell number of current vacancy"
               0  "new_state     the state number that represents the new vacancy"
               0  "iqf           the charge of the emitted relaxation particle"
               0  "np_save       the stack index of the particle inducing in relaxations"
               0  "new1          the first new vacancy for non-radiative transitions"
               0  "new2          the second new vacancy for non-radiative transitions"
               0
               0  $INTEGER sample_alias_histogram;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  shell = shell_eadl(iZ,shell_egs);
               0  IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"
               0
               0  irl = ir(np);
               0  Ec = ecut(irl) - rm;
               0  Pc = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
               0  "store some information in comin RELAX-FOR-USER.  This just duplicates"
               0  "various pieces of info so the user can access them."
               0  rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
               0  rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
               0  rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
               0  rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
               0  rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
               0  "
               0  "Local energy deposition for vacancies below L3 shell."
               0  "Added here for consistency in algorithm for as long as"
               0  "<M> and <N> shells considered instead of proper shells."
               0  "AUSGAB call should be updated when charge of particle"
               0  "creating vacancy becomes available."
               0  IF (shell_egs > 4 & ~mcdf_pe_xsections) [
               1      edep = Evac;        "add energy of vacancy to edep"
               1      edep_local = Evac;  "set value of edep_local to energy of vacancy"
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
               1  ]
               0
               0  vac = shell; Nvac = 0; np_save = np;
               0  LOOP [ "from here to end of routine over all vacancies created"
               1
               1      "check if energy of vacancy < cutoff OR no transitions from this shell"
               1      IF( Evac < min_E | relax_ntran(vac) < 1 ) [
               2          edep += Evac;         "add energy of vacancy to edep"
               2          edep_local = Evac;    "set value of edep_local to energy of vacancy"
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
               2      ]
               1
               1      "prepare_alias_histogram is called from subroutine egs_init_relax and"
               1      "sample_alias_histogram uses the array of bin probabilities and bin"
               1      "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
               1      "to return the bin which has been sampled, i.e. new_state"
               1      "relax_ntran(vac) tells how many transitions are available"
               1      new_state = sample_alias_histogram(relax_ntran(vac),
               1                    relax_prob(relax_first(vac)),
               1                    relax_atbin(relax_first(vac)));
               1      IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
               2                            "EADL was < 1. In this case the entire energy is"
               2                            "given to an electron and no new vacancy is created"
               2          Ef = 0;
               2          iqf = -1;
               2          Ecc = Ec;
               2      ]
               1      ELSE[
               2          new_state = relax_state(relax_first(vac)+new_state-1);
               2          IF( new_state <= 64 ) [ "It was a radiative transition (fluorescence)"
               3            iqf = 0;
               3            new_state += vac - shell_num(vac);
               3            Ef = shell_be(new_state);
               3            Nvac += 1;
               3            vacs(Nvac) = new_state;
               3            Ecc = Pc;
               3          ] "end of fluorescence block"
               2          ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
               3            iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
               3            new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
               3            Ef1 = shell_be(new1); Ef2 = shell_be(new2);
               3            Nvac += 1; vacs(Nvac) = new1;
               3            Nvac += 1; vacs(Nvac) = new2;
               3            Ef = Ef1 + Ef2; Ecc = Ec;
               3          ] "end Auger or Coster-Kronig block"
               2      ]
               1      Ex = Evac - Ef;
               1      edep_local = 0;
               1      IF( Ex > Ecc ) [
               2          np += 1; $CHECK-RELAX-STACK(np,'new_relax');
               2          iq(np) = iqf;
               2          $TRANSFER PROPERTIES TO (np) FROM (np_save);
               2          $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
               2          IF( sint > 0 ) [
               3              sint = sqrt(sint);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
               3          ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
               2          rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
               2          rfu_E = shell_be(vac);
               2          IF( iqf = 0 ) [
               3              e(np) = Ex; $AUSCALL($FLUORTRA);
               3          ]
               2          ELSE [
               3              e(np) = Ex + rm; $AUSCALL($AUGERTRA);
               3          ]
               2      ] ELSE [ "Ex <= Ecc"
               2          edep += Ex;
               2
               2          IF( iqf = 0 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ] ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ] "end Ex <= Ecc block"
               1      :VACANCY:;
               1      IF( Nvac = 0 ) EXIT;
               1      "get next vacancy to process"
               1      vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
               1  ] "end of main loop"
               0  return;
               0  end;
               0  ;
               0
               0  "***************************************************************************"
               0  "     Triplet production stuff                                              "
               0  "***************************************************************************"
               0
               0  REPLACE {$N_TRIPLET_DATA} WITH {55}
               0  REPLACE {$N_ELEMENT} WITH {100}
               0  ;
               0  subroutine init_triplet;
               0  implicit none;
               0  $declare_max_medium;
               0  $COMIN-INIT-TRIPLET;
               0  $REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
               0         sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
               0         sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
               0         as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
               0         ds($N_TRIPLET_DATA);
               0  character*128  triplet_data_file;
               0  $INTEGER want_triplet_unit, triplet_unit, triplet_out;
               0  $INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
               0  $REAL    logE, f_new, f_old, spline;
               0
               0  IF( itriplet = 0 ) return;
               0  $set_string(triplet_data_file,' ');
               0  triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
               0                      'triplet.data';
               0  want_triplet_unit = 63;
               0  triplet_unit = egs_get_unit(want_triplet_unit);
               0  IF( triplet_unit < 1 ) [
               1      $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
               1  ]
               0  open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
               0  $egs_info('(a,$)',' init_triplet: reading triplet data ... ');
               0  read(triplet_unit,*) ntrip;
               0  IF( ntrip > $N_TRIPLET_DATA ) [
               1      $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
               1  ]
               0  read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
               0  DO iel=1,$N_ELEMENT [
               1      read(triplet_unit,*);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_pair(iel,i),i=1,ntrip);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_triplet(iel,i),i=1,ntrip);
               1  ]
               0  $egs_info(*,'OK');
               0  ifirst = 0;
               0  DO i=1,ntrip [
               1      IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
               1      energies(i) = log(energies(i));
               1  ]
               0  log_4rm = log(4*rm);
               0  energies(ifirst-1) = log_4rm;
               0  dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
               0  dli_triplet = 1/dl_triplet;
               0  bli_triplet = 1 - log_4rm/dl_triplet;
               0
               0  DO imed = 1, nmed [
               1
               1      $egs_info('(a,i3,a,$)',
               1        '   Preparing triplet fraction data for medium ',imed,' ... ');
               1      iz1 = zelem(imed,1) + 0.1;
               1      DO i=1,ntrip [
               2          sigp(i) = pz(imed,1)*sig_pair(iz1,i);
               2          sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
               2          DO iel=2,nne(imed) [
               3              izi = zelem(imed,iel) + 0.1;
               3              sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
               3              sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
               3          ]
               2      ]
               1
               1      DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
               1      f_triplet(1) = 0;
               1      call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);
               1
               1      logE = log_4rm; f_old = 0;
               1      DO i=1, $MAX_TRIPLET-1 [
               2          logE = logE + dl_triplet;
               2          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
               2          a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
               2          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
               2          f_old = f_new;
               2      ]
               1      $egs_info(*,'OK');
               1
               1  ]
               0  close(triplet_unit);
               0  return;
               0
               0  :no-triplet-file:;
               0  $egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
               0               triplet_data_file(:lnblnk1(triplet_data_file)));
               0
               0  :error_triplet_data:;
               0  $egs_fatal(*,' init_triplet: error while reading triplet data ');
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE EDGSET(NREGLO,NREGHI);
               0  "******************************************************************"
               0  " SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
               0  " and proper handling of photo-electric absorption
               0  "******************************************************************"
               0  " Programmer:   I. Kawrakow, (NRC)                                 "
               0  "******************************************************************"
               0  "                                                                  "
               0  "  Input:  NREGLO and NREGHI, not needed but left there for        "
               0  "                             compatibility with older user codes  "
               0  "
               0  "  This routine is called from HATCH, it checks whether one of the "
               0  "  elements of IEDGFL has been set to an integer number between    "
               0  "  1 and 100 and if so reads in photo-absorption and relaxation    "
               0  "  data. Note that the array IEDGFL, which used to be the          "
               0  "  `effecvtive' atomic number of a medium is not used for any      "
               0  "  purpose other than to indicate that relaxations are requested   "
               0  "  (if non-zero).
               0  "******************************************************************"
               0  "                                                                  "
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EDGE,X-OPTIONS,EGS-IO/;
               0
               0  "Input variables"
               0  integer  NREGLO,NREGHI;
               0
               0  $INTEGER i,j,k,jj,iz;
               0  logical  do_relax;
               0  logical  got_data;
               0  save     got_data;
               0  data     got_data/.false./;
               0
               0  IF( got_data ) return;
               0     "EDGSET is now called from HATCH. In older user codes it was called
               0     "from within the user code. If this happens, and the data is already
               0     "available, we don't need to read it again. That's why the above
               0     "statement.
               0
               0  $egs_info('(a/,a)',
               0            'Output from subroutine EDGSET:',
               0            '==============================');
               0
               0  $need_relaxation_data(do_relax);
               0  IF( ~do_relax ) [
               1
               1      IF(eadl_relax)[
               2          $egs_fatal('(a,/a)',
               2                     'You must turn ON atomic relaxations when requesting',
               2                     'detailed atomic relaxation (eadl_relax=true)!');
               2      ]
               1      $egs_info('(a/)',' Atomic relaxations not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(a/)',' Atomic relaxations requested! ');
               0
               0  $egs_info('(a$)',' Reading simplified photo-absorption data .....');
               0
               0  got_data = .true.;
               0  rewind($PHOTOUNIT);
               0
               0  DO i=1,$MXELEMENT
               0  [
               1      IF (eadl_relax)[
               2         "Skip, using binding_energies from *_photo.data file
               2         read($PHOTOUNIT,*);
               2      ]
               1      ELSE[
               2         read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
               2         DO k=1,$MXSHELL [
               3            binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
               3         ]
               2      ]
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT
               0  [
               1      read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
               1      interaction_prob($MXSHELL,i)=1.01;
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  $egs_info('(/a$)',' Reading simplified relaxation data .....');
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
               1  ]
               0  $egs_info('(a)',' Done');
               0  $egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
               0  rewind($PHOCSUNIT);
               0  DO i=1,$MXELEMENT [
               1      read($PHOCSUNIT,*) j,edge_number(i);
               1      DO j=1,edge_number(i) [
               2          read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
               2                             edge_d(j,i),edge_energies(j,i);
               2      ]
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  IF (eadl_relax)[
               1   call egs_init_relax;
               1  ]
               0
               0  RETURN;
               0  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PHOTON(IRCODE);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE; "1 => normal return"
               0
               0  $COMIN-PHOTON;   "default replacement produces the following:
               0                   "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
               0                   "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PHOTON;
               0
               0
               0  IRCODE=1;"set up normal return"
               0  PEIG=E(NP);
               0  EIG=PEIG; "energy of incident gamma"
               0  IRL=IR(NP);
               0  $start_new_particle;
               0
               0  IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               0
               0  :PNEWENERGY:
               0  LOOP["enter this loop for each photon with new energy"
               1
               1  IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"
               1
               1  GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"
               1
               1  "   here to sample no. mfp to transport before interacting"
               1
               1  $SELECT-PHOTON-MFP;
               1  " DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
               1  "                                      DPMFP=-LOG(RNNO35);"
               1  "NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
               1  "       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."
               1
               1  IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"
               1
               1  :PNEWMEDIUM:
               1  LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
               2  IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
               3  $EVALUATE GMFPR0 USING GMFP(GLE);]
               2
               2  :PTRANS:
               2  LOOP["PHOTON TRANSPORT LOOP"
               3  IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
               3  ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
               4  GMFP=GMFPR0/RHOF;
               4  $RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
               4  "Ali:photonuc, 1 line"
               4  $PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
               4  TSTEP=GMFP*DPMFP;]
               3  "   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
               3  IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
               3  IDISC=0;"ASSUME PHOTON NOT DISCARDED"
               3  USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
               3  TUSTEP=USTEP;
               3
               3  "IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
               3  $CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"
               3
               3
               3  "   NOW CHECK FOR USER DISCARD REQUEST"
               3  IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
               4  GO TO :USER-PHOTON-DISCARD:;]
               3
               3  VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
               3  TVSTEP=VSTEP;
               3  EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"
               3
               3  x_final = x(np) + u(np)*vstep;
               3  y_final = y(np) + v(np)*vstep;
               3  z_final = z(np) + w(np)*vstep;
               3
               3  $AUSCALL($TRANAUSB);
               3
               3  "   TRANSPORT THE PHOTON"
               3  x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3  DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
               3  IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
               3  IROLD=IR(NP); "SAVE PREVIOUS REGION"
               3
               3  MEDOLD=MEDIUM;
               3  IF (IRNEW.NE.IROLD) ["REGION CHANGE"
               4    $photon_region_change;
               4  ]
               3
               3  "   AFTER TRANSPORT CALL TO USER"
               3  $AUSCALL($TRANAUSA);
               3  "oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
               3  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               3
               3  "   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
               3  "   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
               3  IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;
               3
               3  IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;
               3
               3  IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
               4  EXIT :PNEWMEDIUM:;]
               3  ]REPEAT ":PTRANS: LOOP"
               2
               2  ]REPEAT ":PNEWMEDIUM: LOOP"
               1
               1
               1  "   IT IS FINALLY TIME TO INTERACT."
               1  "   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
               1  $RAYLEIGH-SCATTERING;
               1  "Ali:photonuclear, 1 line"
               1  $PHOTONUCLEAR;
               1  $RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
               1  "   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
               1  $EVALUATE GBR1 USING GBR1(GLE);
               1  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
               2      $AUSCALL($PAIRAUSB);
               2      CALL PAIR;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PAIR;
               2      $AUSCALL($PAIRAUSA);
               2      IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
               2      ELSE [ "this may happen if pair electrons killed via Russian Roulette"
               3          goto :PAIR-ELECTRONS-KILLED:;
               3      ]
               2  ]
               1  "GBR2=(PAIR+COMPTON)/GTOTAL"
               1  $EVALUATE GBR2 USING GBR2(GLE);
               1  IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
               2      $AUSCALL($COMPAUSB);
               2      CALL COMPT;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-COMPT;
               2      $AUSCALL($COMPAUSA);
               2      IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
               2  ]
               1  ELSE["IT WAS PHOTOELECTRIC EFFECT"
               2      $AUSCALL($PHOTOAUSB);
               2      CALL PHOTO;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PHOTO;
               2      IF (NP = 0 | NP < NPOLD ) [RETURN;]
               2        "The above may happen if Russian Roulette is on"
               2        "NP<NPOLD means that only electrons were created in the interaction"
               2        "and that all of them were killed. Hence, the top particle on the "
               2        "stack is from a previous interaction and may be in another region"
               2        "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
               2        "a return to shower so that ELECTR or PHOTON are properly re-entered."
               2        "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
               2        "wrong dose with brems splitting and Russian Roulette on in a low "
               2        "energy calculation."
               2
               2      $AUSCALL($PHOTOAUSA);
               2      IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
               2  ] "END OF PHOTO ELECTRIC BLOCK"
               1
               1  :PAIR-ELECTRONS-KILLED:
               1
               1  "   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
               1  PEIG=E(NP);
               1  EIG=PEIG;
               1  IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
               1  ]REPEAT ":PNEWENERGY: LOOP"
               0
               0  "   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "PHOTON CUTOFF ENERGY DISCARD SECTION         "
               0  "---------------------------------------------"
               0  :PCUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
               1  ] ELSE [ IDR=$EGSCUTAUS; ]
               0  EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
               0  $PHOTON-TRACK-END;
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "User requested photon discard section        "
               0  "---------------------------------------------"
               0  :USER-PHOTON-DISCARD:
               0  EDEP=PEIG;
               0  $AUSCALL($USERDAUS);
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "END OF SUBROUTINE PHOTON"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  $REAL EI,      "initial shower energy"
               0        XI,YI,ZI,"initial co-ordinates"
               0        UI,VI,WI,"initial direction cosines"
               0        WTI;     "initial weight"
               0
               0  $INTEGER
               0        IQI,     "initial particle charge"
               0        IRI;     "initial region number"
               0
               0  "Local variables"
               0  DOUBLE PRECISION
               0        DEG,    "energy for pi-zero option"
               0        DPGL,   "angle factor for pi-zero option"
               0        DEI,    "incident energy for pi-zero option"
               0        DPI,    "intermediate factor for pi-zero option"
               0        DCSTH,  "random number for pi-zero option"
               0        DCOSTH, "cos(theta) for pi-zero option"
               0        PI0MSQ; "pi-zero mass squared (in MeV**2)"
               0
               0  $REAL DNEARI, "initial distance to closest boundary"
               0        CSTH;   "random number for pi-zero option"
               0
               0  $INTEGER
               0        IRCODE; "status returned by ELECTR or PHOTON"
               0
               0  DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"
               0
               0  NP=1; NPold = NP;      "Set the old stack counter"
               0  DNEARI=0.0;
               0  IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
               0  $TRANSFER PROPERTIES TO (1) FROM I;
               0
               0  IF (IQI = 2) ["PI-ZERO OPTION"
               1    "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
               1    "                  noted by      Dr.  Muroyama at Nagoya University
               1    IF(EI**2 <= PI0MSQ) [
               2       $egs_fatal('(//a/,a,g15.5,a)',
               2       ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
               2       ' but the total energy was too small (EI=',EI,' MeV)');
               2    ]
               1    $RANDOMSET CSTH;
               1    DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
               1    DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(1)=0; E(1)=DEG/2.;
               1    CALL UPHI(2,1);
               1    NP=2;
               1    DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(2)=0; E(2)=DEG/2.;
               1    CALL UPHI(3,2);
               1  ]"end of pi-zero option"
               0
               0  LOOP [
               1      ;
               1      IF( np <= 0 ) EXIT;
               1      IF( iq(np) = 0 ) [ call photon(ircode); ]
               1      ELSE             [ call electr(ircode); ]
               1
               1  ]
               0
               0  RETURN;
               0  "end of subroutine shower"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE UPHI(IENTRY,LVL);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
               0  "   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
               0  "   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
               0  "   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  integer  IENTRY,LVL; "entry switches"
               0
               0  "Local variables"
               0  $REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
               0        RNNO38, "random number for azimuthal angle selection"
               0        PHI,    "azimuthal scattering angle"
               0        CPHI,   "5/2*pi-PHI"
               0        A,B,C,  "direction cosines before rotation"
               0        SINPS2, "SINPS2=A*A+B*B"
               0        SINPSI, "Sqrt(SINPS2)"
               0        US,VS,  "x- and y- component of scattering vector"
               0        SINDEL,COSDEL;
               0                "aux. variables for the rotation algorithm"
               0
               0  $INTEGER
               0        IARG,   "index for AUSGAB"
               0        LPHI,LTHETA,LCTHET,LCPHI;
               0                "indeces for sine table"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0  save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;
               0
               0  $AUSCALL($UPHIAUSB);
               0  GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
               0  "   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;
               0
               0  :UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
               0          "TABLE LOOK-UP"
               0  $SET INTERVAL THETA,SINC;
               0  $EVALUATE SINTHE USING SIN(THETA);
               0  CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
               0  $EVALUATE COSTHE USING SIN(CTHET);
               0
               0  "   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
               0  "   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
               0  "   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
               0  "   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "
               0
               0  :UPHI2:;
               0
               0  " It is much faster to use the box method for azimuthal angle selection"
               0  " than the following                                                   "
               0  " $RANDOMSET RNNO38;
               0  " PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
               0  " $EVALUATE SINPHI USING SIN(PHI);
               0  " CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
               0  " $EVALUATE COSPHI USING SIN(CPHI);
               0  $SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);
               0
               0  "   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
               0  "   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
               0  "   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
               0  "   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
               0  "   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
               0  "   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
               0  "   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
               0  "   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
               0  "   SO THAT IT CAN BE USED ON BOTH CALLS."
               0
               0  "   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
               0  "   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
               0  "   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
               0  "   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."
               0
               0  :NRK:
               0  GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
               0  "   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;
               0
               0  :OLD-PARTICLE:
               0  A=U(NP);B=V(NP);C=W(NP);
               0  GO TO :ADJUST:;
               0
               0  :BREMS-GAMMA:
               0  A=U(NP-1);B=V(NP-1);C=W(NP-1);
               0
               0  :NEW-PARTICLE:
               0  $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
               0
               0  "   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
               0  "   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
               0  "   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "
               0
               0  :ADJUST:
               0  SINPS2=A*A+B*B;
               0  "   If SINPS2 is small, no rotation is needed    "
               0  IF (SINPS2.LT.1.0E-20)["small polar angle case"
               1     U(NP)=SINTHE*COSPHI;
               1     V(NP)=SINTHE*SINPHI;
               1     W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
               1  ] "end small polar angle case"
               0  ELSE["large polar angle case"
               1     SINPSI=SQRT(SINPS2);
               1     US=SINTHE*COSPHI;
               1     VS=SINTHE*SINPHI;
               1     SINDEL=B/SINPSI;
               1     COSDEL=A/SINPSI;
               1     U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
               1     V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
               1     W(NP)=-SINPSI*US+C*COSTHE;
               1  ]"end large polar angle case"
               0
               0  $AUSCALL($UPHIAUSA);
               0
               0  RETURN;
               0
               0  :ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
               0  $egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);
               0
               0  "END OF SUBROUTINE UPHI"    END;
               0
               0  ;
1              0  %E
               0  "*************************************************************************
               0  "
               0  " The following is a set of macros and subroutines that implement
               0  " bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
               0  " (which are the basis for ICRU radiative stopping powers, into the
               0  " EGSnrc environment) or the NRC cross sections, which are essentially
               0  " the same as NIST, but with corrections to the electron-electron
               0  " contribution (corrections are only significant for low values of
               0  " atomic number Z and low values of the emitted photon energy k.
               0  "
               0  " In order to use it, you have to `turn on' this option by
               0  " setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
               0  " original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
               0  " data (nrc_brems.data).
               0  "
               0  " If this option is turned on, subroutine HATCH will call
               0  " subroutine init_nist_brems.
               0  " In init_nist_brems the NIST cross sections are read in,
               0  " total bremsstrahlung cross sections are calculated using
               0  " 64 point Gauss-Legendre quadrature, the interpolation arrays
               0  " that are used for total cross sections and brems fraction interpolations
               0  " (esig0, esig1, ebr10, ebr11               for electrons)
               0  " (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
               0  " are updated and alias sampling tables for rapid sampling of brems
               0  " energies are created. These alias sampling tables are then used
               0  " during the simulation in subroutine BREMS.
               0  " Be aware that there is a slight inconsistency when using this option
               0  " as resttricted radiative stopping powers used are the ones coming
               0  " from PEGS and so, they are calculated using Bethe-Heitler.
               0  " This will not matter at all if
               0  "   - AP is much smaller than the electron energy
               0  "       and/or
               0  "   - the restricted radiative stopping power is much smaller
               0  "     then the restricted collision stopping power
               0  " Both conditions are usually satisfied.
               0  "
               0  " I. Kawrakow, NRC, January 2000.
               0  "
               0  " Added NRC brems cross-sections
               0  " F. Tessier, NRC, August 2007.
               0  "
               0  "****************************************************************************
               0
               0  subroutine init_nist_brems;
               0  "**************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL    energy_array($MXBREN),x_array($MXBRXX),
               0           cs_array($MXBREN,$MXBRXX,$MXBREL);
               0  $REAL    xi_array($MXBRXX);
               0  real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);
               0
               0  $INTEGER nmix,kmix,i,n,k,j,ii;
               0  $INTEGER ngauss,i_gauss;
               0  $INTEGER lnblnk1,egs_get_unit;
               0  $INTEGER ifirst,ilast,nener,neke,leil;
               0
               0  $REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
               0  $REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
               0  $REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
               0  $REAL    Z,sumA;
               0  $REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
               0  $REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
               0           sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
               0  $INTEGER iz;
               0  $REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
               0  $INTEGER ndat,k_max_error;
               0  character tmp_string*512, tmp1_string*512;
               0  integer  itmp;
               0
               0  $declare_write_buffer;
               0
               0  $REAL amu;
               0  parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
               0                                "to cm^2/g"
               0  $LOGICAL ex,is_opened;
               0  $declare_max_medium;
               0  $COMIN-INIT-NIST-BREMS;
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  IF( ibr_nist = 1 ) [
               1      $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE [
               1      $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
            '  1      ibr_nist = ', ibr_nist);
               1  ]
               0
               0  "Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
               0  "
               0  rewind($NIST-DATA-UNIT);
               0  read($NIST-DATA-UNIT,*);
               0  read($NIST-DATA-UNIT,*) nmix,kmix;
               0  IF (kmix > $MXBRXX) [
               1      $egs_fatal(*,' init_nist_brems: to many k values in data file!');
               1  ]
               0  IF (nmix > $MXBREN) [
               1      $egs_fatal(*,' init_nist_brems: to many T values in data file!');
               1  ]
               0
               0  read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
               0  DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
               0  read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
               0  read($NIST-DATA-UNIT,*);
               0  DO i=1,$MXBREL [
               1      read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
               1  ]
               0  close($NIST-DATA-UNIT);
               0
               0  DO k=1,kmix [
               1      xi_array(k)=Log(1-x_array(k)+1e-6);
               1      IF( fool_intel_optimizer ) [
               2          $egs_info(*,'xi_array(k): ',xi_array(k));
               2      ]
               1  ]
               0
               0  "Get abscissas and weights for Gauss-Legendre quadrature"
               0  "
               0  ngauss = $MXGAUSS;
               0  call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);
               0
               0  "Calculate total brems cross sections and sampling tables"
               0  "for all media                                           "
               0
               0  $egs_info(*,' ');
               0  IF (ibr_nist = 1) [
               1  $egs_info(*,'Using NIST brems cross sections! ');
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $egs_info(*,'Using NRC brems cross sections! ');
               1  ]
               0  $egs_info(*,' ');
               0  DO medium=1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      $egs_info(*,' Initializing brems data for medium ',medium,'...');
               1      emin = max(ae(medium) - rm, ap(medium));
               1      DO i=1,nmix [
               2          IF( energy_array(i) >= emin ) EXIT;
               2      ]
               1      ifirst = i;
               1      DO i=nmix,1,-1 [
               2          IF( energy_array(i) < ue(medium) - rm ) EXIT;
               2      ]
               1      ilast = i+1;
               1      IF( ifirst < 1 | ilast > nmix ) [
               2          $egs_info(*,' init_nist_brems: data available only for ');
               2          $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
               2          $egs_info(*,' will use spline interpolations to get cross ');
               2          $egs_info(*,' sections beyond the available data but this may');
               2          $egs_info(*,' produce nonsense!');
               2          IF( ifirst < 1 ) ifirst=1;
               2          IF( ilast > nmix ) ilast = nmix;
               2      ]
               1      DO i=ifirst,ilast [
               2          ii = i+1 - ifirst;
               2          ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
               2          sumA = 0;
               2          DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
               2          sumA = sumA*amu;
               2          DO k=1,kmix [
               3              cs(ii,k) = 0;
               3              DO j=1,NNE(medium) [
               4                  Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
               4                  cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
               4              ]
               3              csx(k) = Log(cs(ii,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " Integrate
               2          "
               2          cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
               2          DO i_gauss = 1,ngauss [
               3              xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
               3              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               3              cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
               3          ]
               2      ]
               1      nener = ilast - ifirst + 1;
               1      call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
               1      "
               1      " Now replace the PEGS cross sections "
               1      "
               1      neke = meke(medium);
               1      sigee = 1E-15; sigep = 1E-15;
               1      DO i = 1,neke [
               2          eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
               2          leil = i;
               2          beta2 = ei*(ei+2*rm)/(ei+rm)**2;
               2          IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
               2          ELSE [
               3              sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
               3              sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
               3          ]
               2          $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
               2          $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
               2                                           " then the brems cross section "
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( i > 1 ) [
               3              si_esig = si1_esig;
               3              si_ebr1 = si1_ebr1;
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3              esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
               3              esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
               3              ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
               3              ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3          ]
               2
               2          "
               2          " Positrons "
               2          "
               2          $EVALUATE sigt USING psig(eil);
               2          $EVALUATE ebr1 USING pbr1(eil);
               2          $EVALUATE ebr2 USING pbr2(eil);
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( ebr2 > 1 ) ebr2 = 1;
               2          IF( ebr2 < 0 ) ebr2 = 0;
               2          sig_bhabha = sigt*(ebr2 - ebr1);
               2          IF( sig_bhabha < 0 ) sig_bhabha = 0;
               2          IF( i > 1 ) [
               3              si_psig = si1_psig;
               3              si_pbr1 = si1_pbr1;
               3              si_pbr2 = si1_pbr2;
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3              psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
               3              psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
               3              pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
               3              pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
               3              pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
               3              pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3          ]
               2          $EVALUATE ededx USING ededx(eil);
               2          sige = si1_esig/ededx;
               2          IF( sige > sigee ) sigee = sige;
               2          $EVALUATE ededx USING pdedx(eil);
               2          sige = si1_psig/ededx;
               2          IF( sige > sigep ) sigep = sige;
               2      ]
               1      esig1(neke,medium) = esig1(neke-1,medium);
               1      esig0(neke,medium) = esig0(neke-1,medium);
               1      ebr11(neke,medium) = ebr11(neke-1,medium);
               1      ebr10(neke,medium) = ebr10(neke-1,medium);
               1      psig1(neke,medium) = psig1(neke-1,medium);
               1      psig0(neke,medium) = psig0(neke-1,medium);
               1      pbr11(neke,medium) = pbr11(neke-1,medium);
               1      pbr10(neke,medium) = pbr10(neke-1,medium);
               1      pbr21(neke,medium) = pbr21(neke-1,medium);
               1      pbr20(neke,medium) = pbr20(neke-1,medium);
               1      $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
               1      esig_e(medium) = sigee; psig_e(medium) = sigep;
               1      IF( sigee > esige_max ) esige_max = sigee;
               1      IF( sigep > psige_max ) psige_max = sigep;
               1
               1      "
               1      " Now prepare the arrays for brems sampling
               1      "
               1      nb_emin(medium) = energy_array(ifirst);
               1      IF( nb_emin(medium) <= ap(medium) ) [
               2          nb_emin(medium) = energy_array(ifirst+1);
               2      ]
               1      nb_emax(medium) = energy_array(ilast);
               1      nb_lemin(medium) = log(nb_emin(medium));
               1      nb_lemax(medium) = log(nb_emax(medium));
               1      nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
               1      nb_dlei(medium) = 1/nb_dle(medium);
               1      "
               1      eil = nb_lemin(medium) - nb_dle(medium);
               1      DO i=1,$MXBRES [
               2          eil = eil + nb_dle(medium); ei = exp(eil);
               2          DO ii=1,nener [
               3              IF( ei < ee(ii) ) EXIT;
               3          ]
               2          ii = ii-1;
               2          IF( ii < 1) ii = 1;
               2          IF( ii > nener-1 ) ii = nener-1;
               2          "
               2          " ple and qle are energy interpolation coefficients
               2          "
               2          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
               2          DO k=1,kmix [
               3              csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " fill the abscissas for this energy
               2          "
               2          x = ap(medium)/ei; aux = -log(x);
               2          xi = log(1 - x+1e-6);
               2          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               2          nb_xdata(0,i,medium) = 0;
               2          nb_fdata(0,i,medium) = exp(res);
               2
               2          DO k=1,kmix [
               3              IF( x_array(k) > x ) EXIT;
               3          ]
               2          IF( k > kmix ) k = kmix;
               2          ndat = 0;
               2          DO j=k+1,kmix-1 [
               3              ndat = ndat+1;
               3              nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
               3              nb_fdata(ndat,i,medium) = exp(csx(j));
               3              IF( fool_intel_optimizer ) [
               4                  $egs_info(*,'nb_xdata(ndat,i,medium): ',
               4                          nb_xdata(ndat,i,medium));
               4              ]
               3          ]
               2          ndat = ndat+1;
               2          nb_xdata(ndat,i,medium) = 1;
               2          nb_fdata(ndat,i,medium) = exp(csx(kmix));
               2          "
               2          " Now expand the arrays by filling intermediate points
               2          " at the positions that show the maxium relative error
               2          " when using linear interpolation in x.
               2          " If arrays were allocated dynamically one could use
               2          " a certain condition to stop the iteration but in our case
               2          " memory is allocated anyway and so we use the maximum
               2          " space provided
               2          "
               2          IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
               2          LOOP [
               3              x_max_error = 0; f_max_error = 0; k_max_error = 0;
               3              max_error = 0;
               3              DO k=0,ndat-1 [
               4                  x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
               4                  f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
               4                  xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
               4                  res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               4                  res = exp(res);
               4                  error = abs(1-f/res);
               4                  IF( error > max_error ) [
               5                      x_max_error = x;
               5                      f_max_error = res;
               5                      max_error = error;
               5                      k_max_error = k;
               5                  ]
               4              ]
               3              ndat = ndat+1;
               3              DO k=ndat,k_max_error+2,-1 [
               4                  nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
               4                  nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
               4              ]
               3              nb_xdata(k_max_error+1,i,medium) = x_max_error;
               3              nb_fdata(k_max_error+1,i,medium) = f_max_error;
               3          ] UNTIL (ndat = $MXBRXS);
               2
               2          :SKIP-LOOP:
               2          "
               2          " Now generate the alias tables for rapid brems sampling
               2          " during run time
               2          "
               2          call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               2                 nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));
               2
               2      ]
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,' ');
               0  return;
               0  " Errors "
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0  return;
               0  end;
               0
1              0  %E
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine init_nrc_pair;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  character     nrcp_file*256, endianess*4;
               0  integer       egs_get_unit;
               0  $INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
               0  $INTEGER      i, lnblnk1;
               0  $REAL         tmp, ddx, xx, Z;
               0  real*4        emin, emax;
               0  integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
               0  REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
               0  character     endian, cdum($cdum_size);
               0  $LOGICAL      swap;
               0  real*4        tmp_4, tarray($NRC-PAIR-NXX);
               0  integer*4     itmp_4;
               0  character     c_4(4), ic_4(4);
               0  equivalence   (tmp_4,c_4), (itmp_4, ic_4);
               0
               0  $set_string(nrcp_file,' ');
               0  nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
               0  want_nrcp_unit = 62;
               0  nrcp_unit = egs_get_unit(want_nrcp_unit);
               0  IF( nrcp_unit < 1 ) [
               1      $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
               1  ]
               0
               0  rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
               0  open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
               0          status='old',recl=rec_length,err=:nrcp-open-error:);
               0  read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
               0  IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
               1      tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
               1      itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
               1      itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
               0  $egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
               0  IF( nb ~= $NRC-PAIR-NXX ) [
               1      $egs_fatal(*,'Inconsistent x-grid size');
               1  ]
               0  IF( ne ~= $NRC-PAIR-NEE ) [
               1      $egs_fatal(*,'Inconsistent energy grid size');
               1  ]
               0  nrcp_emin = emin; nrcp_emax = emax;
               0  nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;
               0
               0  nbb = nb/2; ddx = sqrt(0.5)/nbb;
               0  DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
               0  do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO ie=1,$NRC-PAIR-NEE [
               2          DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
               2      ]
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*Z;
               2          irec = (iz-1)*ne + 2;
               2          DO ie=1,$NRC-PAIR-NEE [
               3              read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
               3              DO ix=1,$NRC-PAIR-NXX [
               4                  tmp_4 = tarray(ix);
               4                  IF( swap ) [ call egs_swap_4(c_4); ]
               4                  nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
               4              ]
               3              irec = irec + 1;
               3          ]
               2      ]
               1      DO ie=1,$NRC-PAIR-NEE [
               2          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
               2                  nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
               2      ]
               1
               1      $egs_info('(a)',' done');
               1
               1  ]
               0  $egs_info(*,' ');
               0  close(nrcp_unit);
               0  return;
               0
               0  :nrcp-open-error:;
               0  $egs_fatal(*,'Failed to open NRC pair data file');
               0
               0  :nrcp-read-error:;
               0  $egs_fatal(*,'I/O error while reading NRC pair data file');
               0
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  "                                                                  "
               0  subroutine vmc_electron(ircode);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   This subroutine performs condensed history simulation of       "
               0  "   electron/positron transport according to VMC                   "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Initial coding               "
               0  "                                     coding is in EGSnrc style    "
               0  "                                     for maximum compatibility    "
               0  "                                     with EGSnrc user codes       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  $INTEGER ircode;
               0  $egs_fatal('(//a//)',
               0  ' ********* VMC Transport option not in this distribution ****** ');
               0  end;
               0
               0  " Subroutine versions of the random number generator "
               0  " Included here because it makes life easier for using the EGSnrc RNG"
               0  " from within the C-interface. "
               0  subroutine egs_init_default_rng;
               0  ;COMIN/RANDOM/;
               0  $RNG-DEFAULT-INITIALIZATION;
               0  return; end;
               0
               0  subroutine egs_init_rng(arg1,arg2);
               0  $INTEGER arg1,arg2;
               0  ;COMIN/RANDOM/;
               0  $declare_write_buffer;
               0  $INITIALIZE RNG USING arg1 AND arg2;
               0  return; end;
               0
               0  subroutine egs_get_rndm(ran);
               0  $REAL ran;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET ran;
               0  return; end;
               0
               0  subroutine egs_get_rndm_array(n,rarray);
               0  $INTEGER n;
               0  $REAL    rarray(*);
               0  ;COMIN/RANDOM/;
               0  $REAL    rtmp;
               0  $INTEGER i;
               0  IF( n < 1 ) return;
               0  DO i=1,n [
               1      $RANDOMSET rtmp; rarray(i) = rtmp;
               1  ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "**************************************************************************"
               0  "Init EII. This subroutine is called from HATCH after all media are known, "
               0  "threshold energies and interpolation data have been initialized.          "
               0  "**************************************************************************"
               0  subroutine eii_init;
               0  "**************************************************************************"
               0  implicit none;
               0  $COMIN-EII-INIT;
               0  $INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
               0  $INTEGER jj,jjj;
               0  integer*4 lnblnk1;
               0  $INTEGER tmp_array($MXELEMENT);
               0  $INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
               0  integer  egs_get_unit;
               0  $REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
               0  $REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
               0  $REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
               0  $REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
               0  $REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
               0  $REAL    sigma,sigma_old,wbrem_old,sig_j,de;
               0  $INTEGER lloge;
               0  $LOGICAL check_it,is_monotone,getd;
               0  $REAL    sigma_max;
               0  character eii_file*128;
               0  character*512 toUpper;
               0  $INTEGER occn_numbers(4);
               0  $declare_write_buffer;
               0  $REAL    cons;
               0  parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
               0  data     occn_numbers/2,2,2,4/;
               0
               0  DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
               0  DO j=1,$MXMED [ eii_nsh(j) = 0; ]
               0  IF( eii_flag = 0 ) [ return; ]
               0
               0  $need_relaxation_data(getd);
               0  IF( ~getd )[
               1    $egs_fatal('(/a,/a,/a,/a)',
               1            ' In subroutine eii_init: ',
               1            '   Scattering off bound electrons creates atomic vacancies,',
               1            '   potentially starting an atomic relaxation cascade. ',
               1            '   Please turn ON atomic relaxations.');
               1  ]
               0
               0
               0
               0
               0  e_eii_min = 1e30;
               0  DO imed = 1,nmed [
               1      IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
               1      IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      DO iele = 1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          IF( eii_nshells(iZ) = 0 ) [
               3              nsh = 0;
               3              DO ish=1,4 [
               4                  IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
               4              ]
               3              eii_nshells(iZ) = nsh;
               3          ]
               2      ]
               1  ]
               0
               0
               0  nsh = 0;
               0  DO iZ=1,$MXELEMENT [
               1      nsh = nsh + eii_nshells(iZ);
               1  ]
               0  IF( nsh = 0 ) [
               1      $egs_info(*,'*** EII requested but no shells with binding energies ');
               1      $egs_info(*,'    above the specified threshold found');
               1      $egs_info(*,'    => turning off EII');
               1      eii_flag = 0;
               1  ]
               0  IF( nsh > $MAX_EII_SHELLS ) [
               1      $egs_info(*,'*** Number of shells with binding energies greater than ');
               1      $egs_info(*,'    the specified thresholds is ',nsh);
               1      $egs_info(*,'    This is more than the allocated arrays can hold');
               1      $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
               1  ]
               0  $egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
               0  nsh_tot = nsh;
               0  tmp_array(1) = 0;
               0  DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]
               0
               0
               0  DO imed=1,nmed [
               1      nsh = 0;
               1      DO iele=1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          eii_no(imed,iele) = eii_nshells(iZ);
               2          nsh = nsh + eii_nshells(iZ);
               2          IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
               2          ELSE [ eii_first(imed,iele) = 0; ]
               2      ]
               1      eii_nsh(imed) = nsh;
               1  ]
               0
               0
               0  $set_string(eii_file,' ');
               0  eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
               0             $cstring(eii_xfile) //'.data';
               0  want_eii_unit = 62;
               0  eii_unit = egs_get_unit(want_eii_unit);
               0  IF( eii_unit < 1 ) [
               1      $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
               1  ]
               0  open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
               0  $egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
               0  $egs_info('(a,$)',' eii_init: reading EII data ... ');
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
               0  DO j=1,nskip [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
               1  ]
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
               0  IF( nbin ~= $N_EII_BINS ) [
               1      $egs_fatal(*,'Inconsistent EII data file');
               1  ]
               0  IF (xsec_out = 1)[
               1     eii_out = egs_open_file(93,0,1,'.eiixsec');
               1  ]
               0  ii = 0;
               0  DO j=1,$MXELEMENT [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
               1      IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
               2       write(eii_out,*) '=================================';
               2       write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
               2       write(eii_out,*) '=================================';
               2      ]
               1      IF( nsh < eii_nshells(iZ) ) [
               2          $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
               2          $egs_info(*,iZ,' but according');
               2          $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
               2          $egs_info(*,'shells are required');
               2          $egs_fatal(*,'This is a fatal error.');
               2      ]
               1      DO ish=1,nsh [
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
               2             aux_array;
               2          "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
               2          IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
               2          IF( ish <= eii_nshells(iZ) ) [
               3              IF (xsec_out = 1)[
               4                IF(ish = 1)[
               5                 write(eii_out,'(a,f10.2,a)')
               5                 'K-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 2)[
               5                 write(eii_out,'(a,f9.2,a)')
               5                 '=> LI-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 3)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 4)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LIII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
               4                write(eii_out,*) '   E/keV     sigma/(b/atom)';
               4                write(eii_out,*) '---------------------------';
               4              ]
               3              ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
               3              eii_a(ii) = nbin;
               3              eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
               3              eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
               3              DO k=1,nbin [
               4                  IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
               4                  ELSE [ sigo = 0; ]
               4                  loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
               4                  eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
               4                  eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
               4                  IF (xsec_out = 1)[
               5                     write(eii_out,'(f12.2,2X,10f9.2)')
               5                     Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
               5                  ]
               4              ]
               3          ]
               2      ]
               1      IF( ii = nsh_tot ) [ EXIT; ]
               1  ]
               0  close(eii_unit);
               0  IF (xsec_out = 1)[ close(eii_out); ]
               0  $egs_info(*,' OK '); $egs_info(*,' ');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
               1      /sum_z,sum_pz,sum_a,sum_wa/=0;
               1      DO iele=1,nne(imed) [
               2          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
               2          sum_pz = sum_pz + pz(imed,iele);
               2          sum_wa = sum_wa + rhoz(imed,iele);
               2          sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
               2      ]
               1      con_med = rho(imed)/1.6605655/sum_a;
               1      eii_cons(imed) = con_med;
               1      IF( eii_nsh(imed) > 0 ) [
               2          is_monotone = .true.;
               2          sigma_max = 0;
               2          DO j=1,meke(imed) [
               3              loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
               3              tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              p2 = 2*rm*tau*(tau+2);
               3              lloge = j;
               3              medium = imed;
               3              $EVALUATE dedx USING ededx(loge);
               3              IF( e > ap(medium) | e > 2*Ec ) [
               4                  $EVALUATE sig USING esig(loge);
               4              ] ELSE [ sig = 0; ]
               3              IF( e > 2*Ec ) [
               4                  $EVALUATE wbrem USING ebr1(loge);
               4                  sigm = sig*(1-wbrem);
               4              ] ELSE [ sigm = 0; wbrem = 1; ]
               3              /sum_occn,sum_sigma,sum_dedx/=0;
               3              DO iele=1,nne(imed) [
               4                  iZ = int(zelem(imed,iele)+0.5);
               4                  sum_sh = 0;
               4                  DO ish = 1,eii_no(imed,iele) [
               5                      "jj is the shell index in the list of EII shells "
               5                      jj = eii_first(imed,iele) + ish - 1;
               5                      "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
               5                      jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
               5                      Wmax = (e+U)/2; uwm = U/Wmax;
               5                      "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
               5                      IF( U < e & U > Ecc ) [
               6                          " At this energy interactions with this shell will "
               6                          " be done using the EII differential x-section "
               6                          sum_sh = sum_sh + occn_numbers(jjj);
               6                          ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
               6                            (beta2+0.833333)*(1-uwm**3))/3/U;
               6                          sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
               6                            - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
               6                          ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
               6                            (beta2+1)*(1-uwm**2);
               6                          sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
               6                            +(Wmax**2-U**2)/(e+rm)**2/2
               6                            -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
               6                          av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
               6                            "av_E is the average energy lost in a collision"
               6                            "with this shell"
               6                          i = eii_a(jjj)*loge + eii_b(jjj);
               6                          i = (jj-1)*$N_EII_BINS + i;
               6                          sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
               6                          sig_j = sig_j*pz(imed,iele)*con_med;
               6                          sum_sigma = sum_sigma + sig_j;
               6                          sum_dedx = sum_dedx + sig_j*av_E;
               6                      ]
               5                  ]
               4                  sum_occn = sum_occn + sum_sh*pz(imed,iele);
               4              ]
               3              sigm = sigm + sum_sigma;
               3              dedx = dedx - sum_dedx;
               3              aux = Ec/e;
               3              IF( e > 2*Ec ) [
               4                  sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
               4                          (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
               4                          (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
               4                  de = cons*sum_occn*rho(imed)/beta2*(
               4                    log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
               4                    (tau/(tau+1))**2*(1-4*aux*aux)/8-
               4                    (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
               4                  sigm = sigm - sigo;
               4                  "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
               4                  dedx = dedx + de;
               4              ]
               3              sigma = sigm + wbrem*sig;
               3              IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
               3              IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
               3              ELSE [ wbrem = 1; ]
               3              IF( j > 1 ) [
               4                  ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
               4                  ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
               4                  esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
               4                  esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
               4                  ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
               4                  ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
               4                  IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
               4              ]
               3              dedx_old = dedx; sigm_old = sigm;
               3              sigma_old = sigma; wbrem_old = wbrem;
               3          ]
               2          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
               2          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
               2          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
               2          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
               2          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
               2          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
               2          $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
               2                  sigma_max,' monotone = ',is_monotone);
               2          sig_ismonotone(0,imed) = is_monotone;
               2          esig_e(imed) = sigma_max;
               2      ]
               1  ]
               0  return;
               0
               0  :eii-reading-error:
               0  $egs_fatal(*,'I/O error while reading EII data');
               0
               0  :no-eii-file:
               0  $egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
               0            'Make sure file exists in your $HEN_HOUSE/data directory!',
               0            '****BEWARE of case sensitive file names!!!');
               0
               0  return; end;
               0
               0  "*****************************************************************************"
               0
               0  subroutine eii_sample(ish,iZ,Uj);
               0  implicit none;
               0  $INTEGER ish,iZ;
               0  $REAL    Uj;
               0
               0  $COMIN-EII-SAMPLE;
               0
               0  $REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
               0  $REAL r1,r2,r3,wx,wxx,aux,frej;
               0  real*8 peie,pese1,pese2,dcosth,h1;
               0  $INTEGER iarg;
               0  $REAL    eta,cphi,sphi;
               0  $INTEGER np_save,ip,j;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0
               0  peie = e(np);
               0  T = peie - rm; tau = T/rm; tau1 = tau+1;
               0  tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
               0  beta2 = p2/tau12;
               0  "c1 = tau2/tau12; "
               0  Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
               0  c1 = (Wmax/peie)**2;
               0  c2 = (2*tau+1)/tau12;
               0  fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
               0  prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
               0  "fm_h = 1 + c1 - c2;"
               0  fm_h = 2 + c1 - c2;
               0  IF( fm_h < 1 ) fm_h = 1;
               0  prob = fm_h + prob_s;
               0
               0  LOOP [
               1      $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
               1      IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
               2          wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
               2          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
               2      ] ELSE [               "Use the soft collision cross section "
               2          wx = 1/(r2*xmax**3+1-r2)**0.333333333;
               2          frej = 1 - log(wx)/fm_s;
               2      ]
               1  ] UNTIL ( r3 < frej );
               0
               0  wx = wx*Uj;
               0
               0
               0  h1 = (peie + prm)/T; pese1 = peie - wx;
               0  e(np) = pese1;
               0  dcosth = h1*(pese1-prm)/(pese1+prm);
               0  sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               0  call uphi(2,1);
               0
               0  pese2 = wx - Uj + prm;
               0  edep_local = 0;
               0  IF( pese2 > ae(medium) ) [
               1      $CHECK-STACK(np+1,'eii_sample');
               1      np = np+1; e(np) = pese2;
               1      dcosth = h1*(pese2-prm)/(pese2+prm);
               1      sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               1      iq(np) = -1; call uphi(3,2);
               1      edep = 0;
               1  ] ELSE [
               1      edep = wx - Uj;
               1      edep_local = edep;
               1      $AUSCALL($SELECTRONA);
               1  ]
               0  "ish ranges from 1 to 4 for K,L1,L2,L3 shells"
               0  call relax(Uj,ish,iZ);
               0
               0  IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_scale_photon_xsection(imed,fac,which);
               0  "============================================================================"
               0  "
               0  "  Scale the photon cross section 'which' by factor fac for medium imed.
               0  "  which = 0 for all cross sections
               0  "        = 1 for Rayleigh scattering
               0  "        = 2 for Compton scattering
               0  "        = 3 for Pair production
               0  "        = 4 for photo-absorption
               0  "  If imed = 0, scaling is done for all media.
               0  "============================================================================"
               0  implicit none;
               0  $INTEGER imed,which;
               0  $REAL    fac;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,PHOTIN,EGS-IO/;
               0  $INTEGER ifirst,ilast,medium,j;
               0  $LOGICAL has_r;
               0  $REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
               0  character*8 strings(5);
               0  data       strings/'photon','Rayleigh','Compton','pair','photo'/;
               0
               0  IF( which < 0 | which > 4 ) [ return; ]
               0  IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
               0  ELSE [ ifirst = 1; ilast = nmed; ]
               0  IF( which = 1 ) [
               1      has_r = .false.;
               1      DO medium = ifirst, ilast [
               2          IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
               2      ]
               1      IF( ~has_r ) return;
               1  ]
               0  $egs_info(*,' ');
               0  DO medium = ifirst,ilast [
               1
               1      $egs_info('(a,a,a,i3,a,f9.5)',
               1              'Scaling ',strings(which+1),' x-section data for medium',
               1              medium,' with ',fac);
               1
               1      DO j = 1,mge(medium) [
               2
               2          gle = (j - ge0(medium))/ge1(medium);
               2          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
               2          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
               2          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
               2          IF( iraylm(medium) = 1 ) [
               3              cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
               3          ] ELSE [ cohfac = 1; ]
               2          IF( which = 0 ) [ gmfp = gmfp/fac; ]
               2          ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
               2          ELSE [
               3              IF( which = 2 ) [
               4                  aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
               4                  gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
               4              ]
               3              ELSE IF( which = 3 ) [
               4                  aux = fac*gbr1 + 1 - gbr1;
               4                  gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
               4              ]
               3              ELSE [
               4                  aux = gbr2 + fac*(1-gbr2);
               4                  gbr1 = gbr1/aux; gbr2 = gbr2/aux;
               4              ]
               3              gmfp = gmfp/aux;
               3              cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
               3          ]
               2          IF( j > 1 ) [
               3              gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
               3              gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
               3              gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
               3              cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
               3              cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;
               2
               2      ]
               1      gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
               1      gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
               1      gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
               1      gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
               1      gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
               1      gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
               1      cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
               1      cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$OPEN-UNIT(#,#,#);} WITH {
            {  0      {P1} = {P2};
            {  0      {P1} = egs_get_unit({P1});
            {  0      IF( {P1} < 1 ) [
            {  0          $egs_fatal(*,
            {  0           'egs_init_user_photon: failed to get a free Fortran I/O unit');
            {  0      ]
            {  0      tmp_string = {P3};
            {  0      open({P1},file={P3},status='old',err=:no-user-data-file:);
            {  0  };
               0
               0  REPLACE {$MXINPUT} WITH {2000};
               0  REPLACE {$MXBCINP} WITH {183};
               0
               0  "============================================================================="
               0  "Ali:photonuc, 1 line"
               0   subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
               0  "subroutine egs_init_user_photon(prefix,comp_prefix,out);"
               0  "============================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  character*(*) prefix, comp_prefix,
               0  "Ali:photonuc, 1 line"
               0                photonuc_prefix;
               0  $INTEGER      out;
               0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
               0  $INTEGER   lnblnk1,egs_get_unit,medium,
               0             photo_unit,pair_unit,rayleigh_unit,triplet_unit,
               0             ounit,egs_open_file,compton_unit,
               0  "Ali:photonuc, 1 line"
               0             photonuc_unit;
               0  $INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
               0  $REAL      z_sorted($MXEL),pz_sorted($MXEL);
               0  $REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
               0             sig_rayleigh($MXGE),sig_compton($MXGE);
               0  $REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
               0  $REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
               0  "Ali:photonuc, 3 lines"
               0             sig_photonuc($MXGE),
               0             photonuc,
               0             photonuc_old;
               0
               0  $REAL      etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
               0  $REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
               0  $INTEGER   bc_ne;
               0  $LOGICAL   input_compton_data,
               0  "Ali:photonuc, 1 line"
               0             input_photonuc_data;
               0  character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
               0             triplet_file*142,tmp_string*144,compton_file*144,
               0  "Ali:photonuc, 1 line"
               0             photonuc_file*144;
               0
               0  $egs_info('(/a$)','(Re)-initializing photon cross sections');
               0  $egs_info('(a,a/)',' with files from the series: ',
               0        prefix(:lnblnk1(prefix)));
               0
               0  $egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   $egs_info('(a,a)',' Photonuclear cross sections: ',
               1   $cstring(photonuc_prefix));
               1   input_photonuc_data = .false.;
               1   IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
               2     input_photonuc_data = .true.;
               2   ]
               1  ]
               0
               0  input_compton_data = .false.;
               0  IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
               1      IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
               1  ]
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
               0  pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
               0  triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
               0  rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
               0  IF( input_compton_data ) [
               1      compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
               1                     '_compton.data';
               1  ]
               0  ELSE [
               1      compton_file = $cstring(data_dir) // 'compton_sigma.data';
               1  ]
               0  "Ali: I moved this info line from inside the IF statement
               0  " because it's useful to print the cross section file either way
               0  $egs_info('(a,a)',' Using Compton cross sections from ',
               0            $cstring(compton_file));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   IF( input_photonuc_data ) [
               2      photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
               2                      '_photonuc.data';
               2   ]
               1   ELSE [
               2      photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
               2   ]
               1   $egs_info('(a,a)',' Using photonuclear cross sections from ',
               1    $cstring(photonuc_file));
               1  ]
               0
               0  $OPEN-UNIT(photo_unit,83,photo_file);
               0  $OPEN-UNIT(pair_unit,84,pair_file);
               0  $OPEN-UNIT(triplet_unit,85,triplet_file);
               0  $OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
               0  IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
               0  " Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
               0  "       without rejections. For this we have to use the actual bound   "
               0  "       Compton scattering cross section, which is now available in a  "
               0  "       file called bound_compton.data (the file actually contains the "
               0  "       ratio of the Bound Compton to the KN cross section).           "
               0  "       Because this option is not available on a region by region     "
               0  "       basis, we just need to check ibcmp(1)                          "
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]
               0
               0  IF( out = 1 ) [
               1      ounit = egs_open_file(87,0,1,'.xsections');
               1      write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
               1         $cstring(prefix),' data files';
               1      write(ounit,'(a,/)')
               1  '============================================================================';
               1      write(ounit,'(a,/)') 'Grid energies and cross sections are output';
               1  "Ali:photonuc, 1 block"
               1      IF(iphotonuc = 1) [
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
               2           'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
               2           ' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
               2           '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
               2           'w/ Ray + photnuc';
               2      ]
               1      ELSE[
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
               2              'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
               2              '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
               2     ]
               1  ]
               0
               0  DO iz=1,100 [
               1      read(photo_unit,*) ndat;
               1      read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
               1      k = 0;
               1      DO j=ndat,2,-1 [
               2          IF( etmp(j)-etmp(j-1) < 1e-5 ) [
               3              k = k+1;
               3              IF ( k <= $MXSHXSEC )[
               4                 binding_energies(k,iz) = exp(etmp(j));
               4              ]
               3              ELSE[
               4                $egs_fatal('(i3,a,i3,//a)',
               4                           k,' binding energies read exceeding array size of',
               4                           $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
               4              ]
               3              IF( ~eadl_relax & k >= 4 ) EXIT;
               3          ]
               2      ]
               1  ]
               0
               0  IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]
               0
               0  DO medium = 1,nmed [
               1
               1      mge(medium) = $MXGE; nge = $MXGE;
               1      ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
               1      ge0(medium) = 1 - ge1(medium)*log(ap(medium));
               1
               1      $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
               1      IF( out = 1 ) [
               2          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
               2            (media(k,medium),k=1,24);
               2      ]
               1      /sumZ,sumA/ = 0;
               1      DO i=1,nne(medium) [
               2          z_sorted(i) = zelem(medium,i);
               2          sumZ = sumZ + pz(medium,i)*zelem(medium,i);
               2          sumA = sumA + pz(medium,i)*wa(medium,i);
               2      ]
               1      con1 = sumZ*rho(medium)/(sumA*1.6605655);
               1      con2 = rho(medium)/(sumA*1.6605655);
               1      call egs_heap_sort(nne(medium),z_sorted,sorted);
               1      DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]
               1
               1      IF (mcdf_pe_xsections)[
               2         call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
               2                                  ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      ELSE[
               2         call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                         ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_rayleigh);
               1      call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_pair);
               1      call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_triplet);
               1  "Ali:photonuc, 1 block"
               1      IF( iphotonuc = 1 ) [
               2        call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                          ge1(medium),ge0(medium),sig_photonuc);
               2      ]
               1
               1      IF( ibcmp(1) > 1 ) [
               2          "Get the bound compton cross section data"
               2          IF( input_compton_data ) [
               3              call egsi_get_data(0,compton_unit,nge,nne(medium),
               3                      z_sorted,pz_sorted,ge1(medium),ge0(medium),
               3                      sig_compton);
               3          ]
               2          ELSE [
               3              rewind(compton_unit);
               3              read(compton_unit,*) bc_emin,bc_emax,bc_ne;
               3              IF( bc_ne > $MXBCINP ) [
               4                $egs_fatal(*,'Number of input Compton data exceeds array size');
               4              ]
               3              "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
               3              bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
               3              DO j=1,bc_ne [ bc_data(j) = 0; ]
               3              iz_old = 1;
               3              DO i=1,nne(medium) [
               4                  iz = int(z_sorted(i)+0.5);
               4                  "write(6,*) ' reading bc data for ',iz;
               4                  DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
               4                  DO j=1,bc_ne [
               5                      bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
               5                  ]
               4                  iz_old = iz+1;
               4              ]
               3              DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
               3          ]
               2      ]
               1
               1
               1      call egs_init_rayleigh(medium,sig_rayleigh);
               1
               1      DO i=1,nge [
               2
               2          gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
               2          sig_KN = sumZ*egs_KN_sigma0(e);
               2          IF( ibcmp(1) > 1 ) [
               3              IF( input_compton_data ) [
               4                  sig_KN = sig_compton(i);
               4              ]
               3              ELSE [
               4                  "Apply the bound Compton correction to sig_KN"
               4                  IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
               4                  ELSE IF( e < bc_emax ) [
               5                      aj = 1 + log(e/bc_emin)/bc_dle;
               5                      j = int(aj); aj = aj - j;
               5                      bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
               5                  ]
               4                  ELSE [ bcf = 1; ]
               4                  sig_KN = sig_KN*bcf;
               4                  "write(6,*) 'e = ',e,' bcf = ',bcf;
               4              ]
               3          ]
               2          sig_p  = sig_pair(i) + sig_triplet(i);
               2          sigma  = sig_KN + sig_p + sig_photo(i);
               2          gmfp   = 1/(sigma*con2);
               2          gbr1   = sig_p/sigma;
               2          gbr2   = gbr1 + sig_KN/sigma;
               2          cohe   = sigma/(sig_rayleigh(i) + sigma);
               2  "Ali:photonuc, 1 line"
               2          photonuc = sigma/(sig_photonuc(i) + sigma);
               2
               2          IF( out = 1 ) [
               3  "Ali:photonuc, 1 block"
               3             IF(iphotonucm(medium) = 1) [
               4                write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
               4                gmfp*cohe,gmfp*cohe*photonuc;
               4             ]
               3             ELSE[
               4                write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
               4             ]
               3          ]
               2          IF( i > 1 ) [
               3              gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
               3              gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
               3              gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
               3              cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
               3              cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
               3  "Ali:photonuc, 2 lines"
               3              photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
               3              photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
               2  "Ali:photonuc, 1 line"
               2          photonuc_old = photonuc;
               2      ]
               1
               1      gmfp1(nge,medium) = gmfp1(nge-1,medium);
               1      gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
               1      gbr11(nge,medium) = gbr11(nge-1,medium);
               1      gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
               1      gbr21(nge,medium) = gbr21(nge-1,medium);
               1      gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
               1      cohe1(nge,medium) = cohe1(nge-1,medium);
               1      cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
               1  "Ali:photonuc, 2 lines"
               1      photonuc1(nge,medium) = photonuc1(nge-1,medium);
               1      photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;
               1
               1      $egs_info('(a)','OK');
               1  ]
               0
               0  close(photo_unit); close(pair_unit);
               0  close(triplet_unit); close(rayleigh_unit);
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ close(photonuc_unit);]
               0  IF( ibcmp(1) > 1 ) [ close(compton_unit);]
               0  IF( out = 1 )      [ close(ounit); ]
               0  return;
               0
               0  :no-user-data-file:;
               0  $egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh(medium,sig_rayleigh);
               0
               0
               0
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
               0  DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
               0  DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
               2     ff_file = iray_ff_file(i);
               2  ];]
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0
               0
               0
               0
               0
               0  IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
               1       open(ff_unit,file=$cstring(ff_file),
               1            status='old',err=:no-ff-file:);
               1       GOTO :read-ff:;
               1       :no-ff-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
               1               $cstring(ff_file));
               1       :read-ff:
               1       $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
               1       " read Rayleigh molecular form factor data from a file"
               1       " which is given as Fmol/sqrt(MW) hence no need to compute"
               1       " MW to get the xsections in cm-1. See conv variable below"
               1       j = 0;
               1       LOOP [
               2         j = j + 1;
               2         read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
               2         IF (EOF < 0) EXIT;
               2         IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
               2       ] REPEAT
               1       nff = j-1;
               1       IF (nff > $MXRAYFF)[
               2          $egs_fatal('(a,/,a,i5,a,i5,/,a)',
               2          'subroutine egs_init_rayleigh: form factors size too small!!',
               2          '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
               2          ' and try again!!!');
               2       ]
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
               1
               1       "Since MW already included in the molecular FF,"
               1       "must multiply by sumA which is MW for compound"
               1       "or unity for mixtures."
               1       sumA = 0.0;
               1       DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
               1       DO j=1,MGE(medium) [
               2         gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
               2         sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
               2                         xgrid(1,medium),ff(1,medium))*sumA;
               2       ]
               1  ]
               0  ELSE[
               1       $set_string(afac_file,' ');
               1       afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               1       open(ff_unit,file=$cstring(afac_file),
               1         status='old',err=:no-afac-file:);
               1       GOTO :read-afac:;
               1       :no-afac-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
               1               $cstring(afac_file));
               1       :read-afac:
               1       " read Rayleigh atomic form factor data from a file"
               1       read(ff_unit,*) xval, aff;
               1       "calculate form factor using independent atom model"
               1       DO i=1,$MXRAYFF[
               2         ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               2         DO j=1,nne(medium)[
               3          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               3         ]
               2         ff(i,medium) = sqrt(ff(i,medium));
               2       ]
               1       nff = $MXRAYFF;
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               1  ]
               0  close(ff_unit);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
               0  dlei=1/dle;
               0  DO i=1,ne-1 [
               1
               1
               1
               1
               1
               1
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh_sampling(medium);
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0  $set_string(afac_file,' ');
               0  afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               0  open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
               0  GOTO :read-afac:;
               0  :no-afac-file:
               0  $egs_fatal('(2a)',
               0          'egs_init_rayleigh_sampling: failed to open atomic ff file ',
               0          $cstring(afac_file));
               0  :read-afac:
               0  " read Rayleigh atomic form factor data from a file"
               0  read(ff_unit,*) xval, aff;
               0  "calculate form factor using independent atom model"
               0  DO i=1,$MXRAYFF[
               1    ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               1    DO j=1,nne(medium)[
               2     ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               2    ]
               1    ff(i,medium) = sqrt(ff(i,medium));
               1  ]
               0  nff = $MXRAYFF;
               0  "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               0  "and much less for higher energies"
               0  IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               0  "write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
               0  $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               0
               0  close(ff_unit);
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);
               0  DO i=1,ne-1 [
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0
               0
               0  $REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
               0  $IMPLICIT-NONE;
               0  $INTEGER i, j, k,imed, ndat;
               0  $REAL hc2,conv,b,hc;
               0  parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
               0             hc2 = 0.0001537222280); "h*c squared"
               0  $REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
               0  real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
               0  C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
               0  egs_rayleigh_sigma = 0.0;
               0  DO i=1,ndat-1[
               1     IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
               1     IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
               1     b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
               1     x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
               1     pow_x1=x1**(2*b);pow_x2=x2**(2*b);
               1     raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
               1     raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
               1     raysig = raysig*f(i)*f(i)/pow_x1;
               1     egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
               1     IF(x(i+1)>xmax)[EXIT;]"exit loop"
               1  ]
               0
               0
               0
               0  egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
               0  return;
               0  end;
               0
               0
               0
               0  subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  real*8 e;
               0  $REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
               0  $REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
               0  parameter(hc_i=80.65506856998,      "h*c inverse"
               0            twice_hc2=0.000307444456);"2*(hc)^2"
               0            "h*c=0.0123984768438 [Armstrong]*[MeV]"
               0  $INTEGER lgle,ib,ibin,medium, trials;
               0  ;COMIN/RANDOM,rayleigh_sampling/;
               0  dwi = $RAYCDFSIZE-1;
               0  $EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
               0  LOOP [
               1      $RANDOMSET rnnray1;
               1      LOOP [
               2          $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
               2          ibin = 1 + rnnray0*dwi;
               2          ib = i_array(ibin,medium);
               2          IF( i_array(ibin+1,medium) > ib ) [
               3            LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
               3          ]
               2          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
               2          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
               2      ] UNTIL (xv < xmax);
               1      xv = xv/e;
               1      costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
               1  ] UNTIL ( 2*rnnray1 < 1 + csqthe );
               0  sinthe=sqrt(1.0-csqthe);
               0  return;
               0  end;
               0
               0
               0
               0  subroutine prepare_rayleigh_data(ndat,x,f,
               0                                   ne,emin,emax,pe_array,
               0                                   ncbin,fcum,i_array,
               0                                   b_array,c_array);
               0  $IMPLICIT-NONE;
               0
               0
               0  $INTEGER    ndat;         " number of F data points "
               0  $REAL       x(ndat),      " x values of F data "
               0              f(ndat);      " F data "
               0
               0
               0  $INTEGER    ne;           " number of energy bins "
               0  $REAL       emin,         " minimum photon energy (i.e. AP(medium))"
               0              emax,         " maximum photon energy (i.e. UP(medium))"
               0              pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
               0                            " i.e., pe_array(E) = fcum(xmax(E))      "
               0
               0
               0
               0  $INTEGER    ncbin;          " number of cumulative bins (input)"
               0  $REAL       fcum(ndat);     " cumulative distribution (output)"
               0  $INTEGER    i_array(ncbin); " original data bin in which the i'th "
               0                              " cumulative bin edge falls.          "
               0
               0
               0  $REAL       b_array(ndat),  " F interpolation coefficient "
               0              c_array(ndat);  " needed for sampling at run time "
               0
               0  $REAL zero;
               0
               0  real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
               0         anorm,anorm1,anorm2,w,dw,xold,t,aux;
               0  $INTEGER i,j,k,ibin;
               0
               0  ;COMIN/USEFUL/;
               0
               0  write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';
               0
               0
               0  DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]
               0
               0
               0
               0
               0
               0
               0  sum0=0; fcum(1)=0;
               0  DO i=1,ndat-1 [
               1      b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
               1      x1 = x(i); x2 = x(i+1);
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1      fcum(i+1) = sum0;
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0  dle = log(emax/emin)/(ne-1); i = 1;
               0  DO j=1,ne [
               1      e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
               1      DO k=i,ndat-1 [
               2          IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
               2      ]
               1      i = k; b = b_array(i);
               1      x1 = x(i); x2 = xmax;
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      pe_array(j) = fcum(i) +
               1        f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1  ]
               0  i_array(ncbin) = i;
               0
               0
               0
               0
               0
               0
               0
               0
               0  anorm = 1d0/sqrt(pe_array(ne));
               0  anorm1 = 1.005d0/pe_array(ne);
               0  anorm2 = 1d0/pe_array(ne);
               0  DO j=1,ne [
               1      pe_array(j) = pe_array(j)*anorm1;
               1      IF( pe_array(j) > 1 ) pe_array(j) = 1;
               1  ]
               0  DO j=1,ndat [
               1      f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
               1      c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
               1  ]
               0
               0
               0
               0
               0
               0
               0  dw = 1d0/(ncbin-1);
               0  xold = x(1); ibin = 1;
               0  b = b_array(1);
               0  pow_x1 = x(1)**(2*b);
               0  i_array(1) = 1;
               0  DO i=2,ncbin-1 [
               1      w = dw;
               1      LOOP [
               2          x1 = xold; x2 = x(ibin+1);
               2          t = x1*x1*x1**(2*b);
               2          pow_x2 = x2**(2*b);
               2          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
               2          IF( aux > w ) [
               3              xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
               3              i_array(i) = ibin;
               3              EXIT;
               3          ]
               2          w = w - aux; xold = x2; ibin = ibin+1;
               2          b = b_array(ibin); pow_x1 = xold**(2*b);
               2      ]
               1  ]
               0
               0
               0
               0
               0
               0
               0  DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]
               0
               0
               0  write(*,'(a /)') 'done';
               0
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma0(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm;
               0  IF( ko < 0.01 ) [
               1      egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
               1      return;
               1  ]
               0  c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
               0                  eps1*(c3+0.5*eps1))/e*con;
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma1(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma1 = c1*(1./eps1-1./eps2);
               0  egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
               0  egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
               0  egs_KN_sigma1 = egs_KN_sigma1 +
               0           (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
               0  egs_KN_sigma1 = egs_KN_sigma1*con;
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL    eth;
               0  $INTEGER flag,iunit,n,ne;
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL    gle,sig,p,e;
               0  $INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;
               0
               0  ;COMIN/USEFUL/;
               0
               0  "Ali:photonuc. The whole routine is commented out and re-written
               0  "to accommodate reading photonuclear cross sections. A copy of the
               0  "commented original routine is at the bottom.
               0  " flag = 0: photoelectric, Rayleigh, Compton
               0  " flag = 1: pair
               0  " flag = 2: triplet
               0  " flag = 3: photonuclear
               0
               0  rewind(iunit);
               0  iz_old = 0;
               0  DO k=1,n [ data(k) = 0; ]
               0  DO i=1,ne [
               1      iiz = int(zsorted(i)+0.5);
               1      DO iz=iz_old+1,iiz [
               2          read(iunit,*,err=:user-data-failure:) ndat;
               2          IF( ndat > $MXINPUT ) [
               3              $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
               3          ]
               2          IF( flag = 0 | flag = 3) [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
               3          ]
               2          ELSE [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
               3                  k=1,ndat);
               3              IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
               3              ndat = ndat + 1;
               3              DO k=2,ndat [
               4                  ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
               4              ]
               3              ftmp(1) = ftmp(2); etmp(1) = log(eth);
               3          ]
               2      ]
               1      iz_old = iiz;
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1; e = exp(gle);
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              IF( flag = 0 ) [
               4                  $egs_fatal(*,'Energy ',exp(gle),
               4                     ' is outside the available data range of ',
               4                     exp(etmp(1)),exp(etmp(ndat)));
               4              ]
               3              ELSEIF (flag = 1 | flag = 2) [
               4                  IF( gle < etmp(1) ) [ sig = 0; ]
               4                  ELSE [ sig = exp(ftmp(ndat)); ]
               4              ]
               3              ELSE [ "photonuclear, zero it before and after
               4               sig = 0;
               4              ]
               3          ] ELSE [
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              IF( flag ~= 3) ["log/log interpolation"
               4                 p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               4                 sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               4              ]
               3              ELSE["lin/lin interpolation for photonuc"
               4                 p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               4                 sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
               4              ]
               3          ]
               2          IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2      ]
               1  ]
               0
               0  return;
               0
               0  :user-data-failure:;
               0  $egs_fatal(*,'Error while reading user photon cross sections from unit ',
               0       iunit);
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0  "============================================================================="
               0  subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
               0  $INTEGER n,   "number of data points requested"
               0           ne,  "number of elements in medium"
               0           ndat;"number of data points from original grid"
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    sigma($MXNE),sigmaMedium;
               0  "$INTEGER sorted(*);
               0  real*4    etmp($MXINPUT),ftmp($MXINPUT);
               0  real*4    gle,sig,p;
               0  $INTEGER i,j,k,kk,iz,zpos,imed;
               0
               0  DO k=1,n  [ data(k)  = 0;]
               0  DO k=1,ne [ sigma(k) = 0;]
               0  DO i=1,ne [
               1      iz = int(zsorted(i)+0.5);
               1      zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1      "Total cross sections for a given element"
               1      "on initial energy grid"
               1      DO k=1,ndat[
               2         pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
               2         "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
               2         etmp(k) = pe_energy(k,zpos);
               2         ftmp(k) = log(pe_xsection(k,zpos,0));
               2      ]
               1      "Total cross sections for a given element"
               1      "on requested energy grid"
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1;
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
               3                           ' is outside the available data range of ',
               3                           exp(etmp(1)),exp(etmp(ndat)));
               3          ] ELSE [
               3              "Find energy interval gle falls in"
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              "log/log interpolation"
               3              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               3              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               3          ]
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2          "data(k) = data(k) + pz(imed,sorted(i))*sig;
               2      ]
               1  ]
               0  "Normalize elemental cross section to medium cross section"
               0  "Prepare for log/log interpolation"
               0  DO i=1,ne [
               1     iz = int(zsorted(i)+0.5);
               1     zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1     DO k=1,ndat[
               2        sig = sigmaMedium(imed,pe_energy(k,zpos));
               2        pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
               2     ]
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0  $REAL function sigmaMedium(imed, logE);
               0
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,PE-SHELL-DATA/;
               0  $REAL logE, slope, sigma;
               0  $INTEGER k,imed,Z,zpos,m,ibsearch;
               0
               0  sigmaMedium = 0;
               0  DO k=1,nne(imed) [
               1     Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
               1     m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               1     slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
               1     slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
               1     sigma = log(pe_xsection(m,zpos,0));
               1     sigma += slope*(logE - pe_energy(m,zpos));
               1     sigma = exp(sigma);
               1     sigmaMedium += pz(imed,k)*sigma;
               1  ]
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egs_heap_sort(n,rarray,jarray);
               0  "************************************************************************
               0  "  egs_heap_sort will sort the real array rarray of dimension n in
               0  "  ascending order and at the same time put into the integer array
               0  "  jarray the original position of the elements, e.g.
               0  "  if rarray was on input (5,14,8,2), it will be after completion
               0  "  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
               0  "  heap_sort uses the heap sort algorithm, the implementation is
               0  "  based  on hpsort from Numerical Recipies with a couple of
               0  "  modifications.
               0  "
               0  "  Iwan Kawrakow, NRC, July 2001
               0  "*************************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER n,jarray(*);
               0  $REAL    rarray(*);
               0  $INTEGER i,ir,j,l,ira;
               0  $REAL    rra;
               0
               0  DO i=1,n [ jarray(i)=i; ]
               0  IF (n < 2) return;
               0  l=n/2+1; ir=n;
               0
               0  LOOP [
               1     IF (l > 1)  [
               2         l=l-1; rra=rarray(l); ira=l;
               2     ]
               1     ELSE [
               2         rra=rarray(ir); ira=jarray(ir);
               2         rarray(ir)=rarray(1); jarray(ir)=jarray(1);
               2         ir=ir-1;
               2         IF (ir = 1) [
               3             rarray(1)=rra; jarray(1)=ira; return;
               3         ]
               2     ]
               1     i=l; j=l+l;
               1     LOOP [
               2         IF( j > ir ) EXIT;
               2         IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
               2         IF (rra < rarray(j)) [
               3             rarray(i)=rarray(j); jarray(i)=jarray(j);
               3             i=j; j=j+j;
               3         ] ELSE [ j=ir+1; ]
               2     ]
               1     rarray(i)=rra; jarray(i)=ira;
               1  ]
               0  return; end;
               0
1              0  %E
               0  "Ali:photonuc, 1 subroutine"
               0  "******************************************************************"
               0  SUBROUTINE PHOTONUC;
               0  "******************************************************************"
               0  " Placeholder for photonuclear modelling. Currently the photon is
               0  " discarded and its energy is thrown away (i.e. not deposited).
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-PHOTONUC; "current default replacement is:
               0                   "COMIN/STACK,EPCONT,USEFUL/"
               0  $DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"
               0
               0  npold = np; "set the old stack counter"
               0  edep = pzero; e(np) = pzero; wt(np) = 0;
               0
               0  return;
               0  end;
               0  "******************************************************************"
               0
          END OF MORTRAN INPUT
  61      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
